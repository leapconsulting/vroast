/// <reference path="Intrinsics-1.0.0.d.ts"/>


  
    // Regular classes.  
	declare class VcAboutInfo
	{
		apiType: String;
		apiVersion: String;
		build: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullName: String;
		instanceUuid: String;
		licenseProductName: String;
		licenseProductVersion: String;
		localeBuild: String;
		localeVersion: String;
		name: String;
		osType: String;
		productLineId: String;
		vendor: String;
		version: String;

		constructor();
		constructor(name?: String, fullName?: String, vendor?: String, version?: String, build?: String, localeVersion?: String, localeBuild?: String, osType?: String, productLineId?: String, apiType?: String, apiVersion?: String, instanceUuid?: String, licenseProductName?: String, licenseProductVersion?: String);
	}

	declare class VcAccountCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		spec: VcHostAccountSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, spec?: VcHostAccountSpec, group?: boolean);
	}

	declare class VcAccountRemovedEvent
	{
		account: String;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, account?: String, group?: boolean);
	}

	declare class VcAccountUpdatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		prevDescription: String;
		spec: VcHostAccountSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, spec?: VcHostAccountSpec, group?: boolean, prevDescription?: String);
	}

	declare class VcAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcActionParameter
	{
		readonly alarm: VcActionParameter;
		readonly alarmName: VcActionParameter;
		readonly declaringSummary: VcActionParameter;
		readonly eventDescription: VcActionParameter;
		readonly id: String;
		readonly name: String;
		readonly newStatus: VcActionParameter;
		readonly oldStatus: VcActionParameter;
		readonly target: VcActionParameter;
		readonly targetName: VcActionParameter;
		readonly triggeringSummary: VcActionParameter;
		readonly value: String;

		fromString(value?: VcActionParameter): VcActionParameter;
	}

	declare const VcActionParameter: VcActionParameter;

	interface VcActionType
	{
		readonly DecreaseMigrationThresholdV1: VcActionType;
		readonly DecreaseOthersReservationV1: VcActionType;
		readonly HostInfraUpdateHaV1: VcActionType;
		readonly HostMaintenanceV1: VcActionType;
		readonly HostPowerV1: VcActionType;
		readonly id: String;
		readonly IncreaseClusterCapacityV1: VcActionType;
		readonly IncreaseLimitV1: VcActionType;
		readonly IncreaseReservationV1: VcActionType;
		readonly IncreaseSharesV1: VcActionType;
		readonly IncreaseSizeV1: VcActionType;
		readonly MigrationV1: VcActionType;
		readonly name: String;
		readonly PlacementV1: VcActionType;
		readonly StorageMigrationV1: VcActionType;
		readonly StoragePlacementV1: VcActionType;
		readonly value: String;
		readonly VmPowerV1: VcActionType;

		fromString(value?: VcActionType): VcActionType;
	}

	declare const VcActionType: VcActionType;

	declare class VcActiveDirectoryFault
	{
		errorCode: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(errorCode?: Number);
		printStackTrace(): void;
	}

	declare class VcActiveDirectoryProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcActiveVMsBlockingEVC
	{
		evcMode: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		host: VcHostSystem[];
		hostName: String[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(faults?: VcLocalizedMethodFault[], evcMode?: String, host?: VcHostSystem[], hostName?: String[]);
		printStackTrace(): void;
	}

	declare class VcAdminDisabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcAdminNotDisabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcAdminPasswordNotChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcAffinityConfigured
	{
		configuredAffinity: String[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(configuredAffinity?: String[]);
		printStackTrace(): void;
	}

	interface VcAffinityType
	{
		readonly cpu: VcAffinityType;
		readonly id: String;
		readonly memory: VcAffinityType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcAffinityType): VcAffinityType;
	}

	declare const VcAffinityType: VcAffinityType;

	declare class VcAfterStartupTaskScheduler
	{
		activeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expireTime: Date;
		minute: Number;

		constructor();
		constructor(activeTime?: Date, expireTime?: Date, minute?: Number);
	}

	declare class VcAgentInstallFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		installerOutput: String;
		readonly localizedMessage: String;
		message: String;
		reason: String;
		statusCode: Number;

		constructor();
		constructor(reason?: String, statusCode?: Number, installerOutput?: String);
		printStackTrace(): void;
	}

	interface VcAgentInstallFailedReason
	{
		readonly AgentNotReachable: VcAgentInstallFailedReason;
		readonly AgentNotRunning: VcAgentInstallFailedReason;
		readonly AgentUploadFailed: VcAgentInstallFailedReason;
		readonly AgentUploadTimedout: VcAgentInstallFailedReason;
		readonly id: String;
		readonly InstallTimedout: VcAgentInstallFailedReason;
		readonly name: String;
		readonly NotEnoughSpaceOnDevice: VcAgentInstallFailedReason;
		readonly PrepareToUpgradeFailed: VcAgentInstallFailedReason;
		readonly SignatureVerificationFailed: VcAgentInstallFailedReason;
		readonly UnknownInstallerError: VcAgentInstallFailedReason;
		readonly value: String;

		fromString(value?: VcAgentInstallFailedReason): VcAgentInstallFailedReason;
	}

	declare const VcAgentInstallFailedReason: VcAgentInstallFailedReason;

	interface VcAgentManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		prepareToUpgrade(): String;
		upgrade(arg0?: String, arg1?: String): void;
	}

	declare const VcAgentManager: VcAgentManager;

	interface VcAlarm
	{
		readonly availableField: VcCustomFieldDef[];
		id: String;
		info: VcAlarmInfo;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureAlarm(arg0?: VcAlarmSpec): void;
		removeAlarm(): void;
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcAlarm: VcAlarm;

	declare class VcAlarmAcknowledgedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		source: VcManagedEntityEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, source?: VcManagedEntityEventArgument, entity?: VcManagedEntityEventArgument);
	}

	declare class VcAlarmAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcAlarmActionTriggeredEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		source: VcManagedEntityEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, source?: VcManagedEntityEventArgument, entity?: VcManagedEntityEventArgument);
	}

	declare class VcAlarmClearedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		from: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		source: VcManagedEntityEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, source?: VcManagedEntityEventArgument, entity?: VcManagedEntityEventArgument, from?: String);
	}

	declare class VcAlarmCreatedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, entity?: VcManagedEntityEventArgument);
	}

	declare class VcAlarmDescription
	{
		action: VcTypeDescription[];
		datastoreConnectionState: VcElementDescription[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityStatus: VcElementDescription[];
		expr: VcTypeDescription[];
		hostSystemConnectionState: VcElementDescription[];
		hostSystemPowerState: VcElementDescription[];
		metricOperator: VcElementDescription[];
		stateOperator: VcElementDescription[];
		virtualMachineGuestHeartbeatStatus: VcElementDescription[];
		virtualMachinePowerState: VcElementDescription[];

		constructor();
		constructor(expr?: VcTypeDescription[], stateOperator?: VcElementDescription[], metricOperator?: VcElementDescription[], hostSystemConnectionState?: VcElementDescription[], virtualMachinePowerState?: VcElementDescription[], datastoreConnectionState?: VcElementDescription[], hostSystemPowerState?: VcElementDescription[], virtualMachineGuestHeartbeatStatus?: VcElementDescription[], entityStatus?: VcElementDescription[], action?: VcTypeDescription[]);
	}

	declare class VcAlarmEmailCompletedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		to: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, entity?: VcManagedEntityEventArgument, to?: String);
	}

	declare class VcAlarmEmailFailedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		to: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, entity?: VcManagedEntityEventArgument, to?: String, reason?: VcLocalizedMethodFault);
	}

	declare class VcAlarmEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument);
	}

	declare class VcAlarmEventArgument
	{
		alarm: VcAlarm;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, alarm?: VcAlarm);
	}

	declare class VcAlarmExpression
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcAlarmFilterSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		status: VcManagedEntityStatus[];
		typeEntity: VcAlarmFilterSpecAlarmTypeByEntity;
		typeTrigger: VcAlarmFilterSpecAlarmTypeByTrigger;

		constructor();
		constructor(status?: VcManagedEntityStatus[], typeEntity?: VcAlarmFilterSpecAlarmTypeByEntity, typeTrigger?: VcAlarmFilterSpecAlarmTypeByTrigger);
	}

	interface VcAlarmFilterSpecAlarmTypeByEntity
	{
		readonly entityTypeAll: VcAlarmFilterSpecAlarmTypeByEntity;
		readonly entityTypeHost: VcAlarmFilterSpecAlarmTypeByEntity;
		readonly entityTypeVm: VcAlarmFilterSpecAlarmTypeByEntity;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcAlarmFilterSpecAlarmTypeByEntity): VcAlarmFilterSpecAlarmTypeByEntity;
	}

	declare const VcAlarmFilterSpecAlarmTypeByEntity: VcAlarmFilterSpecAlarmTypeByEntity;

	interface VcAlarmFilterSpecAlarmTypeByTrigger
	{
		readonly id: String;
		readonly name: String;
		readonly triggerTypeAll: VcAlarmFilterSpecAlarmTypeByTrigger;
		readonly triggerTypeEvent: VcAlarmFilterSpecAlarmTypeByTrigger;
		readonly triggerTypeMetric: VcAlarmFilterSpecAlarmTypeByTrigger;
		readonly value: String;

		fromString(value?: VcAlarmFilterSpecAlarmTypeByTrigger): VcAlarmFilterSpecAlarmTypeByTrigger;
	}

	declare const VcAlarmFilterSpecAlarmTypeByTrigger: VcAlarmFilterSpecAlarmTypeByTrigger;

	declare class VcAlarmInfo
	{
		action: VcAlarmAction;
		actionFrequency: Number;
		alarm: VcAlarm;
		alarmMetadata: String;
		creationEventId: Number;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		entity: VcManagedEntity;
		expression: VcAlarmExpression;
		key: String;
		lastModifiedTime: Date;
		lastModifiedUser: String;
		name: String;
		setting: VcAlarmSetting;
		systemName: String;

		constructor();
		constructor(name?: String, systemName?: String, description?: String, enabled?: boolean, expression?: VcAlarmExpression, action?: VcAlarmAction, actionFrequency?: Number, setting?: VcAlarmSetting, alarmMetadata?: String, key?: String, alarm?: VcAlarm, entity?: VcManagedEntity, lastModifiedTime?: Date, lastModifiedUser?: String, creationEventId?: Number);
	}

	interface VcAlarmManager
	{
		defaultExpression: VcAlarmExpression[];
		description: VcAlarmDescription;
		id: String;
		lastTriggerId: Number;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		acknowledgeAlarm(arg0?: VcAlarm, arg1?: VcManagedEntity): void;
		areAlarmActionsEnabled(arg0?: VcManagedEntity): boolean;
		clearTriggeredAlarms(arg0?: VcAlarmFilterSpec): void;
		createAlarm(arg0?: VcManagedEntity, arg1?: VcAlarmSpec): VcAlarm;
		createPrivateAlarm(arg0?: VcManagedEntity, arg1?: VcAlarmSpec): VcAlarm;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		enableAlarmActions(arg0?: VcManagedEntity, arg1?: boolean): void;
		getAlarm(arg0?: VcManagedEntity): VcAlarm[];
		getAlarmState(arg0?: VcManagedEntity): VcAlarmState[];
		queryPrivateAlarms(arg0?: VcManagedEntity, arg1?: String, arg2?: boolean): VcAlarm[];
		retrieveTriggers(arg0?: Number, arg1?: Number): VcAlarmTrigger[];
		setAlarmStatus(arg0?: VcAlarm, arg1?: VcManagedEntity, arg2?: VcManagedEntityStatus): void;
		syncTriggeredAlarms(): VcAlarmTrigger[];
		testSMTPSetup(arg0?: String): void;
	}

	declare const VcAlarmManager: VcAlarmManager;

	declare class VcAlarmReconfiguredEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configChanges: VcChangesInfoEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, entity?: VcManagedEntityEventArgument, configChanges?: VcChangesInfoEventArgument);
	}

	declare class VcAlarmRemovedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, entity?: VcManagedEntityEventArgument);
	}

	declare class VcAlarmScriptCompleteEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		script: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, entity?: VcManagedEntityEventArgument, script?: String);
	}

	declare class VcAlarmScriptFailedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		script: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, entity?: VcManagedEntityEventArgument, script?: String, reason?: VcLocalizedMethodFault);
	}

	declare class VcAlarmSetting
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reportingFrequency: Number;
		toleranceRange: Number;

		constructor();
		constructor(toleranceRange?: Number, reportingFrequency?: Number);
	}

	declare class VcAlarmSnmpCompletedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, entity?: VcManagedEntityEventArgument);
	}

	declare class VcAlarmSnmpFailedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, entity?: VcManagedEntityEventArgument, reason?: VcLocalizedMethodFault);
	}

	declare class VcAlarmSpec
	{
		action: VcAlarmAction;
		actionFrequency: Number;
		alarmMetadata: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		expression: VcAlarmExpression;
		name: String;
		setting: VcAlarmSetting;
		systemName: String;

		constructor();
		constructor(name?: String, systemName?: String, description?: String, enabled?: boolean, expression?: VcAlarmExpression, action?: VcAlarmAction, actionFrequency?: Number, setting?: VcAlarmSetting, alarmMetadata?: String);
	}

	declare class VcAlarmState
	{
		acknowledged: boolean;
		acknowledgedByUser: String;
		acknowledgedTime: Date;
		alarm: VcAlarm;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		eventKey: Number;
		key: String;
		overallStatus: VcManagedEntityStatus;
		time: Date;

		constructor(key?: String, entity?: VcManagedEntity, alarm?: VcAlarm, overallStatus?: VcManagedEntityStatus, time?: Date, acknowledged?: boolean, acknowledgedByUser?: String, acknowledgedTime?: Date, eventKey?: Number);
		constructor();
		isAcknowledged(): boolean;
	}

	declare class VcAlarmStatusChangedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		from: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		source: VcManagedEntityEventArgument;
		to: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, alarm?: VcAlarmEventArgument, source?: VcManagedEntityEventArgument, entity?: VcManagedEntityEventArgument, from?: String, to?: String);
	}

	declare class VcAlarmTrigger
	{
		alarmId: String;
		arguments: VcKeyAnyValue[];
		deviceName: String;
		deviceType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fromStatus: VcManagedEntityStatus;
		object: VcManagedEntity;
		ruleName: String;
		toStatus: VcManagedEntityStatus;
		triggerNum: Number;
		triggerTime: Number;
		type: String;

		constructor();
		constructor(triggerNum?: Number, type?: String, alarmId?: String, object?: VcManagedEntity, deviceName?: String, ruleName?: String, deviceType?: String, triggerTime?: Number, fromStatus?: VcManagedEntityStatus, toStatus?: VcManagedEntityStatus, arguments?: VcKeyAnyValue[]);
	}

	declare class VcAlarmTriggeringAction
	{
		action: VcAction;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		green2yellow: boolean;
		red2yellow: boolean;
		transitionSpecs: VcAlarmTriggeringActionTransitionSpec[];
		yellow2green: boolean;
		yellow2red: boolean;

		constructor();
		constructor(action?: VcAction, transitionSpecs?: VcAlarmTriggeringActionTransitionSpec[], green2yellow?: boolean, yellow2red?: boolean, red2yellow?: boolean, yellow2green?: boolean);
	}

	declare class VcAlarmTriggeringActionTransitionSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		finalState: VcManagedEntityStatus;
		repeats: boolean;
		startState: VcManagedEntityStatus;

		constructor();
		constructor(startState?: VcManagedEntityStatus, finalState?: VcManagedEntityStatus, repeats?: boolean);
	}

	interface VcAlarmTriggerType
	{
		readonly event: VcAlarmTriggerType;
		readonly id: String;
		readonly metric: VcAlarmTriggerType;
		readonly name: String;
		readonly state: VcAlarmTriggerType;
		readonly value: String;

		fromString(value?: VcAlarmTriggerType): VcAlarmTriggerType;
	}

	declare const VcAlarmTriggerType: VcAlarmTriggerType;

	declare class VcAllVirtualMachinesLicensedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcAlreadyAuthenticatedSessionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcAlreadyBeingManaged
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		ipAddress: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(ipAddress?: String);
		printStackTrace(): void;
	}

	declare class VcAlreadyConnected
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String);
		printStackTrace(): void;
	}

	declare class VcAlreadyExists
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String);
		printStackTrace(): void;
	}

	declare class VcAlreadyUpgraded
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcAndAlarmExpression
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expression: VcAlarmExpression[];

		constructor();
		constructor(expression?: VcAlarmExpression[]);
	}

	declare class VcAnswerFile
	{
		createdTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		modifiedTime: Date;
		userInput: VcProfileDeferredPolicyOptionParameter[];

		constructor();
		constructor(userInput?: VcProfileDeferredPolicyOptionParameter[], createdTime?: Date, modifiedTime?: Date);
	}

	declare class VcAnswerFileCreateSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		validating: boolean;

		constructor();
		constructor(validating?: boolean);
		isValidating(): boolean;
	}

	declare class VcAnswerFileOptionsCreateSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		userInput: VcProfileDeferredPolicyOptionParameter[];
		validating: boolean;

		constructor();
		constructor(validating?: boolean, userInput?: VcProfileDeferredPolicyOptionParameter[]);
		isValidating(): boolean;
	}

	declare class VcAnswerFileSerializedCreateSpec
	{
		answerFileConfigString: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		validating: boolean;

		constructor();
		constructor(validating?: boolean, answerFileConfigString?: String);
		isValidating(): boolean;
	}

	declare class VcAnswerFileStatusError
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errMsg: VcLocalizableMessage;
		userInputPath: VcProfilePropertyPath;

		constructor();
		constructor(userInputPath?: VcProfilePropertyPath, errMsg?: VcLocalizableMessage);
	}

	declare class VcAnswerFileStatusResult
	{
		checkedTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcAnswerFileStatusError[];
		host: VcHostSystem;
		status: String;

		constructor();
		constructor(checkedTime?: Date, host?: VcHostSystem, status?: String, error?: VcAnswerFileStatusError[]);
	}

	declare class VcAnswerFileUpdateFailed
	{
		failure: VcAnswerFileUpdateFailure[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(failure?: VcAnswerFileUpdateFailure[]);
		printStackTrace(): void;
	}

	declare class VcAnswerFileUpdateFailure
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errMsg: VcLocalizableMessage;
		userInputPath: VcProfilePropertyPath;

		constructor();
		constructor(userInputPath?: VcProfilePropertyPath, errMsg?: VcLocalizableMessage);
	}

	declare class VcAnswerFileValidationResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcAnswerFileUpdateFailure[];
		status: String;

		constructor();
		constructor(status?: String, error?: VcAnswerFileUpdateFailure[]);
	}

	declare class VcAnswerFileValidationResultMap
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		host: VcHostSystem;
		validationResult: VcAnswerFileValidationResult;

		constructor();
		constructor(host?: VcHostSystem, validationResult?: VcAnswerFileValidationResult, fault?: VcLocalizedMethodFault);
	}

	interface VcAnswerFileValidationResultStatus
	{
		readonly error: VcAnswerFileValidationResultStatus;
		readonly id: String;
		readonly name: String;
		readonly needInput: VcAnswerFileValidationResultStatus;
		readonly success: VcAnswerFileValidationResultStatus;
		readonly value: String;

		fromString(value?: VcAnswerFileValidationResultStatus): VcAnswerFileValidationResultStatus;
	}

	declare const VcAnswerFileValidationResultStatus: VcAnswerFileValidationResultStatus;

	interface VcAntiAffinityGroup
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcAntiAffinityGroup: VcAntiAffinityGroup;

	declare class VcApplicationQuiesceFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcApplyHostProfileConfigurationResult
	{
		completeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errors: VcLocalizedMethodFault[];
		host: VcHostSystem;
		startTime: Date;
		status: String;

		constructor();
		constructor(startTime?: Date, completeTime?: Date, host?: VcHostSystem, status?: String, errors?: VcLocalizedMethodFault[]);
	}

	interface VcApplyHostProfileConfigurationResultStatus
	{
		readonly canceled: VcApplyHostProfileConfigurationResultStatus;
		readonly check_compliance_failed: VcApplyHostProfileConfigurationResultStatus;
		readonly exit_maintenancemode_failed: VcApplyHostProfileConfigurationResultStatus;
		readonly failed: VcApplyHostProfileConfigurationResultStatus;
		readonly id: String;
		readonly name: String;
		readonly reboot_failed: VcApplyHostProfileConfigurationResultStatus;
		readonly state_not_satisfied: VcApplyHostProfileConfigurationResultStatus;
		readonly stateless_reboot_failed: VcApplyHostProfileConfigurationResultStatus;
		readonly success: VcApplyHostProfileConfigurationResultStatus;
		readonly value: String;

		fromString(value?: VcApplyHostProfileConfigurationResultStatus): VcApplyHostProfileConfigurationResultStatus;
	}

	declare const VcApplyHostProfileConfigurationResultStatus: VcApplyHostProfileConfigurationResultStatus;

	declare class VcApplyHostProfileConfigurationSpec
	{
		configSpec: VcHostConfigSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcProfileExecuteError[];
		faultData: VcLocalizedMethodFault;
		host: VcHostSystem;
		inapplicablePath: String[];
		rebootHost: boolean;
		rebootStateless: boolean;
		requireInput: VcProfileDeferredPolicyOptionParameter[];
		status: String;
		taskDescription: VcLocalizableMessage[];
		taskListRequirement: String[];

		constructor();
		constructor(status?: String, configSpec?: VcHostConfigSpec, inapplicablePath?: String[], requireInput?: VcProfileDeferredPolicyOptionParameter[], error?: VcProfileExecuteError[], host?: VcHostSystem, taskListRequirement?: String[], taskDescription?: VcLocalizableMessage[], rebootStateless?: boolean, rebootHost?: boolean, faultData?: VcLocalizedMethodFault);
		isRebootHost(): boolean;
		isRebootStateless(): boolean;
	}

	declare class VcApplyProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcApplyStorageRecommendationResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine);
	}

	interface VcArrayUpdateOperation
	{
		readonly add: VcArrayUpdateOperation;
		readonly edit: VcArrayUpdateOperation;
		readonly id: String;
		readonly name: String;
		readonly remove: VcArrayUpdateOperation;
		readonly value: String;

		fromString(value?: VcArrayUpdateOperation): VcArrayUpdateOperation;
	}

	declare const VcArrayUpdateOperation: VcArrayUpdateOperation;

	declare class VcArrayUpdateSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object);
	}

	declare class VcAuthenticationProfile
	{
		activeDirectory: VcActiveDirectoryProfile;
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, activeDirectory?: VcActiveDirectoryProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcAuthMinimumAdminPermission
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcAuthorizationDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		privilege: VcElementDescription[];
		privilegeGroup: VcElementDescription[];

		constructor();
		constructor(privilege?: VcElementDescription[], privilegeGroup?: VcElementDescription[]);
	}

	declare class VcAuthorizationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	interface VcAuthorizationManager
	{
		description: VcAuthorizationDescription;
		id: String;
		moref: VcManagedObjectReference;
		privilegeList: VcAuthorizationPrivilege[];
		roleList: VcAuthorizationRole[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addAuthorizationRole(arg0?: String, arg1?: String[]): Number;
		checkMethodInvocation(arg0?: VcManagedEntity, arg1?: String, arg2?: String, arg3?: Object[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		disableMethods(arg0?: VcManagedEntity[], arg1?: VcDisabledMethodRequest[], arg2?: String, arg3?: boolean): void;
		enableMethods(arg0?: VcManagedEntity[], arg1?: String[], arg2?: String): VcEntityDisabledMethodInfo[];
		fetchUserPrivilegeOnEntities(arg0?: VcManagedEntity[], arg1?: String): VcUserPrivilegeResult[];
		hasPrivilegeOnEntities(arg0?: VcManagedEntity[], arg1?: String, arg2?: String[]): VcEntityPrivilege[];
		hasPrivilegeOnEntity(arg0?: VcManagedEntity, arg1?: String, arg2?: String[]): boolean[];
		hasUserPrivilegeOnEntities(arg0?: VcManagedObject[], arg1?: String, arg2?: String[]): VcEntityPrivilege[];
		mergePermissions(arg0?: Number, arg1?: Number): void;
		queryDisabledMethods(arg0?: VcManagedEntity): VcDisabledMethodInfo[];
		queryPermissions(arg0?: VcSessionManagerServiceRequestSpec): VcAuthorizationManagerRequiredPermission[];
		removeAuthorizationRole(arg0?: Number, arg1?: boolean): void;
		removeEntityPermission(arg0?: VcManagedEntity, arg1?: String, arg2?: boolean): void;
		resetEntityPermissions(arg0?: VcManagedEntity, arg1?: VcPermission[]): void;
		retrieveAllPermissions(): VcPermission[];
		retrieveEntityPermissions(arg0?: VcManagedEntity, arg1?: boolean): VcPermission[];
		retrievePermissions(): VcPermission[];
		retrieveRolePermissions(arg0?: Number): VcPermission[];
		setEntityPermissions(arg0?: VcManagedEntity, arg1?: VcPermission[]): void;
		updateAuthorizationRole(arg0?: Number, arg1?: String, arg2?: String[]): void;
	}

	declare const VcAuthorizationManager: VcAuthorizationManager;

	declare class VcAuthorizationManagerRequiredPermission
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		privilege: String;

		constructor();
		constructor(privilege?: String, entity?: VcManagedEntity);
	}

	declare class VcAuthorizationPrivilege
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		onParent: boolean;
		privGroupName: String;
		privId: String;

		constructor();
		constructor(privId?: String, onParent?: boolean, name?: String, privGroupName?: String);
	}

	declare class VcAuthorizationRole
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcDescription;
		name: String;
		privilege: String[];
		roleId: Number;
		system: boolean;

		constructor();
		constructor(roleId?: Number, system?: boolean, name?: String, info?: VcDescription, privilege?: String[]);
	}

	interface VcAutoStartAction
	{
		readonly guestShutdown: VcAutoStartAction;
		readonly id: String;
		readonly name: String;
		readonly none: VcAutoStartAction;
		readonly powerOff: VcAutoStartAction;
		readonly powerOn: VcAutoStartAction;
		readonly suspend: VcAutoStartAction;
		readonly systemDefault: VcAutoStartAction;
		readonly value: String;

		fromString(value?: VcAutoStartAction): VcAutoStartAction;
	}

	declare const VcAutoStartAction: VcAutoStartAction;

	declare class VcAutoStartDefaults
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		startDelay: Number;
		stopAction: String;
		stopDelay: Number;
		waitForHeartbeat: boolean;

		constructor();
		constructor(enabled?: boolean, startDelay?: Number, stopDelay?: Number, waitForHeartbeat?: boolean, stopAction?: String);
		isEnabled(): boolean;
		isWaitForHeartbeat(): boolean;
	}

	declare class VcAutoStartPowerInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcVirtualMachine;
		startAction: String;
		startDelay: Number;
		startOrder: Number;
		stopAction: String;
		stopDelay: Number;
		waitForHeartbeat: VcAutoStartWaitHeartbeatSetting;

		constructor();
		constructor(key?: VcVirtualMachine, startOrder?: Number, startDelay?: Number, waitForHeartbeat?: VcAutoStartWaitHeartbeatSetting, startAction?: String, stopDelay?: Number, stopAction?: String);
	}

	interface VcAutoStartWaitHeartbeatSetting
	{
		readonly id: String;
		readonly name: String;
		readonly no: VcAutoStartWaitHeartbeatSetting;
		readonly systemDefault: VcAutoStartWaitHeartbeatSetting;
		readonly value: String;
		readonly yes: VcAutoStartWaitHeartbeatSetting;

		fromString(value?: VcAutoStartWaitHeartbeatSetting): VcAutoStartWaitHeartbeatSetting;
	}

	declare const VcAutoStartWaitHeartbeatSetting: VcAutoStartWaitHeartbeatSetting;

	declare class VcBackupBlobReadFailure
	{
		entityName: String;
		entityType: String;
		fault: VcLocalizedMethodFault;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(entityName?: String, entityType?: String, fault?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcBackupBlobWriteFailure
	{
		entityName: String;
		entityType: String;
		fault: VcLocalizedMethodFault;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(entityName?: String, entityType?: String, fault?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcBadUsernameSessionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ipAddress: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, ipAddress?: String);
	}

	declare class VcBaseConfigInfo
	{
		backing: VcBaseConfigInfoBackingInfo;
		createTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcID;
		iofilter: String[];
		name: String;

		constructor();
		constructor(id?: VcID, name?: String, createTime?: Date, backing?: VcBaseConfigInfoBackingInfo, iofilter?: String[]);
	}

	declare class VcBaseConfigInfoBackingInfo
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(datastore?: VcDatastore);
	}

	declare class VcBaseConfigInfoDiskFileBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		deltaSizeInMB: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filePath: String;
		parent: VcBaseConfigInfoFileBackingInfo;
		provisioningType: String;

		constructor();
		constructor(datastore?: VcDatastore, filePath?: String, backingObjectId?: String, parent?: VcBaseConfigInfoFileBackingInfo, deltaSizeInMB?: Number, provisioningType?: String);
	}

	interface VcBaseConfigInfoDiskFileBackingInfoProvisioningType
	{
		readonly eagerZeroedThick: VcBaseConfigInfoDiskFileBackingInfoProvisioningType;
		readonly id: String;
		readonly lazyZeroedThick: VcBaseConfigInfoDiskFileBackingInfoProvisioningType;
		readonly name: String;
		readonly thin: VcBaseConfigInfoDiskFileBackingInfoProvisioningType;
		readonly value: String;

		fromString(value?: VcBaseConfigInfoDiskFileBackingInfoProvisioningType): VcBaseConfigInfoDiskFileBackingInfoProvisioningType;
	}

	declare const VcBaseConfigInfoDiskFileBackingInfoProvisioningType: VcBaseConfigInfoDiskFileBackingInfoProvisioningType;

	declare class VcBaseConfigInfoFileBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		deltaSizeInMB: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filePath: String;
		parent: VcBaseConfigInfoFileBackingInfo;

		constructor();
		constructor(datastore?: VcDatastore, filePath?: String, backingObjectId?: String, parent?: VcBaseConfigInfoFileBackingInfo, deltaSizeInMB?: Number);
	}

	declare class VcBaseConfigInfoRawDiskMappingBackingInfo
	{
		backingObjectId: String;
		compatibilityMode: String;
		datastore: VcDatastore;
		deltaSizeInMB: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filePath: String;
		lunUuid: String;
		parent: VcBaseConfigInfoFileBackingInfo;

		constructor();
		constructor(datastore?: VcDatastore, filePath?: String, backingObjectId?: String, parent?: VcBaseConfigInfoFileBackingInfo, deltaSizeInMB?: Number, lunUuid?: String, compatibilityMode?: String);
	}

	declare class VcBatchResult
	{
		ds: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		hostKey: String;
		result: String;

		constructor();
		constructor(result?: String, hostKey?: String, ds?: VcDatastore, fault?: VcLocalizedMethodFault);
	}

	interface VcBatchResultResult
	{
		readonly fail: VcBatchResultResult;
		readonly id: String;
		readonly name: String;
		readonly success: VcBatchResultResult;
		readonly value: String;

		fromString(value?: VcBatchResultResult): VcBatchResultResult;
	}

	declare const VcBatchResultResult: VcBatchResultResult;

	declare class VcBlockedByFirewall
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcBoolOption
	{
		defaultValue: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		supported: boolean;
		valueIsReadonly: boolean;

		constructor();
		constructor(valueIsReadonly?: boolean, supported?: boolean, defaultValue?: boolean);
		isValueIsReadonly(): boolean;
	}

	declare class VcBoolPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		value: boolean;

		constructor();
		constructor(inherited?: boolean, value?: boolean);
		isValue(): boolean;
	}

	declare class VcCAMServerRefusedConnection
	{
		camServer: String;
		errorCode: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(errorCode?: Number, camServer?: String);
		printStackTrace(): void;
	}

	declare class VcCanceledHostOperationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcCannotAccessFile
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcCannotAccessLocalSource
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotAccessNetwork
	{
		backing: String;
		connected: boolean;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		network: VcNetwork;

		constructor();
		constructor(device?: String, backing?: String, connected?: boolean, network?: VcNetwork);
		printStackTrace(): void;
	}

	declare class VcCannotAccessVmComponent
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotAccessVmConfig
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: VcLocalizedMethodFault;

		constructor(reason?: VcLocalizedMethodFault);
		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotAccessVmDevice
	{
		backing: String;
		connected: boolean;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String, backing?: String, connected?: boolean);
		printStackTrace(): void;
	}

	declare class VcCannotAccessVmDisk
	{
		backing: String;
		connected: boolean;
		device: String;
		fault: VcLocalizedMethodFault;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String, backing?: String, connected?: boolean, fault?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcCannotAddHostWithFTVmAsStandalone
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotAddHostWithFTVmToDifferentCluster
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotAddHostWithFTVmToNonHACluster
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotChangeDrsBehaviorForFtSecondary
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(vm?: VcVirtualMachine, vmName?: String);
		printStackTrace(): void;
	}

	declare class VcCannotChangeHaSettingsForFtSecondary
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(vm?: VcVirtualMachine, vmName?: String);
		printStackTrace(): void;
	}

	declare class VcCannotChangeVsanClusterUuid
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotChangeVsanNodeUuid
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotComputeFTCompatibleHosts
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(vm?: VcVirtualMachine, vmName?: String);
		printStackTrace(): void;
	}

	declare class VcCannotCreateFile
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcCannotDecryptPasswords
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotDeleteFile
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcCannotDisableDrsOnClustersWithVApps
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotDisableSnapshot
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotDisconnectHostWithFaultToleranceVm
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostName?: String);
		printStackTrace(): void;
	}

	declare class VcCannotEnableVmcpForCluster
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(host?: VcHostSystem, hostName?: String, reason?: String);
		printStackTrace(): void;
	}

	interface VcCannotEnableVmcpForClusterReason
	{
		readonly APDTimeoutDisabled: VcCannotEnableVmcpForClusterReason;
		readonly id: String;
		readonly IncompatibleHostVersion: VcCannotEnableVmcpForClusterReason;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcCannotEnableVmcpForClusterReason): VcCannotEnableVmcpForClusterReason;
	}

	declare const VcCannotEnableVmcpForClusterReason: VcCannotEnableVmcpForClusterReason;

	declare class VcCannotModifyConfigCpuRequirements
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotMoveFaultToleranceVm
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		moveType: String;
		vmName: String;

		constructor();
		constructor(moveType?: String, vmName?: String);
		printStackTrace(): void;
	}

	interface VcCannotMoveFaultToleranceVmMoveType
	{
		readonly cluster: VcCannotMoveFaultToleranceVmMoveType;
		readonly id: String;
		readonly name: String;
		readonly resourcePool: VcCannotMoveFaultToleranceVmMoveType;
		readonly value: String;

		fromString(value?: VcCannotMoveFaultToleranceVmMoveType): VcCannotMoveFaultToleranceVmMoveType;
	}

	declare const VcCannotMoveFaultToleranceVmMoveType: VcCannotMoveFaultToleranceVmMoveType;

	declare class VcCannotMoveHostWithFaultToleranceVm
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotMoveVmWithDeltaDisk
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcCannotMoveVmWithNativeDeltaDisk
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotMoveVsanEnabledHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotPlaceWithoutPrerequisiteMoves
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotPowerOffVmInCluster
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		operation: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(operation?: String, vm?: VcVirtualMachine, vmName?: String);
		printStackTrace(): void;
	}

	interface VcCannotPowerOffVmInClusterOperation
	{
		readonly guestShutdown: VcCannotPowerOffVmInClusterOperation;
		readonly guestSuspend: VcCannotPowerOffVmInClusterOperation;
		readonly id: String;
		readonly name: String;
		readonly powerOff: VcCannotPowerOffVmInClusterOperation;
		readonly suspend: VcCannotPowerOffVmInClusterOperation;
		readonly value: String;

		fromString(value?: VcCannotPowerOffVmInClusterOperation): VcCannotPowerOffVmInClusterOperation;
	}

	declare const VcCannotPowerOffVmInClusterOperation: VcCannotPowerOffVmInClusterOperation;

	declare class VcCannotReconfigureVsanWhenHaEnabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCannotUseNetwork
	{
		backing: String;
		connected: boolean;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		network: VcNetwork;
		reason: String;

		constructor();
		constructor(device?: String, backing?: String, connected?: boolean, reason?: String, network?: VcNetwork);
		printStackTrace(): void;
	}

	interface VcCannotUseNetworkReason
	{
		readonly id: String;
		readonly MismatchedDvsVersionOrVendor: VcCannotUseNetworkReason;
		readonly MismatchedNetworkPolicies: VcCannotUseNetworkReason;
		readonly name: String;
		readonly NetworkReservationNotSupported: VcCannotUseNetworkReason;
		readonly value: String;
		readonly VMotionToUnsupportedNetworkType: VcCannotUseNetworkReason;

		fromString(value?: VcCannotUseNetworkReason): VcCannotUseNetworkReason;
	}

	declare const VcCannotUseNetworkReason: VcCannotUseNetworkReason;

	declare class VcCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		multiHostSupported: boolean;
		networkBackupAndRestoreSupported: boolean;
		provisioningSupported: boolean;
		supportedEVCMode: VcEVCMode[];
		userShellAccessSupported: boolean;

		constructor();
		constructor(provisioningSupported?: boolean, multiHostSupported?: boolean, userShellAccessSupported?: boolean, supportedEVCMode?: VcEVCMode[], networkBackupAndRestoreSupported?: boolean);
		isNetworkBackupAndRestoreSupported(): boolean;
	}

	declare class VcCbrcDeviceBackingNotSupported
	{
		backing: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(backing?: String);
		printStackTrace(): void;
	}

	declare class VcCbrcDeviceSpec
	{
		deviceKey: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, deviceKey?: Number);
	}

	declare class VcCbrcDigestConfigureResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		spec: VcCbrcDeviceSpec;

		constructor();
		constructor(spec?: VcCbrcDeviceSpec, fault?: VcLocalizedMethodFault);
	}

	declare class VcCbrcDigestInfo
	{
		baseDigestPath: String;
		baseDiskCid: Number;
		baseDiskPath: String;
		digestBlockSize: Number;
		digestVersion: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hashCollisionDetectionEnabled: boolean;
		hashKeyLength: Number;
		journalCoverageArea: Number;
		numberHashes: Number;
		numberValidHashes: Number;
		partitionOffsetEnabled: boolean;
		recomputeNeeded: boolean;

		constructor();
		constructor(digestVersion?: Number, digestBlockSize?: Number, numberHashes?: Number, numberValidHashes?: Number, partitionOffsetEnabled?: boolean, hashCollisionDetectionEnabled?: boolean, hashKeyLength?: Number, journalCoverageArea?: Number, baseDiskCid?: Number, baseDiskPath?: String, baseDigestPath?: String, recomputeNeeded?: boolean);
	}

	declare class VcCbrcDigestInfoResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		info: VcCbrcDigestInfo;
		spec: VcCbrcDeviceSpec;

		constructor();
		constructor(spec?: VcCbrcDeviceSpec, fault?: VcLocalizedMethodFault, info?: VcCbrcDigestInfo);
	}

	declare class VcCbrcDigestOperationResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		spec: VcCbrcDeviceSpec;

		constructor();
		constructor(spec?: VcCbrcDeviceSpec, fault?: VcLocalizedMethodFault);
	}

	declare class VcCbrcDigestRecomputeResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		spec: VcCbrcDeviceSpec;

		constructor();
		constructor(spec?: VcCbrcDeviceSpec, fault?: VcLocalizedMethodFault);
	}

	declare class VcCbrcDigestRuntimeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inUse: boolean;

		constructor();
		constructor(inUse?: boolean);
	}

	declare class VcCbrcDigestRuntimeInfoResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		runtimeInfo: VcCbrcDigestRuntimeInfo;
		spec: VcCbrcDeviceSpec;

		constructor();
		constructor(spec?: VcCbrcDeviceSpec, fault?: VcLocalizedMethodFault, runtimeInfo?: VcCbrcDigestRuntimeInfo);
	}

	interface VcCbrcManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		configureDigest_Task(arg0?: VcCbrcDeviceSpec[], arg1?: boolean, arg2?: boolean, arg3?: boolean): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryDigestInfo(arg0?: VcCbrcDeviceSpec[]): VcCbrcDigestInfoResult[];
		queryDigestRuntimeStatus(arg0?: VcCbrcDeviceSpec[]): VcCbrcDigestRuntimeInfoResult[];
		recomputeDigest_Task(arg0?: VcCbrcDeviceSpec[], arg1?: boolean): VcTask;
	}

	declare const VcCbrcManager: VcCbrcManager;

	declare class VcCbrcVmdkLockFailure
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCDCAlarmChange
	{
		acknowledgedByUser: String;
		acknowledgedTime: Date;
		alarm: VcAlarm;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		eventKey: Number;
		kind: String;
		overallStatus: VcManagedEntityStatus;
		time: Date;

		constructor();
		constructor(kind?: String, entity?: VcManagedEntity, alarm?: VcAlarm, overallStatus?: VcManagedEntityStatus, time?: Date, eventKey?: Number, acknowledgedByUser?: String, acknowledgedTime?: Date);
	}

	interface VcCDCAlarmChangeKind
	{
		readonly acknowledged: VcCDCAlarmChangeKind;
		readonly cleared: VcCDCAlarmChangeKind;
		readonly id: String;
		readonly name: String;
		readonly retriggered: VcCDCAlarmChangeKind;
		readonly triggered: VcCDCAlarmChangeKind;
		readonly value: String;

		fromString(value?: VcCDCAlarmChangeKind): VcCDCAlarmChangeKind;
	}

	declare const VcCDCAlarmChangeKind: VcCDCAlarmChangeKind;

	interface VcCDCChangeLogCollector
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		exchangeSequence(arg0?: String, arg1?: String[], arg2?: String[]): String;
		initializeSequence(arg0?: String[]): String;
		waitForChanges(arg0?: String): VcCDCChangeSet;
	}

	declare const VcCDCChangeLogCollector: VcCDCChangeLogCollector;

	interface VcCDCChangeLogCollectorChangeLog
	{
		readonly alarmStatus: VcCDCChangeLogCollectorChangeLog;
		readonly id: String;
		readonly inventory: VcCDCChangeLogCollectorChangeLog;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcCDCChangeLogCollectorChangeLog): VcCDCChangeLogCollectorChangeLog;
	}

	declare const VcCDCChangeLogCollectorChangeLog: VcCDCChangeLogCollectorChangeLog;

	declare class VcCDCChangeSet
	{
		alarmChanges: VcCDCAlarmChange[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inventoryChanges: VcCDCInventoryChange[];
		sequence: String;

		constructor();
		constructor(sequence?: String, inventoryChanges?: VcCDCInventoryChange[], alarmChanges?: VcCDCAlarmChange[]);
	}

	declare class VcCDCInventoryChange
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		kind: String;
		object: VcManagedObject;
		properties: String[];

		constructor();
		constructor(kind?: String, object?: VcManagedObject, properties?: String[]);
	}

	interface VcCDCInventoryChangeKind
	{
		readonly created: VcCDCInventoryChangeKind;
		readonly deleted: VcCDCInventoryChangeKind;
		readonly id: String;
		readonly name: String;
		readonly updated: VcCDCInventoryChangeKind;
		readonly value: String;

		fromString(value?: VcCDCInventoryChangeKind): VcCDCInventoryChangeKind;
	}

	declare const VcCDCInventoryChangeKind: VcCDCInventoryChangeKind;

	interface VcCertificateManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		certMgrRefreshCACertificatesAndCRLs_Task(arg0?: VcHostSystem[]): VcTask;
		certMgrRefreshCertificates_Task(arg0?: VcHostSystem[]): VcTask;
		certMgrRevokeCertificates_Task(arg0?: VcHostSystem[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcCertificateManager: VcCertificateManager;

	declare class VcChangesInfoEventArgument
	{
		added: String;
		deleted: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		modified: String;

		constructor();
		constructor(modified?: String, added?: String, deleted?: String);
	}

	declare class VcCheckResult
	{
		disk: VcCheckResultDiskInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault[];
		host: VcHostSystem;
		vm: VcVirtualMachine;
		warning: VcLocalizedMethodFault[];

		constructor();
		constructor(vm?: VcVirtualMachine, host?: VcHostSystem, disk?: VcCheckResultDiskInfo[], warning?: VcLocalizedMethodFault[], error?: VcLocalizedMethodFault[]);
	}

	declare class VcCheckResultDiskInfo
	{
		datastore: VcDatastore;
		diskId: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(diskId?: Number, datastore?: VcDatastore);
	}

	interface VcCheckTestType
	{
		readonly datastoreTests: VcCheckTestType;
		readonly hostTests: VcCheckTestType;
		readonly id: String;
		readonly name: String;
		readonly networkTests: VcCheckTestType;
		readonly resourcePoolTests: VcCheckTestType;
		readonly sourceTests: VcCheckTestType;
		readonly value: String;

		fromString(value?: VcCheckTestType): VcCheckTestType;
	}

	declare const VcCheckTestType: VcCheckTestType;

	declare class VcChoiceOption
	{
		choiceInfo: VcElementDescription[];
		defaultIndex: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		valueIsReadonly: boolean;

		constructor();
		constructor(valueIsReadonly?: boolean, choiceInfo?: VcElementDescription[], defaultIndex?: Number);
		isValueIsReadonly(): boolean;
	}

	declare class VcClockSkew
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCloneFromSnapshotNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcClusterAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		target: VcManagedObject;
		type: String;

		constructor();
		constructor(type?: String, target?: VcManagedObject);
	}

	declare class VcClusterActionHistory
	{
		action: VcClusterAction;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		time: Date;

		constructor(action?: VcClusterAction, time?: Date);
		constructor();
	}

	declare class VcClusterAffinityRuleSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;
		vm: VcVirtualMachine[];

		constructor();
		constructor(key?: Number, status?: VcManagedEntityStatus, enabled?: boolean, name?: String, mandatory?: boolean, userCreated?: boolean, inCompliance?: boolean, ruleUuid?: String, vm?: VcVirtualMachine[]);
		isEnabled(): boolean;
		isInCompliance(): boolean;
		isMandatory(): boolean;
		isUserCreated(): boolean;
	}

	declare class VcClusterAntiAffinityRuleSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;
		vm: VcVirtualMachine[];

		constructor();
		constructor(key?: Number, status?: VcManagedEntityStatus, enabled?: boolean, name?: String, mandatory?: boolean, userCreated?: boolean, inCompliance?: boolean, ruleUuid?: String, vm?: VcVirtualMachine[]);
		isEnabled(): boolean;
		isInCompliance(): boolean;
		isMandatory(): boolean;
		isUserCreated(): boolean;
	}

	declare class VcClusterAttemptedVmInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		task: VcTask;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, task?: VcTask);
	}

	declare class VcClusterComplianceCheckedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, profile?: VcProfileEventArgument);
	}

	interface VcClusterComputeResource
	{
		actionHistory: VcClusterActionHistory[];
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		configuration: VcClusterConfigInfo;
		readonly configurationEx: VcComputeResourceConfigInfo;
		readonly customValue: VcCustomFieldValue[];
		readonly datastore: VcDatastore[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		drsFault: VcClusterDrsFaults[];
		drsRecommendation: VcClusterDrsRecommendation[];
		readonly effectiveRole: Number[];
		readonly environmentBrowser: VcEnvironmentBrowser;
		readonly host: VcHostSystem[];
		id: String;
		migrationHistory: VcClusterDrsMigration[];
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly network: VcNetwork[];
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		recommendation: VcClusterRecommendation[];
		readonly resourcePool: VcResourcePool;
		resourceUsage: VcClusterResourceUsageSummary;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly summary: VcComputeResourceSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addHost_Task(arg0?: VcHostConnectSpec, arg1?: boolean, arg2?: VcResourcePool, arg3?: String): VcTask;
		addHostWithAdminDisabled_Task(arg0?: VcHostConnectSpec, arg1?: boolean, arg2?: VcResourcePool, arg3?: String): VcTask;
		addTag(arg0?: VcTag[]): void;
		applyRecommendation(arg0?: String): void;
		cancelRecommendation(arg0?: String): void;
		checkDasAdmission(arg0?: VcVirtualMachine[]): VcClusterDasAdmissionResult;
		checkReconfigureDas(arg0?: VcClusterDasConfigInfo, arg1?: boolean): VcClusterDasPrecheckResult;
		checkReconfigureDasVmcp(arg0?: VcClusterDasConfigInfo, arg1?: boolean): VcClusterDasVmcpPrecheckResult;
		clusterEnterMaintenanceMode(arg0?: VcHostSystem[], arg1?: VcOptionValue[]): VcClusterEnterMaintenanceResult;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		evcManager(): VcClusterEVCManager;
		findRulesForVm(arg0?: VcVirtualMachine): VcClusterRuleInfo[];
		generateDrmBundle_Task(arg0?: Date, arg1?: Date, arg2?: Number): VcTask;
		moveHostInto_Task(arg0?: VcHostSystem, arg1?: VcResourcePool): VcTask;
		moveInto_Task(arg0?: VcHostSystem[]): VcTask;
		placeVm(arg0?: VcPlacementSpec): VcPlacementResult;
		queryCompatibilityForFaultTolerance(arg0?: VcVirtualMachine): VcClusterComputeResourceFtCompatibilityResult;
		queryDrmDumpHistory_Task(arg0?: Date, arg1?: Date, arg2?: Number): VcTask;
		queryFaultToleranceCompatibleDatastores(arg0?: VcVirtualMachine, arg1?: VcOptionValue[]): VcClusterComputeResourceFtCompatibleDatastoresResult;
		queryFaultToleranceCompatibleHosts(arg0?: VcVirtualMachine, arg1?: VcFaultToleranceConfigSpec): VcClusterComputeResourceFtCompatibleHostResult[];
		recommendHostsForVm(arg0?: VcVirtualMachine, arg1?: VcResourcePool): VcClusterHostRecommendation[];
		reconfigureCluster_Task(arg0?: VcClusterConfigSpec, arg1?: boolean): VcTask;
		reconfigureComputeResource_Task(arg0?: VcComputeResourceConfigSpec, arg1?: boolean): VcTask;
		refreshRecommendation(): void;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		retrieveDasAdvancedRuntimeInfo(): VcClusterDasAdvancedRuntimeInfo;
		retrieveDasData(): VcClusterDasData;
		setCustomValue(arg0?: String, arg1?: String): void;
		stampAllRulesWithUuid_Task(): VcTask;
		transitionalEVCManager(): VcClusterTransitionalEVCManager;
		verifyFaultToleranceConfigSpec(arg0?: VcVirtualMachine, arg1?: VcHostSystem, arg2?: VcFaultToleranceConfigSpec): VcClusterComputeResourceFtConfigSpecVerificationResult;
	}

	declare const VcClusterComputeResource: VcClusterComputeResource;

	declare class VcClusterComputeResourceDrmBundleInfo
	{
		drmDumpInfo: VcClusterComputeResourceDrmDumpInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		url: String;

		constructor();
		constructor(url?: String, drmDumpInfo?: VcClusterComputeResourceDrmDumpInfo);
	}

	declare class VcClusterComputeResourceDrmDumpInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		earliestDumpFileTimestamp: Date;
		latestDumpFileTimestamp: Date;
		totalNumberOfDumpFiles: Number;

		constructor();
		constructor(totalNumberOfDumpFiles?: Number, latestDumpFileTimestamp?: Date, earliestDumpFileTimestamp?: Date);
	}

	declare class VcClusterComputeResourceFtCompatibilityResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errors: VcLocalizedMethodFault[];
		warnings: VcLocalizedMethodFault[];

		constructor();
		constructor(errors?: VcLocalizedMethodFault[], warnings?: VcLocalizedMethodFault[]);
	}

	declare class VcClusterComputeResourceFtCompatibleDatastoresResult
	{
		compatibleFtMetadataDatastores: VcDatastore[];
		compatibleFtSecondaryConfigDatastores: VcDatastore[];
		compatibleFtSecondaryDiskDatastores: VcDatastore[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		primaryHost: VcHostSystem;

		constructor();
		constructor(primaryHost?: VcHostSystem, compatibleFtMetadataDatastores?: VcDatastore[], compatibleFtSecondaryConfigDatastores?: VcDatastore[], compatibleFtSecondaryDiskDatastores?: VcDatastore[]);
	}

	declare class VcClusterComputeResourceFtCompatibleHostResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errors: VcLocalizedMethodFault[];
		ftHost: VcHostSystem;
		warnings: VcLocalizedMethodFault[];

		constructor();
		constructor(ftHost?: VcHostSystem, errors?: VcLocalizedMethodFault[], warnings?: VcLocalizedMethodFault[]);
	}

	declare class VcClusterComputeResourceFtConfigSpecVerificationResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errors: VcLocalizedMethodFault[];
		warnings: VcLocalizedMethodFault[];

		constructor();
		constructor(errors?: VcLocalizedMethodFault[], warnings?: VcLocalizedMethodFault[]);
	}

	declare class VcClusterComputeResourceSummary
	{
		admissionControlInfo: VcClusterDasAdmissionControlInfo;
		currentBalance: Number;
		currentEVCModeKey: String;
		currentFailoverLevel: Number;
		dasData: VcClusterDasData;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		effectiveCpu: Number;
		effectiveMemory: Number;
		numCpuCores: Number;
		numCpuThreads: Number;
		numEffectiveHosts: Number;
		numHosts: Number;
		numVmotions: Number;
		overallStatus: VcManagedEntityStatus;
		targetBalance: Number;
		totalCpu: Number;
		totalMemory: Number;
		usageSummary: VcClusterUsageSummary;

		constructor();
		constructor(totalCpu?: Number, totalMemory?: Number, numCpuCores?: Number, numCpuThreads?: Number, effectiveCpu?: Number, effectiveMemory?: Number, numHosts?: Number, numEffectiveHosts?: Number, overallStatus?: VcManagedEntityStatus, currentFailoverLevel?: Number, admissionControlInfo?: VcClusterDasAdmissionControlInfo, numVmotions?: Number, targetBalance?: Number, currentBalance?: Number, usageSummary?: VcClusterUsageSummary, currentEVCModeKey?: String, dasData?: VcClusterDasData);
	}

	declare class VcClusterConfigInfo
	{
		dasConfig: VcClusterDasConfigInfo;
		dasVmConfig: VcClusterDasVmConfigInfo[];
		drsConfig: VcClusterDrsConfigInfo;
		drsVmConfig: VcClusterDrsVmConfigInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		rule: VcClusterRuleInfo[];

		constructor();
		constructor(dasConfig?: VcClusterDasConfigInfo, dasVmConfig?: VcClusterDasVmConfigInfo[], drsConfig?: VcClusterDrsConfigInfo, drsVmConfig?: VcClusterDrsVmConfigInfo[], rule?: VcClusterRuleInfo[]);
	}

	declare class VcClusterConfigInfoEx
	{
		dasConfig: VcClusterDasConfigInfo;
		dasVmConfig: VcClusterDasVmConfigInfo[];
		defaultHardwareVersionKey: String;
		dpmConfigInfo: VcClusterDpmConfigInfo;
		dpmHostConfig: VcClusterDpmHostConfigInfo[];
		drsConfig: VcClusterDrsConfigInfo;
		drsVmConfig: VcClusterDrsVmConfigInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		group: VcClusterGroupInfo[];
		infraUpdateHaConfig: VcClusterInfraUpdateHaConfigInfo;
		orchestration: VcClusterOrchestrationInfo;
		proactiveDrsConfig: VcClusterProactiveDrsConfigInfo;
		rule: VcClusterRuleInfo[];
		spbmEnabled: boolean;
		vmOrchestration: VcClusterVmOrchestrationInfo[];
		vmSwapPlacement: String;
		vsanConfigInfo: VcVsanClusterConfigInfo;
		vsanHostConfig: VcVsanHostConfigInfo[];

		constructor();
		constructor(vmSwapPlacement?: String, spbmEnabled?: boolean, defaultHardwareVersionKey?: String, dasConfig?: VcClusterDasConfigInfo, dasVmConfig?: VcClusterDasVmConfigInfo[], drsConfig?: VcClusterDrsConfigInfo, drsVmConfig?: VcClusterDrsVmConfigInfo[], rule?: VcClusterRuleInfo[], orchestration?: VcClusterOrchestrationInfo, vmOrchestration?: VcClusterVmOrchestrationInfo[], dpmConfigInfo?: VcClusterDpmConfigInfo, dpmHostConfig?: VcClusterDpmHostConfigInfo[], vsanConfigInfo?: VcVsanClusterConfigInfo, vsanHostConfig?: VcVsanHostConfigInfo[], group?: VcClusterGroupInfo[], infraUpdateHaConfig?: VcClusterInfraUpdateHaConfigInfo, proactiveDrsConfig?: VcClusterProactiveDrsConfigInfo);
		isSpbmEnabled(): boolean;
	}

	declare class VcClusterConfigSpec
	{
		dasConfig: VcClusterDasConfigInfo;
		dasVmConfigSpec: VcClusterDasVmConfigSpec[];
		drsConfig: VcClusterDrsConfigInfo;
		drsVmConfigSpec: VcClusterDrsVmConfigSpec[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		rulesSpec: VcClusterRuleSpec[];

		constructor();
		constructor(dasConfig?: VcClusterDasConfigInfo, dasVmConfigSpec?: VcClusterDasVmConfigSpec[], drsConfig?: VcClusterDrsConfigInfo, drsVmConfigSpec?: VcClusterDrsVmConfigSpec[], rulesSpec?: VcClusterRuleSpec[]);
	}

	declare class VcClusterConfigSpecEx
	{
		dasConfig: VcClusterDasConfigInfo;
		dasVmConfigSpec: VcClusterDasVmConfigSpec[];
		defaultHardwareVersionKey: String;
		dpmConfig: VcClusterDpmConfigInfo;
		dpmHostConfigSpec: VcClusterDpmHostConfigSpec[];
		drsConfig: VcClusterDrsConfigInfo;
		drsVmConfigSpec: VcClusterDrsVmConfigSpec[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		groupSpec: VcClusterGroupSpec[];
		infraUpdateHaConfig: VcClusterInfraUpdateHaConfigInfo;
		orchestration: VcClusterOrchestrationInfo;
		proactiveDrsConfig: VcClusterProactiveDrsConfigInfo;
		rulesSpec: VcClusterRuleSpec[];
		spbmEnabled: boolean;
		vmOrchestrationSpec: VcClusterVmOrchestrationSpec[];
		vmSwapPlacement: String;
		vsanConfig: VcVsanClusterConfigInfo;
		vsanHostConfigSpec: VcVsanHostConfigInfo[];

		constructor();
		constructor(vmSwapPlacement?: String, spbmEnabled?: boolean, defaultHardwareVersionKey?: String, dasConfig?: VcClusterDasConfigInfo, dasVmConfigSpec?: VcClusterDasVmConfigSpec[], drsConfig?: VcClusterDrsConfigInfo, drsVmConfigSpec?: VcClusterDrsVmConfigSpec[], rulesSpec?: VcClusterRuleSpec[], orchestration?: VcClusterOrchestrationInfo, vmOrchestrationSpec?: VcClusterVmOrchestrationSpec[], dpmConfig?: VcClusterDpmConfigInfo, dpmHostConfigSpec?: VcClusterDpmHostConfigSpec[], vsanConfig?: VcVsanClusterConfigInfo, vsanHostConfigSpec?: VcVsanHostConfigInfo[], groupSpec?: VcClusterGroupSpec[], infraUpdateHaConfig?: VcClusterInfraUpdateHaConfigInfo, proactiveDrsConfig?: VcClusterProactiveDrsConfigInfo);
		isSpbmEnabled(): boolean;
	}

	declare class VcClusterCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		parent: VcFolderEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, parent?: VcFolderEventArgument);
	}

	declare class VcClusterDasAamHostInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostDasState: VcClusterDasAamNodeState[];
		primaryHosts: String[];

		constructor();
		constructor(hostDasState?: VcClusterDasAamNodeState[], primaryHosts?: String[]);
	}

	declare class VcClusterDasAamNodeState
	{
		configState: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		name: String;
		runtimeState: String;

		constructor();
		constructor(host?: VcHostSystem, name?: String, configState?: String, runtimeState?: String);
	}

	interface VcClusterDasAamNodeStateDasState
	{
		readonly agentShutdown: VcClusterDasAamNodeStateDasState;
		readonly configuring: VcClusterDasAamNodeStateDasState;
		readonly error: VcClusterDasAamNodeStateDasState;
		readonly id: String;
		readonly initialized: VcClusterDasAamNodeStateDasState;
		readonly name: String;
		readonly nodeFailed: VcClusterDasAamNodeStateDasState;
		readonly running: VcClusterDasAamNodeStateDasState;
		readonly unconfiguring: VcClusterDasAamNodeStateDasState;
		readonly uninitialized: VcClusterDasAamNodeStateDasState;
		readonly value: String;

		fromString(value?: VcClusterDasAamNodeStateDasState): VcClusterDasAamNodeStateDasState;
	}

	declare const VcClusterDasAamNodeStateDasState: VcClusterDasAamNodeStateDasState;

	declare class VcClusterDasAdmissionControlInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcClusterDasAdmissionControlPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		resourceReductionToToleratePercent: Number;

		constructor();
		constructor(resourceReductionToToleratePercent?: Number);
	}

	declare class VcClusterDasAdmissionResult
	{
		advancedInfo: VcClusterDasAdvancedRuntimeInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcClusterDasAdmissionControlInfo;
		pass: boolean;

		constructor();
		constructor(pass?: boolean, info?: VcClusterDasAdmissionControlInfo, advancedInfo?: VcClusterDasAdvancedRuntimeInfo);
	}

	declare class VcClusterDasAdvancedRuntimeInfo
	{
		dasHostInfo: VcClusterDasHostInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		heartbeatDatastoreInfo: VcDasHeartbeatDatastoreInfo[];
		vmcpSupported: VcClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo;

		constructor();
		constructor(dasHostInfo?: VcClusterDasHostInfo, vmcpSupported?: VcClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo, heartbeatDatastoreInfo?: VcDasHeartbeatDatastoreInfo[]);
	}

	declare class VcClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		storageAPDSupported: boolean;
		storagePDLSupported: boolean;

		constructor();
		constructor(storageAPDSupported?: boolean, storagePDLSupported?: boolean);
	}

	declare class VcClusterDasConfigInfo
	{
		admissionControlEnabled: boolean;
		admissionControlPolicy: VcClusterDasAdmissionControlPolicy;
		defaultVmSettings: VcClusterDasVmSettings;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		failoverLevel: Number;
		hBDatastoreCandidatePolicy: String;
		hBDatastoresPerHost: Number;
		heartbeatDatastore: VcDatastore[];
		hostMonitoring: String;
		option: VcOptionValue[];
		vmComponentProtecting: String;
		vmMonitoring: String;

		constructor();
		constructor(enabled?: boolean, vmMonitoring?: String, hostMonitoring?: String, vmComponentProtecting?: String, failoverLevel?: Number, admissionControlPolicy?: VcClusterDasAdmissionControlPolicy, admissionControlEnabled?: boolean, defaultVmSettings?: VcClusterDasVmSettings, option?: VcOptionValue[], heartbeatDatastore?: VcDatastore[], hBDatastoreCandidatePolicy?: String, hBDatastoresPerHost?: Number);
		isAdmissionControlEnabled(): boolean;
		isEnabled(): boolean;
	}

	interface VcClusterDasConfigInfoHBDatastoreCandidate
	{
		readonly allFeasibleDs: VcClusterDasConfigInfoHBDatastoreCandidate;
		readonly allFeasibleDsWithUserPreference: VcClusterDasConfigInfoHBDatastoreCandidate;
		readonly id: String;
		readonly name: String;
		readonly userSelectedDs: VcClusterDasConfigInfoHBDatastoreCandidate;
		readonly value: String;

		fromString(value?: VcClusterDasConfigInfoHBDatastoreCandidate): VcClusterDasConfigInfoHBDatastoreCandidate;
	}

	declare const VcClusterDasConfigInfoHBDatastoreCandidate: VcClusterDasConfigInfoHBDatastoreCandidate;

	interface VcClusterDasConfigInfoServiceState
	{
		readonly disabled: VcClusterDasConfigInfoServiceState;
		readonly enabled: VcClusterDasConfigInfoServiceState;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcClusterDasConfigInfoServiceState): VcClusterDasConfigInfoServiceState;
	}

	declare const VcClusterDasConfigInfoServiceState: VcClusterDasConfigInfoServiceState;

	interface VcClusterDasConfigInfoVmMonitoringState
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmAndAppMonitoring: VcClusterDasConfigInfoVmMonitoringState;
		readonly vmMonitoringDisabled: VcClusterDasConfigInfoVmMonitoringState;
		readonly vmMonitoringOnly: VcClusterDasConfigInfoVmMonitoringState;

		fromString(value?: VcClusterDasConfigInfoVmMonitoringState): VcClusterDasConfigInfoVmMonitoringState;
	}

	declare const VcClusterDasConfigInfoVmMonitoringState: VcClusterDasConfigInfoVmMonitoringState;

	declare class VcClusterDasData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcClusterDasDataDetails
	{
		clusterConfig: VcClusterVersionedBinaryData;
		clusterConfigVersion: Number;
		compatList: VcClusterVersionedBinaryData;
		compatListVersion: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostList: VcClusterVersionedStringData;
		hostListVersion: Number;

		constructor();
		constructor(hostListVersion?: Number, clusterConfigVersion?: Number, compatListVersion?: Number, hostList?: VcClusterVersionedStringData, clusterConfig?: VcClusterVersionedBinaryData, compatList?: VcClusterVersionedBinaryData);
	}

	declare class VcClusterDasDataSummary
	{
		clusterConfigVersion: Number;
		compatListVersion: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostListVersion: Number;

		constructor();
		constructor(hostListVersion?: Number, clusterConfigVersion?: Number, compatListVersion?: Number);
	}

	declare class VcClusterDasFailoverLevelAdvancedRuntimeInfo
	{
		dasHostInfo: VcClusterDasHostInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		heartbeatDatastoreInfo: VcDasHeartbeatDatastoreInfo[];
		hostSlots: VcClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots[];
		slotInfo: VcClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo;
		totalGoodHosts: Number;
		totalHosts: Number;
		totalSlots: Number;
		totalVms: Number;
		unreservedSlots: Number;
		usedSlots: Number;
		vmcpSupported: VcClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo;
		vmsRequiringMultipleSlots: VcClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots[];

		constructor();
		constructor(dasHostInfo?: VcClusterDasHostInfo, vmcpSupported?: VcClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo, heartbeatDatastoreInfo?: VcDasHeartbeatDatastoreInfo[], slotInfo?: VcClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo, totalSlots?: Number, usedSlots?: Number, unreservedSlots?: Number, totalVms?: Number, totalHosts?: Number, totalGoodHosts?: Number, hostSlots?: VcClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots[], vmsRequiringMultipleSlots?: VcClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots[]);
	}

	declare class VcClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		slots: Number;

		constructor();
		constructor(host?: VcHostSystem, slots?: Number);
	}

	declare class VcClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo
	{
		cpuMHz: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memoryMB: Number;
		numVcpus: Number;

		constructor();
		constructor(numVcpus?: Number, cpuMHz?: Number, memoryMB?: Number);
	}

	declare class VcClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		slots: Number;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, slots?: Number);
	}

	interface VcClusterDasFdmAvailabilityState
	{
		readonly connectedToMaster: VcClusterDasFdmAvailabilityState;
		readonly election: VcClusterDasFdmAvailabilityState;
		readonly fdmUnreachable: VcClusterDasFdmAvailabilityState;
		readonly hostDown: VcClusterDasFdmAvailabilityState;
		readonly id: String;
		readonly initializationError: VcClusterDasFdmAvailabilityState;
		readonly master: VcClusterDasFdmAvailabilityState;
		readonly name: String;
		readonly networkIsolated: VcClusterDasFdmAvailabilityState;
		readonly networkPartitionedFromMaster: VcClusterDasFdmAvailabilityState;
		readonly uninitializationError: VcClusterDasFdmAvailabilityState;
		readonly uninitialized: VcClusterDasFdmAvailabilityState;
		readonly value: String;

		fromString(value?: VcClusterDasFdmAvailabilityState): VcClusterDasFdmAvailabilityState;
	}

	declare const VcClusterDasFdmAvailabilityState: VcClusterDasFdmAvailabilityState;

	declare class VcClusterDasFdmHostState
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		state: String;
		stateReporter: VcHostSystem;

		constructor();
		constructor(state?: String, stateReporter?: VcHostSystem);
	}

	declare class VcClusterDasHostInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcClusterDasHostRecommendation
	{
		drsRating: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;

		constructor();
		constructor(host?: VcHostSystem, drsRating?: Number);
	}

	declare class VcClusterDasPrecheckResult
	{
		admission: VcClusterDasAdmissionResult;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(admission?: VcClusterDasAdmissionResult);
	}

	declare class VcClusterDasVmConfigInfo
	{
		dasSettings: VcClusterDasVmSettings;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcVirtualMachine;
		powerOffOnIsolation: boolean;
		restartPriority: VcDasVmPriority;

		constructor();
		constructor(key?: VcVirtualMachine, restartPriority?: VcDasVmPriority, powerOffOnIsolation?: boolean, dasSettings?: VcClusterDasVmSettings);
		isPowerOffOnIsolation(): boolean;
	}

	declare class VcClusterDasVmConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcClusterDasVmConfigInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcClusterDasVmConfigInfo);
	}

	declare class VcClusterDasVmcpPrecheckResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostsWithApdTimeoutDisabled: VcHostSystem[];
		hostsWithIncompatibleVersion: VcHostSystem[];

		constructor();
		constructor(hostsWithIncompatibleVersion?: VcHostSystem[], hostsWithApdTimeoutDisabled?: VcHostSystem[]);
	}

	declare class VcClusterDasVmSettings
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		isolationResponse: String;
		restartPriority: String;
		restartPriorityTimeout: Number;
		vmComponentProtectionSettings: VcClusterVmComponentProtectionSettings;
		vmToolsMonitoringSettings: VcClusterVmToolsMonitoringSettings;

		constructor();
		constructor(restartPriority?: String, restartPriorityTimeout?: Number, isolationResponse?: String, vmToolsMonitoringSettings?: VcClusterVmToolsMonitoringSettings, vmComponentProtectionSettings?: VcClusterVmComponentProtectionSettings);
	}

	interface VcClusterDasVmSettingsIsolationResponse
	{
		readonly clusterIsolationResponse: VcClusterDasVmSettingsIsolationResponse;
		readonly id: String;
		readonly name: String;
		readonly none: VcClusterDasVmSettingsIsolationResponse;
		readonly powerOff: VcClusterDasVmSettingsIsolationResponse;
		readonly shutdown: VcClusterDasVmSettingsIsolationResponse;
		readonly value: String;

		fromString(value?: VcClusterDasVmSettingsIsolationResponse): VcClusterDasVmSettingsIsolationResponse;
	}

	declare const VcClusterDasVmSettingsIsolationResponse: VcClusterDasVmSettingsIsolationResponse;

	interface VcClusterDasVmSettingsRestartPriority
	{
		readonly clusterRestartPriority: VcClusterDasVmSettingsRestartPriority;
		readonly disabled: VcClusterDasVmSettingsRestartPriority;
		readonly high: VcClusterDasVmSettingsRestartPriority;
		readonly highest: VcClusterDasVmSettingsRestartPriority;
		readonly id: String;
		readonly low: VcClusterDasVmSettingsRestartPriority;
		readonly lowest: VcClusterDasVmSettingsRestartPriority;
		readonly medium: VcClusterDasVmSettingsRestartPriority;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcClusterDasVmSettingsRestartPriority): VcClusterDasVmSettingsRestartPriority;
	}

	declare const VcClusterDasVmSettingsRestartPriority: VcClusterDasVmSettingsRestartPriority;

	declare class VcClusterDependencyRuleInfo
	{
		dependsOnVmGroup: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;
		vmGroup: String;

		constructor();
		constructor(key?: Number, status?: VcManagedEntityStatus, enabled?: boolean, name?: String, mandatory?: boolean, userCreated?: boolean, inCompliance?: boolean, ruleUuid?: String, vmGroup?: String, dependsOnVmGroup?: String);
		isEnabled(): boolean;
		isInCompliance(): boolean;
		isMandatory(): boolean;
		isUserCreated(): boolean;
	}

	declare class VcClusterDestroyedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcClusterDiagnoseResourceAllocationResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entitlement: VcClusterDiagnoseResourceAllocationResultVmStaticEntitlement[];
		fault: VcClusterDrsFaults[];
		recommendation: VcClusterRecommendation[];

		constructor();
		constructor(recommendation?: VcClusterRecommendation[], fault?: VcClusterDrsFaults[], entitlement?: VcClusterDiagnoseResourceAllocationResultVmStaticEntitlement[]);
	}

	declare class VcClusterDiagnoseResourceAllocationResultVmStaticEntitlement
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		staticEntitlement: VcClusterPerResourceValue[];
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, staticEntitlement?: VcClusterPerResourceValue[]);
	}

	declare class VcClusterDpmConfigInfo
	{
		defaultDpmBehavior: VcDpmBehavior;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		hostPowerActionRate: Number;
		option: VcOptionValue[];

		constructor();
		constructor(enabled?: boolean, defaultDpmBehavior?: VcDpmBehavior, hostPowerActionRate?: Number, option?: VcOptionValue[]);
		isEnabled(): boolean;
	}

	declare class VcClusterDpmHostConfigInfo
	{
		behavior: VcDpmBehavior;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		key: VcHostSystem;

		constructor();
		constructor(key?: VcHostSystem, enabled?: boolean, behavior?: VcDpmBehavior);
		isEnabled(): boolean;
	}

	declare class VcClusterDpmHostConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcClusterDpmHostConfigInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcClusterDpmHostConfigInfo);
	}

	declare class VcClusterDrsConfigInfo
	{
		defaultVmBehavior: VcDrsBehavior;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		enableVmBehaviorOverrides: boolean;
		option: VcOptionValue[];
		vmotionRate: Number;

		constructor();
		constructor(enabled?: boolean, enableVmBehaviorOverrides?: boolean, defaultVmBehavior?: VcDrsBehavior, vmotionRate?: Number, option?: VcOptionValue[]);
		isEnabled(): boolean;
		isEnableVmBehaviorOverrides(): boolean;
	}

	declare class VcClusterDrsFaults
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		faultsByVm: VcClusterDrsFaultsFaultsByVm[];
		reason: String;

		constructor();
		constructor(reason?: String, faultsByVm?: VcClusterDrsFaultsFaultsByVm[]);
	}

	declare class VcClusterDrsFaultsFaultsByVirtualDisk
	{
		disk: VcVirtualDiskId;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault[];
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, fault?: VcLocalizedMethodFault[], disk?: VcVirtualDiskId);
	}

	declare class VcClusterDrsFaultsFaultsByVm
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault[];
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, fault?: VcLocalizedMethodFault[]);
	}

	declare class VcClusterDrsMigration
	{
		cpuLoad: Number;
		destination: VcHostSystem;
		destinationCpuLoad: Number;
		destinationMemoryLoad: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		memoryLoad: Number;
		source: VcHostSystem;
		sourceCpuLoad: Number;
		sourceMemoryLoad: Number;
		time: Date;
		vm: VcVirtualMachine;

		constructor(key?: String, time?: Date, vm?: VcVirtualMachine, cpuLoad?: Number, memoryLoad?: Number, source?: VcHostSystem, sourceCpuLoad?: Number, sourceMemoryLoad?: Number, destination?: VcHostSystem, destinationCpuLoad?: Number, destinationMemoryLoad?: Number);
		constructor();
	}

	declare class VcClusterDrsRecommendation
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		migrationList: VcClusterDrsMigration[];
		rating: Number;
		reason: String;
		reasonText: String;

		constructor();
		constructor(key?: String, rating?: Number, reason?: String, reasonText?: String, migrationList?: VcClusterDrsMigration[]);
	}

	declare class VcClusterDrsVmConfigInfo
	{
		behavior: VcDrsBehavior;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		key: VcVirtualMachine;

		constructor();
		constructor(key?: VcVirtualMachine, enabled?: boolean, behavior?: VcDrsBehavior);
		isEnabled(): boolean;
	}

	declare class VcClusterDrsVmConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcClusterDrsVmConfigInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcClusterDrsVmConfigInfo);
	}

	declare class VcClusterEnterMaintenanceResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcClusterDrsFaults;
		recommendations: VcClusterRecommendation[];

		constructor();
		constructor(recommendations?: VcClusterRecommendation[], fault?: VcClusterDrsFaults);
	}

	interface VcClusterEVCManager
	{
		readonly availableField: VcCustomFieldDef[];
		evcState: VcClusterEVCManagerEVCState;
		id: String;
		managedCluster: VcClusterComputeResource;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkAddHostEvc_Task(arg0?: VcHostConnectSpec): VcTask;
		checkConfigureEvcMode_Task(arg0?: String): VcTask;
		configureEvcMode_Task(arg0?: String): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		disableEvcMode_Task(): VcTask;
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcClusterEVCManager: VcClusterEVCManager;

	declare class VcClusterEVCManagerCheckResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault;
		evcModeKey: String;
		host: VcHostSystem[];

		constructor();
		constructor(evcModeKey?: String, error?: VcLocalizedMethodFault, host?: VcHostSystem[]);
	}

	declare class VcClusterEVCManagerEVCState
	{
		currentEVCModeKey: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		featureCapability: VcHostFeatureCapability[];
		featureMask: VcHostFeatureMask[];
		featureRequirement: VcVirtualMachineFeatureRequirement[];
		guaranteedCPUFeatures: VcHostCpuIdInfo[];
		supportedEVCMode: VcEVCMode[];

		constructor();
		constructor(supportedEVCMode?: VcEVCMode[], currentEVCModeKey?: String, guaranteedCPUFeatures?: VcHostCpuIdInfo[], featureCapability?: VcHostFeatureCapability[], featureMask?: VcHostFeatureMask[], featureRequirement?: VcVirtualMachineFeatureRequirement[]);
	}

	declare class VcClusterEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcClusterFailoverHostAdmissionControlInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostStatus: VcClusterFailoverHostAdmissionControlInfoHostStatus[];

		constructor();
		constructor(hostStatus?: VcClusterFailoverHostAdmissionControlInfoHostStatus[]);
	}

	declare class VcClusterFailoverHostAdmissionControlInfoHostStatus
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		status: VcManagedEntityStatus;

		constructor();
		constructor(host?: VcHostSystem, status?: VcManagedEntityStatus);
	}

	declare class VcClusterFailoverHostAdmissionControlPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failoverHosts: VcHostSystem[];
		failoverLevel: Number;
		resourceReductionToToleratePercent: Number;

		constructor();
		constructor(resourceReductionToToleratePercent?: Number, failoverHosts?: VcHostSystem[], failoverLevel?: Number);
	}

	declare class VcClusterFailoverLevelAdmissionControlInfo
	{
		currentFailoverLevel: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(currentFailoverLevel?: Number);
	}

	declare class VcClusterFailoverLevelAdmissionControlPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failoverLevel: Number;
		resourceReductionToToleratePercent: Number;
		slotPolicy: VcClusterSlotPolicy;

		constructor();
		constructor(resourceReductionToToleratePercent?: Number, failoverLevel?: Number, slotPolicy?: VcClusterSlotPolicy);
	}

	declare class VcClusterFailoverResourcesAdmissionControlInfo
	{
		currentCpuFailoverResourcesPercent: Number;
		currentMemoryFailoverResourcesPercent: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(currentCpuFailoverResourcesPercent?: Number, currentMemoryFailoverResourcesPercent?: Number);
	}

	declare class VcClusterFailoverResourcesAdmissionControlPolicy
	{
		autoComputePercentages: boolean;
		cpuFailoverResourcesPercent: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failoverLevel: Number;
		memoryFailoverResourcesPercent: Number;
		resourceReductionToToleratePercent: Number;

		constructor();
		constructor(resourceReductionToToleratePercent?: Number, cpuFailoverResourcesPercent?: Number, memoryFailoverResourcesPercent?: Number, failoverLevel?: Number, autoComputePercentages?: boolean);
		isAutoComputePercentages(): boolean;
	}

	declare class VcClusterFixedSizeSlotPolicy
	{
		cpu: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memory: Number;

		constructor();
		constructor(cpu?: Number, memory?: Number);
	}

	declare class VcClusterFtVmHostRuleInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		hostGroupName: String[];
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		primaryVmGroupName: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;

		constructor();
		constructor(key?: Number, status?: VcManagedEntityStatus, enabled?: boolean, name?: String, mandatory?: boolean, userCreated?: boolean, inCompliance?: boolean, ruleUuid?: String, primaryVmGroupName?: String, hostGroupName?: String[]);
		isEnabled(): boolean;
		isInCompliance(): boolean;
		isMandatory(): boolean;
		isUserCreated(): boolean;
	}

	declare class VcClusterGroupInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		uniqueID: String;
		userCreated: boolean;

		constructor();
		constructor(name?: String, userCreated?: boolean, uniqueID?: String);
		isUserCreated(): boolean;
	}

	declare class VcClusterGroupSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcClusterGroupInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcClusterGroupInfo);
	}

	declare class VcClusterHostGroup
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem[];
		name: String;
		uniqueID: String;
		userCreated: boolean;

		constructor();
		constructor(name?: String, userCreated?: boolean, uniqueID?: String, host?: VcHostSystem[]);
		isUserCreated(): boolean;
	}

	declare class VcClusterHostInfraUpdateHaModeAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operationType: String;
		target: VcManagedObject;
		type: String;

		constructor();
		constructor(type?: String, target?: VcManagedObject, operationType?: String);
	}

	interface VcClusterHostInfraUpdateHaModeActionOperationType
	{
		readonly enterMaintenance: VcClusterHostInfraUpdateHaModeActionOperationType;
		readonly enterQuarantine: VcClusterHostInfraUpdateHaModeActionOperationType;
		readonly exitQuarantine: VcClusterHostInfraUpdateHaModeActionOperationType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcClusterHostInfraUpdateHaModeActionOperationType): VcClusterHostInfraUpdateHaModeActionOperationType;
	}

	declare const VcClusterHostInfraUpdateHaModeActionOperationType: VcClusterHostInfraUpdateHaModeActionOperationType;

	declare class VcClusterHostPowerAction
	{
		cpuCapacityMHz: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memCapacityMB: Number;
		operationType: VcHostPowerOperationType;
		powerConsumptionWatt: Number;
		target: VcManagedObject;
		type: String;

		constructor();
		constructor(type?: String, target?: VcManagedObject, operationType?: VcHostPowerOperationType, powerConsumptionWatt?: Number, cpuCapacityMHz?: Number, memCapacityMB?: Number);
	}

	declare class VcClusterHostRecommendation
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		rating: Number;

		constructor();
		constructor(host?: VcHostSystem, rating?: Number);
	}

	declare class VcClusterIncreaseAllocationAction
	{
		delta: VcClusterPerResourceValue;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		target: VcManagedObject;
		type: String;

		constructor();
		constructor(type?: String, target?: VcManagedObject, delta?: VcClusterPerResourceValue);
	}

	declare class VcClusterIncreaseCpuCapacityAction
	{
		delta: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		numCpus: Number;
		target: VcManagedObject;
		type: String;

		constructor();
		constructor(type?: String, target?: VcManagedObject, delta?: Number, numCpus?: Number);
	}

	declare class VcClusterInfraUpdateHaConfigInfo
	{
		behavior: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		moderateRemediation: String;
		providers: String[];
		severeRemediation: String;

		constructor();
		constructor(enabled?: boolean, behavior?: String, moderateRemediation?: String, severeRemediation?: String, providers?: String[]);
		isEnabled(): boolean;
	}

	interface VcClusterInfraUpdateHaConfigInfoBehaviorType
	{
		readonly Automated: VcClusterInfraUpdateHaConfigInfoBehaviorType;
		readonly id: String;
		readonly Manual: VcClusterInfraUpdateHaConfigInfoBehaviorType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcClusterInfraUpdateHaConfigInfoBehaviorType): VcClusterInfraUpdateHaConfigInfoBehaviorType;
	}

	declare const VcClusterInfraUpdateHaConfigInfoBehaviorType: VcClusterInfraUpdateHaConfigInfoBehaviorType;

	interface VcClusterInfraUpdateHaConfigInfoRemediationType
	{
		readonly id: String;
		readonly MaintenanceMode: VcClusterInfraUpdateHaConfigInfoRemediationType;
		readonly name: String;
		readonly QuarantineMode: VcClusterInfraUpdateHaConfigInfoRemediationType;
		readonly value: String;

		fromString(value?: VcClusterInfraUpdateHaConfigInfoRemediationType): VcClusterInfraUpdateHaConfigInfoRemediationType;
	}

	declare const VcClusterInfraUpdateHaConfigInfoRemediationType: VcClusterInfraUpdateHaConfigInfoRemediationType;

	declare class VcClusterInitialPlacementAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pool: VcResourcePool;
		target: VcManagedObject;
		targetHost: VcHostSystem;
		type: String;

		constructor();
		constructor(type?: String, target?: VcManagedObject, targetHost?: VcHostSystem, pool?: VcResourcePool);
	}

	declare class VcClusterIoFilterInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		name: String;
		opType: String;
		releaseDate: String;
		summary: String;
		type: String;
		vendor: String;
		version: String;
		vibUrl: String;

		constructor();
		constructor(id?: String, name?: String, vendor?: String, version?: String, type?: String, summary?: String, releaseDate?: String, opType?: String, vibUrl?: String);
	}

	declare class VcClusterMigrationAction
	{
		drsMigration: VcClusterDrsMigration;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		target: VcManagedObject;
		type: String;

		constructor();
		constructor(type?: String, target?: VcManagedObject, drsMigration?: VcClusterDrsMigration);
	}

	declare class VcClusterNetworkConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipSettings: VcCustomizationIPSettings;
		networkPortGroup: VcNetwork;

		constructor();
		constructor(networkPortGroup?: VcNetwork, ipSettings?: VcCustomizationIPSettings);
	}

	declare class VcClusterNotAttemptedVmInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, fault?: VcLocalizedMethodFault);
	}

	declare class VcClusterOrchestrationInfo
	{
		defaultVmReadiness: VcClusterVmReadiness;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(defaultVmReadiness?: VcClusterVmReadiness);
	}

	declare class VcClusterOvercommittedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcClusterPerResourceValue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		resourceType: String;
		value: Number;

		constructor();
		constructor(resourceType?: String, value?: Number);
	}

	interface VcClusterPowerOnVmOption
	{
		readonly id: String;
		readonly name: String;
		readonly OverrideAutomationLevel: VcClusterPowerOnVmOption;
		readonly ReserveResources: VcClusterPowerOnVmOption;
		readonly value: String;

		fromString(value?: VcClusterPowerOnVmOption): VcClusterPowerOnVmOption;
	}

	declare const VcClusterPowerOnVmOption: VcClusterPowerOnVmOption;

	declare class VcClusterPowerOnVmResult
	{
		attempted: VcClusterAttemptedVmInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		notAttempted: VcClusterNotAttemptedVmInfo[];
		recommendations: VcClusterRecommendation[];

		constructor();
		constructor(attempted?: VcClusterAttemptedVmInfo[], notAttempted?: VcClusterNotAttemptedVmInfo[], recommendations?: VcClusterRecommendation[]);
	}

	declare class VcClusterProactiveDrsConfigInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;

		constructor();
		constructor(enabled?: boolean);
		isEnabled(): boolean;
	}

	interface VcClusterProfile
	{
		readonly complianceStatus: String;
		readonly config: VcProfileConfigInfo;
		readonly createdTime: Date;
		readonly description: VcProfileDescription;
		readonly entity: VcManagedEntity[];
		id: String;
		readonly modifiedTime: Date;
		moref: VcManagedObjectReference;
		readonly name: String;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		associateProfile(arg0?: VcManagedEntity[]): void;
		checkProfileCompliance_Task(arg0?: VcManagedEntity[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyProfile(): void;
		dissociateProfile(arg0?: VcManagedEntity[]): void;
		exportProfile(): String;
		retrieveDescription(): VcProfileDescription;
		updateClusterProfile(arg0?: VcClusterProfileConfigSpec): void;
	}

	declare const VcClusterProfile: VcClusterProfile;

	declare class VcClusterProfileCompleteConfigSpec
	{
		annotation: String;
		complyProfile: VcComplianceProfile;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean, complyProfile?: VcComplianceProfile);
		isEnabled(): boolean;
	}

	declare class VcClusterProfileConfigInfo
	{
		annotation: String;
		complyProfile: VcComplianceProfile;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean, complyProfile?: VcComplianceProfile);
	}

	declare class VcClusterProfileConfigServiceCreateSpec
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;
		serviceType: String[];

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean, serviceType?: String[]);
		isEnabled(): boolean;
	}

	declare class VcClusterProfileConfigSpec
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean);
		isEnabled(): boolean;
	}

	declare class VcClusterProfileCreateSpec
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean);
		isEnabled(): boolean;
	}

	interface VcClusterProfileManager
	{
		id: String;
		moref: VcManagedObjectReference;
		readonly profile: VcProfile[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createProfile(arg0?: VcProfileCreateSpec): VcProfile;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		findAssociatedProfile(arg0?: VcManagedEntity): VcProfile[];
		queryPolicyMetadata(arg0?: String[], arg1?: VcProfile): VcProfilePolicyMetadata[];
	}

	declare const VcClusterProfileManager: VcClusterProfileManager;

	interface VcClusterProfileServiceType
	{
		readonly DPM: VcClusterProfileServiceType;
		readonly DRS: VcClusterProfileServiceType;
		readonly FT: VcClusterProfileServiceType;
		readonly HA: VcClusterProfileServiceType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcClusterProfileServiceType): VcClusterProfileServiceType;
	}

	declare const VcClusterProfileServiceType: VcClusterProfileServiceType;

	declare class VcClusterRecommendation
	{
		action: VcClusterAction[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		prerequisite: String[];
		rating: Number;
		reason: String;
		reasonText: String;
		target: VcManagedObject;
		time: Date;
		type: String;
		warningDetails: VcLocalizableMessage;
		warningText: String;

		constructor();
		constructor(key?: String, type?: String, time?: Date, rating?: Number, reason?: String, reasonText?: String, warningText?: String, warningDetails?: VcLocalizableMessage, prerequisite?: String[], action?: VcClusterAction[], target?: VcManagedObject);
	}

	declare class VcClusterReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configChanges: VcChangesInfoEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, configChanges?: VcChangesInfoEventArgument);
	}

	declare class VcClusterResourceUsageSummary
	{
		cpuCapacityMHz: Number;
		cpuUsedMHz: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memCapacityMB: Number;
		memUsedMB: Number;
		pMemAvailableMB: Number;
		pMemCapacityMB: Number;
		storageCapacityMB: Number;
		storageUsedMB: Number;

		constructor();
		constructor(cpuUsedMHz?: Number, cpuCapacityMHz?: Number, memUsedMB?: Number, memCapacityMB?: Number, pMemAvailableMB?: Number, pMemCapacityMB?: Number, storageUsedMB?: Number, storageCapacityMB?: Number);
	}

	declare class VcClusterRuleInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;

		constructor();
		constructor(key?: Number, status?: VcManagedEntityStatus, enabled?: boolean, name?: String, mandatory?: boolean, userCreated?: boolean, inCompliance?: boolean, ruleUuid?: String);
		isEnabled(): boolean;
		isInCompliance(): boolean;
		isMandatory(): boolean;
		isUserCreated(): boolean;
	}

	declare class VcClusterRuleSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcClusterRuleInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcClusterRuleInfo);
	}

	declare class VcClusterSlotPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcClusterStatusChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newStatus: String;
		oldStatus: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, oldStatus?: String, newStatus?: String);
	}

	interface VcClusterTransitionalEVCManager
	{
		readonly availableField: VcCustomFieldDef[];
		evcState: VcClusterTransitionalEVCManagerEVCState;
		id: String;
		managedCluster: VcClusterComputeResource;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkAddHost_Task(arg0?: VcHostConnectSpec): VcTask;
		checkConfigureEVC_Task(arg0?: String): VcTask;
		configureEVC_Task(arg0?: String): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		disableEVC_Task(): VcTask;
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcClusterTransitionalEVCManager: VcClusterTransitionalEVCManager;

	declare class VcClusterTransitionalEVCManagerCheckResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault;
		evcModeKey: String;
		host: VcHostSystem[];

		constructor();
		constructor(evcModeKey?: String, error?: VcLocalizedMethodFault, host?: VcHostSystem[]);
	}

	declare class VcClusterTransitionalEVCManagerEVCState
	{
		currentEVCModeKey: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		featureCapability: VcHostFeatureCapability[];
		featureMask: VcHostFeatureMask[];
		featureRequirement: VcVirtualMachineFeatureRequirement[];
		guaranteedCPUFeatures: VcHostCpuIdInfo[];
		supportedEVCMode: VcEVCMode[];

		constructor();
		constructor(supportedEVCMode?: VcEVCMode[], currentEVCModeKey?: String, guaranteedCPUFeatures?: VcHostCpuIdInfo[], featureCapability?: VcHostFeatureCapability[], featureMask?: VcHostFeatureMask[], featureRequirement?: VcVirtualMachineFeatureRequirement[]);
	}

	declare class VcClusterUsageSummary
	{
		cpuDemandMhz: Number;
		cpuEntitledMhz: Number;
		cpuReservationMhz: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memDemandMB: Number;
		memEntitledMB: Number;
		memReservationMB: Number;
		poweredOffCpuReservationMhz: Number;
		poweredOffMemReservationMB: Number;
		poweredOffVmCount: Number;
		statsGenNumber: Number;
		totalCpuCapacityMhz: Number;
		totalMemCapacityMB: Number;
		totalVmCount: Number;

		constructor();
		constructor(totalCpuCapacityMhz?: Number, totalMemCapacityMB?: Number, cpuReservationMhz?: Number, memReservationMB?: Number, poweredOffCpuReservationMhz?: Number, poweredOffMemReservationMB?: Number, cpuDemandMhz?: Number, memDemandMB?: Number, statsGenNumber?: Number, cpuEntitledMhz?: Number, memEntitledMB?: Number, poweredOffVmCount?: Number, totalVmCount?: Number);
	}

	declare class VcClusterVersionedBinaryData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		version: Number;

		constructor();
	}

	declare class VcClusterVersionedStringData
	{
		data: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		version: Number;

		constructor(version?: Number, data?: String);
		constructor();
	}

	declare class VcClusterVmComponentProtectionSettings
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enableAPDTimeoutForHosts: boolean;
		vmReactionOnAPDCleared: String;
		vmStorageProtectionForAPD: String;
		vmStorageProtectionForPDL: String;
		vmTerminateDelayForAPDSec: Number;

		constructor();
		constructor(vmStorageProtectionForAPD?: String, enableAPDTimeoutForHosts?: boolean, vmTerminateDelayForAPDSec?: Number, vmReactionOnAPDCleared?: String, vmStorageProtectionForPDL?: String);
		isEnableAPDTimeoutForHosts(): boolean;
	}

	interface VcClusterVmComponentProtectionSettingsStorageVmReaction
	{
		readonly clusterDefault: VcClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly disabled: VcClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly id: String;
		readonly name: String;
		readonly restartAggressive: VcClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly restartConservative: VcClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly value: String;
		readonly warning: VcClusterVmComponentProtectionSettingsStorageVmReaction;

		fromString(value?: VcClusterVmComponentProtectionSettingsStorageVmReaction): VcClusterVmComponentProtectionSettingsStorageVmReaction;
	}

	declare const VcClusterVmComponentProtectionSettingsStorageVmReaction: VcClusterVmComponentProtectionSettingsStorageVmReaction;

	interface VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared
	{
		readonly id: String;
		readonly name: String;
		readonly none: VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
		readonly reset: VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
		readonly useClusterDefault: VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
		readonly value: String;

		fromString(value?: VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared): VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
	}

	declare const VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared: VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;

	declare class VcClusterVmGroup
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		uniqueID: String;
		userCreated: boolean;
		vm: VcVirtualMachine[];

		constructor();
		constructor(name?: String, userCreated?: boolean, uniqueID?: String, vm?: VcVirtualMachine[]);
		isUserCreated(): boolean;
	}

	declare class VcClusterVmHostRuleInfo
	{
		affineHostGroupName: String;
		antiAffineHostGroupName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;
		vmGroupName: String;

		constructor();
		constructor(key?: Number, status?: VcManagedEntityStatus, enabled?: boolean, name?: String, mandatory?: boolean, userCreated?: boolean, inCompliance?: boolean, ruleUuid?: String, vmGroupName?: String, affineHostGroupName?: String, antiAffineHostGroupName?: String);
		isEnabled(): boolean;
		isInCompliance(): boolean;
		isMandatory(): boolean;
		isUserCreated(): boolean;
	}

	declare class VcClusterVmOrchestrationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vm: VcVirtualMachine;
		vmReadiness: VcClusterVmReadiness;

		constructor();
		constructor(vm?: VcVirtualMachine, vmReadiness?: VcClusterVmReadiness);
	}

	declare class VcClusterVmOrchestrationSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcClusterVmOrchestrationInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcClusterVmOrchestrationInfo);
	}

	declare class VcClusterVmReadiness
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		postReadyDelay: Number;
		readyCondition: String;

		constructor();
		constructor(readyCondition?: String, postReadyDelay?: Number);
	}

	interface VcClusterVmReadinessReadyCondition
	{
		readonly appHbStatusGreen: VcClusterVmReadinessReadyCondition;
		readonly guestHbStatusGreen: VcClusterVmReadinessReadyCondition;
		readonly id: String;
		readonly name: String;
		readonly none: VcClusterVmReadinessReadyCondition;
		readonly poweredOn: VcClusterVmReadinessReadyCondition;
		readonly useClusterDefault: VcClusterVmReadinessReadyCondition;
		readonly value: String;

		fromString(value?: VcClusterVmReadinessReadyCondition): VcClusterVmReadinessReadyCondition;
	}

	declare const VcClusterVmReadinessReadyCondition: VcClusterVmReadinessReadyCondition;

	declare class VcClusterVmToolsMonitoringSettings
	{
		clusterSettings: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		failureInterval: Number;
		maxFailures: Number;
		maxFailureWindow: Number;
		minUpTime: Number;
		vmMonitoring: String;

		constructor();
		constructor(enabled?: boolean, vmMonitoring?: String, clusterSettings?: boolean, failureInterval?: Number, minUpTime?: Number, maxFailures?: Number, maxFailureWindow?: Number);
		isClusterSettings(): boolean;
		isEnabled(): boolean;
	}

	declare class VcCollectorAddressUnset
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcComplianceFailure
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expressionName: String;
		failureType: String;
		failureValues: VcComplianceFailureComplianceFailureValues[];
		message: VcLocalizableMessage;

		constructor();
		constructor(failureType?: String, message?: VcLocalizableMessage, expressionName?: String, failureValues?: VcComplianceFailureComplianceFailureValues[]);
	}

	declare class VcComplianceFailureComplianceFailureValues
	{
		comparisonIdentifier: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostValue_AnyValue: Object;
		hostValue_FloatValue: Number;
		hostValue_IntValue: Number;
		hostValue_LongValue: Number;
		profileInstance: String;
		profileValue_AnyValue: Object;
		profileValue_FloatValue: Number;
		profileValue_IntValue: Number;
		profileValue_LongValue: Number;

		constructor();
		constructor(comparisonIdentifier?: String, profileInstance?: String, hostValue?: Object, profileValue?: Object);
	}

	declare class VcComplianceLocator
	{
		applyPath: VcProfilePropertyPath;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expressionName: String;

		constructor();
		constructor(expressionName?: String, applyPath?: VcProfilePropertyPath);
	}

	declare class VcComplianceProfile
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expression: VcProfileExpression[];
		rootExpression: String;

		constructor();
		constructor(expression?: VcProfileExpression[], rootExpression?: String);
	}

	declare class VcComplianceResult
	{
		checkTime: Date;
		complianceStatus: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		failure: VcComplianceFailure[];
		profile: VcProfile;

		constructor();
		constructor(profile?: VcProfile, complianceStatus?: String, entity?: VcManagedEntity, checkTime?: Date, failure?: VcComplianceFailure[]);
	}

	interface VcComplianceResultStatus
	{
		readonly compliant: VcComplianceResultStatus;
		readonly id: String;
		readonly name: String;
		readonly nonCompliant: VcComplianceResultStatus;
		readonly unknown: VcComplianceResultStatus;
		readonly value: String;

		fromString(value?: VcComplianceResultStatus): VcComplianceResultStatus;
	}

	declare const VcComplianceResultStatus: VcComplianceResultStatus;

	declare class VcCompositePolicyOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		option: VcPolicyOption[];
		parameter: VcKeyAnyValue[];

		constructor();
		constructor(id?: String, parameter?: VcKeyAnyValue[], option?: VcPolicyOption[]);
	}

	interface VcComputeResource
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		configurationEx: VcComputeResourceConfigInfo;
		readonly customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		environmentBrowser: VcEnvironmentBrowser;
		host: VcHostSystem[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		network: VcNetwork[];
		network_DistributedVirtualPortgroup: Object[];
		network_Network: Object[];
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		resourcePool: VcResourcePool;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		summary: VcComputeResourceSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		reconfigureComputeResource_Task(arg0?: VcComputeResourceConfigSpec, arg1?: boolean): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcComputeResource: VcComputeResource;

	declare class VcComputeResourceConfigInfo
	{
		defaultHardwareVersionKey: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		spbmEnabled: boolean;
		vmSwapPlacement: String;

		constructor();
		constructor(vmSwapPlacement?: String, spbmEnabled?: boolean, defaultHardwareVersionKey?: String);
		isSpbmEnabled(): boolean;
	}

	declare class VcComputeResourceConfigSpec
	{
		defaultHardwareVersionKey: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		spbmEnabled: boolean;
		vmSwapPlacement: String;

		constructor();
		constructor(vmSwapPlacement?: String, spbmEnabled?: boolean, defaultHardwareVersionKey?: String);
		isSpbmEnabled(): boolean;
	}

	declare class VcComputeResourceEventArgument
	{
		computeResource: VcComputeResource;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, computeResource?: VcComputeResource);
	}

	declare class VcComputeResourceHostSPBMLicenseInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		licenseState: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;

		constructor();
		constructor(host?: VcHostSystem, licenseState?: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState);
	}

	interface VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState
	{
		readonly id: String;
		readonly licensed: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
		readonly name: String;
		readonly unknown: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
		readonly unlicensed: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
		readonly value: String;

		fromString(value?: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState): VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
	}

	declare const VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;

	declare class VcComputeResourceSummary
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		effectiveCpu: Number;
		effectiveMemory: Number;
		numCpuCores: Number;
		numCpuThreads: Number;
		numEffectiveHosts: Number;
		numHosts: Number;
		overallStatus: VcManagedEntityStatus;
		totalCpu: Number;
		totalMemory: Number;

		constructor();
		constructor(totalCpu?: Number, totalMemory?: Number, numCpuCores?: Number, numCpuThreads?: Number, effectiveCpu?: Number, effectiveMemory?: Number, numHosts?: Number, numEffectiveHosts?: Number, overallStatus?: VcManagedEntityStatus);
	}

	declare class VcConcurrentAccess
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	interface VcConfigSpecOperation
	{
		readonly add: VcConfigSpecOperation;
		readonly edit: VcConfigSpecOperation;
		readonly id: String;
		readonly name: String;
		readonly remove: VcConfigSpecOperation;
		readonly value: String;

		fromString(value?: VcConfigSpecOperation): VcConfigSpecOperation;
	}

	declare const VcConfigSpecOperation: VcConfigSpecOperation;

	declare class VcConfigTarget
	{
		autoVmotion: boolean;
		availablePersistentMemoryReservationMB: Number;
		cdRom: VcVirtualMachineCdromInfo[];
		datastore: VcVirtualMachineDatastoreInfo[];
		distributedVirtualPortgroup: VcDistributedVirtualPortgroupInfo[];
		distributedVirtualSwitch: VcDistributedVirtualSwitchInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		floppy: VcVirtualMachineFloppyInfo[];
		ideDisk: VcVirtualMachineIdeDiskDeviceInfo[];
		legacyNetworkInfo: VcVirtualMachineLegacyNetworkSwitchInfo[];
		maxMemMBOptimalPerf: Number;
		maxPersistentMemoryMB: Number;
		network: VcVirtualMachineNetworkInfo[];
		numCpuCores: Number;
		numCpus: Number;
		numNumaNodes: Number;
		opaqueNetwork: VcOpaqueNetworkTargetInfo[];
		parallel: VcVirtualMachineParallelInfo[];
		pciPassthrough: VcVirtualMachinePciPassthroughInfo[];
		resourcePool: VcResourcePoolRuntimeInfo;
		scsiDisk: VcVirtualMachineScsiDiskDeviceInfo[];
		scsiPassthrough: VcVirtualMachineScsiPassthroughInfo[];
		serial: VcVirtualMachineSerialInfo[];
		sharedGpuPassthroughTypes: VcVirtualMachinePciSharedGpuPassthroughInfo[];
		smcPresent: boolean;
		sound: VcVirtualMachineSoundInfo[];
		sriov: VcVirtualMachineSriovInfo[];
		usb: VcVirtualMachineUsbInfo[];
		vFlashModule: VcVirtualMachineVFlashModuleInfo[];

		constructor();
		constructor(numCpus?: Number, numCpuCores?: Number, numNumaNodes?: Number, smcPresent?: boolean, datastore?: VcVirtualMachineDatastoreInfo[], network?: VcVirtualMachineNetworkInfo[], opaqueNetwork?: VcOpaqueNetworkTargetInfo[], distributedVirtualPortgroup?: VcDistributedVirtualPortgroupInfo[], distributedVirtualSwitch?: VcDistributedVirtualSwitchInfo[], cdRom?: VcVirtualMachineCdromInfo[], serial?: VcVirtualMachineSerialInfo[], parallel?: VcVirtualMachineParallelInfo[], sound?: VcVirtualMachineSoundInfo[], usb?: VcVirtualMachineUsbInfo[], floppy?: VcVirtualMachineFloppyInfo[], legacyNetworkInfo?: VcVirtualMachineLegacyNetworkSwitchInfo[], scsiPassthrough?: VcVirtualMachineScsiPassthroughInfo[], scsiDisk?: VcVirtualMachineScsiDiskDeviceInfo[], ideDisk?: VcVirtualMachineIdeDiskDeviceInfo[], maxMemMBOptimalPerf?: Number, resourcePool?: VcResourcePoolRuntimeInfo, autoVmotion?: boolean, pciPassthrough?: VcVirtualMachinePciPassthroughInfo[], sriov?: VcVirtualMachineSriovInfo[], vFlashModule?: VcVirtualMachineVFlashModuleInfo[], sharedGpuPassthroughTypes?: VcVirtualMachinePciSharedGpuPassthroughInfo[], maxPersistentMemoryMB?: Number, availablePersistentMemoryReservationMB?: Number);
		isAutoVmotion(): boolean;
		isSmcPresent(): boolean;
	}

	declare class VcConflictingConfiguration
	{
		configInConflict: VcConflictingConfigurationConfig[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(configInConflict?: VcConflictingConfigurationConfig[]);
		printStackTrace(): void;
	}

	declare class VcConflictingConfigurationConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		propertyPath: String;

		constructor();
		constructor(entity?: VcManagedEntity, propertyPath?: String);
	}

	declare class VcConflictingDatastoreFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		url: String;

		constructor();
		constructor(name?: String, url?: String);
		printStackTrace(): void;
	}

	declare class VcConnectedIso
	{
		cdrom: VcVirtualCdrom;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		filename: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(cdrom?: VcVirtualCdrom, filename?: String);
		printStackTrace(): void;
	}

	interface VcContainerView
	{
		container: VcManagedEntity;
		id: String;
		moref: VcManagedObjectReference;
		recursive: boolean;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly view: VcManagedObject[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyView(): void;
	}

	declare const VcContainerView: VcContainerView;

	interface VcContentLibrary
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcContentLibrary: VcContentLibrary;

	interface VcContentLibraryItem
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcContentLibraryItem: VcContentLibraryItem;

	declare class VcContext
	{
		data: VcKeyAnyValue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		host: VcHostSystem;
		instanceId: String;
		migrationId: Number;
		opId: String;
		pool: VcResourcePool;
		priority: VcVirtualMachineMovePriority;
		target: VcManagedObject;
		wsdlMethodName: String;

		constructor();
		constructor(wsdlMethodName?: String, target?: VcManagedObject, instanceId?: String, opId?: String, migrationId?: Number, priority?: VcVirtualMachineMovePriority, pool?: VcResourcePool, host?: VcHostSystem, data?: VcKeyAnyValue[], fault?: VcLocalizedMethodFault);
	}

	declare class VcCpuCompatibilityUnknown
	{
		desiredBits: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		level: Number;
		readonly localizedMessage: String;
		message: String;
		registerBits: String;
		registerName: String;

		constructor();
		constructor(level?: Number, registerName?: String, registerBits?: String, desiredBits?: String, host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcCpuHotPlugNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCpuIncompatible
	{
		desiredBits: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		level: Number;
		readonly localizedMessage: String;
		message: String;
		registerBits: String;
		registerName: String;

		constructor();
		constructor(level?: Number, registerName?: String, registerBits?: String, desiredBits?: String, host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcCpuIncompatible1ECX
	{
		aes: boolean;
		desiredBits: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		level: Number;
		readonly localizedMessage: String;
		message: String;
		other: boolean;
		otherOnly: boolean;
		pclmulqdq: boolean;
		registerBits: String;
		registerName: String;
		sse3: boolean;
		sse41: boolean;
		sse42: boolean;
		ssse3: boolean;

		constructor();
		constructor(level?: Number, registerName?: String, registerBits?: String, desiredBits?: String, host?: VcHostSystem, sse3?: boolean, pclmulqdq?: boolean, ssse3?: boolean, sse41?: boolean, sse42?: boolean, aes?: boolean, other?: boolean, otherOnly?: boolean);
		isAes(): boolean;
		isPclmulqdq(): boolean;
		printStackTrace(): void;
	}

	declare class VcCpuIncompatible81EDX
	{
		desiredBits: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		ffxsr: boolean;
		host: VcHostSystem;
		level: Number;
		lm: boolean;
		readonly localizedMessage: String;
		message: String;
		nx: boolean;
		other: boolean;
		otherOnly: boolean;
		rdtscp: boolean;
		registerBits: String;
		registerName: String;

		constructor();
		constructor(level?: Number, registerName?: String, registerBits?: String, desiredBits?: String, host?: VcHostSystem, nx?: boolean, ffxsr?: boolean, rdtscp?: boolean, lm?: boolean, other?: boolean, otherOnly?: boolean);
		printStackTrace(): void;
	}

	declare class VcCreateTaskAction
	{
		cancelable: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		taskTypeId: String;

		constructor();
		constructor(taskTypeId?: String, cancelable?: boolean);
	}

	declare class VcCryptoKeyId
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyId: String;
		providerId: VcKeyProviderId;

		constructor();
		constructor(keyId?: String, providerId?: VcKeyProviderId);
	}

	declare class VcCryptoKeyPlain
	{
		algorithm: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyData: String;
		keyId: VcCryptoKeyId;

		constructor();
		constructor(keyId?: VcCryptoKeyId, algorithm?: String, keyData?: String);
	}

	declare class VcCryptoKeyResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyId: VcCryptoKeyId;
		reason: String;
		success: boolean;

		constructor();
		constructor(keyId?: VcCryptoKeyId, success?: boolean, reason?: String);
	}

	interface VcCryptoManager
	{
		enabled: boolean;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addKey(arg0?: VcCryptoKeyPlain): void;
		addKeys(arg0?: VcCryptoKeyPlain[]): VcCryptoKeyResult[];
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		listKeys(arg0?: Number): VcCryptoKeyId[];
		removeKey(arg0?: VcCryptoKeyId, arg1?: boolean): void;
		removeKeys(arg0?: VcCryptoKeyId[], arg1?: boolean): VcCryptoKeyResult[];
	}

	declare const VcCryptoManager: VcCryptoManager;

	interface VcCryptoManagerKmip
	{
		readonly enabled: boolean;
		id: String;
		kmipServers: VcKmipClusterInfo[];
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addKey(arg0?: VcCryptoKeyPlain): void;
		addKeys(arg0?: VcCryptoKeyPlain[]): VcCryptoKeyResult[];
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		generateClientCsr(arg0?: VcKeyProviderId): String;
		generateKey(arg0?: VcKeyProviderId): VcCryptoKeyResult;
		generateSelfSignedClientCert(arg0?: VcKeyProviderId): String;
		listKeys(arg0?: Number): VcCryptoKeyId[];
		listKmipServers(arg0?: Number): VcKmipClusterInfo[];
		markDefault(arg0?: VcKeyProviderId): void;
		registerKmipServer(arg0?: VcKmipServerSpec): void;
		removeKey(arg0?: VcCryptoKeyId, arg1?: boolean): void;
		removeKeys(arg0?: VcCryptoKeyId[], arg1?: boolean): VcCryptoKeyResult[];
		removeKmipServer(arg0?: VcKeyProviderId, arg1?: String): void;
		retrieveClientCert(arg0?: VcKeyProviderId): String;
		retrieveClientCsr(arg0?: VcKeyProviderId): String;
		retrieveKmipServerCert(arg0?: VcKeyProviderId, arg1?: VcKmipServerInfo): VcCryptoManagerKmipServerCertInfo;
		retrieveKmipServersStatus_Task(arg0?: VcKmipClusterInfo[]): VcTask;
		retrieveSelfSignedClientCert(arg0?: VcKeyProviderId): String;
		updateKmipServer(arg0?: VcKmipServerSpec): void;
		updateKmsSignedCsrClientCert(arg0?: VcKeyProviderId, arg1?: String): void;
		updateSelfSignedClientCert(arg0?: VcKeyProviderId, arg1?: String): void;
		uploadClientCert(arg0?: VcKeyProviderId, arg1?: String, arg2?: String): void;
		uploadKmipServerCert(arg0?: VcKeyProviderId, arg1?: String): void;
	}

	declare const VcCryptoManagerKmip: VcCryptoManagerKmip;

	declare class VcCryptoManagerKmipCertificateInfo
	{
		checkTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fingerprint: String;
		issuer: String;
		notAfter: Date;
		notBefore: Date;
		secondsBeforeExpire: Number;
		secondsSinceValid: Number;
		serialNumber: String;
		subject: String;

		constructor();
		constructor(subject?: String, issuer?: String, serialNumber?: String, notBefore?: Date, notAfter?: Date, fingerprint?: String, checkTime?: Date, secondsSinceValid?: Number, secondsBeforeExpire?: Number);
	}

	declare class VcCryptoManagerKmipClusterStatus
	{
		clientCertInfo: VcCryptoManagerKmipCertificateInfo;
		clusterId: VcKeyProviderId;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		servers: VcCryptoManagerKmipServerStatus[];

		constructor();
		constructor(clusterId?: VcKeyProviderId, servers?: VcCryptoManagerKmipServerStatus[], clientCertInfo?: VcCryptoManagerKmipCertificateInfo);
	}

	declare class VcCryptoManagerKmipServerCertInfo
	{
		certificate: String;
		certInfo: VcCryptoManagerKmipCertificateInfo;
		clientTrustServer: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(certificate?: String, certInfo?: VcCryptoManagerKmipCertificateInfo, clientTrustServer?: boolean);
		isClientTrustServer(): boolean;
	}

	declare class VcCryptoManagerKmipServerStatus
	{
		certInfo: VcCryptoManagerKmipCertificateInfo;
		clientTrustServer: boolean;
		connectionStatus: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		serverTrustClient: boolean;
		status: VcManagedEntityStatus;

		constructor();
		constructor(name?: String, status?: VcManagedEntityStatus, connectionStatus?: String, certInfo?: VcCryptoManagerKmipCertificateInfo, clientTrustServer?: boolean, serverTrustClient?: boolean);
		isClientTrustServer(): boolean;
		isServerTrustClient(): boolean;
	}

	declare class VcCryptoSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCryptoSpecDecrypt
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCryptoSpecDeepRecrypt
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		newKeyId: VcCryptoKeyId;

		constructor();
		constructor(newKeyId?: VcCryptoKeyId);
	}

	declare class VcCryptoSpecEncrypt
	{
		cryptoKeyId: VcCryptoKeyId;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(cryptoKeyId?: VcCryptoKeyId);
	}

	declare class VcCryptoSpecNoOp
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCryptoSpecRegister
	{
		cryptoKeyId: VcCryptoKeyId;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(cryptoKeyId?: VcCryptoKeyId);
	}

	declare class VcCryptoSpecShallowRecrypt
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		newKeyId: VcCryptoKeyId;

		constructor();
		constructor(newKeyId?: VcCryptoKeyId);
	}

	declare class VcCustomFieldDef
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fieldDefPrivileges: VcPrivilegePolicyDef;
		fieldInstancePrivileges: VcPrivilegePolicyDef;
		key: Number;
		managedObjectType: String;
		name: String;
		type: String;

		constructor();
		constructor(key?: Number, name?: String, type?: String, managedObjectType?: String, fieldDefPrivileges?: VcPrivilegePolicyDef, fieldInstancePrivileges?: VcPrivilegePolicyDef);
	}

	declare class VcCustomFieldDefAddedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fieldKey: Number;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		name: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, fieldKey?: Number, name?: String);
	}

	declare class VcCustomFieldDefEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fieldKey: Number;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		name: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, fieldKey?: Number, name?: String);
	}

	declare class VcCustomFieldDefRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fieldKey: Number;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		name: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, fieldKey?: Number, name?: String);
	}

	declare class VcCustomFieldDefRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fieldKey: Number;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		name: String;
		net: VcNetworkEventArgument;
		newName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, fieldKey?: Number, name?: String, newName?: String);
	}

	declare class VcCustomFieldEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	interface VcCustomFieldsManager
	{
		field: VcCustomFieldDef[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addCustomFieldDef(arg0?: String, arg1?: String, arg2?: VcPrivilegePolicyDef, arg3?: VcPrivilegePolicyDef): VcCustomFieldDef;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		getEntitiesWithCustomFieldAndValue(arg0?: String, arg1?: String, arg2?: boolean): VcManagedEntity[];
		removeCustomFieldDef(arg0?: Number): void;
		renameCustomFieldDef(arg0?: Number, arg1?: String): void;
		retrieveCustomFields(arg0?: String[]): VcCustomFieldDef[];
		setField(arg0?: VcManagedEntity, arg1?: Number, arg2?: String): void;
	}

	declare const VcCustomFieldsManager: VcCustomFieldsManager;

	declare class VcCustomFieldStringValue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		value: String;

		constructor();
		constructor(key?: Number, value?: String);
	}

	declare class VcCustomFieldValue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;

		constructor(key?: Number);
		constructor();
	}

	declare class VcCustomFieldValueChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fieldKey: Number;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		name: String;
		net: VcNetworkEventArgument;
		prevState: String;
		userName: String;
		value: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, entity?: VcManagedEntityEventArgument, fieldKey?: Number, name?: String, value?: String, prevState?: String);
	}

	declare class VcCustomizationAdapterMapping
	{
		adapter: VcCustomizationIPSettings;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		macAddress: String;

		constructor();
		constructor(macAddress?: String, adapter?: VcCustomizationIPSettings);
	}

	declare class VcCustomizationAutoIpV6Generator
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationCustomIpGenerator
	{
		argument: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(argument?: String);
	}

	declare class VcCustomizationCustomIpV6Generator
	{
		argument: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(argument?: String);
	}

	declare class VcCustomizationCustomName
	{
		argument: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(argument?: String);
	}

	declare class VcCustomizationDhcpIpGenerator
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationDhcpIpV6Generator
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, logLocation?: String);
	}

	declare class VcCustomizationFailed
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, logLocation?: String);
	}

	declare class VcCustomizationFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCustomizationFixedIp
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;

		constructor();
		constructor(ipAddress?: String);
	}

	declare class VcCustomizationFixedIpV6
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;
		subnetMask: Number;

		constructor();
		constructor(ipAddress?: String, subnetMask?: Number);
	}

	declare class VcCustomizationFixedName
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String);
	}

	declare class VcCustomizationGlobalIPSettings
	{
		dnsServerList: String[];
		dnsSuffixList: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(dnsSuffixList?: String[], dnsServerList?: String[]);
	}

	declare class VcCustomizationGuiRunOnce
	{
		commandList: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(commandList?: String[]);
	}

	declare class VcCustomizationGuiUnattended
	{
		autoLogon: boolean;
		autoLogonCount: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		password: VcCustomizationPassword;
		timeZone: Number;

		constructor();
		constructor(password?: VcCustomizationPassword, timeZone?: Number, autoLogon?: boolean, autoLogonCount?: Number);
	}

	declare class VcCustomizationIdentification
	{
		domainAdmin: String;
		domainAdminPassword: VcCustomizationPassword;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		joinDomain: String;
		joinWorkgroup: String;

		constructor();
		constructor(joinWorkgroup?: String, joinDomain?: String, domainAdmin?: String, domainAdminPassword?: VcCustomizationPassword);
	}

	declare class VcCustomizationIdentitySettings
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationIpGenerator
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationIPSettings
	{
		dnsDomain: String;
		dnsServerList: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gateway: String[];
		ip: VcCustomizationIpGenerator;
		ipV6Spec: VcCustomizationIPSettingsIpV6AddressSpec;
		netBIOS: VcCustomizationNetBIOSMode;
		primaryWINS: String;
		secondaryWINS: String;
		subnetMask: String;

		constructor();
		constructor(ip?: VcCustomizationIpGenerator, subnetMask?: String, gateway?: String[], ipV6Spec?: VcCustomizationIPSettingsIpV6AddressSpec, dnsServerList?: String[], dnsDomain?: String, primaryWINS?: String, secondaryWINS?: String, netBIOS?: VcCustomizationNetBIOSMode);
	}

	declare class VcCustomizationIPSettingsIpV6AddressSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gateway: String[];
		ip: VcCustomizationIpV6Generator[];

		constructor();
		constructor(ip?: VcCustomizationIpV6Generator[], gateway?: String[]);
	}

	declare class VcCustomizationIpV6Generator
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcCustomizationLicenseDataMode
	{
		readonly id: String;
		readonly name: String;
		readonly perSeat: VcCustomizationLicenseDataMode;
		readonly perServer: VcCustomizationLicenseDataMode;
		readonly value: String;

		fromString(value?: VcCustomizationLicenseDataMode): VcCustomizationLicenseDataMode;
	}

	declare const VcCustomizationLicenseDataMode: VcCustomizationLicenseDataMode;

	declare class VcCustomizationLicenseFilePrintData
	{
		autoMode: VcCustomizationLicenseDataMode;
		autoUsers: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(autoMode?: VcCustomizationLicenseDataMode, autoUsers?: Number);
	}

	declare class VcCustomizationLinuxIdentityFailed
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, logLocation?: String);
	}

	declare class VcCustomizationLinuxOptions
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationLinuxPrep
	{
		domain: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostName: VcCustomizationName;
		hwClockUTC: boolean;
		timeZone: String;

		constructor();
		constructor(hostName?: VcCustomizationName, domain?: String, timeZone?: String, hwClockUTC?: boolean);
		isHwClockUTC(): boolean;
	}

	declare class VcCustomizationName
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcCustomizationNetBIOSMode
	{
		readonly disableNetBIOS: VcCustomizationNetBIOSMode;
		readonly enableNetBIOS: VcCustomizationNetBIOSMode;
		readonly enableNetBIOSViaDhcp: VcCustomizationNetBIOSMode;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcCustomizationNetBIOSMode): VcCustomizationNetBIOSMode;
	}

	declare const VcCustomizationNetBIOSMode: VcCustomizationNetBIOSMode;

	declare class VcCustomizationNetworkSetupFailed
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, logLocation?: String);
	}

	declare class VcCustomizationOptions
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationPassword
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		plainText: boolean;
		value: String;

		constructor();
		constructor(value?: String, plainText?: boolean);
	}

	declare class VcCustomizationPending
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcCustomizationPrefixName
	{
		base: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(base?: String);
	}

	declare class VcCustomizationSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encryptionKey: Number[];
		globalIPSettings: VcCustomizationGlobalIPSettings;
		identity: VcCustomizationIdentitySettings;
		nicSettingMap: VcCustomizationAdapterMapping[];
		options: VcCustomizationOptions;

		constructor();
		constructor(options?: VcCustomizationOptions, identity?: VcCustomizationIdentitySettings, globalIPSettings?: VcCustomizationGlobalIPSettings, nicSettingMap?: VcCustomizationAdapterMapping[], encryptionKey?: Number[]);
	}

	declare class VcCustomizationSpecInfo
	{
		changeVersion: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lastUpdateTime: Date;
		name: String;
		type: String;

		constructor();
		constructor(name?: String, description?: String, type?: String, changeVersion?: String, lastUpdateTime?: Date);
	}

	declare class VcCustomizationSpecItem
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcCustomizationSpecInfo;
		spec: VcCustomizationSpec;

		constructor();
		constructor(info?: VcCustomizationSpecInfo, spec?: VcCustomizationSpec);
	}

	interface VcCustomizationSpecManager
	{
		encryptionKey: Number[];
		id: String;
		info: VcCustomizationSpecInfo[];
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkCustomizationResources(arg0?: String): void;
		createCustomizationSpec(arg0?: VcCustomizationSpecItem): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		customizationSpecItemToXml(arg0?: VcCustomizationSpecItem): String;
		deleteCustomizationSpec(arg0?: String): void;
		doesCustomizationSpecExist(arg0?: String): boolean;
		duplicateCustomizationSpec(arg0?: String, arg1?: String): void;
		getCustomizationSpec(arg0?: String): VcCustomizationSpecItem;
		overwriteCustomizationSpec(arg0?: VcCustomizationSpecItem): void;
		renameCustomizationSpec(arg0?: String, arg1?: String): void;
		xmlToCustomizationSpecItem(arg0?: String): VcCustomizationSpecItem;
	}

	declare const VcCustomizationSpecManager: VcCustomizationSpecManager;

	declare class VcCustomizationStartedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, logLocation?: String);
	}

	declare class VcCustomizationStatelessIpV6Generator
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationSucceeded
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, logLocation?: String);
	}

	declare class VcCustomizationSysprep
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		guiRunOnce: VcCustomizationGuiRunOnce;
		guiUnattended: VcCustomizationGuiUnattended;
		identification: VcCustomizationIdentification;
		licenseFilePrintData: VcCustomizationLicenseFilePrintData;
		userData: VcCustomizationUserData;

		constructor();
		constructor(guiUnattended?: VcCustomizationGuiUnattended, userData?: VcCustomizationUserData, guiRunOnce?: VcCustomizationGuiRunOnce, identification?: VcCustomizationIdentification, licenseFilePrintData?: VcCustomizationLicenseFilePrintData);
	}

	declare class VcCustomizationSysprepFailed
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		sysprepVersion: String;
		systemVersion: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, logLocation?: String, sysprepVersion?: String, systemVersion?: String);
	}

	interface VcCustomizationSysprepRebootOption
	{
		readonly id: String;
		readonly name: String;
		readonly noreboot: VcCustomizationSysprepRebootOption;
		readonly reboot: VcCustomizationSysprepRebootOption;
		readonly shutdown: VcCustomizationSysprepRebootOption;
		readonly value: String;

		fromString(value?: VcCustomizationSysprepRebootOption): VcCustomizationSysprepRebootOption;
	}

	declare const VcCustomizationSysprepRebootOption: VcCustomizationSysprepRebootOption;

	declare class VcCustomizationSysprepText
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		value: String;

		constructor();
		constructor(value?: String);
	}

	declare class VcCustomizationUnknownFailure
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, logLocation?: String);
	}

	declare class VcCustomizationUnknownIpGenerator
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationUnknownIpV6Generator
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationUnknownName
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationUserData
	{
		computerName: VcCustomizationName;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullName: String;
		orgName: String;
		productId: String;

		constructor();
		constructor(fullName?: String, orgName?: String, computerName?: VcCustomizationName, productId?: String);
	}

	declare class VcCustomizationVirtualMachineName
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcCustomizationWinOptions
	{
		changeSID: boolean;
		deleteAccounts: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reboot: VcCustomizationSysprepRebootOption;

		constructor();
		constructor(changeSID?: boolean, deleteAccounts?: boolean, reboot?: VcCustomizationSysprepRebootOption);
	}

	declare class VcDailyTaskScheduler
	{
		activeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expireTime: Date;
		hour: Number;
		interval: Number;
		minute: Number;

		constructor();
		constructor(activeTime?: Date, expireTime?: Date, interval?: Number, minute?: Number, hour?: Number);
	}

	declare class VcDasAdmissionControlDisabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDasAdmissionControlEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDasAgentFoundEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDasAgentUnavailableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDasClusterIsolatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDasConfigFault
	{
		event: VcEvent[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		output: String;
		reason: String;

		constructor();
		constructor(reason?: String, output?: String, event?: VcEvent[]);
		printStackTrace(): void;
	}

	interface VcDasConfigFaultDasConfigFaultReason
	{
		readonly CreateConfigVvolFailed: VcDasConfigFaultDasConfigFaultReason;
		readonly DasNetworkMisconfiguration: VcDasConfigFaultDasConfigFaultReason;
		readonly HostMisconfiguration: VcDasConfigFaultDasConfigFaultReason;
		readonly HostNetworkMisconfiguration: VcDasConfigFaultDasConfigFaultReason;
		readonly id: String;
		readonly InsufficientPrivileges: VcDasConfigFaultDasConfigFaultReason;
		readonly name: String;
		readonly NoDatastoresConfigured: VcDasConfigFaultDasConfigFaultReason;
		readonly NoPrimaryAgentAvailable: VcDasConfigFaultDasConfigFaultReason;
		readonly Other: VcDasConfigFaultDasConfigFaultReason;
		readonly value: String;
		readonly VSanNotSupportedOnHost: VcDasConfigFaultDasConfigFaultReason;

		fromString(value?: VcDasConfigFaultDasConfigFaultReason): VcDasConfigFaultDasConfigFaultReason;
	}

	declare const VcDasConfigFaultDasConfigFaultReason: VcDasConfigFaultDasConfigFaultReason;

	declare class VcDasDisabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDasEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDasHeartbeatDatastoreInfo
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hosts: VcHostSystem[];

		constructor();
		constructor(datastore?: VcDatastore, hosts?: VcHostSystem[]);
	}

	declare class VcDasHostFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failedHost: VcHostEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, failedHost?: VcHostEventArgument);
	}

	declare class VcDasHostIsolatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		isolatedHost: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, isolatedHost?: VcHostEventArgument);
	}

	interface VcDasVmPriority
	{
		readonly disabled: VcDasVmPriority;
		readonly high: VcDasVmPriority;
		readonly id: String;
		readonly low: VcDasVmPriority;
		readonly medium: VcDasVmPriority;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcDasVmPriority): VcDasVmPriority;
	}

	declare const VcDasVmPriority: VcDasVmPriority;

	declare class VcDatabaseError
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcDatabaseSizeEstimate
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		size: Number;

		constructor();
		constructor(size?: Number);
	}

	declare class VcDatabaseSizeParam
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inventoryDesc: VcInventoryDescription;
		perfStatsDesc: VcPerformanceStatisticsDescription;

		constructor();
		constructor(inventoryDesc?: VcInventoryDescription, perfStatsDesc?: VcPerformanceStatisticsDescription);
	}

	interface VcDatacenter
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		configuration: VcDatacenterConfigInfo;
		readonly customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		datastoreFolder: VcFolder;
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		hostFolder: VcFolder;
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		network: VcNetwork[];
		networkFolder: VcFolder;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		vmFolder: VcFolder;

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		powerOnMultiVM_Task(arg0?: VcVirtualMachine[], arg1?: VcOptionValue[]): VcTask;
		queryConnectionInfo(arg0?: String, arg1?: Number, arg2?: String, arg3?: String, arg4?: String): VcHostConnectInfo;
		queryConnectionInfoViaSpec(arg0?: VcHostConnectSpec): VcHostConnectInfo;
		queryDatacenterConfigOptionDescriptor(): VcVirtualMachineConfigOptionDescriptor[];
		reconfigureDatacenter_Task(arg0?: VcDatacenterConfigSpec, arg1?: boolean): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcDatacenter: VcDatacenter;

	declare class VcDatacenterConfigInfo
	{
		defaultHardwareVersionKey: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(defaultHardwareVersionKey?: String);
	}

	declare class VcDatacenterConfigSpec
	{
		defaultHardwareVersionKey: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(defaultHardwareVersionKey?: String);
	}

	declare class VcDatacenterCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		parent: VcFolderEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, parent?: VcFolderEventArgument);
	}

	declare class VcDatacenterEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDatacenterEventArgument
	{
		datacenter: VcDatacenter;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, datacenter?: VcDatacenter);
	}

	interface VcDatacenterFolder
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		childEntity: VcManagedEntity[];
		childType: String[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		datacenter: Object[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		folder: Object[];
		folderTypes: Object[];
		id: String;
		name: String;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		wrappedFolder: VcFolder;

		_getRef(): VcManagedObjectReference;
		addStandaloneHost_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		addStandaloneHostWithAdminDisabled_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		addTag(tag?: VcTag[]): void;
		createCluster(name?: String, spec?: VcClusterConfigSpec): VcClusterComputeResource;
		createClusterEx(name?: String, spec?: VcClusterConfigSpecEx): VcClusterComputeResource;
		createDatacenter(name?: String): VcDatacenter;
		createDVS_Task(spec?: VcDVSCreateSpec): VcTask;
		createFolder(name?: String): VcFolder;
		createStoragePod(name?: String): VcStoragePod;
		createVM_Task(config?: VcVirtualMachineConfigSpec, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		destroy_Task(): VcTask;
		isFolder(type?: String): boolean;
		moveIntoFolder_Task(list?: VcManagedEntity[]): VcTask;
		registerVM_Task(path?: String, name?: String, asTemplate?: boolean, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		reload(): void;
		removeTag(tag?: VcTag[]): void;
		rename_Task(newName?: String): VcTask;
		retrieveCustomValues(keys?: Number[]): VcCustomFieldValue[];
		setCustomValue(key?: String, value?: String): void;
		unregisterAndDestroy_Task(): VcTask;
	}

	interface VcDatacenterFolderConstructor {
		new(value?:any): VcDatacenterFolder;
		readonly prototype: VcDatacenterFolder;
	}

	declare const VcDatacenterFolder: VcDatacenterFolderConstructor;

	declare class VcDatacenterMismatch
	{
		expectedDatacenter: VcDatacenter;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		invalidArgument: VcDatacenterMismatchArgument[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(invalidArgument?: VcDatacenterMismatchArgument[], expectedDatacenter?: VcDatacenter);
		printStackTrace(): void;
	}

	declare class VcDatacenterMismatchArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		inputDatacenter: VcDatacenter;

		constructor();
		constructor(entity?: VcManagedEntity, inputDatacenter?: VcDatacenter);
	}

	declare class VcDatacenterRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, oldName?: String, newName?: String);
	}

	interface VcDataObject
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

	}

	declare const VcDataObject: VcDataObject;

	interface VcDatastore
	{
		accessible: boolean;
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		browser: VcHostDatastoreBrowser;
		capability: VcDatastoreCapability;
		capacity: Number;
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		datastoreNativeCloneCapable: boolean;
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		freeSpace: Number;
		host: VcDatastoreHostMount[];
		id: String;
		info: VcDatastoreInfo;
		iormConfiguration: VcStorageIORMInfo;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		provisionedSpace: Number;
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		summary: VcDatastoreSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		url: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		vm: VcVirtualMachine[];

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		datastoreCleanupLocks_Task(arg0?: String): VcTask;
		datastoreEnterMaintenanceMode(): VcStoragePlacementResult;
		datastoreExitMaintenanceMode_Task(): VcTask;
		destroy_Task(): VcTask;
		destroyDatastore(): void;
		refreshDatastore(): void;
		refreshDatastoreStorageInfo(): void;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		renameDatastore(arg0?: String): void;
		replaceEmbeddedFilePaths_Task(arg0?: VcKeyValue[]): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
		updateVirtualMachineFiles_Task(arg0?: VcDatastoreMountPathDatastorePair[]): VcTask;
		updateVVolVirtualMachineFiles_Task(arg0?: VcDatastoreVVolContainerFailoverPair[]): VcTask;
	}

	declare const VcDatastore: VcDatastore;

	interface VcDatastoreAccessible
	{
		readonly False: VcDatastoreAccessible;
		readonly id: String;
		readonly name: String;
		readonly True: VcDatastoreAccessible;
		readonly value: String;

		fromString(value?: VcDatastoreAccessible): VcDatastoreAccessible;
	}

	declare const VcDatastoreAccessible: VcDatastoreAccessible;

	declare class VcDatastoreCapability
	{
		directoryHierarchySupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nativeSnapshotCopySupported: boolean;
		nativeSnapshotSupported: boolean;
		perFileThinProvisioningSupported: boolean;
		rawDiskMappingsSupported: boolean;
		seSparseSupported: boolean;
		storageIORMSupported: boolean;
		topLevelDirectoryCreateSupported: boolean;
		upitSupported: boolean;
		vmdkExpandSupported: boolean;
		vmfsSparseSupported: boolean;
		vsanSparseSupported: boolean;

		constructor();
		constructor(directoryHierarchySupported?: boolean, rawDiskMappingsSupported?: boolean, perFileThinProvisioningSupported?: boolean, storageIORMSupported?: boolean, nativeSnapshotSupported?: boolean, nativeSnapshotCopySupported?: boolean, topLevelDirectoryCreateSupported?: boolean, seSparseSupported?: boolean, vmfsSparseSupported?: boolean, vsanSparseSupported?: boolean, upitSupported?: boolean, vmdkExpandSupported?: boolean);
		isNativeSnapshotCopySupported(): boolean;
		isNativeSnapshotSupported(): boolean;
		isSeSparseSupported(): boolean;
		isStorageIORMSupported(): boolean;
		isTopLevelDirectoryCreateSupported(): boolean;
		isUpitSupported(): boolean;
		isVmdkExpandSupported(): boolean;
		isVmfsSparseSupported(): boolean;
		isVsanSparseSupported(): boolean;
	}

	declare class VcDatastoreCapacityIncreasedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newCapacity: Number;
		oldCapacity: Number;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument, oldCapacity?: Number, newCapacity?: Number);
	}

	declare class VcDatastoreDestroyedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument);
	}

	declare class VcDatastoreDiscoveredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument);
	}

	declare class VcDatastoreDuplicatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument);
	}

	declare class VcDatastoreEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument);
	}

	declare class VcDatastoreEventArgument
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, datastore?: VcDatastore);
	}

	declare class VcDatastoreFileCopiedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDatastore: VcDatastoreEventArgument;
		sourceFile: String;
		sourceOfOperation: String;
		succeeded: boolean;
		targetFile: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument, targetFile?: String, sourceOfOperation?: String, succeeded?: boolean, sourceDatastore?: VcDatastoreEventArgument, sourceFile?: String);
		isSucceeded(): boolean;
	}

	declare class VcDatastoreFileDeletedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceOfOperation: String;
		succeeded: boolean;
		targetFile: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument, targetFile?: String, sourceOfOperation?: String, succeeded?: boolean);
		isSucceeded(): boolean;
	}

	declare class VcDatastoreFileEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceOfOperation: String;
		succeeded: boolean;
		targetFile: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument, targetFile?: String, sourceOfOperation?: String, succeeded?: boolean);
		isSucceeded(): boolean;
	}

	declare class VcDatastoreFileMovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDatastore: VcDatastoreEventArgument;
		sourceFile: String;
		sourceOfOperation: String;
		succeeded: boolean;
		targetFile: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument, targetFile?: String, sourceOfOperation?: String, succeeded?: boolean, sourceDatastore?: VcDatastoreEventArgument, sourceFile?: String);
		isSucceeded(): boolean;
	}

	interface VcDatastoreFolder
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		childEntity: VcManagedEntity[];
		childType: String[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		datastore: Object[];
		datastoreCluster: Object[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		folder: Object[];
		folderTypes: Object[];
		id: String;
		name: String;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		wrappedFolder: VcFolder;

		_getRef(): VcManagedObjectReference;
		addStandaloneHost_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		addStandaloneHostWithAdminDisabled_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		addTag(tag?: VcTag[]): void;
		createCluster(name?: String, spec?: VcClusterConfigSpec): VcClusterComputeResource;
		createClusterEx(name?: String, spec?: VcClusterConfigSpecEx): VcClusterComputeResource;
		createDatacenter(name?: String): VcDatacenter;
		createDVS_Task(spec?: VcDVSCreateSpec): VcTask;
		createFolder(name?: String): VcFolder;
		createStoragePod(name?: String): VcStoragePod;
		createVM_Task(config?: VcVirtualMachineConfigSpec, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		destroy_Task(): VcTask;
		isFolder(type?: String): boolean;
		moveIntoFolder_Task(list?: VcManagedEntity[]): VcTask;
		registerVM_Task(path?: String, name?: String, asTemplate?: boolean, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		reload(): void;
		removeTag(tag?: VcTag[]): void;
		rename_Task(newName?: String): VcTask;
		retrieveCustomValues(keys?: Number[]): VcCustomFieldValue[];
		setCustomValue(key?: String, value?: String): void;
		unregisterAndDestroy_Task(): VcTask;
	}

	interface VcDatastoreFolderConstructor {
		new(value?:any): VcDatastoreFolder;
		readonly prototype: VcDatastoreFolder;
	}

	declare const VcDatastoreFolder: VcDatastoreFolderConstructor;

	declare class VcDatastoreHostMount
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcHostSystem;
		mountInfo: VcHostMountInfo;

		constructor();
		constructor(key?: VcHostSystem, mountInfo?: VcHostMountInfo);
	}

	declare class VcDatastoreInfo
	{
		containerId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpace: Number;
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxVirtualDiskCapacity: Number;
		name: String;
		timestamp: Date;
		url: String;

		constructor();
		constructor(name?: String, url?: String, freeSpace?: Number, maxFileSize?: Number, maxVirtualDiskCapacity?: Number, maxMemoryFileSize?: Number, timestamp?: Date, containerId?: String);
	}

	declare class VcDatastoreIORMReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument);
	}

	declare class VcDatastoreMountPathDatastorePair
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		oldMountPath: String;

		constructor();
		constructor(oldMountPath?: String, datastore?: VcDatastore);
	}

	interface VcDatastoreNamespaceManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		convertNamespacePathToUuidPath(arg0?: VcDatacenter, arg1?: String): String;
		createDirectory(arg0?: VcDatastore, arg1?: String, arg2?: String): String;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteDirectory(arg0?: VcDatacenter, arg1?: String): void;
	}

	declare const VcDatastoreNamespaceManager: VcDatastoreNamespaceManager;

	declare class VcDatastoreNotWritableOnHost
	{
		datastore: VcDatastore;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(datastore?: VcDatastore, name?: String, host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcDatastoreOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		unsupportedVolumes: VcVirtualMachineDatastoreVolumeOption[];

		constructor();
		constructor(unsupportedVolumes?: VcVirtualMachineDatastoreVolumeOption[]);
	}

	declare class VcDatastorePrincipalConfigured
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastorePrincipal: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastorePrincipal?: String);
	}

	declare class VcDatastoreRemovedOnHostEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument);
	}

	declare class VcDatastoreRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument, oldName?: String, newName?: String);
	}

	declare class VcDatastoreRenamedOnHostEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, oldName?: String, newName?: String);
	}

	declare class VcDatastoreSummary
	{
		accessible: boolean;
		capacity: Number;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpace: Number;
		maintenanceMode: String;
		multipleHostAccess: boolean;
		name: String;
		type: String;
		uncommitted: Number;
		url: String;

		constructor();
		constructor(datastore?: VcDatastore, name?: String, url?: String, capacity?: Number, freeSpace?: Number, uncommitted?: Number, accessible?: boolean, multipleHostAccess?: boolean, type?: String, maintenanceMode?: String);
		isMultipleHostAccess(): boolean;
	}

	interface VcDatastoreSummaryMaintenanceModeState
	{
		readonly enteringMaintenance: VcDatastoreSummaryMaintenanceModeState;
		readonly id: String;
		readonly inMaintenance: VcDatastoreSummaryMaintenanceModeState;
		readonly name: String;
		readonly normal: VcDatastoreSummaryMaintenanceModeState;
		readonly value: String;

		fromString(value?: VcDatastoreSummaryMaintenanceModeState): VcDatastoreSummaryMaintenanceModeState;
	}

	declare const VcDatastoreSummaryMaintenanceModeState: VcDatastoreSummaryMaintenanceModeState;

	declare class VcDatastoreVVolContainerFailoverPair
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		srcContainer: String;
		tgtContainer: String;
		vvolMapping: VcKeyValue[];

		constructor();
		constructor(srcContainer?: String, tgtContainer?: String, vvolMapping?: VcKeyValue[]);
	}

	declare class VcDateTimeProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	interface VcDayOfWeek
	{
		readonly friday: VcDayOfWeek;
		readonly id: String;
		readonly monday: VcDayOfWeek;
		readonly name: String;
		readonly saturday: VcDayOfWeek;
		readonly sunday: VcDayOfWeek;
		readonly thursday: VcDayOfWeek;
		readonly tuesday: VcDayOfWeek;
		readonly value: String;
		readonly wednesday: VcDayOfWeek;

		fromString(value?: VcDayOfWeek): VcDayOfWeek;
	}

	declare const VcDayOfWeek: VcDayOfWeek;

	declare class VcDeltaDiskFormatNotSupported
	{
		datastore: VcDatastore[];
		deltaDiskFormat: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(datastore?: VcDatastore[], deltaDiskFormat?: String);
		printStackTrace(): void;
	}

	interface VcDeploymentInfo
	{
		hostName: String;
		id: String;
		moref: VcManagedObjectReference;
		pscNodes: VcDeploymentInfoServiceInfo[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcDeploymentInfo: VcDeploymentInfo;

	declare class VcDeploymentInfoServiceInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostId: String;
		ownerId: String;
		serviceId: String;
		version: String;

		constructor();
		constructor(serviceId?: String, hostId?: String, ownerId?: String, version?: String);
	}

	declare class VcDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		label: String;
		summary: String;

		constructor();
		constructor(label?: String, summary?: String);
	}

	declare class VcDestinationSwitchFull
	{
		backing: String;
		connected: boolean;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		network: VcNetwork;

		constructor();
		constructor(device?: String, backing?: String, connected?: boolean, network?: VcNetwork);
		printStackTrace(): void;
	}

	declare class VcDestinationVsanDisabled
	{
		destinationCluster: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(destinationCluster?: String);
		printStackTrace(): void;
	}

	declare class VcDeviceBackedVirtualDiskSpec
	{
		adapterType: String;
		device: String;
		diskType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(diskType?: String, adapterType?: String, device?: String);
	}

	declare class VcDeviceBackingNotSupported
	{
		backing: String;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String, backing?: String);
		printStackTrace(): void;
	}

	declare class VcDeviceControllerNotSupported
	{
		controller: String;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String, controller?: String);
		printStackTrace(): void;
	}

	declare class VcDeviceGroupId
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;

		constructor();
		constructor(id?: String);
	}

	declare class VcDeviceHotPlugNotSupported
	{
		deviceIndex: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String, deviceIndex?: Number);
		printStackTrace(): void;
	}

	declare class VcDeviceNotFound
	{
		deviceIndex: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String, deviceIndex?: Number);
		printStackTrace(): void;
	}

	declare class VcDeviceNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	interface VcDeviceNotSupportedReason
	{
		readonly guest: VcDeviceNotSupportedReason;
		readonly host: VcDeviceNotSupportedReason;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcDeviceNotSupportedReason): VcDeviceNotSupportedReason;
	}

	declare const VcDeviceNotSupportedReason: VcDeviceNotSupportedReason;

	declare class VcDeviceUnsupportedForVmPlatform
	{
		deviceIndex: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String, deviceIndex?: Number);
		printStackTrace(): void;
	}

	declare class VcDeviceUnsupportedForVmVersion
	{
		currentVersion: String;
		deviceIndex: Number;
		expectedVersion: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String, deviceIndex?: Number, currentVersion?: String, expectedVersion?: String);
		printStackTrace(): void;
	}

	interface VcDiagnosticManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		browseDiagnosticLog(arg0?: VcHostSystem, arg1?: String, arg2?: Number, arg3?: Number): VcDiagnosticManagerLogHeader;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		generateLogBundles_Task(arg0?: boolean, arg1?: VcHostSystem[], arg2?: VcKeyValue[]): VcTask;
		queryDescriptions(arg0?: VcHostSystem): VcDiagnosticManagerLogDescriptor[];
		queryFileHash_Task(arg0?: VcDiagnosticManagerFileHashSpec): VcTask;
	}

	declare const VcDiagnosticManager: VcDiagnosticManager;

	declare class VcDiagnosticManagerBundleInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		system: VcHostSystem;
		url: String;

		constructor();
		constructor(system?: VcHostSystem, url?: String);
	}

	declare class VcDiagnosticManagerFileHashInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filePath: String;
		hash: String;

		constructor();
		constructor(filePath?: String, hash?: String);
	}

	declare class VcDiagnosticManagerFileHashSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filePath: String[];
		hashAlgorithm: String;
		host: VcHostSystem;

		constructor();
		constructor(host?: VcHostSystem, filePath?: String[], hashAlgorithm?: String);
	}

	interface VcDiagnosticManagerFileHashSpecHashAlgorithm
	{
		readonly id: String;
		readonly name: String;
		readonly sha256: VcDiagnosticManagerFileHashSpecHashAlgorithm;
		readonly value: String;

		fromString(value?: VcDiagnosticManagerFileHashSpecHashAlgorithm): VcDiagnosticManagerFileHashSpecHashAlgorithm;
	}

	declare const VcDiagnosticManagerFileHashSpecHashAlgorithm: VcDiagnosticManagerFileHashSpecHashAlgorithm;

	interface VcDiagnosticManagerLogCreator
	{
		readonly hostd: VcDiagnosticManagerLogCreator;
		readonly id: String;
		readonly install: VcDiagnosticManagerLogCreator;
		readonly name: String;
		readonly recordLog: VcDiagnosticManagerLogCreator;
		readonly serverd: VcDiagnosticManagerLogCreator;
		readonly value: String;
		readonly vpxa: VcDiagnosticManagerLogCreator;
		readonly vpxClient: VcDiagnosticManagerLogCreator;
		readonly vpxd: VcDiagnosticManagerLogCreator;

		fromString(value?: VcDiagnosticManagerLogCreator): VcDiagnosticManagerLogCreator;
	}

	declare const VcDiagnosticManagerLogCreator: VcDiagnosticManagerLogCreator;

	declare class VcDiagnosticManagerLogDescriptor
	{
		creator: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;
		format: String;
		info: VcDescription;
		key: String;
		mimeType: String;

		constructor();
		constructor(key?: String, fileName?: String, creator?: String, format?: String, mimeType?: String, info?: VcDescription);
	}

	interface VcDiagnosticManagerLogFormat
	{
		readonly id: String;
		readonly name: String;
		readonly plain: VcDiagnosticManagerLogFormat;
		readonly value: String;

		fromString(value?: VcDiagnosticManagerLogFormat): VcDiagnosticManagerLogFormat;
	}

	declare const VcDiagnosticManagerLogFormat: VcDiagnosticManagerLogFormat;

	declare class VcDiagnosticManagerLogHeader
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lineEnd: Number;
		lineStart: Number;
		lineText: String[];

		constructor();
		constructor(lineStart?: Number, lineEnd?: Number, lineText?: String[]);
	}

	interface VcDiagnosticPartitionStorageType
	{
		readonly directAttached: VcDiagnosticPartitionStorageType;
		readonly id: String;
		readonly name: String;
		readonly networkAttached: VcDiagnosticPartitionStorageType;
		readonly value: String;

		fromString(value?: VcDiagnosticPartitionStorageType): VcDiagnosticPartitionStorageType;
	}

	declare const VcDiagnosticPartitionStorageType: VcDiagnosticPartitionStorageType;

	interface VcDiagnosticPartitionType
	{
		readonly id: String;
		readonly multiHost: VcDiagnosticPartitionType;
		readonly name: String;
		readonly singleHost: VcDiagnosticPartitionType;
		readonly value: String;

		fromString(value?: VcDiagnosticPartitionType): VcDiagnosticPartitionType;
	}

	declare const VcDiagnosticPartitionType: VcDiagnosticPartitionType;

	declare class VcDigestNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcDirectoryNotEmpty
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcDisableAdminNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcDisableAlarmExpression
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDisabledMethodInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		method: String;
		sources: VcDisabledMethodSource[];

		constructor();
		constructor(method?: String, sources?: VcDisabledMethodSource[]);
	}

	declare class VcDisabledMethodRequest
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		method: String;
		reasonId: String;

		constructor();
		constructor(method?: String, reasonId?: String);
	}

	declare class VcDisabledMethodSource
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reasonId: String;
		sourceId: String;

		constructor();
		constructor(sourceId?: String, reasonId?: String);
	}

	declare class VcDisallowedChangeByService
	{
		disallowedChange: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		serviceName: String;

		constructor();
		constructor(serviceName?: String, disallowedChange?: String);
		printStackTrace(): void;
	}

	interface VcDisallowedChangeByServiceDisallowedChange
	{
		readonly hotExtendDisk: VcDisallowedChangeByServiceDisallowedChange;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcDisallowedChangeByServiceDisallowedChange): VcDisallowedChangeByServiceDisallowedChange;
	}

	declare const VcDisallowedChangeByServiceDisallowedChange: VcDisallowedChangeByServiceDisallowedChange;

	declare class VcDisallowedDiskModeChange
	{
		deviceIndex: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String, deviceIndex?: Number);
		printStackTrace(): void;
	}

	declare class VcDisallowedMigrationDeviceAttached
	{
		fault: VcLocalizedMethodFault;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(fault?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcDisallowedOperationOnFailoverHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		hostname: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem, hostname?: String);
		printStackTrace(): void;
	}

	declare class VcDisconnectedHostsBlockingEVC
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(faults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcDiskChangeExtent
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		length: Number;
		start: Number;

		constructor();
		constructor(start?: Number, length?: Number);
	}

	declare class VcDiskChangeInfo
	{
		changedArea: VcDiskChangeExtent[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		length: Number;
		startOffset: Number;

		constructor();
		constructor(startOffset?: Number, length?: Number, changedArea?: VcDiskChangeExtent[]);
	}

	declare class VcDiskHasPartitions
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcDiskIsLastRemainingNonSSD
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcDiskIsNonLocal
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcDiskIsUSB
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcDiskMoveTypeNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcDiskNotSupported
	{
		disk: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(disk?: Number);
		printStackTrace(): void;
	}

	declare class VcDiskTooSmall
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcDistributedVirtualPort
	{
		config: VcDVPortConfigInfo;
		conflict: boolean;
		conflictPortKey: String;
		connectee: VcDistributedVirtualSwitchPortConnectee;
		connectionCookie: Number;
		dvsUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostLocalPort: boolean;
		key: String;
		lastStatusChange: Date;
		portgroupKey: String;
		proxyHost: VcHostSystem;
		state: VcDVPortState;

		constructor();
		constructor(key?: String, config?: VcDVPortConfigInfo, dvsUuid?: String, portgroupKey?: String, proxyHost?: VcHostSystem, connectee?: VcDistributedVirtualSwitchPortConnectee, conflict?: boolean, conflictPortKey?: String, state?: VcDVPortState, connectionCookie?: Number, lastStatusChange?: Date, hostLocalPort?: boolean);
		isHostLocalPort(): boolean;
	}

	interface VcDistributedVirtualPortgroup
	{
		accessible: boolean;
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		config: VcDVPortgroupConfigInfo;
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		readonly host: VcHostSystem[];
		id: String;
		key: String;
		moref: VcManagedObjectReference;
		name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		portKeys: String[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly summary: VcNetworkSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		readonly vm: VcVirtualMachine[];

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		destroyNetwork(): void;
		dVPortgroupRollback_Task(arg0?: VcEntityBackupConfig): VcTask;
		reconfigureDVPortgroup_Task(arg0?: VcDVPortgroupConfigSpec): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcDistributedVirtualPortgroup: VcDistributedVirtualPortgroup;

	declare class VcDistributedVirtualPortgroupInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		networkReservationSupported: boolean;
		portgroup: VcDistributedVirtualPortgroup;
		portgroupKey: String;
		portgroupName: String;
		portgroupType: String;
		switchName: String;
		switchUuid: String;
		uplinkPortgroup: boolean;

		constructor();
		constructor(switchName?: String, switchUuid?: String, portgroupName?: String, portgroupKey?: String, portgroupType?: String, uplinkPortgroup?: boolean, portgroup?: VcDistributedVirtualPortgroup, networkReservationSupported?: boolean);
		isNetworkReservationSupported(): boolean;
	}

	interface VcDistributedVirtualPortgroupMetaTagName
	{
		readonly dvsName: VcDistributedVirtualPortgroupMetaTagName;
		readonly id: String;
		readonly name: String;
		readonly portgroupName: VcDistributedVirtualPortgroupMetaTagName;
		readonly portIndex: VcDistributedVirtualPortgroupMetaTagName;
		readonly value: String;

		fromString(value?: VcDistributedVirtualPortgroupMetaTagName): VcDistributedVirtualPortgroupMetaTagName;
	}

	declare const VcDistributedVirtualPortgroupMetaTagName: VcDistributedVirtualPortgroupMetaTagName;

	interface VcDistributedVirtualPortgroupPortgroupType
	{
		readonly earlyBinding: VcDistributedVirtualPortgroupPortgroupType;
		readonly ephemeral: VcDistributedVirtualPortgroupPortgroupType;
		readonly id: String;
		readonly lateBinding: VcDistributedVirtualPortgroupPortgroupType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcDistributedVirtualPortgroupPortgroupType): VcDistributedVirtualPortgroupPortgroupType;
	}

	declare const VcDistributedVirtualPortgroupPortgroupType: VcDistributedVirtualPortgroupPortgroupType;

	interface VcDistributedVirtualSwitch
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		capability: VcDVSCapability;
		config: VcDVSConfigInfo;
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		description: String;
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		networkResourcePool: VcDVSNetworkResourcePool[];
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		portgroup: VcDistributedVirtualPortgroup[];
		readonly recentTask: VcTask[];
		runtime: VcDVSRuntimeInfo;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		summary: VcDVSSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		uuid: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addDVPortgroup_Task(arg0?: VcDVPortgroupConfigSpec[]): VcTask;
		addNetworkResourcePool(arg0?: VcDVSNetworkResourcePoolConfigSpec[]): void;
		addTag(arg0?: VcTag[]): void;
		createDVPortgroup_Task(arg0?: VcDVPortgroupConfigSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		dvsReconfigureVmVnicNetworkResourcePool_Task(arg0?: VcDvsVmVnicResourcePoolConfigSpec[]): VcTask;
		dVSRollback_Task(arg0?: VcEntityBackupConfig): VcTask;
		enableNetworkResourceManagement(arg0?: boolean): void;
		fetchDVPortKeys(arg0?: VcDistributedVirtualSwitchPortCriteria): String[];
		fetchDVPorts(arg0?: VcDistributedVirtualSwitchPortCriteria): VcDistributedVirtualPort[];
		lookupDvPortGroup(arg0?: String): VcDistributedVirtualPortgroup;
		mergeDvs_Task(arg0?: VcDistributedVirtualSwitch): VcTask;
		moveDVPort_Task(arg0?: String[], arg1?: String): VcTask;
		performDvsProductSpecOperation_Task(arg0?: String, arg1?: VcDistributedVirtualSwitchProductSpec): VcTask;
		queryUsedVlanIdInDvs(): Number[];
		reconfigureDVPort_Task(arg0?: VcDVPortConfigSpec[]): VcTask;
		reconfigureDvs_Task(arg0?: VcDVSConfigSpec): VcTask;
		rectifyDvsHost_Task(arg0?: VcHostSystem[]): VcTask;
		refreshDVPortState(arg0?: String[]): void;
		reload(): void;
		removeNetworkResourcePool(arg0?: String[]): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
		updateDvsCapability(arg0?: VcDVSCapability): void;
		updateDVSHealthCheckConfig_Task(arg0?: VcDVSHealthCheckConfig[]): VcTask;
		updateNetworkResourcePool(arg0?: VcDVSNetworkResourcePoolConfigSpec[]): void;
	}

	declare const VcDistributedVirtualSwitch: VcDistributedVirtualSwitch;

	interface VcDistributedVirtualSwitchHostInfrastructureTrafficClass
	{
		readonly faultTolerance: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly hbr: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly id: String;
		readonly iSCSI: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly management: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly name: String;
		readonly nfs: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly value: String;
		readonly vdp: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly virtualMachine: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly vmotion: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly vsan: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;

		fromString(value?: VcDistributedVirtualSwitchHostInfrastructureTrafficClass): VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
	}

	declare const VcDistributedVirtualSwitchHostInfrastructureTrafficClass: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;

	declare class VcDistributedVirtualSwitchHostMember
	{
		config: VcDistributedVirtualSwitchHostMemberConfigInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		runtimeState: VcDistributedVirtualSwitchHostMemberRuntimeState;
		status: String;
		statusDetail: String;
		uplinkPortKey: String[];

		constructor();
		constructor(runtimeState?: VcDistributedVirtualSwitchHostMemberRuntimeState, config?: VcDistributedVirtualSwitchHostMemberConfigInfo, productInfo?: VcDistributedVirtualSwitchProductSpec, uplinkPortKey?: String[], status?: String, statusDetail?: String);
	}

	declare class VcDistributedVirtualSwitchHostMemberBacking
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDistributedVirtualSwitchHostMemberConfigInfo
	{
		backing: VcDistributedVirtualSwitchHostMemberBacking;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		maxProxySwitchPorts: Number;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];

		constructor();
		constructor(host?: VcHostSystem, maxProxySwitchPorts?: Number, vendorSpecificConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], backing?: VcDistributedVirtualSwitchHostMemberBacking);
	}

	declare class VcDistributedVirtualSwitchHostMemberConfigSpec
	{
		backing: VcDistributedVirtualSwitchHostMemberBacking;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		maxProxySwitchPorts: Number;
		operation: String;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];

		constructor();
		constructor(operation?: String, host?: VcHostSystem, backing?: VcDistributedVirtualSwitchHostMemberBacking, maxProxySwitchPorts?: Number, vendorSpecificConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[]);
	}

	interface VcDistributedVirtualSwitchHostMemberHostComponentState
	{
		readonly disconnected: VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly down: VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly id: String;
		readonly name: String;
		readonly outOfSync: VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly pending: VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly up: VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly value: String;
		readonly warning: VcDistributedVirtualSwitchHostMemberHostComponentState;

		fromString(value?: VcDistributedVirtualSwitchHostMemberHostComponentState): VcDistributedVirtualSwitchHostMemberHostComponentState;
	}

	declare const VcDistributedVirtualSwitchHostMemberHostComponentState: VcDistributedVirtualSwitchHostMemberHostComponentState;

	declare class VcDistributedVirtualSwitchHostMemberPnicBacking
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pnicSpec: VcDistributedVirtualSwitchHostMemberPnicSpec[];

		constructor();
		constructor(pnicSpec?: VcDistributedVirtualSwitchHostMemberPnicSpec[]);
	}

	declare class VcDistributedVirtualSwitchHostMemberPnicSpec
	{
		connectionCookie: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pnicDevice: String;
		uplinkPortgroupKey: String;
		uplinkPortKey: String;

		constructor();
		constructor(pnicDevice?: String, uplinkPortKey?: String, uplinkPortgroupKey?: String, connectionCookie?: Number);
	}

	declare class VcDistributedVirtualSwitchHostMemberRuntimeState
	{
		currentMaxProxySwitchPorts: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(currentMaxProxySwitchPorts?: Number);
	}

	declare class VcDistributedVirtualSwitchHostProductSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		productLineId: String;
		version: String;

		constructor();
		constructor(productLineId?: String, version?: String);
	}

	declare class VcDistributedVirtualSwitchInfo
	{
		distributedVirtualSwitch: VcDistributedVirtualSwitch;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		networkReservationSupported: boolean;
		switchName: String;
		switchUuid: String;

		constructor();
		constructor(switchName?: String, switchUuid?: String, distributedVirtualSwitch?: VcDistributedVirtualSwitch, networkReservationSupported?: boolean);
		isNetworkReservationSupported(): boolean;
	}

	declare class VcDistributedVirtualSwitchKeyedOpaqueBlob
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		opaqueData: String;

		constructor();
		constructor(key?: String, opaqueData?: String);
	}

	interface VcDistributedVirtualSwitchManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		dVSManagerExportEntity_Task(arg0?: VcSelectionSet[]): VcTask;
		dVSManagerImportEntity_Task(arg0?: VcEntityBackupConfig[], arg1?: String): VcTask;
		dVSManagerLookupDvPortGroup(arg0?: String, arg1?: String): VcDistributedVirtualPortgroup;
		dVSManagerQueryDvpgUplinkTeam(arg0?: String[]): VcDVSManagerDvpgUplinkTeam[];
		dVSManagerQueryHostNetworkResource(arg0?: String[]): VcHostNetworkResource[];
		executeDvsOpaqueCommand_Task(arg0?: VcSelectionSet[], arg1?: VcDVSOpaqueCommandReqSpec): VcTask;
		fetchDvsOpaqueData(arg0?: VcSelectionSet[], arg1?: boolean): VcDVSOpaqueDataConfigInfo[];
		fetchDvsOpaqueDataEx(arg0?: VcSelectionSet[], arg1?: boolean): VcDVSOpaqueConfigInfo[];
		queryAvailableDvsSpec(arg0?: boolean): VcDistributedVirtualSwitchProductSpec[];
		queryCompatibleHostForExistingDvs(arg0?: VcManagedEntity, arg1?: boolean, arg2?: VcDistributedVirtualSwitch): VcHostSystem[];
		queryCompatibleHostForNewDvs(arg0?: VcManagedEntity, arg1?: boolean, arg2?: VcDistributedVirtualSwitchProductSpec): VcHostSystem[];
		queryDvsByUuid(arg0?: String): VcDistributedVirtualSwitch;
		queryDvsCheckCompatibility(arg0?: VcDistributedVirtualSwitchManagerHostContainer, arg1?: VcDistributedVirtualSwitchManagerDvsProductSpec, arg2?: VcDistributedVirtualSwitchManagerHostDvsFilterSpec[]): VcDistributedVirtualSwitchManagerCompatibilityResult[];
		queryDvsCompatibleHostSpec(arg0?: VcDistributedVirtualSwitchProductSpec): VcDistributedVirtualSwitchHostProductSpec[];
		queryDvsConfigTarget(arg0?: VcHostSystem, arg1?: VcDistributedVirtualSwitch): VcDVSManagerDvsConfigTarget;
		queryDvsFeatureCapability(arg0?: VcDistributedVirtualSwitchProductSpec): VcDVSFeatureCapability;
		queryVwirePort(arg0?: VcOpaqueNetwork, arg1?: VcManagedEntity): VcVwirePort[];
		rectifyDvsOnHost_Task(arg0?: VcHostSystem[]): VcTask;
		updateDvsOpaqueData_Task(arg0?: VcSelectionSet[], arg1?: VcDVSOpaqueDataConfigSpec[], arg2?: boolean): VcTask;
		updateDvsOpaqueDataEx_Task(arg0?: VcSelectionSet[], arg1?: VcDVSOpaqueConfigSpec[], arg2?: boolean): VcTask;
	}

	declare const VcDistributedVirtualSwitchManager: VcDistributedVirtualSwitchManager;

	declare class VcDistributedVirtualSwitchManagerCompatibilityResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault[];
		host: VcHostSystem;

		constructor();
		constructor(host?: VcHostSystem, error?: VcLocalizedMethodFault[]);
	}

	declare class VcDistributedVirtualSwitchManagerDvsProductSpec
	{
		distributedVirtualSwitch: VcDistributedVirtualSwitch;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		newSwitchProductSpec: VcDistributedVirtualSwitchProductSpec;

		constructor();
		constructor(newSwitchProductSpec?: VcDistributedVirtualSwitchProductSpec, distributedVirtualSwitch?: VcDistributedVirtualSwitch);
	}

	declare class VcDistributedVirtualSwitchManagerHostArrayFilter
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem[];
		inclusive: boolean;

		constructor();
		constructor(inclusive?: boolean, host?: VcHostSystem[]);
	}

	declare class VcDistributedVirtualSwitchManagerHostContainer
	{
		container: VcManagedEntity;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		recursive: boolean;

		constructor();
		constructor(container?: VcManagedEntity, recursive?: boolean);
	}

	declare class VcDistributedVirtualSwitchManagerHostContainerFilter
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostContainer: VcDistributedVirtualSwitchManagerHostContainer;
		inclusive: boolean;

		constructor();
		constructor(inclusive?: boolean, hostContainer?: VcDistributedVirtualSwitchManagerHostContainer);
	}

	declare class VcDistributedVirtualSwitchManagerHostDvsFilterSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inclusive: boolean;

		constructor();
		constructor(inclusive?: boolean);
	}

	declare class VcDistributedVirtualSwitchManagerHostDvsMembershipFilter
	{
		distributedVirtualSwitch: VcDistributedVirtualSwitch;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inclusive: boolean;

		constructor();
		constructor(inclusive?: boolean, distributedVirtualSwitch?: VcDistributedVirtualSwitch);
	}

	declare class VcDistributedVirtualSwitchManagerImportResult
	{
		distributedVirtualPortgroup: VcDistributedVirtualPortgroup[];
		distributedVirtualSwitch: VcDistributedVirtualSwitch[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		importFault: VcImportOperationBulkFaultFaultOnImport[];

		constructor();
		constructor(distributedVirtualSwitch?: VcDistributedVirtualSwitch[], distributedVirtualPortgroup?: VcDistributedVirtualPortgroup[], importFault?: VcImportOperationBulkFaultFaultOnImport[]);
	}

	interface VcDistributedVirtualSwitchNetworkResourceControlVersion
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly version2: VcDistributedVirtualSwitchNetworkResourceControlVersion;
		readonly version3: VcDistributedVirtualSwitchNetworkResourceControlVersion;

		fromString(value?: VcDistributedVirtualSwitchNetworkResourceControlVersion): VcDistributedVirtualSwitchNetworkResourceControlVersion;
	}

	declare const VcDistributedVirtualSwitchNetworkResourceControlVersion: VcDistributedVirtualSwitchNetworkResourceControlVersion;

	interface VcDistributedVirtualSwitchNicTeamingPolicyMode
	{
		readonly failover_explicit: VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly id: String;
		readonly loadbalance_ip: VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly loadbalance_loadbased: VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly loadbalance_srcid: VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly loadbalance_srcmac: VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcDistributedVirtualSwitchNicTeamingPolicyMode): VcDistributedVirtualSwitchNicTeamingPolicyMode;
	}

	declare const VcDistributedVirtualSwitchNicTeamingPolicyMode: VcDistributedVirtualSwitchNicTeamingPolicyMode;

	declare class VcDistributedVirtualSwitchPortConnectee
	{
		addressHint: String;
		connectedEntity: VcManagedEntity;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nicKey: String;
		type: String;

		constructor();
		constructor(connectedEntity?: VcManagedEntity, nicKey?: String, type?: String, addressHint?: String);
	}

	interface VcDistributedVirtualSwitchPortConnecteeConnecteeType
	{
		readonly hostConsoleVnic: VcDistributedVirtualSwitchPortConnecteeConnecteeType;
		readonly hostVmkVnic: VcDistributedVirtualSwitchPortConnecteeConnecteeType;
		readonly id: String;
		readonly name: String;
		readonly pnic: VcDistributedVirtualSwitchPortConnecteeConnecteeType;
		readonly value: String;
		readonly vmVnic: VcDistributedVirtualSwitchPortConnecteeConnecteeType;

		fromString(value?: VcDistributedVirtualSwitchPortConnecteeConnecteeType): VcDistributedVirtualSwitchPortConnecteeConnecteeType;
	}

	declare const VcDistributedVirtualSwitchPortConnecteeConnecteeType: VcDistributedVirtualSwitchPortConnecteeConnecteeType;

	declare class VcDistributedVirtualSwitchPortConnection
	{
		connectionCookie: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		portgroupKey: String;
		portKey: String;
		switchUuid: String;

		constructor();
		constructor(switchUuid?: String, portgroupKey?: String, portKey?: String, connectionCookie?: Number);
	}

	declare class VcDistributedVirtualSwitchPortCriteria
	{
		active: boolean;
		connected: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem[];
		inside: boolean;
		portgroupKey: String[];
		portKey: String[];
		scope: VcManagedEntity;
		uplinkPort: boolean;

		constructor();
		constructor(connected?: boolean, active?: boolean, uplinkPort?: boolean, scope?: VcManagedEntity, portgroupKey?: String[], inside?: boolean, portKey?: String[], host?: VcHostSystem[]);
		isActive(): boolean;
		isConnected(): boolean;
		isInside(): boolean;
		isUplinkPort(): boolean;
	}

	declare class VcDistributedVirtualSwitchPortStatistics
	{
		bytesInBroadcast: Number;
		bytesInFromPnic: Number;
		bytesInMulticast: Number;
		bytesInUnicast: Number;
		bytesOutBroadcast: Number;
		bytesOutMulticast: Number;
		bytesOutToPnic: Number;
		bytesOutUnicast: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		packetsInBroadcast: Number;
		packetsInDropped: Number;
		packetsInException: Number;
		packetsInMulticast: Number;
		packetsInUnicast: Number;
		packetsOutBroadcast: Number;
		packetsOutDropped: Number;
		packetsOutException: Number;
		packetsOutMulticast: Number;
		packetsOutUnicast: Number;

		constructor();
		constructor(packetsInMulticast?: Number, packetsOutMulticast?: Number, bytesInMulticast?: Number, bytesOutMulticast?: Number, packetsInUnicast?: Number, packetsOutUnicast?: Number, bytesInUnicast?: Number, bytesOutUnicast?: Number, packetsInBroadcast?: Number, packetsOutBroadcast?: Number, bytesInBroadcast?: Number, bytesOutBroadcast?: Number, packetsInDropped?: Number, packetsOutDropped?: Number, packetsInException?: Number, packetsOutException?: Number, bytesInFromPnic?: Number, bytesOutToPnic?: Number);
	}

	declare class VcDistributedVirtualSwitchProductSpec
	{
		build: String;
		bundleId: String;
		bundleUrl: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		forwardingClass: String;
		name: String;
		vendor: String;
		version: String;

		constructor();
		constructor(name?: String, vendor?: String, version?: String, build?: String, forwardingClass?: String, bundleId?: String, bundleUrl?: String);
	}

	interface VcDistributedVirtualSwitchProductSpecOperationType
	{
		readonly id: String;
		readonly name: String;
		readonly notifyAvailableUpgrade: VcDistributedVirtualSwitchProductSpecOperationType;
		readonly preInstall: VcDistributedVirtualSwitchProductSpecOperationType;
		readonly proceedWithUpgrade: VcDistributedVirtualSwitchProductSpecOperationType;
		readonly updateBundleInfo: VcDistributedVirtualSwitchProductSpecOperationType;
		readonly upgrade: VcDistributedVirtualSwitchProductSpecOperationType;
		readonly value: String;

		fromString(value?: VcDistributedVirtualSwitchProductSpecOperationType): VcDistributedVirtualSwitchProductSpecOperationType;
	}

	declare const VcDistributedVirtualSwitchProductSpecOperationType: VcDistributedVirtualSwitchProductSpecOperationType;

	declare class VcDomainNotFound
	{
		domainName: String;
		errorCode: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(errorCode?: Number, domainName?: String);
		printStackTrace(): void;
	}

	interface VcDpmBehavior
	{
		readonly automated: VcDpmBehavior;
		readonly id: String;
		readonly manual: VcDpmBehavior;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcDpmBehavior): VcDpmBehavior;
	}

	declare const VcDpmBehavior: VcDpmBehavior;

	interface VcDrsBehavior
	{
		readonly fullyAutomated: VcDrsBehavior;
		readonly id: String;
		readonly manual: VcDrsBehavior;
		readonly name: String;
		readonly partiallyAutomated: VcDrsBehavior;
		readonly value: String;

		fromString(value?: VcDrsBehavior): VcDrsBehavior;
	}

	declare const VcDrsBehavior: VcDrsBehavior;

	declare class VcDrsCorrelationPair
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;

		constructor();
		constructor(key?: Number, datastore?: VcDatastore);
	}

	declare class VcDrsDatastoreCorrelation
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		state: VcDrsInjectorWorkloadCorrelationState;

		constructor();
		constructor(datastore?: VcDatastore, state?: VcDrsInjectorWorkloadCorrelationState);
	}

	declare class VcDrsDisabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDrsDisabledOnVm
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcDrsEnabledEvent
	{
		behavior: String;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, behavior?: String);
	}

	declare class VcDrsEnteredStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDrsEnteringStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDrsExitedStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDrsExitingStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDrsExitStandbyModeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDrsHostIormStatus
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcDatastore;
		status: Number;

		constructor();
		constructor(status?: Number, key?: VcDatastore);
	}

	declare class VcDrsInjectorWorkload
	{
		correlation: VcDrsDatastoreCorrelation[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inflectionPoint: Number;
		intercept1: Number;
		intercept2: Number;
		key: VcDatastore;
		slope1: Number;
		slope2: Number;
		writeIntercept: Number;
		writeSlope: Number;

		constructor();
		constructor(key?: VcDatastore, slope1?: Number, intercept1?: Number, slope2?: Number, intercept2?: Number, inflectionPoint?: Number, writeSlope?: Number, writeIntercept?: Number, correlation?: VcDrsDatastoreCorrelation[]);
	}

	interface VcDrsInjectorWorkloadCorrelationState
	{
		readonly Correlated: VcDrsInjectorWorkloadCorrelationState;
		readonly id: String;
		readonly name: String;
		readonly Uncorrelated: VcDrsInjectorWorkloadCorrelationState;
		readonly value: String;

		fromString(value?: VcDrsInjectorWorkloadCorrelationState): VcDrsInjectorWorkloadCorrelationState;
	}

	declare const VcDrsInjectorWorkloadCorrelationState: VcDrsInjectorWorkloadCorrelationState;

	declare class VcDrsInvocationFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDrsPlacementRequiresVmsInTopologicalOrder
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	interface VcDrsRecommendationReasonCode
	{
		readonly antiAffin: VcDrsRecommendationReasonCode;
		readonly fairnessCpuAvg: VcDrsRecommendationReasonCode;
		readonly fairnessMemAvg: VcDrsRecommendationReasonCode;
		readonly hostMaint: VcDrsRecommendationReasonCode;
		readonly id: String;
		readonly jointAffin: VcDrsRecommendationReasonCode;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcDrsRecommendationReasonCode): VcDrsRecommendationReasonCode;
	}

	declare const VcDrsRecommendationReasonCode: VcDrsRecommendationReasonCode;

	declare class VcDrsRecoveredFromFailureEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDrsResourceConfigureFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcDrsResourceConfigureSyncedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDrsRuleComplianceEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcDrsRuleViolationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcDrsSoftRuleViolationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	interface VcDrsStatsManager
	{
		hostIormStatus: VcDrsHostIormStatus[];
		id: String;
		injectorWorkload: VcDrsInjectorWorkload[];
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		drsConfigureCorrelationDetector(arg0?: VcDrsCorrelationPair[]): void;
		drsConfigureWorkloadCharacterization(arg0?: VcDrsWorkloadCharacterization[]): void;
		drsQueryCorrelationResult(arg0?: VcDatastore): VcDatastore[];
		drsQueryWorkloadCharacterization(arg0?: VcHostSystem): VcDrsWorkloadCharacterization[];
	}

	declare const VcDrsStatsManager: VcDrsStatsManager;

	declare class VcDrsVmMigratedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDatacenter: VcDatacenterEventArgument;
		sourceDatastore: VcDatastoreEventArgument;
		sourceHost: VcHostEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, sourceHost?: VcHostEventArgument, sourceDatacenter?: VcDatacenterEventArgument, sourceDatastore?: VcDatastoreEventArgument);
	}

	declare class VcDrsVmotionIncompatibleFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcDrsVmPoweredOnEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcDrsWorkloadCharacterization
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ioSize: Number;
		key: VcDatastore;
		outstandingIo: Number;
		randomPercent: Number;
		readPercent: Number;

		constructor();
		constructor(key?: VcDatastore, outstandingIo?: Number, ioSize?: Number, readPercent?: Number, randomPercent?: Number);
	}

	declare class VcDuplicateDisks
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcDuplicateIpDetectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		duplicateIP: String;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		macAddress: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, duplicateIP?: String, macAddress?: String);
	}

	declare class VcDuplicateName
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		object: VcManagedObject;

		constructor();
		constructor(name?: String, object?: VcManagedObject);
		printStackTrace(): void;
	}

	declare class VcDuplicateVsanNetworkInterface
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcDvpgImportEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		importType: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, importType?: String);
	}

	declare class VcDvpgRestoreEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDVPortConfigInfo
	{
		configVersion: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		scope: VcManagedEntity[];
		setting: VcDVPortSetting;

		constructor();
		constructor(name?: String, scope?: VcManagedEntity[], description?: String, setting?: VcDVPortSetting, configVersion?: String);
	}

	declare class VcDVPortConfigSpec
	{
		configVersion: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		name: String;
		operation: String;
		scope: VcManagedEntity[];
		setting: VcDVPortSetting;

		constructor();
		constructor(operation?: String, key?: String, name?: String, scope?: VcManagedEntity[], description?: String, setting?: VcDVPortSetting, configVersion?: String);
	}

	declare class VcDVPortgroupConfigInfo
	{
		autoExpand: boolean;
		configVersion: String;
		defaultPortConfig: VcDVPortSetting;
		description: String;
		distributedVirtualSwitch: VcDistributedVirtualSwitch;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		name: String;
		numPorts: Number;
		policy: VcDVPortgroupPolicy;
		portNameFormat: String;
		scope: VcManagedEntity[];
		type: String;
		uplink: boolean;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vmVnicNetworkResourcePoolKey: String;

		constructor();
		constructor(key?: String, name?: String, numPorts?: Number, distributedVirtualSwitch?: VcDistributedVirtualSwitch, defaultPortConfig?: VcDVPortSetting, description?: String, type?: String, policy?: VcDVPortgroupPolicy, portNameFormat?: String, scope?: VcManagedEntity[], vendorSpecificConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], configVersion?: String, autoExpand?: boolean, vmVnicNetworkResourcePoolKey?: String, uplink?: boolean);
		isAutoExpand(): boolean;
		isUplink(): boolean;
	}

	declare class VcDVPortgroupConfigSpec
	{
		autoExpand: boolean;
		configVersion: String;
		defaultPortConfig: VcDVPortSetting;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		numPorts: Number;
		policy: VcDVPortgroupPolicy;
		portNameFormat: String;
		scope: VcManagedEntity[];
		type: String;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vmVnicNetworkResourcePoolKey: String;

		constructor();
		constructor(configVersion?: String, name?: String, numPorts?: Number, portNameFormat?: String, defaultPortConfig?: VcDVPortSetting, description?: String, type?: String, scope?: VcManagedEntity[], policy?: VcDVPortgroupPolicy, vendorSpecificConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], autoExpand?: boolean, vmVnicNetworkResourcePoolKey?: String);
		isAutoExpand(): boolean;
	}

	declare class VcDVPortgroupCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDVPortgroupDestroyedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDVPortgroupEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDVPortgroupPolicy
	{
		blockOverrideAllowed: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		livePortMovingAllowed: boolean;
		networkResourcePoolOverrideAllowed: boolean;
		portConfigResetAtDisconnect: boolean;
		shapingOverrideAllowed: boolean;
		trafficFilterOverrideAllowed: boolean;
		vendorConfigOverrideAllowed: boolean;

		constructor();
		constructor(blockOverrideAllowed?: boolean, shapingOverrideAllowed?: boolean, vendorConfigOverrideAllowed?: boolean, livePortMovingAllowed?: boolean, portConfigResetAtDisconnect?: boolean, networkResourcePoolOverrideAllowed?: boolean, trafficFilterOverrideAllowed?: boolean);
		isNetworkResourcePoolOverrideAllowed(): boolean;
		isTrafficFilterOverrideAllowed(): boolean;
	}

	declare class VcDVPortgroupReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configChanges: VcChangesInfoEventArgument;
		configSpec: VcDVPortgroupConfigSpec;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, configSpec?: VcDVPortgroupConfigSpec, configChanges?: VcChangesInfoEventArgument);
	}

	declare class VcDVPortgroupRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, oldName?: String, newName?: String);
	}

	declare class VcDVPortgroupSelection
	{
		dvsUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		portgroupKey: String[];

		constructor();
		constructor(dvsUuid?: String, portgroupKey?: String[]);
	}

	declare class VcDVPortNotSupported
	{
		backing: String;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String, backing?: String);
		printStackTrace(): void;
	}

	declare class VcDVPortSelection
	{
		dvsUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		portKey: String[];

		constructor();
		constructor(dvsUuid?: String, portKey?: String[]);
	}

	declare class VcDVPortSetting
	{
		blocked: VcBoolPolicy;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filterPolicy: VcDvsFilterPolicy;
		inShapingPolicy: VcDVSTrafficShapingPolicy;
		networkResourcePoolKey: VcStringPolicy;
		outShapingPolicy: VcDVSTrafficShapingPolicy;
		vendorSpecificConfig: VcDVSVendorSpecificConfig;
		vmDirectPathGen2Allowed: VcBoolPolicy;

		constructor();
		constructor(blocked?: VcBoolPolicy, vmDirectPathGen2Allowed?: VcBoolPolicy, inShapingPolicy?: VcDVSTrafficShapingPolicy, outShapingPolicy?: VcDVSTrafficShapingPolicy, vendorSpecificConfig?: VcDVSVendorSpecificConfig, networkResourcePoolKey?: VcStringPolicy, filterPolicy?: VcDvsFilterPolicy);
	}

	declare class VcDVPortState
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		runtimeInfo: VcDVPortStatus;
		stats: VcDistributedVirtualSwitchPortStatistics;
		vendorSpecificState: VcDistributedVirtualSwitchKeyedOpaqueBlob[];

		constructor();
		constructor(runtimeInfo?: VcDVPortStatus, stats?: VcDistributedVirtualSwitchPortStatistics, vendorSpecificState?: VcDistributedVirtualSwitchKeyedOpaqueBlob[]);
	}

	declare class VcDVPortStatus
	{
		blocked: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		linkPeer: String;
		linkUp: boolean;
		macAddress: String;
		mtu: Number;
		statusDetail: String;
		trunkingMode: boolean;
		vlanIds: VcNumericRange[];
		vmDirectPathGen2Active: boolean;
		vmDirectPathGen2InactiveReasonExtended: String;
		vmDirectPathGen2InactiveReasonNetwork: String[];
		vmDirectPathGen2InactiveReasonOther: String[];

		constructor();
		constructor(linkUp?: boolean, blocked?: boolean, vlanIds?: VcNumericRange[], trunkingMode?: boolean, mtu?: Number, linkPeer?: String, macAddress?: String, statusDetail?: String, vmDirectPathGen2Active?: boolean, vmDirectPathGen2InactiveReasonNetwork?: String[], vmDirectPathGen2InactiveReasonOther?: String[], vmDirectPathGen2InactiveReasonExtended?: String);
		isTrunkingMode(): boolean;
		isVmDirectPathGen2Active(): boolean;
	}

	interface VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork
	{
		readonly id: String;
		readonly name: String;
		readonly portNptDisabledForPort: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly portNptIncompatibleDvs: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly portNptNoCompatibleNics: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly portNptNoVirtualFunctionsAvailable: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly value: String;

		fromString(value?: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork): VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
	}

	declare const VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;

	interface VcDVPortStatusVmDirectPathGen2InactiveReasonOther
	{
		readonly id: String;
		readonly name: String;
		readonly portNptIncompatibleConnectee: VcDVPortStatusVmDirectPathGen2InactiveReasonOther;
		readonly portNptIncompatibleHost: VcDVPortStatusVmDirectPathGen2InactiveReasonOther;
		readonly value: String;

		fromString(value?: VcDVPortStatusVmDirectPathGen2InactiveReasonOther): VcDVPortStatusVmDirectPathGen2InactiveReasonOther;
	}

	declare const VcDVPortStatusVmDirectPathGen2InactiveReasonOther: VcDVPortStatusVmDirectPathGen2InactiveReasonOther;

	declare class VcDvsAcceptNetworkRuleAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDvsApplyOperationFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		objectFault: VcDvsApplyOperationFaultFaultOnObject[];

		constructor();
		constructor(objectFault?: VcDvsApplyOperationFaultFaultOnObject[]);
		printStackTrace(): void;
	}

	declare class VcDvsApplyOperationFaultFaultOnObject
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		objectId: String;
		type: String;

		constructor();
		constructor(objectId?: String, type?: String, fault?: VcLocalizedMethodFault);
	}

	declare class VcDVSBackupRestoreCapability
	{
		backupRestoreSupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(backupRestoreSupported?: boolean);
	}

	declare class VcDVSCapability
	{
		compatibleHostComponentProductInfo: VcDistributedVirtualSwitchHostProductSpec[];
		dvPortGroupOperationSupported: boolean;
		dvPortOperationSupported: boolean;
		dvsOperationSupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		featuresSupported: VcDVSFeatureCapability;

		constructor();
		constructor(dvsOperationSupported?: boolean, dvPortGroupOperationSupported?: boolean, dvPortOperationSupported?: boolean, compatibleHostComponentProductInfo?: VcDistributedVirtualSwitchHostProductSpec[], featuresSupported?: VcDVSFeatureCapability);
		isDvPortGroupOperationSupported(): boolean;
		isDvPortOperationSupported(): boolean;
		isDvsOperationSupported(): boolean;
	}

	declare class VcDVSConfigInfo
	{
		configVersion: String;
		contact: VcDVSContactInfo;
		createTime: Date;
		defaultPortConfig: VcDVPortSetting;
		defaultProxySwitchMaxNumPorts: Number;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extensionKey: String;
		healthCheckConfig: VcDVSHealthCheckConfig[];
		host: VcDistributedVirtualSwitchHostMember[];
		infrastructureTrafficResourceConfig: VcDvsHostInfrastructureTrafficResource[];
		maxPorts: Number;
		name: String;
		networkResourceControlVersion: String;
		networkResourceManagementEnabled: boolean;
		numPorts: Number;
		numStandalonePorts: Number;
		pnicCapacityRatioForReservation: Number;
		policy: VcDVSPolicy;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		switchIpAddress: String;
		targetInfo: VcDistributedVirtualSwitchProductSpec;
		uplinkPortgroup: VcDistributedVirtualPortgroup[];
		uplinkPortPolicy: VcDVSUplinkPortPolicy;
		uuid: String;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vmVnicNetworkResourcePool: VcDVSVmVnicNetworkResourcePool[];

		constructor();
		constructor(uuid?: String, name?: String, numStandalonePorts?: Number, numPorts?: Number, maxPorts?: Number, uplinkPortPolicy?: VcDVSUplinkPortPolicy, uplinkPortgroup?: VcDistributedVirtualPortgroup[], defaultPortConfig?: VcDVPortSetting, host?: VcDistributedVirtualSwitchHostMember[], productInfo?: VcDistributedVirtualSwitchProductSpec, targetInfo?: VcDistributedVirtualSwitchProductSpec, extensionKey?: String, vendorSpecificConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], policy?: VcDVSPolicy, description?: String, configVersion?: String, contact?: VcDVSContactInfo, switchIpAddress?: String, createTime?: Date, networkResourceManagementEnabled?: boolean, defaultProxySwitchMaxNumPorts?: Number, healthCheckConfig?: VcDVSHealthCheckConfig[], infrastructureTrafficResourceConfig?: VcDvsHostInfrastructureTrafficResource[], networkResourceControlVersion?: String, vmVnicNetworkResourcePool?: VcDVSVmVnicNetworkResourcePool[], pnicCapacityRatioForReservation?: Number);
		isNetworkResourceManagementEnabled(): boolean;
	}

	declare class VcDVSConfigSpec
	{
		configVersion: String;
		contact: VcDVSContactInfo;
		defaultPortConfig: VcDVPortSetting;
		defaultProxySwitchMaxNumPorts: Number;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extensionKey: String;
		host: VcDistributedVirtualSwitchHostMemberConfigSpec[];
		infrastructureTrafficResourceConfig: VcDvsHostInfrastructureTrafficResource[];
		maxPorts: Number;
		name: String;
		networkResourceControlVersion: String;
		numStandalonePorts: Number;
		policy: VcDVSPolicy;
		switchIpAddress: String;
		uplinkPortgroup: VcDistributedVirtualPortgroup[];
		uplinkPortPolicy: VcDVSUplinkPortPolicy;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];

		constructor();
		constructor(configVersion?: String, name?: String, numStandalonePorts?: Number, maxPorts?: Number, uplinkPortPolicy?: VcDVSUplinkPortPolicy, uplinkPortgroup?: VcDistributedVirtualPortgroup[], defaultPortConfig?: VcDVPortSetting, host?: VcDistributedVirtualSwitchHostMemberConfigSpec[], extensionKey?: String, description?: String, policy?: VcDVSPolicy, vendorSpecificConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], contact?: VcDVSContactInfo, switchIpAddress?: String, defaultProxySwitchMaxNumPorts?: Number, infrastructureTrafficResourceConfig?: VcDvsHostInfrastructureTrafficResource[], networkResourceControlVersion?: String);
	}

	declare class VcDVSContactInfo
	{
		contact: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, contact?: String);
	}

	declare class VcDvsCopyNetworkRuleAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDvsCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		parent: VcFolderEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, parent?: VcFolderEventArgument);
	}

	declare class VcDVSCreateSpec
	{
		capability: VcDVSCapability;
		configSpec: VcDVSConfigSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		productInfo: VcDistributedVirtualSwitchProductSpec;

		constructor();
		constructor(configSpec?: VcDVSConfigSpec, productInfo?: VcDistributedVirtualSwitchProductSpec, capability?: VcDVSCapability);
	}

	declare class VcDvsDestroyedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDvsDropNetworkRuleAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDvsEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDvsEventArgument
	{
		dvs: VcDistributedVirtualSwitch;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, dvs?: VcDistributedVirtualSwitch);
	}

	interface VcDvsEventPortBlockState
	{
		readonly blocked: VcDvsEventPortBlockState;
		readonly id: String;
		readonly name: String;
		readonly unblocked: VcDvsEventPortBlockState;
		readonly unknown: VcDvsEventPortBlockState;
		readonly unset: VcDvsEventPortBlockState;
		readonly value: String;

		fromString(value?: VcDvsEventPortBlockState): VcDvsEventPortBlockState;
	}

	declare const VcDvsEventPortBlockState: VcDvsEventPortBlockState;

	declare class VcDVSFailureCriteria
	{
		checkBeacon: VcBoolPolicy;
		checkDuplex: VcBoolPolicy;
		checkErrorPercent: VcBoolPolicy;
		checkSpeed: VcStringPolicy;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullDuplex: VcBoolPolicy;
		inherited: boolean;
		percentage: VcIntPolicy;
		speed: VcIntPolicy;

		constructor();
		constructor(inherited?: boolean, checkSpeed?: VcStringPolicy, speed?: VcIntPolicy, checkDuplex?: VcBoolPolicy, fullDuplex?: VcBoolPolicy, checkErrorPercent?: VcBoolPolicy, percentage?: VcIntPolicy, checkBeacon?: VcBoolPolicy);
	}

	declare class VcDvsFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcDVSFeatureCapability
	{
		backupRestoreCapability: VcDVSBackupRestoreCapability;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		healthCheckCapability: VcDVSHealthCheckCapability;
		networkFilterSupported: boolean;
		networkResourceManagementCapability: VcDVSNetworkResourceManagementCapability;
		networkResourceManagementSupported: boolean;
		networkResourcePoolHighShareValue: Number;
		nicTeamingPolicy: String[];
		rollbackCapability: VcDVSRollbackCapability;
		vmDirectPathGen2Supported: boolean;

		constructor();
		constructor(networkResourceManagementSupported?: boolean, vmDirectPathGen2Supported?: boolean, nicTeamingPolicy?: String[], networkResourcePoolHighShareValue?: Number, networkResourceManagementCapability?: VcDVSNetworkResourceManagementCapability, healthCheckCapability?: VcDVSHealthCheckCapability, rollbackCapability?: VcDVSRollbackCapability, backupRestoreCapability?: VcDVSBackupRestoreCapability, networkFilterSupported?: boolean);
		isNetworkFilterSupported(): boolean;
	}

	declare class VcDvsFilterConfig
	{
		agentName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		key: String;
		onFailure: String;
		parameters: VcDvsFilterParameter;
		slotNumber: String;

		constructor();
		constructor(inherited?: boolean, key?: String, agentName?: String, slotNumber?: String, parameters?: VcDvsFilterParameter, onFailure?: String);
	}

	declare class VcDvsFilterConfigSpec
	{
		agentName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		key: String;
		onFailure: String;
		operation: String;
		parameters: VcDvsFilterParameter;
		slotNumber: String;

		constructor();
		constructor(inherited?: boolean, key?: String, agentName?: String, slotNumber?: String, parameters?: VcDvsFilterParameter, onFailure?: String, operation?: String);
	}

	interface VcDvsFilterOnFailure
	{
		readonly failClosed: VcDvsFilterOnFailure;
		readonly failOpen: VcDvsFilterOnFailure;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcDvsFilterOnFailure): VcDvsFilterOnFailure;
	}

	declare const VcDvsFilterOnFailure: VcDvsFilterOnFailure;

	declare class VcDvsFilterParameter
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parameters: String[];

		constructor();
		constructor(parameters?: String[]);
	}

	declare class VcDvsFilterPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filterConfig: VcDvsFilterConfig[];
		inherited: boolean;

		constructor();
		constructor(inherited?: boolean, filterConfig?: VcDvsFilterConfig[]);
	}

	declare class VcDvsGreEncapNetworkRuleAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encapsulationIp: VcSingleIp;

		constructor();
		constructor(encapsulationIp?: VcSingleIp);
	}

	declare class VcDVSHealthCheckCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDVSHealthCheckConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enable: boolean;
		interval: Number;

		constructor();
		constructor(enable?: boolean, interval?: Number);
		isEnable(): boolean;
	}

	declare class VcDvsHealthStatusChangeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String, healthResult?: VcHostMemberHealthCheckResult);
	}

	declare class VcDvsHostBackInSyncEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostBackInSync: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostBackInSync?: VcHostEventArgument);
	}

	declare class VcDvsHostInfrastructureTrafficResource
	{
		allocationInfo: VcDvsHostInfrastructureTrafficResourceAllocation;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;

		constructor();
		constructor(key?: String, description?: String, allocationInfo?: VcDvsHostInfrastructureTrafficResourceAllocation);
	}

	declare class VcDvsHostInfrastructureTrafficResourceAllocation
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		limit: Number;
		reservation: Number;
		shares: VcSharesInfo;

		constructor();
		constructor(limit?: Number, shares?: VcSharesInfo, reservation?: Number);
	}

	declare class VcDvsHostJoinedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostJoined: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostJoined?: VcHostEventArgument);
	}

	declare class VcDvsHostLeftEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostLeft: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostLeft?: VcHostEventArgument);
	}

	declare class VcDVSHostLocalPortInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		portKey: String;
		setting: VcDVPortSetting;
		switchUuid: String;
		vnic: String;

		constructor();
		constructor(switchUuid?: String, portKey?: String, setting?: VcDVPortSetting, vnic?: String);
	}

	declare class VcDvsHostStatusUpdated
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostMember: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newStatus: String;
		newStatusDetail: String;
		oldStatus: String;
		oldStatusDetail: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostMember?: VcHostEventArgument, oldStatus?: String, newStatus?: String, oldStatusDetail?: String, newStatusDetail?: String);
	}

	declare class VcDvsHostVNicProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		ipConfig: VcIpAddressProfile;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String, ipConfig?: VcIpAddressProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcDvsHostWentOutOfSyncEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostOutOfSync: VcDvsOutOfSyncHostArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostOutOfSync?: VcDvsOutOfSyncHostArgument);
	}

	declare class VcDvsImportEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		importType: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, importType?: String);
	}

	declare class VcDVSInheritedOpaqueData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		key: String;

		constructor();
	}

	declare class VcDvsIpNetworkRuleQualifier
	{
		destinationAddress: VcIpAddress;
		destinationIpPort: VcDvsIpPort;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		protocol: VcIntExpression;
		sourceAddress: VcIpAddress;
		sourceIpPort: VcDvsIpPort;
		tcpFlags: VcIntExpression;

		constructor();
		constructor(key?: String, sourceAddress?: VcIpAddress, destinationAddress?: VcIpAddress, protocol?: VcIntExpression, sourceIpPort?: VcDvsIpPort, destinationIpPort?: VcDvsIpPort, tcpFlags?: VcIntExpression);
	}

	declare class VcDvsIpPort
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;

		constructor();
		constructor(negate?: boolean);
		isNegate(): boolean;
	}

	declare class VcDvsIpPortContainer
	{
		containerId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;

		constructor();
		constructor(negate?: boolean, containerId?: String);
		isNegate(): boolean;
	}

	declare class VcDvsIpPortRange
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endPortNumber: Number;
		negate: boolean;
		startPortNumber: Number;

		constructor();
		constructor(negate?: boolean, startPortNumber?: Number, endPortNumber?: Number);
		isNegate(): boolean;
	}

	declare class VcDVSKeyedOpaqueData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		key: String;

		constructor();
	}

	declare class VcDVSKeyedOpaqueDataList
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyedOpaqueData: VcDVSKeyedOpaqueData[];

		constructor();
		constructor(keyedOpaqueData?: VcDVSKeyedOpaqueData[]);
	}

	declare class VcDvsLogNetworkRuleAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDvsMacNetworkRuleQualifier
	{
		destinationAddress: VcMacAddress;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		protocol: VcIntExpression;
		sourceAddress: VcMacAddress;
		vlanId: VcIntExpression;

		constructor();
		constructor(key?: String, sourceAddress?: VcMacAddress, destinationAddress?: VcMacAddress, protocol?: VcIntExpression, vlanId?: VcIntExpression);
	}

	declare class VcDvsMacRewriteNetworkRuleAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		rewriteMac: String;

		constructor();
		constructor(rewriteMac?: String);
	}

	declare class VcDVSManagerDvpgUplinkTeam
	{
		dvpgKey: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		uplink: String[];

		constructor();
		constructor(dvpgKey?: String, uplink?: String[]);
	}

	declare class VcDVSManagerDvsConfigTarget
	{
		distributedVirtualPortgroup: VcDistributedVirtualPortgroupInfo[];
		distributedVirtualSwitch: VcDistributedVirtualSwitchInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(distributedVirtualPortgroup?: VcDistributedVirtualPortgroupInfo[], distributedVirtualSwitch?: VcDistributedVirtualSwitchInfo[]);
	}

	declare class VcDvsMergedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destinationDvs: VcDvsEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDvs: VcDvsEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, sourceDvs?: VcDvsEventArgument, destinationDvs?: VcDvsEventArgument);
	}

	declare class VcDVSNameArrayUplinkPortPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		uplinkPortName: String[];

		constructor();
		constructor(uplinkPortName?: String[]);
	}

	declare class VcDVSNetworkResourceManagementCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		networkResourceControlVersion3Supported: boolean;
		networkResourceManagementSupported: boolean;
		networkResourcePoolHighShareValue: Number;
		qosSupported: boolean;
		userDefinedNetworkResourcePoolsSupported: boolean;

		constructor();
		constructor(networkResourceManagementSupported?: boolean, networkResourcePoolHighShareValue?: Number, qosSupported?: boolean, userDefinedNetworkResourcePoolsSupported?: boolean, networkResourceControlVersion3Supported?: boolean);
		isNetworkResourceControlVersion3Supported(): boolean;
	}

	declare class VcDVSNetworkResourcePool
	{
		allocationInfo: VcDVSNetworkResourcePoolAllocationInfo;
		configVersion: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		name: String;

		constructor();
		constructor(key?: String, name?: String, description?: String, configVersion?: String, allocationInfo?: VcDVSNetworkResourcePoolAllocationInfo);
	}

	declare class VcDVSNetworkResourcePoolAllocationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		limit: Number;
		priorityTag: Number;
		shares: VcSharesInfo;

		constructor();
		constructor(limit?: Number, shares?: VcSharesInfo, priorityTag?: Number);
	}

	declare class VcDVSNetworkResourcePoolConfigSpec
	{
		allocationInfo: VcDVSNetworkResourcePoolAllocationInfo;
		configVersion: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		name: String;

		constructor();
		constructor(key?: String, configVersion?: String, allocationInfo?: VcDVSNetworkResourcePoolAllocationInfo, name?: String, description?: String);
	}

	declare class VcDvsNetworkRuleAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcDvsNetworkRuleDirectionType
	{
		readonly both: VcDvsNetworkRuleDirectionType;
		readonly id: String;
		readonly incomingPackets: VcDvsNetworkRuleDirectionType;
		readonly name: String;
		readonly outgoingPackets: VcDvsNetworkRuleDirectionType;
		readonly value: String;

		fromString(value?: VcDvsNetworkRuleDirectionType): VcDvsNetworkRuleDirectionType;
	}

	declare const VcDvsNetworkRuleDirectionType: VcDvsNetworkRuleDirectionType;

	declare class VcDvsNetworkRuleQualifier
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;

		constructor(key?: String);
		constructor();
	}

	declare class VcDvsNotAuthorized
	{
		dvsExtensionKey: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		sessionExtensionKey: String;

		constructor();
		constructor(sessionExtensionKey?: String, dvsExtensionKey?: String);
		printStackTrace(): void;
	}

	declare class VcDVSOpaqueCommandData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDVSOpaqueCommandReqSpec
	{
		arguments: VcDVSOpaqueCommandData;
		command: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(command?: String, arguments?: VcDVSOpaqueCommandData);
	}

	declare class VcDVSOpaqueCommandResultInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		opaqueResult: VcDVSOpaqueCommandData;
		selection: VcSelectionSet;

		constructor();
		constructor(selection?: VcSelectionSet, host?: VcHostSystem, opaqueResult?: VcDVSOpaqueCommandData);
	}

	declare class VcDVSOpaqueConfigInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		opaqueData: VcDVSOpaqueData[];
		selection: VcSelectionSet;

		constructor();
		constructor(selection?: VcSelectionSet, opaqueData?: VcDVSOpaqueData[]);
	}

	declare class VcDVSOpaqueConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		opaqueData: VcDVSOpaqueData;
		operation: String;

		constructor();
		constructor(operation?: String, opaqueData?: VcDVSOpaqueData);
	}

	declare class VcDVSOpaqueData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;

		constructor();
	}

	declare class VcDVSOpaqueDataConfigInfo
	{
		dvsUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		keyedOpaqueData: VcDVSKeyedOpaqueData[];
		portgroupKey: String;
		portKey: String;

		constructor();
		constructor(dvsUuid?: String, portKey?: String, portgroupKey?: String, host?: VcHostSystem, keyedOpaqueData?: VcDVSKeyedOpaqueData[]);
	}

	declare class VcDVSOpaqueDataConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyedOpaqueData: VcDVSKeyedOpaqueData;
		operation: String;

		constructor();
		constructor(operation?: String, keyedOpaqueData?: VcDVSKeyedOpaqueData);
	}

	declare class VcDVSOpaqueDataList
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		opaqueData: VcDVSOpaqueData[];

		constructor();
		constructor(opaqueData?: VcDVSOpaqueData[]);
	}

	declare class VcDvsOperationBulkFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostFault: VcDvsOperationBulkFaultFaultOnHost[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostFault?: VcDvsOperationBulkFaultFaultOnHost[]);
		printStackTrace(): void;
	}

	declare class VcDvsOperationBulkFaultFaultOnHost
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		host: VcHostSystem;

		constructor();
		constructor(host?: VcHostSystem, fault?: VcLocalizedMethodFault);
	}

	declare class VcDvsOutOfSyncHostArgument
	{
		configParamters: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		outOfSyncHost: VcHostEventArgument;

		constructor();
		constructor(outOfSyncHost?: VcHostEventArgument, configParamters?: String[]);
	}

	declare class VcDVSPolicy
	{
		autoPreInstallAllowed: boolean;
		autoUpgradeAllowed: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		partialUpgradeAllowed: boolean;

		constructor();
		constructor(autoPreInstallAllowed?: boolean, autoUpgradeAllowed?: boolean, partialUpgradeAllowed?: boolean);
		isAutoPreInstallAllowed(): boolean;
		isAutoUpgradeAllowed(): boolean;
		isPartialUpgradeAllowed(): boolean;
	}

	declare class VcDvsPortBlockedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		prevBlockState: String;
		runtimeInfo: VcDVPortStatus;
		statusDetail: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, statusDetail?: String, runtimeInfo?: VcDVPortStatus, prevBlockState?: String);
	}

	declare class VcDvsPortConnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		connectee: VcDistributedVirtualSwitchPortConnectee;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, connectee?: VcDistributedVirtualSwitchPortConnectee);
	}

	declare class VcDvsPortCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String[]);
	}

	declare class VcDvsPortDeletedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String[]);
	}

	declare class VcDvsPortDisconnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		connectee: VcDistributedVirtualSwitchPortConnectee;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, connectee?: VcDistributedVirtualSwitchPortConnectee);
	}

	declare class VcDvsPortEnteredPassthruEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, runtimeInfo?: VcDVPortStatus);
	}

	declare class VcDvsPortExitedPassthruEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, runtimeInfo?: VcDVPortStatus);
	}

	declare class VcDvsPortJoinPortgroupEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portgroupKey: String;
		portgroupName: String;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, portgroupKey?: String, portgroupName?: String);
	}

	declare class VcDvsPortLeavePortgroupEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portgroupKey: String;
		portgroupName: String;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, portgroupKey?: String, portgroupName?: String);
	}

	declare class VcDvsPortLinkDownEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, runtimeInfo?: VcDVPortStatus);
	}

	declare class VcDvsPortLinkUpEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, runtimeInfo?: VcDVPortStatus);
	}

	declare class VcDvsPortReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configChanges: VcChangesInfoEventArgument[];
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String[], configChanges?: VcChangesInfoEventArgument[]);
	}

	declare class VcDvsPortRuntimeChangeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, runtimeInfo?: VcDVPortStatus);
	}

	declare class VcDvsPortUnblockedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		prevBlockState: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String, runtimeInfo?: VcDVPortStatus, prevBlockState?: String);
	}

	declare class VcDvsPortVendorSpecificStateChangeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, portKey?: String);
	}

	declare class VcDvsProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		name: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;
		uplink: VcPnicUplinkProfile[];

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String, name?: String, uplink?: VcPnicUplinkProfile[]);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcDvsPuntNetworkRuleAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDvsRateLimitNetworkRuleAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		packetsPerSecond: Number;

		constructor();
		constructor(packetsPerSecond?: Number);
	}

	declare class VcDvsReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configChanges: VcChangesInfoEventArgument;
		configSpec: VcDVSConfigSpec;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, configSpec?: VcDVSConfigSpec, configChanges?: VcChangesInfoEventArgument);
	}

	declare class VcDvsRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, oldName?: String, newName?: String);
	}

	declare class VcDvsResourceRuntimeInfo
	{
		allocatedResource: VcDvsVnicAllocatedResource[];
		available: Number;
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		usage: Number;
		vmVnicNetworkResourcePoolRuntime: VcDvsVmVnicNetworkResourcePoolRuntimeInfo[];

		constructor();
		constructor(capacity?: Number, usage?: Number, available?: Number, allocatedResource?: VcDvsVnicAllocatedResource[], vmVnicNetworkResourcePoolRuntime?: VcDvsVmVnicNetworkResourcePoolRuntimeInfo[]);
	}

	declare class VcDvsRestoreEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcDVSRollbackCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		rollbackSupported: boolean;

		constructor();
		constructor(rollbackSupported?: boolean);
	}

	declare class VcDVSRuntimeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostMemberRuntime: VcHostMemberRuntimeInfo[];
		resourceRuntimeInfo: VcDvsResourceRuntimeInfo;

		constructor();
		constructor(hostMemberRuntime?: VcHostMemberRuntimeInfo[], resourceRuntimeInfo?: VcDvsResourceRuntimeInfo);
	}

	declare class VcDvsScopeViolated
	{
		entity: VcManagedEntity;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		scope: VcManagedEntity[];

		constructor();
		constructor(scope?: VcManagedEntity[], entity?: VcManagedEntity);
		printStackTrace(): void;
	}

	declare class VcDVSSecurityPolicy
	{
		allowPromiscuous: VcBoolPolicy;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		forgedTransmits: VcBoolPolicy;
		inherited: boolean;
		macChanges: VcBoolPolicy;

		constructor();
		constructor(inherited?: boolean, allowPromiscuous?: VcBoolPolicy, macChanges?: VcBoolPolicy, forgedTransmits?: VcBoolPolicy);
	}

	declare class VcDVSSelection
	{
		dvsUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(dvsUuid?: String);
	}

	declare class VcDvsServiceConsoleVNicProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		ipConfig: VcIpAddressProfile;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String, ipConfig?: VcIpAddressProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcDvsSingleIpPort
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;
		portNumber: Number;

		constructor();
		constructor(negate?: boolean, portNumber?: Number);
		isNegate(): boolean;
	}

	declare class VcDVSSummary
	{
		contact: VcDVSContactInfo;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem[];
		hostMember: VcHostSystem[];
		name: String;
		numHosts: Number;
		numPorts: Number;
		portgroupName: String[];
		productInfo: VcDistributedVirtualSwitchProductSpec;
		uuid: String;
		vm: VcVirtualMachine[];

		constructor();
		constructor(name?: String, uuid?: String, numPorts?: Number, productInfo?: VcDistributedVirtualSwitchProductSpec, hostMember?: VcHostSystem[], vm?: VcVirtualMachine[], host?: VcHostSystem[], portgroupName?: String[], description?: String, contact?: VcDVSContactInfo, numHosts?: Number);
	}

	declare class VcDvsSystemTrafficNetworkRuleQualifier
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		typeOfSystemTraffic: VcStringExpression;

		constructor();
		constructor(key?: String, typeOfSystemTraffic?: VcStringExpression);
	}

	declare class VcDvsTrafficFilterConfig
	{
		agentName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		key: String;
		onFailure: String;
		parameters: VcDvsFilterParameter;
		slotNumber: String;
		trafficRuleset: VcDvsTrafficRuleset;

		constructor();
		constructor(inherited?: boolean, key?: String, agentName?: String, slotNumber?: String, parameters?: VcDvsFilterParameter, onFailure?: String, trafficRuleset?: VcDvsTrafficRuleset);
	}

	declare class VcDvsTrafficFilterConfigSpec
	{
		agentName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		key: String;
		onFailure: String;
		operation: String;
		parameters: VcDvsFilterParameter;
		slotNumber: String;
		trafficRuleset: VcDvsTrafficRuleset;

		constructor();
		constructor(inherited?: boolean, key?: String, agentName?: String, slotNumber?: String, parameters?: VcDvsFilterParameter, onFailure?: String, trafficRuleset?: VcDvsTrafficRuleset, operation?: String);
	}

	declare class VcDvsTrafficRule
	{
		action: VcDvsNetworkRuleAction;
		description: String;
		direction: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		qualifier: VcDvsNetworkRuleQualifier[];
		sequence: Number;

		constructor();
		constructor(key?: String, description?: String, sequence?: Number, qualifier?: VcDvsNetworkRuleQualifier[], action?: VcDvsNetworkRuleAction, direction?: String);
	}

	declare class VcDvsTrafficRuleset
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		key: String;
		precedence: Number;
		rules: VcDvsTrafficRule[];

		constructor();
		constructor(key?: String, enabled?: boolean, precedence?: Number, rules?: VcDvsTrafficRule[]);
		isEnabled(): boolean;
	}

	declare class VcDVSTrafficShapingPolicy
	{
		averageBandwidth: VcLongPolicy;
		burstSize: VcLongPolicy;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: VcBoolPolicy;
		inherited: boolean;
		peakBandwidth: VcLongPolicy;

		constructor();
		constructor(inherited?: boolean, enabled?: VcBoolPolicy, averageBandwidth?: VcLongPolicy, peakBandwidth?: VcLongPolicy, burstSize?: VcLongPolicy);
	}

	declare class VcDvsUpdateTagNetworkRuleAction
	{
		dscpTag: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		qosTag: Number;

		constructor();
		constructor(qosTag?: Number, dscpTag?: Number);
	}

	declare class VcDvsUpgradeAvailableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, productInfo?: VcDistributedVirtualSwitchProductSpec);
	}

	declare class VcDvsUpgradedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, productInfo?: VcDistributedVirtualSwitchProductSpec);
	}

	declare class VcDvsUpgradeInProgressEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, productInfo?: VcDistributedVirtualSwitchProductSpec);
	}

	declare class VcDvsUpgradeRejectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, productInfo?: VcDistributedVirtualSwitchProductSpec);
	}

	declare class VcDVSUplinkPortPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDVSVendorSpecificConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		keyValue: VcDistributedVirtualSwitchKeyedOpaqueBlob[];

		constructor();
		constructor(inherited?: boolean, keyValue?: VcDistributedVirtualSwitchKeyedOpaqueBlob[]);
	}

	declare class VcDVSVmVnicNetworkResourcePool
	{
		allocationInfo: VcDvsVmVnicResourceAllocation;
		configVersion: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		name: String;

		constructor();
		constructor(key?: String, name?: String, description?: String, configVersion?: String, allocationInfo?: VcDvsVmVnicResourceAllocation);
	}

	declare class VcDvsVmVnicNetworkResourcePoolRuntimeInfo
	{
		allocatedResource: VcDvsVnicAllocatedResource[];
		available: Number;
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		name: String;
		status: String;
		usage: Number;

		constructor();
		constructor(key?: String, name?: String, capacity?: Number, usage?: Number, available?: Number, status?: String, allocatedResource?: VcDvsVnicAllocatedResource[]);
	}

	declare class VcDvsVmVnicResourceAllocation
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reservationQuota: Number;

		constructor();
		constructor(reservationQuota?: Number);
	}

	declare class VcDvsVmVnicResourcePoolConfigSpec
	{
		allocationInfo: VcDvsVmVnicResourceAllocation;
		configVersion: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		name: String;
		operation: String;

		constructor();
		constructor(operation?: String, key?: String, configVersion?: String, allocationInfo?: VcDvsVmVnicResourceAllocation, name?: String, description?: String);
	}

	declare class VcDvsVnicAllocatedResource
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reservation: Number;
		vm: VcVirtualMachine;
		vnicKey: String;

		constructor();
		constructor(vm?: VcVirtualMachine, vnicKey?: String, reservation?: Number);
	}

	declare class VcDvsVNicProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		ipConfig: VcIpAddressProfile;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String, ipConfig?: VcIpAddressProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	interface VcDynamicArray
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		val: Object[];

	}

	declare const VcDynamicArray: VcDynamicArray;

	interface VcDynamicData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

	}

	declare const VcDynamicData: VcDynamicData;

	interface VcDynamicProperty
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		val_AnyValue: Object;
		val_FloatValue: Number;
		val_IntValue: Number;
		val_LongValue: Number;

	}

	declare const VcDynamicProperty: VcDynamicProperty;

	declare class VcDynamicTypeEnumTypeInfo
	{
		annotation: VcDynamicTypeMgrAnnotation[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		value: String[];
		version: String;
		wsdlName: String;

		constructor();
		constructor(name?: String, wsdlName?: String, version?: String, value?: String[], annotation?: VcDynamicTypeMgrAnnotation[]);
	}

	declare class VcDynamicTypeMgrAllTypeInfo
	{
		dataTypeInfo: VcDynamicTypeMgrDataTypeInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enumTypeInfo: VcDynamicTypeEnumTypeInfo[];
		managedTypeInfo: VcDynamicTypeMgrManagedTypeInfo[];

		constructor();
		constructor(managedTypeInfo?: VcDynamicTypeMgrManagedTypeInfo[], enumTypeInfo?: VcDynamicTypeEnumTypeInfo[], dataTypeInfo?: VcDynamicTypeMgrDataTypeInfo[]);
	}

	declare class VcDynamicTypeMgrAnnotation
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		parameter: String[];

		constructor();
		constructor(name?: String, parameter?: String[]);
	}

	declare class VcDynamicTypeMgrDataTypeInfo
	{
		annotation: VcDynamicTypeMgrAnnotation[];
		base: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		property: VcDynamicTypeMgrPropertyTypeInfo[];
		version: String;
		wsdlName: String;

		constructor();
		constructor(name?: String, wsdlName?: String, version?: String, base?: String[], property?: VcDynamicTypeMgrPropertyTypeInfo[], annotation?: VcDynamicTypeMgrAnnotation[]);
	}

	declare class VcDynamicTypeMgrFilterSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcDynamicTypeMgrManagedTypeInfo
	{
		annotation: VcDynamicTypeMgrAnnotation[];
		base: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		method: VcDynamicTypeMgrMethodTypeInfo[];
		name: String;
		property: VcDynamicTypeMgrPropertyTypeInfo[];
		version: String;
		wsdlName: String;

		constructor();
		constructor(name?: String, wsdlName?: String, version?: String, base?: String[], property?: VcDynamicTypeMgrPropertyTypeInfo[], method?: VcDynamicTypeMgrMethodTypeInfo[], annotation?: VcDynamicTypeMgrAnnotation[]);
	}

	declare class VcDynamicTypeMgrMethodTypeInfo
	{
		annotation: VcDynamicTypeMgrAnnotation[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: String[];
		name: String;
		paramTypeInfo: VcDynamicTypeMgrParamTypeInfo[];
		privId: String;
		returnTypeInfo: VcDynamicTypeMgrParamTypeInfo;
		version: String;
		wsdlName: String;

		constructor();
		constructor(name?: String, wsdlName?: String, version?: String, paramTypeInfo?: VcDynamicTypeMgrParamTypeInfo[], returnTypeInfo?: VcDynamicTypeMgrParamTypeInfo, fault?: String[], privId?: String, annotation?: VcDynamicTypeMgrAnnotation[]);
	}

	interface VcDynamicTypeMgrMethodTypeInfoAnnotationType
	{
		readonly id: String;
		readonly internal: VcDynamicTypeMgrMethodTypeInfoAnnotationType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcDynamicTypeMgrMethodTypeInfoAnnotationType): VcDynamicTypeMgrMethodTypeInfoAnnotationType;
	}

	declare const VcDynamicTypeMgrMethodTypeInfoAnnotationType: VcDynamicTypeMgrMethodTypeInfoAnnotationType;

	declare class VcDynamicTypeMgrMoFilterSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		typeSubstr: String;

		constructor();
		constructor(id?: String, typeSubstr?: String);
	}

	declare class VcDynamicTypeMgrMoInstance
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		moType: String;

		constructor();
		constructor(id?: String, moType?: String);
	}

	declare class VcDynamicTypeMgrParamTypeInfo
	{
		annotation: VcDynamicTypeMgrAnnotation[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		privId: String;
		type: String;
		version: String;

		constructor();
		constructor(name?: String, version?: String, type?: String, privId?: String, annotation?: VcDynamicTypeMgrAnnotation[]);
	}

	interface VcDynamicTypeMgrParamTypeInfoAnnotationType
	{
		readonly id: String;
		readonly name: String;
		readonly optional: VcDynamicTypeMgrParamTypeInfoAnnotationType;
		readonly secret: VcDynamicTypeMgrParamTypeInfoAnnotationType;
		readonly value: String;

		fromString(value?: VcDynamicTypeMgrParamTypeInfoAnnotationType): VcDynamicTypeMgrParamTypeInfoAnnotationType;
	}

	declare const VcDynamicTypeMgrParamTypeInfoAnnotationType: VcDynamicTypeMgrParamTypeInfoAnnotationType;

	declare class VcDynamicTypeMgrPropertyTypeInfo
	{
		annotation: VcDynamicTypeMgrAnnotation[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		msgIdFormat: String;
		name: String;
		privId: String;
		type: String;
		version: String;

		constructor();
		constructor(name?: String, version?: String, type?: String, privId?: String, msgIdFormat?: String, annotation?: VcDynamicTypeMgrAnnotation[]);
	}

	interface VcDynamicTypeMgrPropertyTypeInfoAnnotationType
	{
		readonly id: String;
		readonly link: VcDynamicTypeMgrPropertyTypeInfoAnnotationType;
		readonly linkable: VcDynamicTypeMgrPropertyTypeInfoAnnotationType;
		readonly name: String;
		readonly optional: VcDynamicTypeMgrPropertyTypeInfoAnnotationType;
		readonly readonly: VcDynamicTypeMgrPropertyTypeInfoAnnotationType;
		readonly value: String;

		fromString(value?: VcDynamicTypeMgrPropertyTypeInfoAnnotationType): VcDynamicTypeMgrPropertyTypeInfoAnnotationType;
	}

	declare const VcDynamicTypeMgrPropertyTypeInfoAnnotationType: VcDynamicTypeMgrPropertyTypeInfoAnnotationType;

	declare class VcDynamicTypeMgrTypeFilterSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		typeSubstr: String;

		constructor();
		constructor(typeSubstr?: String);
	}

	declare class VcEightHostLimitViolated
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcElementDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		label: String;
		summary: String;

		constructor(label?: String, summary?: String, key?: String);
		constructor();
	}

	declare class VcEnteredMaintenanceModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcEnteredStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcEnteringMaintenanceModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcEnteringStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcEntityAndComplianceStatus
	{
		complianceStatus: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;

		constructor();
		constructor(entity?: VcManagedEntity, complianceStatus?: String);
	}

	declare class VcEntityBackup
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcEntityBackupConfig
	{
		configVersion: String;
		container: VcManagedEntity;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityType: String;
		key: String;
		name: String;

		constructor();
	}

	declare class VcEntityDisabledMethodInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		methodList: VcDisabledMethodInfo[];

		constructor();
		constructor(entity?: VcManagedEntity, methodList?: VcDisabledMethodInfo[]);
	}

	declare class VcEntityEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String);
	}

	interface VcEntityImportType
	{
		readonly applyToEntitySpecified: VcEntityImportType;
		readonly createEntityWithNewIdentifier: VcEntityImportType;
		readonly createEntityWithOriginalIdentifier: VcEntityImportType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcEntityImportType): VcEntityImportType;
	}

	declare const VcEntityImportType: VcEntityImportType;

	declare class VcEntityPrivilege
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		privAvailability: VcPrivilegeAvailability[];

		constructor();
		constructor(entity?: VcManagedEntity, privAvailability?: VcPrivilegeAvailability[]);
	}

	interface VcEntityType
	{
		readonly distributedVirtualPortgroup: VcEntityType;
		readonly distributedVirtualSwitch: VcEntityType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcEntityType): VcEntityType;
	}

	declare const VcEntityType: VcEntityType;

	declare class VcEnumDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		tags: VcElementDescription[];

		constructor();
		constructor(key?: String, tags?: VcElementDescription[]);
	}

	interface VcEnvironmentBrowser
	{
		datastoreBrowser: VcHostDatastoreBrowser;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryConfigOption(arg0?: String, arg1?: VcHostSystem): VcVirtualMachineConfigOption;
		queryConfigOptionDescriptor(): VcVirtualMachineConfigOptionDescriptor[];
		queryConfigOptionEx(arg0?: VcEnvironmentBrowserConfigOptionQuerySpec): VcVirtualMachineConfigOption;
		queryConfigTarget(arg0?: VcHostSystem): VcConfigTarget;
		queryConfigTargetSpec(arg0?: VcHostSystem, arg1?: VcEnvironmentBrowserConfigTargetQuerySpec): VcConfigTarget;
		queryProvisioningPolicy(arg0?: VcHostSystem): VcVirtualMachineProvisioningPolicy;
		queryTargetCapabilities(arg0?: VcHostSystem): VcHostCapability;
	}

	declare const VcEnvironmentBrowser: VcEnvironmentBrowser;

	declare class VcEnvironmentBrowserConfigOptionQuerySpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		guestId: String[];
		host: VcHostSystem;
		key: String;

		constructor();
		constructor(key?: String, host?: VcHostSystem, guestId?: String[]);
	}

	declare class VcEnvironmentBrowserConfigTargetQuerySpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		includeDatastores: boolean;
		includeDevices: boolean;
		includeDisks: boolean;
		includeNetworks: boolean;
		vmSpecific: boolean;

		constructor();
		constructor(includeDatastores?: boolean, includeNetworks?: boolean, includeDevices?: boolean, includeDisks?: boolean, vmSpecific?: boolean);
		isIncludeDatastores(): boolean;
		isIncludeDevices(): boolean;
		isIncludeDisks(): boolean;
		isIncludeNetworks(): boolean;
		isVmSpecific(): boolean;
	}

	declare class VcErrorUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	interface VcEsxAgentConfigManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryAgentVmInfo(arg0?: VcVirtualMachine[]): VcEsxAgentConfigManagerAgentVmInfo[];
		queryComputeResourceAgentInfo(arg0?: VcComputeResource[]): VcEsxAgentConfigManagerComputeResourceAgentInfo[];
		updateAgentVmInfo(arg0?: VcEsxAgentConfigManagerAgentVmInfo[]): void;
		updateComputeResourceAgentInfo(arg0?: VcEsxAgentConfigManagerComputeResourceAgentInfo[]): void;
	}

	declare const VcEsxAgentConfigManager: VcEsxAgentConfigManager;

	declare class VcEsxAgentConfigManagerAgentVmInfo
	{
		agentVm: VcVirtualMachine;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		state: String;

		constructor();
		constructor(agentVm?: VcVirtualMachine, state?: String);
	}

	interface VcEsxAgentConfigManagerAgentVmState
	{
		readonly disabled: VcEsxAgentConfigManagerAgentVmState;
		readonly enabled: VcEsxAgentConfigManagerAgentVmState;
		readonly id: String;
		readonly manuallyEnabled: VcEsxAgentConfigManagerAgentVmState;
		readonly name: String;
		readonly unavailable: VcEsxAgentConfigManagerAgentVmState;
		readonly value: String;

		fromString(value?: VcEsxAgentConfigManagerAgentVmState): VcEsxAgentConfigManagerAgentVmState;
	}

	declare const VcEsxAgentConfigManagerAgentVmState: VcEsxAgentConfigManagerAgentVmState;

	declare class VcEsxAgentConfigManagerComputeResourceAgentInfo
	{
		computeResource: VcComputeResource;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		numRequiredAgents: Number;

		constructor();
		constructor(computeResource?: VcComputeResource, numRequiredAgents?: Number);
	}

	declare class VcEvaluationLicenseSource
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		remainingHours: Number;

		constructor();
		constructor(remainingHours?: Number);
	}

	declare class VcEVCAdmissionFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, faults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcEVCAdmissionFailedCPUFeaturesForMode
	{
		currentEVCModeKey: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, faults?: VcLocalizedMethodFault[], currentEVCModeKey?: String);
		printStackTrace(): void;
	}

	declare class VcEVCAdmissionFailedCPUModel
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, faults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcEVCAdmissionFailedCPUModelForMode
	{
		currentEVCModeKey: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, faults?: VcLocalizedMethodFault[], currentEVCModeKey?: String);
		printStackTrace(): void;
	}

	declare class VcEVCAdmissionFailedCPUVendor
	{
		clusterCPUVendor: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		hostCPUVendor: String;
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, faults?: VcLocalizedMethodFault[], clusterCPUVendor?: String, hostCPUVendor?: String);
		printStackTrace(): void;
	}

	declare class VcEVCAdmissionFailedCPUVendorUnknown
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, faults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcEVCAdmissionFailedHostDisconnected
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, faults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcEVCAdmissionFailedHostSoftware
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, faults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcEVCAdmissionFailedHostSoftwareForMode
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, faults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcEVCAdmissionFailedVmActive
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, faults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcEVCConfigFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(faults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcEVCMode
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		featureCapability: VcHostFeatureCapability[];
		featureMask: VcHostFeatureMask[];
		featureRequirement: VcVirtualMachineFeatureRequirement[];
		guaranteedCPUFeatures: VcHostCpuIdInfo[];
		key: String;
		label: String;
		summary: String;
		track: String[];
		vendor: String;
		vendorTier: Number;

		constructor();
		constructor(label?: String, summary?: String, key?: String, guaranteedCPUFeatures?: VcHostCpuIdInfo[], featureCapability?: VcHostFeatureCapability[], featureMask?: VcHostFeatureMask[], featureRequirement?: VcVirtualMachineFeatureRequirement[], vendor?: String, track?: String[], vendorTier?: Number);
	}

	declare class VcEVCModeIllegalByVendor
	{
		clusterCPUVendor: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;
		modeCPUVendor: String;

		constructor();
		constructor(faults?: VcLocalizedMethodFault[], clusterCPUVendor?: String, modeCPUVendor?: String);
		printStackTrace(): void;
	}

	declare class VcEVCModeUnsupportedByHosts
	{
		evcMode: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		host: VcHostSystem[];
		hostName: String[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(faults?: VcLocalizedMethodFault[], evcMode?: String, host?: VcHostSystem[], hostName?: String[]);
		printStackTrace(): void;
	}

	declare class VcEVCUnsupportedByHostHardware
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		host: VcHostSystem[];
		hostName: String[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(faults?: VcLocalizedMethodFault[], host?: VcHostSystem[], hostName?: String[]);
		printStackTrace(): void;
	}

	declare class VcEVCUnsupportedByHostSoftware
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		host: VcHostSystem[];
		hostName: String[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(faults?: VcLocalizedMethodFault[], host?: VcHostSystem[], hostName?: String[]);
		printStackTrace(): void;
	}

	declare class VcEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcEventAlarmExpression
	{
		comparisons: VcEventAlarmExpressionComparison[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eventType: String;
		eventTypeId: String;
		objectType: String;
		status: VcManagedEntityStatus;

		constructor();
		constructor(comparisons?: VcEventAlarmExpressionComparison[], eventType?: String, eventTypeId?: String, objectType?: String, status?: VcManagedEntityStatus);
	}

	declare class VcEventAlarmExpressionComparison
	{
		attributeName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operator: String;
		value: String;

		constructor();
		constructor(attributeName?: String, operator?: String, value?: String);
	}

	interface VcEventAlarmExpressionComparisonOperator
	{
		readonly doesNotEndWith: VcEventAlarmExpressionComparisonOperator;
		readonly doesNotStartWith: VcEventAlarmExpressionComparisonOperator;
		readonly endsWith: VcEventAlarmExpressionComparisonOperator;
		readonly equals: VcEventAlarmExpressionComparisonOperator;
		readonly id: String;
		readonly name: String;
		readonly notEqualTo: VcEventAlarmExpressionComparisonOperator;
		readonly startsWith: VcEventAlarmExpressionComparisonOperator;
		readonly value: String;

		fromString(value?: VcEventAlarmExpressionComparisonOperator): VcEventAlarmExpressionComparisonOperator;
	}

	declare const VcEventAlarmExpressionComparisonOperator: VcEventAlarmExpressionComparisonOperator;

	declare class VcEventArgDesc
	{
		array: boolean;
		description: VcElementDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eventObject: boolean;
		name: String;
		type: String;

		constructor();
		constructor(name?: String, type?: String, array?: boolean, eventObject?: boolean, description?: VcElementDescription);
		isArray(): boolean;
		isEventObject(): boolean;
	}

	declare class VcEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcEventCategory
	{
		readonly error: VcEventCategory;
		readonly id: String;
		readonly info: VcEventCategory;
		readonly name: String;
		readonly user: VcEventCategory;
		readonly value: String;
		readonly warning: VcEventCategory;

		fromString(value?: VcEventCategory): VcEventCategory;
	}

	declare const VcEventCategory: VcEventCategory;

	declare class VcEventDescription
	{
		category: VcElementDescription[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enumeratedTypes: VcEnumDescription[];
		eventInfo: VcEventDescriptionEventDetail[];

		constructor();
		constructor(category?: VcElementDescription[], eventInfo?: VcEventDescriptionEventDetail[], enumeratedTypes?: VcEnumDescription[]);
	}

	declare class VcEventDescriptionEventDetail
	{
		category: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		formatOnComputeResource: String;
		formatOnDatacenter: String;
		formatOnHost: String;
		formatOnVm: String;
		fullFormat: String;
		key: String;
		longDescription: String;

		constructor();
		constructor(key?: String, description?: String, category?: String, formatOnDatacenter?: String, formatOnComputeResource?: String, formatOnHost?: String, formatOnVm?: String, fullFormat?: String, longDescription?: String);
	}

	interface VcEventEventSeverity
	{
		readonly error: VcEventEventSeverity;
		readonly id: String;
		readonly info: VcEventEventSeverity;
		readonly name: String;
		readonly user: VcEventEventSeverity;
		readonly value: String;
		readonly warning: VcEventEventSeverity;

		fromString(value?: VcEventEventSeverity): VcEventEventSeverity;
	}

	declare const VcEventEventSeverity: VcEventEventSeverity;

	declare class VcEventEx
	{
		arguments: VcKeyAnyValue[];
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eventTypeId: String;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		objectId: String;
		objectName: String;
		objectType: String;
		severity: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, eventTypeId?: String, severity?: String, message?: String, arguments?: VcKeyAnyValue[], objectId?: String, objectType?: String, objectName?: String, fault?: VcLocalizedMethodFault);
	}

	declare class VcEventFilterSpec
	{
		alarm: VcAlarm;
		category: String[];
		disableFullMessage: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcEventFilterSpecByEntity;
		eventChainId: Number;
		eventTypeId: String[];
		maxCount: Number;
		order: String;
		scheduledTask: VcScheduledTask;
		tag: String[];
		time: VcEventFilterSpecByTime;
		type: String[];
		userName: VcEventFilterSpecByUsername;

		constructor();
		constructor(entity?: VcEventFilterSpecByEntity, time?: VcEventFilterSpecByTime, userName?: VcEventFilterSpecByUsername, eventChainId?: Number, alarm?: VcAlarm, scheduledTask?: VcScheduledTask, disableFullMessage?: boolean, category?: String[], type?: String[], tag?: String[], eventTypeId?: String[], maxCount?: Number, order?: String);
		isDisableFullMessage(): boolean;
	}

	declare class VcEventFilterSpecByEntity
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		recursion: VcEventFilterSpecRecursionOption;

		constructor();
		constructor(entity?: VcManagedEntity, recursion?: VcEventFilterSpecRecursionOption);
	}

	declare class VcEventFilterSpecByTime
	{
		beginTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endTime: Date;

		constructor();
		constructor(beginTime?: Date, endTime?: Date);
	}

	declare class VcEventFilterSpecByUsername
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		systemUser: boolean;
		userList: String[];

		constructor();
		constructor(systemUser?: boolean, userList?: String[]);
	}

	interface VcEventFilterSpecOrderBy
	{
		readonly createdTime: VcEventFilterSpecOrderBy;
		readonly eventId: VcEventFilterSpecOrderBy;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcEventFilterSpecOrderBy): VcEventFilterSpecOrderBy;
	}

	declare const VcEventFilterSpecOrderBy: VcEventFilterSpecOrderBy;

	interface VcEventFilterSpecRecursionOption
	{
		readonly all: VcEventFilterSpecRecursionOption;
		readonly children: VcEventFilterSpecRecursionOption;
		readonly id: String;
		readonly name: String;
		readonly self: VcEventFilterSpecRecursionOption;
		readonly value: String;

		fromString(value?: VcEventFilterSpecRecursionOption): VcEventFilterSpecRecursionOption;
	}

	declare const VcEventFilterSpecRecursionOption: VcEventFilterSpecRecursionOption;

	interface VcEventHistoryCollector
	{
		readonly filter_AnyValue: Object;
		readonly filter_FloatValue: Number;
		readonly filter_IntValue: Number;
		readonly filter_LongValue: Number;
		id: String;
		latestPage: VcEvent[];
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyCollector(): void;
		readNextEvents(arg0?: Number): VcEvent[];
		readPreviousEvents(arg0?: Number): VcEvent[];
		resetCollector(): void;
		rewindCollector(): void;
	}

	declare const VcEventHistoryCollector: VcEventHistoryCollector;

	interface VcEventManager
	{
		description: VcEventDescription;
		id: String;
		latestEvent: VcEvent;
		maxCollector: Number;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createCollectorForEvents(arg0?: VcEventFilterSpec): VcEventHistoryCollector;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		logUserEvent(arg0?: VcManagedEntity, arg1?: String): void;
		postEvent(arg0?: VcEvent, arg1?: VcTaskInfo): void;
		queryEvents(arg0?: VcEventFilterSpec): VcEvent[];
		queryEventsById(arg0?: Number[]): VcEvent[];
		queryLastEvent(arg0?: VcLastEventFilterSpec): VcEvent[];
		retrieveArgumentDescription(arg0?: String): VcEventArgDesc[];
	}

	declare const VcEventManager: VcEventManager;

	declare class VcExitedStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcExitingStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcExitMaintenanceModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcExitStandbyModeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcExpiredAddonLicense
	{
		count: Number;
		expirationDate: Date;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		feature: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(feature?: String, count?: Number, expirationDate?: Date);
		printStackTrace(): void;
	}

	declare class VcExpiredEditionLicense
	{
		count: Number;
		expirationDate: Date;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		feature: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(feature?: String, count?: Number, expirationDate?: Date);
		printStackTrace(): void;
	}

	declare class VcExpiredFeatureLicense
	{
		count: Number;
		expirationDate: Date;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		feature: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(feature?: String, count?: Number, expirationDate?: Date);
		printStackTrace(): void;
	}

	declare class VcExtendedDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		label: String;
		messageArg: VcKeyAnyValue[];
		messageCatalogKeyPrefix: String;
		summary: String;

		constructor();
		constructor(label?: String, summary?: String, messageCatalogKeyPrefix?: String, messageArg?: VcKeyAnyValue[]);
	}

	declare class VcExtendedElementDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		label: String;
		messageArg: VcKeyAnyValue[];
		messageCatalogKeyPrefix: String;
		summary: String;

		constructor();
		constructor(label?: String, summary?: String, key?: String, messageCatalogKeyPrefix?: String, messageArg?: VcKeyAnyValue[]);
	}

	declare class VcExtendedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		data: VcExtendedEventPair[];
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eventTypeId: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		managedObject: VcManagedObject;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String, eventTypeId?: String, managedObject?: VcManagedObject, data?: VcExtendedEventPair[]);
	}

	declare class VcExtendedEventPair
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		value: String;

		constructor();
		constructor(key?: String, value?: String);
	}

	declare class VcExtendedFault
	{
		data: VcKeyValue[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faultTypeId: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(faultTypeId?: String, data?: VcKeyValue[]);
		printStackTrace(): void;
	}

	interface VcExtensibleManagedObject
	{
		availableField: VcCustomFieldDef[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcExtensibleManagedObject: VcExtensibleManagedObject;

	declare class VcExtension
	{
		client: VcExtensionClientInfo[];
		company: String;
		description: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eventList: VcExtensionEventTypeInfo[];
		extendedProductInfo: VcExtExtendedProductInfo;
		faultList: VcExtensionFaultTypeInfo[];
		healthInfo: VcExtensionHealthInfo;
		key: String;
		lastHeartbeatTime: Date;
		managedEntityInfo: VcExtManagedEntityInfo[];
		ovfConsumerInfo: VcExtensionOvfConsumerInfo;
		privilegeList: VcExtensionPrivilegeInfo[];
		resourceList: VcExtensionResourceInfo[];
		server: VcExtensionServerInfo[];
		shownInSolutionManager: boolean;
		solutionManagerInfo: VcExtSolutionManagerInfo;
		subjectName: String;
		taskList: VcExtensionTaskTypeInfo[];
		type: String;
		version: String;

		constructor();
		constructor(description?: VcDescription, key?: String, company?: String, type?: String, version?: String, subjectName?: String, server?: VcExtensionServerInfo[], client?: VcExtensionClientInfo[], taskList?: VcExtensionTaskTypeInfo[], eventList?: VcExtensionEventTypeInfo[], faultList?: VcExtensionFaultTypeInfo[], privilegeList?: VcExtensionPrivilegeInfo[], resourceList?: VcExtensionResourceInfo[], lastHeartbeatTime?: Date, healthInfo?: VcExtensionHealthInfo, ovfConsumerInfo?: VcExtensionOvfConsumerInfo, extendedProductInfo?: VcExtExtendedProductInfo, managedEntityInfo?: VcExtManagedEntityInfo[], shownInSolutionManager?: boolean, solutionManagerInfo?: VcExtSolutionManagerInfo);
		isShownInSolutionManager(): boolean;
	}

	declare class VcExtensionClientInfo
	{
		company: String;
		description: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;
		url: String;
		version: String;

		constructor();
		constructor(version?: String, description?: VcDescription, company?: String, type?: String, url?: String);
	}

	declare class VcExtensionEventTypeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eventID: String;
		eventTypeSchema: String;

		constructor();
		constructor(eventID?: String, eventTypeSchema?: String);
	}

	declare class VcExtensionFaultTypeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		faultID: String;

		constructor();
		constructor(faultID?: String);
	}

	declare class VcExtensionHealthInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		url: String;

		constructor();
		constructor(url?: String);
	}

	interface VcExtensionManager
	{
		extensionList: VcExtension[];
		id: String;
		moref: VcManagedObjectReference;
		publicKey: String;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		clearExtensionData(arg0?: String[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		findExtension(arg0?: String): VcExtension;
		queryExtensionData(arg0?: String[]): VcKeyValue[];
		queryExtensionDataKeys(): String[];
		queryExtensionDataUsage(arg0?: String[]): VcExtensionManagerExtensionDataUsage[];
		queryExtensionIpAllocationUsage(arg0?: String[]): VcExtensionManagerIpAllocationUsage[];
		queryManagedBy(arg0?: String): VcManagedEntity[];
		registerExtension(arg0?: VcExtension): void;
		setExtensionCertificate(arg0?: String, arg1?: String): void;
		setPublicKey(arg0?: String, arg1?: String): void;
		unregisterExtension(arg0?: String): void;
		updateExtension(arg0?: VcExtension): void;
		updateExtensionData(arg0?: VcKeyValue[]): void;
	}

	declare const VcExtensionManager: VcExtensionManager;

	declare class VcExtensionManagerExtensionDataUsage
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extensionKey: String;
		numKeys: Number;
		size: Number;

		constructor();
		constructor(extensionKey?: String, numKeys?: Number, size?: Number);
	}

	declare class VcExtensionManagerIpAllocationUsage
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extensionKey: String;
		numAddresses: Number;

		constructor();
		constructor(extensionKey?: String, numAddresses?: Number);
	}

	declare class VcExtensionOvfConsumerInfo
	{
		callbackUrl: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		sectionType: String[];

		constructor();
		constructor(callbackUrl?: String, sectionType?: String[]);
	}

	declare class VcExtensionPrivilegeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		privGroupName: String;
		privID: String;

		constructor();
		constructor(privID?: String, privGroupName?: String);
	}

	declare class VcExtensionResourceInfo
	{
		data: VcKeyValue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		locale: String;
		module: String;

		constructor(locale?: String, module?: String, data?: VcKeyValue[]);
		constructor();
	}

	declare class VcExtensionServerInfo
	{
		adminEmail: String[];
		company: String;
		description: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		serverThumbprint: String;
		type: String;
		url: String;

		constructor();
		constructor(url?: String, description?: VcDescription, company?: String, type?: String, adminEmail?: String[], serverThumbprint?: String);
	}

	declare class VcExtensionTaskTypeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		taskID: String;

		constructor();
		constructor(taskID?: String);
	}

	interface VcExternalStatsManager
	{
		enabledClusters: VcClusterComputeResource[];
		id: String;
		moref: VcManagedObjectReference;
		registeredProviders: VcExternalStatsManagerProviderInfo[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		isRegistered(arg0?: String): boolean;
		registerStatsProvider(arg0?: VcExternalStatsManagerProviderInfo, arg1?: boolean): void;
		unregisterStatsProvider(arg0?: String): void;
		updateStats(arg0?: String, arg1?: VcClusterComputeResource, arg2?: VcExternalStatsManagerStatsUpdate[]): void;
	}

	declare const VcExternalStatsManager: VcExternalStatsManager;

	interface VcExternalStatsManagerMetricType
	{
		readonly CpuActivePct: VcExternalStatsManagerMetricType;
		readonly id: String;
		readonly MemoryNonZeroActiveMb: VcExternalStatsManagerMetricType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcExternalStatsManagerMetricType): VcExternalStatsManagerMetricType;
	}

	declare const VcExternalStatsManagerMetricType: VcExternalStatsManagerMetricType;

	declare class VcExternalStatsManagerMetricValueMap
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		metricType: String;
		startTimeMs: Number;
		statValues: VcExternalStatsManagerTimeValuePair[];

		constructor();
		constructor(metricType?: String, startTimeMs?: Number, statValues?: VcExternalStatsManagerTimeValuePair[]);
	}

	declare class VcExternalStatsManagerProviderInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		metadata: String;

		constructor();
		constructor(id?: String, metadata?: String);
	}

	declare class VcExternalStatsManagerStatsUpdate
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		statsData: VcExternalStatsManagerMetricValueMap[];

		constructor();
		constructor(entity?: VcManagedEntity, statsData?: VcExternalStatsManagerMetricValueMap[]);
	}

	declare class VcExternalStatsManagerTimeValuePair
	{
		duration: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		value: Number;

		constructor();
		constructor(duration?: Number, value?: Number);
	}

	declare class VcExtExtendedProductInfo
	{
		companyUrl: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		managementUrl: String;
		productUrl: String;
		self: VcManagedEntity;

		constructor();
		constructor(companyUrl?: String, productUrl?: String, managementUrl?: String, self?: VcManagedEntity);
	}

	declare class VcExtManagedEntityInfo
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		iconUrl: String;
		smallIconUrl: String;
		type: String;

		constructor();
		constructor(type?: String, smallIconUrl?: String, iconUrl?: String, description?: String);
	}

	declare class VcExtSolutionManagerInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		smallIconUrl: String;
		tab: VcExtSolutionManagerInfoTabInfo[];

		constructor();
		constructor(tab?: VcExtSolutionManagerInfoTabInfo[], smallIconUrl?: String);
	}

	declare class VcExtSolutionManagerInfoTabInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		label: String;
		url: String;

		constructor();
		constructor(label?: String, url?: String);
	}

	interface VcFailoverClusterConfigurator
	{
		disabledConfigureMethod: String[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vchaConfig: VcVchaClusterConfigInfo;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		configureVcha_Task(arg0?: VcVchaClusterConfigSpec): VcTask;
		createPassiveNode_Task(arg0?: VcPassiveNodeDeploymentSpec, arg1?: VcSourceNodeSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createWitnessNode_Task(arg0?: VcNodeDeploymentSpec, arg1?: VcSourceNodeSpec): VcTask;
		deployVcha_Task(arg0?: VcVchaClusterDeploymentSpec): VcTask;
		destroyVcha_Task(): VcTask;
		prepareVcha_Task(arg0?: VcVchaClusterNetworkSpec): VcTask;
	}

	declare const VcFailoverClusterConfigurator: VcFailoverClusterConfigurator;

	interface VcFailoverClusterManager
	{
		clusterMode: String;
		disabledClusterMethod: String[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vchaClusterHealth: VcVchaClusterHealth;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		initiateFailover_Task(arg0?: boolean): VcTask;
		setClusterMode_Task(arg0?: String): VcTask;
	}

	declare const VcFailoverClusterManager: VcFailoverClusterManager;

	declare class VcFailoverLevelRestored
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcFailoverNodeInfo
	{
		biosUuid: String;
		clusterIpSettings: VcCustomizationIPSettings;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failoverIp: VcCustomizationIPSettings;

		constructor();
		constructor(clusterIpSettings?: VcCustomizationIPSettings, failoverIp?: VcCustomizationIPSettings, biosUuid?: String);
	}

	declare class VcFailToEnableSPBM
	{
		cs: VcComputeResource;
		csName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostLicenseStates: VcComputeResourceHostSPBMLicenseInfo[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(cs?: VcComputeResource, csName?: String, hostLicenseStates?: VcComputeResourceHostSPBMLicenseInfo[]);
		printStackTrace(): void;
	}

	declare class VcFailToLockFaultToleranceVMs
	{
		alreadyLockedVm: VcVirtualMachine;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(vmName?: String, vm?: VcVirtualMachine, alreadyLockedVm?: VcVirtualMachine);
		printStackTrace(): void;
	}

	declare class VcFaultDomainId
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;

		constructor();
		constructor(id?: String);
	}

	declare class VcFaultToleranceAntiAffinityViolated
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		hostName: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostName?: String, host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcFaultToleranceCannotEditMem
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(vmName?: String, vm?: VcVirtualMachine);
		printStackTrace(): void;
	}

	declare class VcFaultToleranceConfigInfo
	{
		configPaths: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		instanceUuids: String[];
		orphaned: boolean;
		role: Number;

		constructor();
		constructor(role?: Number, instanceUuids?: String[], configPaths?: String[], orphaned?: boolean);
		isOrphaned(): boolean;
	}

	declare class VcFaultToleranceConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		metaDataPath: VcFaultToleranceMetaSpec;
		secondaryVmSpec: VcFaultToleranceVMConfigSpec;

		constructor();
		constructor(metaDataPath?: VcFaultToleranceMetaSpec, secondaryVmSpec?: VcFaultToleranceVMConfigSpec);
	}

	declare class VcFaultToleranceCpuIncompatible
	{
		desiredBits: String;
		family: boolean;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		level: Number;
		readonly localizedMessage: String;
		message: String;
		model: boolean;
		registerBits: String;
		registerName: String;
		stepping: boolean;

		constructor();
		constructor(level?: Number, registerName?: String, registerBits?: String, desiredBits?: String, host?: VcHostSystem, model?: boolean, family?: boolean, stepping?: boolean);
		printStackTrace(): void;
	}

	declare class VcFaultToleranceDiskSpec
	{
		datastore: VcDatastore;
		disk: VcVirtualDevice;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(disk?: VcVirtualDevice, datastore?: VcDatastore);
	}

	declare class VcFaultToleranceMetaSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		metaDataDatastore: VcDatastore;

		constructor();
		constructor(metaDataDatastore?: VcDatastore);
	}

	declare class VcFaultToleranceNeedsThickDisk
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmName: String;

		constructor();
		constructor(vmName?: String);
		printStackTrace(): void;
	}

	declare class VcFaultToleranceNotLicensed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostName?: String);
		printStackTrace(): void;
	}

	declare class VcFaultToleranceNotSameBuild
	{
		build: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(build?: String);
		printStackTrace(): void;
	}

	declare class VcFaultTolerancePrimaryConfigInfo
	{
		configPaths: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		instanceUuids: String[];
		orphaned: boolean;
		role: Number;
		secondaries: VcVirtualMachine[];

		constructor();
		constructor(role?: Number, instanceUuids?: String[], configPaths?: String[], orphaned?: boolean, secondaries?: VcVirtualMachine[]);
		isOrphaned(): boolean;
	}

	declare class VcFaultTolerancePrimaryPowerOnNotAttempted
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		primaryVm: VcVirtualMachine;
		secondaryVm: VcVirtualMachine;

		constructor();
		constructor(secondaryVm?: VcVirtualMachine, primaryVm?: VcVirtualMachine);
		printStackTrace(): void;
	}

	declare class VcFaultToleranceSecondaryConfigInfo
	{
		configPaths: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		instanceUuids: String[];
		orphaned: boolean;
		primaryVM: VcVirtualMachine;
		role: Number;

		constructor();
		constructor(role?: Number, instanceUuids?: String[], configPaths?: String[], orphaned?: boolean, primaryVM?: VcVirtualMachine);
		isOrphaned(): boolean;
	}

	declare class VcFaultToleranceSecondaryOpResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		powerOnAttempted: boolean;
		powerOnResult: VcClusterPowerOnVmResult;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, powerOnAttempted?: boolean, powerOnResult?: VcClusterPowerOnVmResult);
	}

	declare class VcFaultToleranceVMConfigSpec
	{
		disks: VcFaultToleranceDiskSpec[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vmConfig: VcDatastore;

		constructor();
		constructor(vmConfig?: VcDatastore, disks?: VcFaultToleranceDiskSpec[]);
	}

	declare class VcFaultToleranceVmNotDasProtected
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(vm?: VcVirtualMachine, vmName?: String);
		printStackTrace(): void;
	}

	declare class VcFcoeConfig
	{
		capabilities: VcFcoeConfigFcoeCapabilities;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fcoeActive: boolean;
		priorityClass: Number;
		sourceMac: String;
		vlanRange: VcFcoeConfigVlanRange[];

		constructor();
		constructor(priorityClass?: Number, sourceMac?: String, vlanRange?: VcFcoeConfigVlanRange[], capabilities?: VcFcoeConfigFcoeCapabilities, fcoeActive?: boolean);
	}

	declare class VcFcoeConfigFcoeCapabilities
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		priorityClass: boolean;
		sourceMacAddress: boolean;
		vlanRange: boolean;

		constructor();
		constructor(priorityClass?: boolean, sourceMacAddress?: boolean, vlanRange?: boolean);
	}

	declare class VcFcoeConfigFcoeSpecification
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		priorityClass: Number;
		sourceMac: String;
		underlyingPnic: String;
		vlanRange: VcFcoeConfigVlanRange[];

		constructor();
		constructor(underlyingPnic?: String, priorityClass?: Number, sourceMac?: String, vlanRange?: VcFcoeConfigVlanRange[]);
	}

	declare class VcFcoeConfigVlanRange
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vlanHigh: Number;
		vlanLow: Number;

		constructor();
		constructor(vlanLow?: Number, vlanHigh?: Number);
	}

	declare class VcFcoeFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcFcoeFaultPnicHasNoPortSet
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		nicDevice: String;

		constructor();
		constructor(nicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcFeatureRequirementsNotMet
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		featureRequirement: VcVirtualMachineFeatureRequirement[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(featureRequirement?: VcVirtualMachineFeatureRequirement[], vm?: VcVirtualMachine, host?: VcHostSystem);
		printStackTrace(): void;
	}

	interface VcFibreChannelPortType
	{
		readonly fabric: VcFibreChannelPortType;
		readonly id: String;
		readonly loop: VcFibreChannelPortType;
		readonly name: String;
		readonly pointToPoint: VcFibreChannelPortType;
		readonly unknown: VcFibreChannelPortType;
		readonly value: String;

		fromString(value?: VcFibreChannelPortType): VcFibreChannelPortType;
	}

	declare const VcFibreChannelPortType: VcFibreChannelPortType;

	declare class VcFileAlreadyExists
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcFileBackedPortNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcFileBackedVirtualDiskSpec
	{
		adapterType: String;
		capacityKb: Number;
		crypto: VcCryptoSpec;
		diskType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(diskType?: String, adapterType?: String, capacityKb?: Number, profile?: VcVirtualMachineProfileSpec[], crypto?: VcCryptoSpec);
	}

	declare class VcFileFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSize: Number;
		friendlyName: String;
		modification: Date;
		owner: String;
		path: String;

		constructor();
		constructor(path?: String, friendlyName?: String, fileSize?: Number, modification?: Date, owner?: String);
	}

	declare class VcFileLocked
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	interface VcFileManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		changeOwner(arg0?: String, arg1?: VcDatacenter, arg2?: String): void;
		copy_Task(arg0?: VcDatacenter, arg1?: String, arg2?: VcDatacenter, arg3?: String, arg4?: boolean, arg5?: String): VcTask;
		copyDatastoreFile_Task(arg0?: String, arg1?: VcDatacenter, arg2?: String, arg3?: VcDatacenter, arg4?: boolean): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		delete_Task(arg0?: VcDatacenter, arg1?: String, arg2?: String): VcTask;
		deleteDatastoreFile_Task(arg0?: String, arg1?: VcDatacenter): VcTask;
		makeDirectory(arg0?: String, arg1?: VcDatacenter, arg2?: boolean): void;
		move_Task(arg0?: VcDatacenter, arg1?: String, arg2?: VcDatacenter, arg3?: String, arg4?: boolean, arg5?: String): VcTask;
		moveDatastoreFile_Task(arg0?: String, arg1?: VcDatacenter, arg2?: String, arg3?: VcDatacenter, arg4?: boolean): VcTask;
	}

	declare const VcFileManager: VcFileManager;

	interface VcFileManagerFileType
	{
		readonly File: VcFileManagerFileType;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly VirtualDisk: VcFileManagerFileType;

		fromString(value?: VcFileManagerFileType): VcFileManagerFileType;
	}

	declare const VcFileManagerFileType: VcFileManagerFileType;

	declare class VcFileNameTooLong
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcFileNotFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcFileNotWritable
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcFileQuery
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcFileQueryFlags
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileOwner: boolean;
		fileSize: boolean;
		fileType: boolean;
		modification: boolean;

		constructor();
		constructor(fileType?: boolean, fileSize?: boolean, modification?: boolean, fileOwner?: boolean);
		isFileOwner(): boolean;
	}

	interface VcFileSystemMountInfoVStorageSupportStatus
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vStorageSupported: VcFileSystemMountInfoVStorageSupportStatus;
		readonly vStorageUnknown: VcFileSystemMountInfoVStorageSupportStatus;
		readonly vStorageUnsupported: VcFileSystemMountInfoVStorageSupportStatus;

		fromString(value?: VcFileSystemMountInfoVStorageSupportStatus): VcFileSystemMountInfoVStorageSupportStatus;
	}

	declare const VcFileSystemMountInfoVStorageSupportStatus: VcFileSystemMountInfoVStorageSupportStatus;

	declare class VcFilesystemQuiesceFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcFileTooLarge
	{
		datastore: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		fileSize: Number;
		readonly localizedMessage: String;
		maxFileSize: Number;
		message: String;

		constructor();
		constructor(file?: String, datastore?: String, fileSize?: Number, maxFileSize?: Number);
		printStackTrace(): void;
	}

	declare class VcFileTransferInformation
	{
		attributes: VcGuestFileAttributes;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		size: Number;
		url: String;

		constructor();
		constructor(attributes?: VcGuestFileAttributes, size?: Number, url?: String);
	}

	declare class VcFilterInUse
	{
		disk: VcVirtualDiskId[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		type: String;

		constructor();
		constructor(type?: String, name?: String, disk?: VcVirtualDiskId[]);
		printStackTrace(): void;
	}

	declare class VcFirewallProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		ruleset: VcFirewallProfileRulesetProfile[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, ruleset?: VcFirewallProfileRulesetProfile[]);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcFirewallProfileRulesetProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcFloatOption
	{
		defaultValue: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		max: Number;
		min: Number;
		valueIsReadonly: boolean;

		constructor();
		constructor(valueIsReadonly?: boolean, min?: Number, max?: Number, defaultValue?: Number);
		isValueIsReadonly(): boolean;
	}

	declare class VcFloppyImageFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSize: Number;
		friendlyName: String;
		modification: Date;
		owner: String;
		path: String;

		constructor();
		constructor(path?: String, friendlyName?: String, fileSize?: Number, modification?: Date, owner?: String);
	}

	declare class VcFloppyImageFileQuery
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcFolder
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		childEntity: VcManagedEntity[];
		childType: String[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addStandaloneHost_Task(arg0?: VcHostConnectSpec, arg1?: VcComputeResourceConfigSpec, arg2?: boolean, arg3?: String): VcTask;
		addStandaloneHostWithAdminDisabled_Task(arg0?: VcHostConnectSpec, arg1?: VcComputeResourceConfigSpec, arg2?: boolean, arg3?: String): VcTask;
		addTag(arg0?: VcTag[]): void;
		createCluster(arg0?: String, arg1?: VcClusterConfigSpec): VcClusterComputeResource;
		createClusterEx(arg0?: String, arg1?: VcClusterConfigSpecEx): VcClusterComputeResource;
		createDatacenter(arg0?: String): VcDatacenter;
		createDVS_Task(arg0?: VcDVSCreateSpec): VcTask;
		createFolder(arg0?: String): VcFolder;
		createStoragePod(arg0?: String): VcStoragePod;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVM_Task(arg0?: VcVirtualMachineConfigSpec, arg1?: VcResourcePool, arg2?: VcHostSystem): VcTask;
		destroy_Task(): VcTask;
		moveIntoFolder_Task(arg0?: VcManagedEntity[]): VcTask;
		registerVM_Task(arg0?: String, arg1?: String, arg2?: boolean, arg3?: VcResourcePool, arg4?: VcHostSystem): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
		unregisterAndDestroy_Task(): VcTask;
	}

	declare const VcFolder: VcFolder;

	declare class VcFolderEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		folder: VcFolder;
		name: String;

		constructor();
		constructor(name?: String, folder?: VcFolder);
	}

	declare class VcFolderFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSize: Number;
		friendlyName: String;
		modification: Date;
		owner: String;
		path: String;

		constructor();
		constructor(path?: String, friendlyName?: String, fileSize?: Number, modification?: Date, owner?: String);
	}

	declare class VcFolderFileQuery
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcFormattedHostProfilesCustomizations
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		format: String;
		formattedCustomizations: String;

		constructor();
		constructor(entity?: VcManagedEntity, format?: String, formattedCustomizations?: String);
	}

	declare class VcFtIssuesOnHost
	{
		errors: VcLocalizedMethodFault[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		hostName: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem, hostName?: String, errors?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	interface VcFtIssuesOnHostHostSelectionType
	{
		readonly drs: VcFtIssuesOnHostHostSelectionType;
		readonly id: String;
		readonly name: String;
		readonly user: VcFtIssuesOnHostHostSelectionType;
		readonly value: String;
		readonly vc: VcFtIssuesOnHostHostSelectionType;

		fromString(value?: VcFtIssuesOnHostHostSelectionType): VcFtIssuesOnHostHostSelectionType;
	}

	declare const VcFtIssuesOnHostHostSelectionType: VcFtIssuesOnHostHostSelectionType;

	declare class VcFullStorageVMotionNotSupported
	{
		atSourceHost: boolean;
		failedHost: VcHostSystem;
		failedHostName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHostName?: String, failedHost?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcGatewayConnectFault
	{
		details: VcLocalizableMessage;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		gatewayId: String;
		gatewayInfo: String;
		gatewayType: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(gatewayType?: String, gatewayId?: String, gatewayInfo?: String, details?: VcLocalizableMessage);
		printStackTrace(): void;
	}

	declare class VcGatewayHostNotReachable
	{
		details: VcLocalizableMessage;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		gatewayId: String;
		gatewayInfo: String;
		gatewayType: String;
		hostname: String;
		readonly localizedMessage: String;
		message: String;
		port: Number;

		constructor();
		constructor(gatewayType?: String, gatewayId?: String, gatewayInfo?: String, details?: VcLocalizableMessage, hostname?: String, port?: Number);
		printStackTrace(): void;
	}

	declare class VcGatewayNotFound
	{
		details: VcLocalizableMessage;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		gatewayId: String;
		gatewayInfo: String;
		gatewayType: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(gatewayType?: String, gatewayId?: String, gatewayInfo?: String, details?: VcLocalizableMessage);
		printStackTrace(): void;
	}

	declare class VcGatewayNotReachable
	{
		details: VcLocalizableMessage;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		gatewayId: String;
		gatewayInfo: String;
		gatewayType: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(gatewayType?: String, gatewayId?: String, gatewayInfo?: String, details?: VcLocalizableMessage);
		printStackTrace(): void;
	}

	declare class VcGatewayOperationRefused
	{
		details: VcLocalizableMessage;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		gatewayId: String;
		gatewayInfo: String;
		gatewayType: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(gatewayType?: String, gatewayId?: String, gatewayInfo?: String, details?: VcLocalizableMessage);
		printStackTrace(): void;
	}

	declare class VcGatewayToHostAuthFault
	{
		details: VcLocalizableMessage;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		gatewayId: String;
		gatewayInfo: String;
		gatewayType: String;
		hostname: String;
		invalidProperties: String[];
		readonly localizedMessage: String;
		message: String;
		missingProperties: String[];
		port: Number;

		constructor();
		constructor(gatewayType?: String, gatewayId?: String, gatewayInfo?: String, details?: VcLocalizableMessage, hostname?: String, port?: Number, invalidProperties?: String[], missingProperties?: String[]);
		printStackTrace(): void;
	}

	declare class VcGatewayToHostConnectFault
	{
		details: VcLocalizableMessage;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		gatewayId: String;
		gatewayInfo: String;
		gatewayType: String;
		hostname: String;
		readonly localizedMessage: String;
		message: String;
		port: Number;

		constructor();
		constructor(gatewayType?: String, gatewayId?: String, gatewayInfo?: String, details?: VcLocalizableMessage, hostname?: String, port?: Number);
		printStackTrace(): void;
	}

	declare class VcGatewayToHostTrustVerifyFault
	{
		details: VcLocalizableMessage;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		gatewayId: String;
		gatewayInfo: String;
		gatewayType: String;
		hostname: String;
		readonly localizedMessage: String;
		message: String;
		port: Number;
		propertiesToVerify: VcKeyValue[];
		verificationToken: String;

		constructor();
		constructor(gatewayType?: String, gatewayId?: String, gatewayInfo?: String, details?: VcLocalizableMessage, hostname?: String, port?: Number, verificationToken?: String, propertiesToVerify?: VcKeyValue[]);
		printStackTrace(): void;
	}

	declare class VcGeneralEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	declare class VcGeneralHostErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	declare class VcGeneralHostInfoEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	declare class VcGeneralHostWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	declare class VcGeneralUserEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String, entity?: VcManagedEntityEventArgument);
	}

	declare class VcGeneralVmErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	declare class VcGeneralVmInfoEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	declare class VcGeneralVmWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	declare class VcGenericDrsFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostFaults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostFaults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcGenericVmConfigFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor(reason?: String);
		constructor();
		printStackTrace(): void;
	}

	declare class VcGhostDvsProxySwitchDetectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String[]);
	}

	declare class VcGhostDvsProxySwitchRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String[]);
	}

	declare class VcGlobalMessageChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		prevMessage: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String, prevMessage?: String);
	}

	declare class VcGroupAlarmAction
	{
		action: VcAlarmAction[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(action?: VcAlarmAction[]);
	}

	declare class VcGuestAliases
	{
		aliases: VcGuestAuthAliasInfo[];
		base64Cert: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(base64Cert?: String, aliases?: VcGuestAuthAliasInfo[]);
	}

	interface VcGuestAliasManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addGuestAlias(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: boolean, arg4?: String, arg5?: VcGuestAuthAliasInfo): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		listGuestAliases(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String): VcGuestAliases[];
		listGuestMappedAliases(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication): VcGuestMappedAliases[];
		removeGuestAlias(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: String, arg4?: VcGuestAuthSubject): void;
		removeGuestAliasByCert(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: String): void;
	}

	declare const VcGuestAliasManager: VcGuestAliasManager;

	declare class VcGuestAuthAliasInfo
	{
		comment: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		subject: VcGuestAuthSubject;

		constructor();
		constructor(subject?: VcGuestAuthSubject, comment?: String);
	}

	declare class VcGuestAuthAnySubject
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcGuestAuthentication
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		interactiveSession: boolean;

		constructor();
		constructor(interactiveSession?: boolean);
	}

	declare class VcGuestAuthenticationChallenge
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		serverChallenge: VcGuestAuthentication;
		sessionID: Number;

		constructor();
		constructor(serverChallenge?: VcGuestAuthentication, sessionID?: Number);
		printStackTrace(): void;
	}

	interface VcGuestAuthManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		acquireCredentialsInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: Number): VcGuestAuthentication;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		releaseCredentialsInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication): void;
		validateCredentialsInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication): void;
	}

	declare const VcGuestAuthManager: VcGuestAuthManager;

	declare class VcGuestAuthNamedSubject
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String);
	}

	declare class VcGuestAuthSubject
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcGuestComponentsOutOfDate
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcGuestDiskInfo
	{
		capacity: Number;
		diskPath: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpace: Number;

		constructor();
		constructor(diskPath?: String, capacity?: Number, freeSpace?: Number);
	}

	declare class VcGuestFileAttributes
	{
		accessTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		modificationTime: Date;
		symlinkTarget: String;

		constructor();
		constructor(modificationTime?: Date, accessTime?: Date, symlinkTarget?: String);
	}

	declare class VcGuestFileInfo
	{
		attributes: VcGuestFileAttributes;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		path: String;
		size: Number;
		type: String;

		constructor();
		constructor(path?: String, type?: String, size?: Number, attributes?: VcGuestFileAttributes);
	}

	interface VcGuestFileManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		changeFileAttributesInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: VcGuestFileAttributes): void;
		createTemporaryDirectoryInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: String, arg4?: String): String;
		createTemporaryFileInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: String, arg4?: String): String;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteDirectoryInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: boolean): void;
		deleteFileInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String): void;
		downloadFile(vcoPath?: String, fileTransferInformation?: VcFileTransferInformation): boolean;
		initiateFileTransferFromGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, guestFilePath?: String): VcFileTransferInformation;
		initiateFileTransferToGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, guestFilePath?: String, fileAttributes?: VcGuestFileAttributes, fileSize?: Number, overwrite?: boolean): String;
		listFilesInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: Number, arg4?: Number, arg5?: String): VcGuestListFileInfo;
		makeDirectoryInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: boolean): void;
		moveDirectoryInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: String): void;
		moveFileInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String, arg3?: String, arg4?: boolean): void;
		putFile(vcoPath?: String, uri?: String): boolean;
	}

	declare const VcGuestFileManager: VcGuestFileManager;

	interface VcGuestFileType
	{
		readonly directory: VcGuestFileType;
		readonly file: VcGuestFileType;
		readonly id: String;
		readonly name: String;
		readonly symlink: VcGuestFileType;
		readonly value: String;

		fromString(value?: VcGuestFileType): VcGuestFileType;
	}

	declare const VcGuestFileType: VcGuestFileType;

	declare class VcGuestInfo
	{
		appHeartbeatStatus: String;
		appState: String;
		disk: VcGuestDiskInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		generationInfo: VcGuestInfoNamespaceGenerationInfo[];
		guestFamily: String;
		guestFullName: String;
		guestId: String;
		guestKernelCrashed: boolean;
		guestOperationsReady: boolean;
		guestState: String;
		guestStateChangeSupported: boolean;
		hostName: String;
		interactiveGuestOperationsReady: boolean;
		ipAddress: String;
		ipStack: VcGuestStackInfo[];
		net: VcGuestNicInfo[];
		powerPolicy: VcVirtualMachinePowerPolicy;
		screen: VcGuestScreenInfo;
		toolsInstallType: String;
		toolsRunningStatus: String;
		toolsStatus: VcVirtualMachineToolsStatus;
		toolsUpdateStatus: VcVirtualMachineToolsUpdateStatus;
		toolsVersion: String;
		toolsVersionStatus: String;
		toolsVersionStatus2: String;

		constructor();
		constructor(toolsStatus?: VcVirtualMachineToolsStatus, toolsVersionStatus?: String, toolsVersionStatus2?: String, toolsRunningStatus?: String, toolsVersion?: String, toolsInstallType?: String, toolsUpdateStatus?: VcVirtualMachineToolsUpdateStatus, guestId?: String, guestFamily?: String, guestFullName?: String, hostName?: String, ipAddress?: String, net?: VcGuestNicInfo[], ipStack?: VcGuestStackInfo[], disk?: VcGuestDiskInfo[], screen?: VcGuestScreenInfo, guestState?: String, powerPolicy?: VcVirtualMachinePowerPolicy, appHeartbeatStatus?: String, guestKernelCrashed?: boolean, appState?: String, guestOperationsReady?: boolean, interactiveGuestOperationsReady?: boolean, guestStateChangeSupported?: boolean, generationInfo?: VcGuestInfoNamespaceGenerationInfo[]);
		isGuestKernelCrashed(): boolean;
		isGuestOperationsReady(): boolean;
		isGuestStateChangeSupported(): boolean;
		isInteractiveGuestOperationsReady(): boolean;
	}

	interface VcGuestInfoAppStateType
	{
		readonly appStateNeedReset: VcGuestInfoAppStateType;
		readonly appStateOk: VcGuestInfoAppStateType;
		readonly id: String;
		readonly name: String;
		readonly none: VcGuestInfoAppStateType;
		readonly value: String;

		fromString(value?: VcGuestInfoAppStateType): VcGuestInfoAppStateType;
	}

	declare const VcGuestInfoAppStateType: VcGuestInfoAppStateType;

	declare class VcGuestInfoNamespaceGenerationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		generationNo: Number;
		key: String;

		constructor();
		constructor(key?: String, generationNo?: Number);
	}

	declare class VcGuestListFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		files: VcGuestFileInfo[];
		remaining: Number;

		constructor();
		constructor(files?: VcGuestFileInfo[], remaining?: Number);
	}

	declare class VcGuestMappedAliases
	{
		base64Cert: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		subjects: VcGuestAuthSubject[];
		username: String;

		constructor();
		constructor(base64Cert?: String, username?: String, subjects?: VcGuestAuthSubject[]);
	}

	declare class VcGuestMultipleMappings
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcGuestNicInfo
	{
		connected: boolean;
		deviceConfigId: Number;
		dnsConfig: VcNetDnsConfigInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String[];
		ipConfig: VcNetIpConfigInfo;
		macAddress: String;
		netBIOSConfig: VcNetBIOSConfigInfo;
		network: String;

		constructor();
		constructor(network?: String, ipAddress?: String[], macAddress?: String, connected?: boolean, deviceConfigId?: Number, dnsConfig?: VcNetDnsConfigInfo, ipConfig?: VcNetIpConfigInfo, netBIOSConfig?: VcNetBIOSConfigInfo);
	}

	declare class VcGuestOperationsFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	interface VcGuestOperationsManager
	{
		aliasManager: VcGuestAliasManager;
		authManager: VcGuestAuthManager;
		fileManager: VcGuestFileManager;
		guestWindowsRegistryManager: VcGuestWindowsRegistryManager;
		id: String;
		moref: VcManagedObjectReference;
		processManager: VcGuestProcessManager;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryGuestOperationsDisabledMethods(arg0?: VcVirtualMachine): String[];
	}

	declare const VcGuestOperationsManager: VcGuestOperationsManager;

	declare class VcGuestOperationsUnavailable
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcGuestOsDescriptor
	{
		cpuFeatureMask: VcHostCpuIdInfo[];
		defaultSecureBoot: boolean;
		diskUuidEnabled: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		family: String;
		fullName: String;
		ich7mRecommended: boolean;
		id: String;
		numRecommendedCoresPerSocket: Number;
		numRecommendedPhysicalSockets: Number;
		numSupportedCoresPerSocket: Number;
		numSupportedFloppyDevices: Number;
		numSupportedPhysicalSockets: Number;
		persistentMemoryColdGrowthGranularityMB: Number;
		persistentMemoryColdGrowthSupported: boolean;
		persistentMemoryHotAddSupported: boolean;
		persistentMemoryHotGrowthGranularityMB: Number;
		persistentMemoryHotGrowthSupported: boolean;
		persistentMemoryHotRemoveSupported: boolean;
		persistentMemorySupported: boolean;
		recommended3D: boolean;
		recommendedCdromController: String;
		recommendedColorDepth: Number;
		recommendedDiskController: String;
		recommendedDiskSizeMB: Number;
		recommendedEthernetCard: String;
		recommendedFirmware: String;
		recommendedMemMB: Number;
		recommendedPersistentMemoryMB: Number;
		recommendedSCSIController: String;
		recommendedUSBController: String;
		smcRecommended: boolean;
		smcRequired: boolean;
		supportedDiskControllerList: String[];
		supportedEthernetCard: String[];
		supportedFirmware: String[];
		supportedForCreate: boolean;
		supportedMaxCPUs: Number;
		supportedMaxMemMB: Number;
		supportedMaxPersistentMemoryMB: Number;
		supportedMinMemMB: Number;
		supportedMinPersistentMemoryMB: Number;
		supportedNumDisks: Number;
		supportedUSBControllerList: String[];
		supportLevel: String;
		supports3D: boolean;
		supportsCpuHotAdd: boolean;
		supportsCpuHotRemove: boolean;
		supportsHotPlugPCI: boolean;
		supportsMemoryHotAdd: boolean;
		supportsPvscsiControllerForBoot: boolean;
		supportsSecureBoot: boolean;
		supportsSlaveDisk: boolean;
		supportsVMI: boolean;
		supportsWakeOnLan: boolean;
		usbRecommended: boolean;
		vRAMSizeInKB: VcIntOption;
		wakeOnLanEthernetCard: String[];

		constructor();
		constructor(id?: String, family?: String, fullName?: String, supportedMaxCPUs?: Number, numSupportedPhysicalSockets?: Number, numSupportedCoresPerSocket?: Number, supportedMinMemMB?: Number, supportedMaxMemMB?: Number, recommendedMemMB?: Number, recommendedColorDepth?: Number, supportedDiskControllerList?: String[], recommendedSCSIController?: String, recommendedDiskController?: String, supportedNumDisks?: Number, recommendedDiskSizeMB?: Number, recommendedCdromController?: String, supportedEthernetCard?: String[], recommendedEthernetCard?: String, supportsSlaveDisk?: boolean, cpuFeatureMask?: VcHostCpuIdInfo[], smcRequired?: boolean, supportsWakeOnLan?: boolean, supportsVMI?: boolean, supportsMemoryHotAdd?: boolean, supportsCpuHotAdd?: boolean, supportsCpuHotRemove?: boolean, supportedFirmware?: String[], recommendedFirmware?: String, supportedUSBControllerList?: String[], recommendedUSBController?: String, supports3D?: boolean, recommended3D?: boolean, smcRecommended?: boolean, ich7mRecommended?: boolean, usbRecommended?: boolean, supportLevel?: String, supportedForCreate?: boolean, vRAMSizeInKB?: VcIntOption, numSupportedFloppyDevices?: Number, wakeOnLanEthernetCard?: String[], supportsPvscsiControllerForBoot?: boolean, diskUuidEnabled?: boolean, supportsHotPlugPCI?: boolean, supportsSecureBoot?: boolean, defaultSecureBoot?: boolean, persistentMemorySupported?: boolean, supportedMinPersistentMemoryMB?: Number, supportedMaxPersistentMemoryMB?: Number, recommendedPersistentMemoryMB?: Number, persistentMemoryHotAddSupported?: boolean, persistentMemoryHotRemoveSupported?: boolean, persistentMemoryColdGrowthSupported?: boolean, persistentMemoryColdGrowthGranularityMB?: Number, persistentMemoryHotGrowthSupported?: boolean, persistentMemoryHotGrowthGranularityMB?: Number, numRecommendedPhysicalSockets?: Number, numRecommendedCoresPerSocket?: Number);
		isDefaultSecureBoot(): boolean;
		isDiskUuidEnabled(): boolean;
		isIch7mRecommended(): boolean;
		isPersistentMemoryColdGrowthSupported(): boolean;
		isPersistentMemoryHotAddSupported(): boolean;
		isPersistentMemoryHotGrowthSupported(): boolean;
		isPersistentMemoryHotRemoveSupported(): boolean;
		isPersistentMemorySupported(): boolean;
		isRecommended3D(): boolean;
		isSmcRecommended(): boolean;
		isSmcRequired(): boolean;
		isSupportedForCreate(): boolean;
		isSupports3D(): boolean;
		isSupportsCpuHotAdd(): boolean;
		isSupportsCpuHotRemove(): boolean;
		isSupportsHotPlugPCI(): boolean;
		isSupportsMemoryHotAdd(): boolean;
		isSupportsPvscsiControllerForBoot(): boolean;
		isSupportsSecureBoot(): boolean;
		isSupportsSlaveDisk(): boolean;
		isSupportsVMI(): boolean;
		isUsbRecommended(): boolean;
	}

	interface VcGuestOsDescriptorFirmwareType
	{
		readonly bios: VcGuestOsDescriptorFirmwareType;
		readonly csm: VcGuestOsDescriptorFirmwareType;
		readonly efi: VcGuestOsDescriptorFirmwareType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcGuestOsDescriptorFirmwareType): VcGuestOsDescriptorFirmwareType;
	}

	declare const VcGuestOsDescriptorFirmwareType: VcGuestOsDescriptorFirmwareType;

	interface VcGuestOsDescriptorSupportLevel
	{
		readonly deprecated: VcGuestOsDescriptorSupportLevel;
		readonly experimental: VcGuestOsDescriptorSupportLevel;
		readonly id: String;
		readonly legacy: VcGuestOsDescriptorSupportLevel;
		readonly name: String;
		readonly supported: VcGuestOsDescriptorSupportLevel;
		readonly techPreview: VcGuestOsDescriptorSupportLevel;
		readonly terminated: VcGuestOsDescriptorSupportLevel;
		readonly unsupported: VcGuestOsDescriptorSupportLevel;
		readonly value: String;

		fromString(value?: VcGuestOsDescriptorSupportLevel): VcGuestOsDescriptorSupportLevel;
	}

	declare const VcGuestOsDescriptorSupportLevel: VcGuestOsDescriptorSupportLevel;

	declare class VcGuestPermissionDenied
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcGuestPosixFileAttributes
	{
		accessTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		groupId: Number;
		modificationTime: Date;
		ownerId: Number;
		permissions: Number;
		symlinkTarget: String;

		constructor();
		constructor(modificationTime?: Date, accessTime?: Date, symlinkTarget?: String, ownerId?: Number, groupId?: Number, permissions?: Number);
	}

	declare class VcGuestProcessInfo
	{
		cmdLine: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endTime: Date;
		exitCode: Number;
		name: String;
		owner: String;
		pid: Number;
		startTime: Date;

		constructor();
		constructor(name?: String, pid?: Number, owner?: String, cmdLine?: String, startTime?: Date, endTime?: Date, exitCode?: Number);
	}

	interface VcGuestProcessManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		listProcessesInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: Number[]): VcGuestProcessInfo[];
		readEnvironmentVariableInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: String[]): String[];
		startProgramInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: VcGuestProgramSpec): Number;
		terminateProcessInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: Number): void;
	}

	declare const VcGuestProcessManager: VcGuestProcessManager;

	declare class VcGuestProcessNotFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		pid: Number;

		constructor();
		constructor(pid?: Number);
		printStackTrace(): void;
	}

	declare class VcGuestProgramSpec
	{
		arguments: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		envVariables: String[];
		programPath: String;
		workingDirectory: String;

		constructor();
		constructor(programPath?: String, arguments?: String, workingDirectory?: String, envVariables?: String[]);
	}

	declare class VcGuestRegistryFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		windowsSystemErrorCode: Number;

		constructor();
		constructor(windowsSystemErrorCode?: Number);
		printStackTrace(): void;
	}

	declare class VcGuestRegistryKeyAlreadyExists
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		keyName: String;
		readonly localizedMessage: String;
		message: String;
		windowsSystemErrorCode: Number;

		constructor();
		constructor(windowsSystemErrorCode?: Number, keyName?: String);
		printStackTrace(): void;
	}

	declare class VcGuestRegistryKeyFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		keyName: String;
		readonly localizedMessage: String;
		message: String;
		windowsSystemErrorCode: Number;

		constructor();
		constructor(windowsSystemErrorCode?: Number, keyName?: String);
		printStackTrace(): void;
	}

	declare class VcGuestRegistryKeyHasSubkeys
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		keyName: String;
		readonly localizedMessage: String;
		message: String;
		windowsSystemErrorCode: Number;

		constructor();
		constructor(windowsSystemErrorCode?: Number, keyName?: String);
		printStackTrace(): void;
	}

	declare class VcGuestRegistryKeyInvalid
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		keyName: String;
		readonly localizedMessage: String;
		message: String;
		windowsSystemErrorCode: Number;

		constructor();
		constructor(windowsSystemErrorCode?: Number, keyName?: String);
		printStackTrace(): void;
	}

	declare class VcGuestRegistryKeyParentVolatile
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		keyName: String;
		readonly localizedMessage: String;
		message: String;
		windowsSystemErrorCode: Number;

		constructor();
		constructor(windowsSystemErrorCode?: Number, keyName?: String);
		printStackTrace(): void;
	}

	declare class VcGuestRegistryValueFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		keyName: String;
		readonly localizedMessage: String;
		message: String;
		valueName: String;
		windowsSystemErrorCode: Number;

		constructor();
		constructor(windowsSystemErrorCode?: Number, keyName?: String, valueName?: String);
		printStackTrace(): void;
	}

	declare class VcGuestRegistryValueNotFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		keyName: String;
		readonly localizedMessage: String;
		message: String;
		valueName: String;
		windowsSystemErrorCode: Number;

		constructor();
		constructor(windowsSystemErrorCode?: Number, keyName?: String, valueName?: String);
		printStackTrace(): void;
	}

	declare class VcGuestRegKeyNameSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		registryPath: String;
		wowBitness: String;

		constructor();
		constructor(registryPath?: String, wowBitness?: String);
	}

	declare class VcGuestRegKeyRecordSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		key: VcGuestRegKeySpec;

		constructor();
		constructor(key?: VcGuestRegKeySpec, fault?: VcLocalizedMethodFault);
	}

	declare class VcGuestRegKeySpec
	{
		classType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyName: VcGuestRegKeyNameSpec;
		lastWritten: Date;

		constructor();
		constructor(keyName?: VcGuestRegKeyNameSpec, classType?: String, lastWritten?: Date);
	}

	interface VcGuestRegKeyWowSpec
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly WOW32: VcGuestRegKeyWowSpec;
		readonly WOW64: VcGuestRegKeyWowSpec;
		readonly WOWNative: VcGuestRegKeyWowSpec;

		fromString(value?: VcGuestRegKeyWowSpec): VcGuestRegKeyWowSpec;
	}

	declare const VcGuestRegKeyWowSpec: VcGuestRegKeyWowSpec;

	declare class VcGuestRegValueBinarySpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcGuestRegValueDataSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcGuestRegValueDwordSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		value: Number;

		constructor();
		constructor(value?: Number);
	}

	declare class VcGuestRegValueExpandStringSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		value: String;

		constructor();
		constructor(value?: String);
	}

	declare class VcGuestRegValueMultiStringSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		value: String[];

		constructor();
		constructor(value?: String[]);
	}

	declare class VcGuestRegValueNameSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyName: VcGuestRegKeyNameSpec;
		name: String;

		constructor();
		constructor(keyName?: VcGuestRegKeyNameSpec, name?: String);
	}

	declare class VcGuestRegValueQwordSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		value: Number;

		constructor();
		constructor(value?: Number);
	}

	declare class VcGuestRegValueSpec
	{
		data: VcGuestRegValueDataSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: VcGuestRegValueNameSpec;

		constructor();
		constructor(name?: VcGuestRegValueNameSpec, data?: VcGuestRegValueDataSpec);
	}

	declare class VcGuestRegValueStringSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		value: String;

		constructor();
		constructor(value?: String);
	}

	declare class VcGuestScreenInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		height: Number;
		width: Number;

		constructor();
		constructor(width?: Number, height?: Number);
	}

	declare class VcGuestStackInfo
	{
		dhcpConfig: VcNetDhcpConfigInfo;
		dnsConfig: VcNetDnsConfigInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipRouteConfig: VcNetIpRouteConfigInfo;
		ipStackConfig: VcKeyValue[];

		constructor();
		constructor(dnsConfig?: VcNetDnsConfigInfo, ipRouteConfig?: VcNetIpRouteConfigInfo, ipStackConfig?: VcKeyValue[], dhcpConfig?: VcNetDhcpConfigInfo);
	}

	declare class VcGuestWindowsFileAttributes
	{
		accessTime: Date;
		createTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hidden: boolean;
		modificationTime: Date;
		readOnly: boolean;
		symlinkTarget: String;

		constructor(modificationTime?: Date, accessTime?: Date, symlinkTarget?: String, hidden?: boolean, readOnly?: boolean, createTime?: Date);
		constructor();
		isHidden(): boolean;
		isReadOnly(): boolean;
	}

	declare class VcGuestWindowsProgramSpec
	{
		arguments: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		envVariables: String[];
		programPath: String;
		startMinimized: boolean;
		workingDirectory: String;

		constructor();
		constructor(programPath?: String, arguments?: String, workingDirectory?: String, envVariables?: String[], startMinimized?: boolean);
	}

	interface VcGuestWindowsRegistryManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createRegistryKeyInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: VcGuestRegKeyNameSpec, arg3?: boolean, arg4?: String): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteRegistryKeyInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: VcGuestRegKeyNameSpec, arg3?: boolean): void;
		deleteRegistryValueInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: VcGuestRegValueNameSpec): void;
		listRegistryKeysInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: VcGuestRegKeyNameSpec, arg3?: boolean, arg4?: String): VcGuestRegKeyRecordSpec[];
		listRegistryValuesInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: VcGuestRegKeyNameSpec, arg3?: boolean, arg4?: String): VcGuestRegValueSpec[];
		setRegistryValueInGuest(arg0?: VcVirtualMachine, arg1?: VcGuestAuthentication, arg2?: VcGuestRegValueSpec): void;
	}

	declare const VcGuestWindowsRegistryManager: VcGuestWindowsRegistryManager;

	declare class VcHAErrorsAtDest
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcHbrDiskMigrationAction
	{
		collectionId: String;
		collectionName: String;
		destination: VcDatastore;
		diskIds: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ioLatencyDstBefore: Number;
		ioLatencySrcBefore: Number;
		sizeTransferred: Number;
		source: VcDatastore;
		spaceUtilDstAfter: Number;
		spaceUtilDstBefore: Number;
		spaceUtilSrcAfter: Number;
		spaceUtilSrcBefore: Number;
		target: VcManagedObject;
		type: String;

		constructor();
		constructor(type?: String, target?: VcManagedObject, collectionId?: String, collectionName?: String, diskIds?: String[], source?: VcDatastore, destination?: VcDatastore, sizeTransferred?: Number, spaceUtilSrcBefore?: Number, spaceUtilDstBefore?: Number, spaceUtilSrcAfter?: Number, spaceUtilDstAfter?: Number, ioLatencySrcBefore?: Number, ioLatencyDstBefore?: Number);
	}

	interface VcHbrManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		hbrCreateInstance_Task(arg0?: VcVirtualMachine, arg1?: String): VcTask;
		hbrDisableReplication_Task(arg0?: VcVirtualMachine): VcTask;
		hbrEnableReplication_Task(arg0?: VcVirtualMachine, arg1?: VcReplicationConfigSpec): VcTask;
		hbrFullSync_Task(arg0?: VcVirtualMachine): VcTask;
		hbrPauseReplication_Task(arg0?: VcVirtualMachine): VcTask;
		hbrQueryReplicationCapabilities(arg0?: VcVirtualMachine[]): VcHbrManagerVmReplicationCapability[];
		hbrQueryReplicationState(arg0?: VcVirtualMachine): VcHbrManagerReplicationVmInfo;
		hbrReconfigureReplication_Task(arg0?: VcVirtualMachine, arg1?: VcReplicationConfigSpec): VcTask;
		hbrResumeReplication_Task(arg0?: VcVirtualMachine): VcTask;
		hbrRetrieveReplicationConfig(arg0?: VcVirtualMachine): VcReplicationConfigSpec;
		hbrStartOfflineInstance_Task(arg0?: VcVirtualMachine, arg1?: String): VcTask;
		hbrStopOfflineInstance(arg0?: VcVirtualMachine, arg1?: String): void;
	}

	declare const VcHbrManager: VcHbrManager;

	declare class VcHbrManagerReplicationVmInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		imageId: String;
		lastError: VcLocalizedMethodFault;
		progressInfo: VcReplicationVmProgressInfo;
		state: String;

		constructor();
		constructor(state?: String, progressInfo?: VcReplicationVmProgressInfo, imageId?: String, lastError?: VcLocalizedMethodFault);
	}

	declare class VcHbrManagerVmReplicationCapability
	{
		compressionSupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		maxSupportedSourceDiskCapacity: Number;
		minRpo: Number;
		supportedQuiesceMode: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, supportedQuiesceMode?: String, compressionSupported?: boolean, maxSupportedSourceDiskCapacity?: Number, minRpo?: Number, fault?: VcLocalizedMethodFault);
	}

	declare class VcHbrObjectInfo
	{
		allocatedSizeKb: Number;
		contentID: Number;
		dependents: String[];
		descriptorPath: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		managed: boolean;
		objectType: String;
		parentUri: String;
		policy: String;
		runningPoint: boolean;
		sizeKb: Number;
		tags: VcHbrObjectTag[];
		totalAllocatedSizeKb: Number;
		unsharedSizeKb: Number;

		constructor();
		constructor(objectType?: String, managed?: boolean, runningPoint?: boolean, contentID?: Number, descriptorPath?: String, parentUri?: String, policy?: String, sizeKb?: Number, allocatedSizeKb?: Number, unsharedSizeKb?: Number, totalAllocatedSizeKb?: Number, tags?: VcHbrObjectTag[], dependents?: String[]);
		isRunningPoint(): boolean;
	}

	declare class VcHbrObjectTag
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		value: String;

		constructor();
		constructor(key?: String, value?: String);
	}

	declare class VcHealthStatusChangedEvent
	{
		chainId: Number;
		changeTag: String;
		componentId: String;
		componentName: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newStatus: String;
		oldStatus: String;
		serviceId: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, componentId?: String, oldStatus?: String, newStatus?: String, componentName?: String, serviceId?: String);
	}

	declare class VcHealthSystemRuntime
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hardwareStatusInfo: VcHostHardwareStatusInfo;
		systemHealthInfo: VcHostSystemHealthInfo;

		constructor();
		constructor(systemHealthInfo?: VcHostSystemHealthInfo, hardwareStatusInfo?: VcHostHardwareStatusInfo);
	}

	declare class VcHealthUpdate
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		healthUpdateInfoId: String;
		id: String;
		remediation: String;
		status: VcManagedEntityStatus;

		constructor();
		constructor(entity?: VcManagedEntity, healthUpdateInfoId?: String, id?: String, status?: VcManagedEntityStatus, remediation?: String);
	}

	declare class VcHealthUpdateInfo
	{
		componentType: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;

		constructor();
		constructor(id?: String, componentType?: String, description?: String);
	}

	interface VcHealthUpdateInfoComponentType
	{
		readonly Fan: VcHealthUpdateInfoComponentType;
		readonly id: String;
		readonly Memory: VcHealthUpdateInfoComponentType;
		readonly name: String;
		readonly Network: VcHealthUpdateInfoComponentType;
		readonly Power: VcHealthUpdateInfoComponentType;
		readonly Storage: VcHealthUpdateInfoComponentType;
		readonly value: String;

		fromString(value?: VcHealthUpdateInfoComponentType): VcHealthUpdateInfoComponentType;
	}

	declare const VcHealthUpdateInfoComponentType: VcHealthUpdateInfoComponentType;

	interface VcHealthUpdateManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addFilter(arg0?: String, arg1?: String, arg2?: String[]): String;
		addFilterEntities(arg0?: String, arg1?: VcManagedEntity[]): void;
		addMonitoredEntities(arg0?: String, arg1?: VcManagedEntity[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		hasMonitoredEntity(arg0?: String, arg1?: VcManagedEntity): boolean;
		hasProvider(arg0?: String): boolean;
		postHealthUpdates(arg0?: String, arg1?: VcHealthUpdate[]): void;
		queryFilterEntities(arg0?: String): VcManagedEntity[];
		queryFilterInfoIds(arg0?: String): String[];
		queryFilterList(arg0?: String): String[];
		queryFilterName(arg0?: String): String;
		queryHealthUpdateInfos(arg0?: String): VcHealthUpdateInfo[];
		queryHealthUpdates(arg0?: String): VcHealthUpdate[];
		queryMonitoredEntities(arg0?: String): VcManagedEntity[];
		queryProviderList(): String[];
		queryProviderName(arg0?: String): String;
		queryUnmonitoredHosts(arg0?: String, arg1?: VcClusterComputeResource): VcHostSystem[];
		registerHealthUpdateProvider(arg0?: String, arg1?: VcHealthUpdateInfo[]): String;
		removeFilter(arg0?: String): void;
		removeFilterEntities(arg0?: String, arg1?: VcManagedEntity[]): void;
		removeMonitoredEntities(arg0?: String, arg1?: VcManagedEntity[]): void;
		unregisterHealthUpdateProvider(arg0?: String): void;
	}

	declare const VcHealthUpdateManager: VcHealthUpdateManager;

	declare class VcHeterogenousHostsBlockingEVC
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(faults?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	interface VcHistoryCollector
	{
		readonly filter_AnyValue: Object;
		readonly filter_FloatValue: Number;
		readonly filter_IntValue: Number;
		readonly filter_LongValue: Number;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyCollector(): void;
		resetCollector(): void;
		rewindCollector(): void;
	}

	declare const VcHistoryCollector: VcHistoryCollector;

	declare class VcHostAccessControlEntry
	{
		accessMode: VcHostAccessMode;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		group: boolean;
		principal: String;

		constructor();
		constructor(principal?: String, group?: boolean, accessMode?: VcHostAccessMode);
	}

	interface VcHostAccessManager
	{
		id: String;
		lockdownMode: VcHostLockdownMode;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		changeAccessMode(arg0?: String, arg1?: boolean, arg2?: VcHostAccessMode): void;
		changeLockdownMode(arg0?: VcHostLockdownMode): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryDcuiAccess(): String[];
		queryLockdownExceptions(): String[];
		querySystemUsers(): String[];
		retrieveHostAccessControlEntries(): VcHostAccessControlEntry[];
		updateDcuiAccess(arg0?: String[]): void;
		updateLockdownExceptions(arg0?: String[]): void;
		updateSystemUsers(arg0?: String[]): void;
	}

	declare const VcHostAccessManager: VcHostAccessManager;

	interface VcHostAccessMode
	{
		readonly accessAdmin: VcHostAccessMode;
		readonly accessNoAccess: VcHostAccessMode;
		readonly accessNone: VcHostAccessMode;
		readonly accessOther: VcHostAccessMode;
		readonly accessReadOnly: VcHostAccessMode;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostAccessMode): VcHostAccessMode;
	}

	declare const VcHostAccessMode: VcHostAccessMode;

	declare class VcHostAccessRestrictedToManagementServer
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		managementServer: String;
		message: String;

		constructor();
		constructor(managementServer?: String);
		printStackTrace(): void;
	}

	declare class VcHostAccountSpec
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		password: String;

		constructor();
		constructor(id?: String, password?: String, description?: String);
	}

	declare class VcHostActiveDirectory
	{
		changeOperation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		spec: VcHostActiveDirectorySpec;

		constructor();
		constructor(changeOperation?: String, spec?: VcHostActiveDirectorySpec);
	}

	interface VcHostActiveDirectoryAuthentication
	{
		id: String;
		readonly info: VcHostAuthenticationStoreInfo;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		disableSmartCardAuthentication(): void;
		enableSmartCardAuthentication(): void;
		importCertificateForCAM_Task(arg0?: String, arg1?: String): VcTask;
		installSmartCardTrustAnchor(arg0?: String): void;
		joinDomain_Task(arg0?: String, arg1?: String, arg2?: String): VcTask;
		joinDomainWithCAM_Task(arg0?: String, arg1?: String): VcTask;
		leaveCurrentDomain_Task(arg0?: boolean): VcTask;
		listSmartCardTrustAnchors(): String[];
		removeSmartCardTrustAnchor(arg0?: String, arg1?: String): void;
		removeSmartCardTrustAnchorByFingerprint(arg0?: String, arg1?: String): void;
		replaceSmartCardTrustAnchors(arg0?: String[]): void;
	}

	declare const VcHostActiveDirectoryAuthentication: VcHostActiveDirectoryAuthentication;

	interface VcHostActiveDirectoryAuthenticationCertificateDigest
	{
		readonly id: String;
		readonly name: String;
		readonly SHA1: VcHostActiveDirectoryAuthenticationCertificateDigest;
		readonly value: String;

		fromString(value?: VcHostActiveDirectoryAuthenticationCertificateDigest): VcHostActiveDirectoryAuthenticationCertificateDigest;
	}

	declare const VcHostActiveDirectoryAuthenticationCertificateDigest: VcHostActiveDirectoryAuthenticationCertificateDigest;

	declare class VcHostActiveDirectoryInfo
	{
		domainMembershipStatus: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		joinedDomain: String;
		smartCardAuthenticationEnabled: boolean;
		trustedDomain: String[];

		constructor();
		constructor(enabled?: boolean, joinedDomain?: String, trustedDomain?: String[], domainMembershipStatus?: String, smartCardAuthenticationEnabled?: boolean);
		isSmartCardAuthenticationEnabled(): boolean;
	}

	interface VcHostActiveDirectoryInfoDomainMembershipStatus
	{
		readonly clientTrustBroken: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly id: String;
		readonly inconsistentTrust: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly name: String;
		readonly noServers: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly ok: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly otherProblem: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly serverTrustBroken: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly unknown: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly value: String;

		fromString(value?: VcHostActiveDirectoryInfoDomainMembershipStatus): VcHostActiveDirectoryInfoDomainMembershipStatus;
	}

	declare const VcHostActiveDirectoryInfoDomainMembershipStatus: VcHostActiveDirectoryInfoDomainMembershipStatus;

	declare class VcHostActiveDirectorySpec
	{
		camServer: String;
		domainName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		password: String;
		smartCardAuthenticationEnabled: boolean;
		smartCardTrustAnchors: String[];
		thumbprint: String;
		userName: String;

		constructor();
		constructor(domainName?: String, userName?: String, password?: String, camServer?: String, thumbprint?: String, smartCardAuthenticationEnabled?: boolean, smartCardTrustAnchors?: String[]);
		isSmartCardAuthenticationEnabled(): boolean;
	}

	declare class VcHostAddedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostAddFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostname: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostname?: String);
	}

	declare class VcHostAdminDisableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostAdminEnableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostApplyProfile
	{
		authentication: VcAuthenticationProfile;
		copyEnableStatus: boolean;
		datetime: VcDateTimeProfile;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		firewall: VcFirewallProfile;
		memory: VcHostMemoryProfile;
		network: VcNetworkProfile;
		option: VcOptionProfile[];
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		security: VcSecurityProfile;
		service: VcServiceProfile[];
		storage: VcStorageProfile;
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;
		userAccount: VcUserProfile[];
		usergroupAccount: VcUserGroupProfile[];

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, memory?: VcHostMemoryProfile, storage?: VcStorageProfile, network?: VcNetworkProfile, datetime?: VcDateTimeProfile, firewall?: VcFirewallProfile, security?: VcSecurityProfile, service?: VcServiceProfile[], option?: VcOptionProfile[], userAccount?: VcUserProfile[], usergroupAccount?: VcUserGroupProfile[], authentication?: VcAuthenticationProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	interface VcHostAuthenticationManager
	{
		id: String;
		info: VcHostAuthenticationManagerInfo;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		supportedStore: VcHostAuthenticationStore[];
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostAuthenticationManager: VcHostAuthenticationManager;

	declare class VcHostAuthenticationManagerInfo
	{
		authConfig: VcHostAuthenticationStoreInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(authConfig?: VcHostAuthenticationStoreInfo[]);
	}

	interface VcHostAuthenticationStore
	{
		id: String;
		info: VcHostAuthenticationStoreInfo;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostAuthenticationStore: VcHostAuthenticationStore;

	declare class VcHostAuthenticationStoreInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;

		constructor();
		constructor(enabled?: boolean);
	}

	interface VcHostAutoStartManager
	{
		config: VcHostAutoStartManagerConfig;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		autoStartPowerOff(): void;
		autoStartPowerOn(): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureAutostart(arg0?: VcHostAutoStartManagerConfig): void;
	}

	declare const VcHostAutoStartManager: VcHostAutoStartManager;

	declare class VcHostAutoStartManagerConfig
	{
		defaults: VcAutoStartDefaults;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		powerInfo: VcAutoStartPowerInfo[];

		constructor();
		constructor(defaults?: VcAutoStartDefaults, powerInfo?: VcAutoStartPowerInfo[]);
	}

	declare class VcHostBIOSInfo
	{
		biosVersion: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		firmwareMajorRelease: Number;
		firmwareMinorRelease: Number;
		majorRelease: Number;
		minorRelease: Number;
		releaseDate: Date;
		vendor: String;

		constructor();
		constructor(biosVersion?: String, releaseDate?: Date, vendor?: String, majorRelease?: Number, minorRelease?: Number, firmwareMajorRelease?: Number, firmwareMinorRelease?: Number);
	}

	declare class VcHostBlockAdapterTargetTransport
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcHostBlockHba
	{
		bus: Number;
		device: String;
		driver: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		model: String;
		pci: String;
		status: String;

		constructor();
		constructor(key?: String, device?: String, bus?: Number, status?: String, model?: String, driver?: String, pci?: String);
	}

	declare class VcHostBootDevice
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;

		constructor();
		constructor(key?: String, description?: String);
	}

	declare class VcHostBootDeviceInfo
	{
		bootDevices: VcHostBootDevice[];
		currentBootDeviceKey: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(bootDevices?: VcHostBootDevice[], currentBootDeviceKey?: String);
	}

	interface VcHostBootDeviceSystem
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryBootDevices(): VcHostBootDeviceInfo;
		updateBootDevice(arg0?: String): void;
	}

	declare const VcHostBootDeviceSystem: VcHostBootDeviceSystem;

	declare class VcHostCacheConfigurationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcDatastore;
		swapSize: Number;

		constructor();
		constructor(key?: VcDatastore, swapSize?: Number);
	}

	interface VcHostCacheConfigurationManager
	{
		cacheConfigurationInfo: VcHostCacheConfigurationInfo[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		configureHostCache_Task(arg0?: VcHostCacheConfigurationSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostCacheConfigurationManager: VcHostCacheConfigurationManager;

	declare class VcHostCacheConfigurationSpec
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		swapSize: Number;

		constructor();
		constructor(datastore?: VcDatastore, swapSize?: Number);
	}

	declare class VcHostCapability
	{
		accel3dSupported: boolean;
		backgroundSnapshotsSupported: boolean;
		checkpointFtCompatibilityIssues: String[];
		checkpointFtSupported: boolean;
		cloneFromSnapshotSupported: boolean;
		cpuHwMmuSupported: boolean;
		cpuMemoryResourceConfigurationSupported: boolean;
		cryptoSupported: boolean;
		datastorePrincipalSupported: boolean;
		deltaDiskBackingsSupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eightPlusHostVmfsSharedAccessSupported: boolean;
		encryptedVMotionSupported: boolean;
		encryptionCBRCSupported: boolean;
		encryptionChangeOnAddRemoveSupported: boolean;
		encryptionFaultToleranceSupported: boolean;
		encryptionHBRSupported: boolean;
		encryptionHotOperationSupported: boolean;
		encryptionMemorySaveSupported: boolean;
		encryptionRDMSupported: boolean;
		encryptionVFlashSupported: boolean;
		encryptionWithSnapshotsSupported: boolean;
		featureCapabilitiesSupported: boolean;
		firewallIpRulesSupported: boolean;
		ftCompatibilityIssues: String[];
		ftSupported: boolean;
		gatewayOnNicSupported: boolean;
		hbrNicSelectionSupported: boolean;
		highGuestMemSupported: boolean;
		hostAccessManagerSupported: boolean;
		interVMCommunicationThroughVMCISupported: boolean;
		ipmiSupported: boolean;
		iscsiSupported: boolean;
		latencySensitivitySupported: boolean;
		localSwapDatastoreSupported: boolean;
		loginBySSLThumbprintSupported: boolean;
		maintenanceModeSupported: boolean;
		markAsLocalSupported: boolean;
		markAsSsdSupported: boolean;
		maxHostRunningVms: Number;
		maxHostSupportedVcpus: Number;
		maxNumDisksSVMotion: Number;
		maxRegisteredVMs: Number;
		maxRunningVMs: Number;
		maxSupportedVcpus: Number;
		maxSupportedVMs: Number;
		maxVcpusPerFtVm: Number;
		messageBusProxySupported: boolean;
		multipleNetworkStackInstanceSupported: boolean;
		nestedHVSupported: boolean;
		nfs41Krb5iSupported: boolean;
		nfs41Supported: boolean;
		nfsSupported: boolean;
		nicTeamingSupported: boolean;
		oneKVolumeAPIsSupported: boolean;
		perVMNetworkTrafficShapingSupported: boolean;
		perVmSwapFiles: boolean;
		pMemSupported: boolean;
		preAssignedPCIUnitNumbersSupported: boolean;
		provisioningNicSelectionSupported: boolean;
		rebootSupported: boolean;
		recordReplaySupported: boolean;
		recursiveResourcePoolsSupported: boolean;
		reliableMemoryAware: boolean;
		replayCompatibilityIssues: String[];
		replayUnsupportedReason: String;
		restrictedSnapshotRelocateSupported: boolean;
		sanSupported: boolean;
		scaledScreenshotSupported: boolean;
		scheduledHardwareUpgradeSupported: boolean;
		screenshotSupported: boolean;
		servicePackageInfoSupported: boolean;
		shutdownSupported: boolean;
		smartCardAuthenticationSupported: boolean;
		smpFtCompatibilityIssues: String[];
		smpFtSupported: boolean;
		snapshotRelayoutSupported: boolean;
		standbySupported: boolean;
		storageIORMSupported: boolean;
		storagePolicySupported: boolean;
		storageVMotionSupported: boolean;
		supportedCpuFeature: VcHostCpuIdInfo[];
		supportedVmfsMajorVersion: Number[];
		suspendedRelocateSupported: boolean;
		tpmSupported: boolean;
		turnDiskLocatorLedSupported: boolean;
		unsharedSwapVMotionSupported: boolean;
		upitSupported: boolean;
		vFlashSupported: boolean;
		virtualExecUsageSupported: boolean;
		virtualVolumeDatastoreSupported: boolean;
		vlanTaggingSupported: boolean;
		vmDirectPathGen2Supported: boolean;
		vmDirectPathGen2UnsupportedReason: String[];
		vmDirectPathGen2UnsupportedReasonExtended: String;
		vmfsDatastoreMountCapable: boolean;
		vmotionAcrossNetworkSupported: boolean;
		vmotionSupported: boolean;
		vmotionWithStorageVMotionSupported: boolean;
		vPMCSupported: boolean;
		vrNfcNicSelectionSupported: boolean;
		vsanSupported: boolean;
		vStorageCapable: boolean;

		constructor();
		constructor(recursiveResourcePoolsSupported?: boolean, cpuMemoryResourceConfigurationSupported?: boolean, rebootSupported?: boolean, shutdownSupported?: boolean, vmotionSupported?: boolean, standbySupported?: boolean, ipmiSupported?: boolean, maxSupportedVMs?: Number, maxRunningVMs?: Number, maxSupportedVcpus?: Number, maxRegisteredVMs?: Number, datastorePrincipalSupported?: boolean, sanSupported?: boolean, nfsSupported?: boolean, iscsiSupported?: boolean, vlanTaggingSupported?: boolean, nicTeamingSupported?: boolean, highGuestMemSupported?: boolean, maintenanceModeSupported?: boolean, suspendedRelocateSupported?: boolean, restrictedSnapshotRelocateSupported?: boolean, perVmSwapFiles?: boolean, localSwapDatastoreSupported?: boolean, unsharedSwapVMotionSupported?: boolean, backgroundSnapshotsSupported?: boolean, preAssignedPCIUnitNumbersSupported?: boolean, screenshotSupported?: boolean, scaledScreenshotSupported?: boolean, storageVMotionSupported?: boolean, vmotionWithStorageVMotionSupported?: boolean, vmotionAcrossNetworkSupported?: boolean, maxNumDisksSVMotion?: Number, hbrNicSelectionSupported?: boolean, vrNfcNicSelectionSupported?: boolean, recordReplaySupported?: boolean, ftSupported?: boolean, replayUnsupportedReason?: String, replayCompatibilityIssues?: String[], checkpointFtSupported?: boolean, smpFtSupported?: boolean, ftCompatibilityIssues?: String[], checkpointFtCompatibilityIssues?: String[], smpFtCompatibilityIssues?: String[], maxVcpusPerFtVm?: Number, loginBySSLThumbprintSupported?: boolean, cloneFromSnapshotSupported?: boolean, deltaDiskBackingsSupported?: boolean, perVMNetworkTrafficShapingSupported?: boolean, tpmSupported?: boolean, supportedCpuFeature?: VcHostCpuIdInfo[], virtualExecUsageSupported?: boolean, storageIORMSupported?: boolean, vmDirectPathGen2Supported?: boolean, vmDirectPathGen2UnsupportedReason?: String[], vmDirectPathGen2UnsupportedReasonExtended?: String, supportedVmfsMajorVersion?: Number[], vStorageCapable?: boolean, snapshotRelayoutSupported?: boolean, firewallIpRulesSupported?: boolean, servicePackageInfoSupported?: boolean, maxHostRunningVms?: Number, maxHostSupportedVcpus?: Number, vmfsDatastoreMountCapable?: boolean, eightPlusHostVmfsSharedAccessSupported?: boolean, nestedHVSupported?: boolean, vPMCSupported?: boolean, interVMCommunicationThroughVMCISupported?: boolean, scheduledHardwareUpgradeSupported?: boolean, featureCapabilitiesSupported?: boolean, latencySensitivitySupported?: boolean, storagePolicySupported?: boolean, accel3dSupported?: boolean, reliableMemoryAware?: boolean, multipleNetworkStackInstanceSupported?: boolean, messageBusProxySupported?: boolean, vsanSupported?: boolean, vFlashSupported?: boolean, hostAccessManagerSupported?: boolean, provisioningNicSelectionSupported?: boolean, nfs41Supported?: boolean, nfs41Krb5iSupported?: boolean, turnDiskLocatorLedSupported?: boolean, virtualVolumeDatastoreSupported?: boolean, markAsSsdSupported?: boolean, markAsLocalSupported?: boolean, smartCardAuthenticationSupported?: boolean, pMemSupported?: boolean, cryptoSupported?: boolean, oneKVolumeAPIsSupported?: boolean, gatewayOnNicSupported?: boolean, upitSupported?: boolean, cpuHwMmuSupported?: boolean, encryptedVMotionSupported?: boolean, encryptionChangeOnAddRemoveSupported?: boolean, encryptionHotOperationSupported?: boolean, encryptionWithSnapshotsSupported?: boolean, encryptionFaultToleranceSupported?: boolean, encryptionMemorySaveSupported?: boolean, encryptionRDMSupported?: boolean, encryptionVFlashSupported?: boolean, encryptionCBRCSupported?: boolean, encryptionHBRSupported?: boolean);
		isAccel3dSupported(): boolean;
		isCheckpointFtSupported(): boolean;
		isCloneFromSnapshotSupported(): boolean;
		isCpuHwMmuSupported(): boolean;
		isCryptoSupported(): boolean;
		isDeltaDiskBackingsSupported(): boolean;
		isEightPlusHostVmfsSharedAccessSupported(): boolean;
		isEncryptedVMotionSupported(): boolean;
		isEncryptionCBRCSupported(): boolean;
		isEncryptionChangeOnAddRemoveSupported(): boolean;
		isEncryptionFaultToleranceSupported(): boolean;
		isEncryptionHBRSupported(): boolean;
		isEncryptionHotOperationSupported(): boolean;
		isEncryptionMemorySaveSupported(): boolean;
		isEncryptionRDMSupported(): boolean;
		isEncryptionVFlashSupported(): boolean;
		isEncryptionWithSnapshotsSupported(): boolean;
		isFeatureCapabilitiesSupported(): boolean;
		isFirewallIpRulesSupported(): boolean;
		isFtSupported(): boolean;
		isGatewayOnNicSupported(): boolean;
		isHbrNicSelectionSupported(): boolean;
		isHostAccessManagerSupported(): boolean;
		isInterVMCommunicationThroughVMCISupported(): boolean;
		isIpmiSupported(): boolean;
		isLatencySensitivitySupported(): boolean;
		isLoginBySSLThumbprintSupported(): boolean;
		isMarkAsLocalSupported(): boolean;
		isMarkAsSsdSupported(): boolean;
		isMessageBusProxySupported(): boolean;
		isMultipleNetworkStackInstanceSupported(): boolean;
		isNestedHVSupported(): boolean;
		isNfs41Krb5iSupported(): boolean;
		isNfs41Supported(): boolean;
		isOneKVolumeAPIsSupported(): boolean;
		isPerVMNetworkTrafficShapingSupported(): boolean;
		isPMemSupported(): boolean;
		isProvisioningNicSelectionSupported(): boolean;
		isRecordReplaySupported(): boolean;
		isReliableMemoryAware(): boolean;
		isScheduledHardwareUpgradeSupported(): boolean;
		isServicePackageInfoSupported(): boolean;
		isSmartCardAuthenticationSupported(): boolean;
		isSmpFtSupported(): boolean;
		isSnapshotRelayoutSupported(): boolean;
		isStorageIORMSupported(): boolean;
		isStoragePolicySupported(): boolean;
		isStorageVMotionSupported(): boolean;
		isTpmSupported(): boolean;
		isTurnDiskLocatorLedSupported(): boolean;
		isUpitSupported(): boolean;
		isVFlashSupported(): boolean;
		isVirtualExecUsageSupported(): boolean;
		isVirtualVolumeDatastoreSupported(): boolean;
		isVmDirectPathGen2Supported(): boolean;
		isVmfsDatastoreMountCapable(): boolean;
		isVmotionAcrossNetworkSupported(): boolean;
		isVmotionWithStorageVMotionSupported(): boolean;
		isVPMCSupported(): boolean;
		isVrNfcNicSelectionSupported(): boolean;
		isVsanSupported(): boolean;
		isVStorageCapable(): boolean;
	}

	interface VcHostCapabilityFtUnsupportedReason
	{
		readonly cpuHvDisabled: VcHostCapabilityFtUnsupportedReason;
		readonly cpuHvUnsupported: VcHostCapabilityFtUnsupportedReason;
		readonly cpuHwmmuUnsupported: VcHostCapabilityFtUnsupportedReason;
		readonly ftNotLicensed: VcHostCapabilityFtUnsupportedReason;
		readonly haAgentIssue: VcHostCapabilityFtUnsupportedReason;
		readonly id: String;
		readonly missingFTLoggingNic: VcHostCapabilityFtUnsupportedReason;
		readonly missingVMotionNic: VcHostCapabilityFtUnsupportedReason;
		readonly name: String;
		readonly unsupportedProduct: VcHostCapabilityFtUnsupportedReason;
		readonly value: String;
		readonly vMotionNotLicensed: VcHostCapabilityFtUnsupportedReason;

		fromString(value?: VcHostCapabilityFtUnsupportedReason): VcHostCapabilityFtUnsupportedReason;
	}

	declare const VcHostCapabilityFtUnsupportedReason: VcHostCapabilityFtUnsupportedReason;

	interface VcHostCapabilityVmDirectPathGen2UnsupportedReason
	{
		readonly hostNptDisabled: VcHostCapabilityVmDirectPathGen2UnsupportedReason;
		readonly hostNptIncompatibleHardware: VcHostCapabilityVmDirectPathGen2UnsupportedReason;
		readonly hostNptIncompatibleProduct: VcHostCapabilityVmDirectPathGen2UnsupportedReason;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostCapabilityVmDirectPathGen2UnsupportedReason): VcHostCapabilityVmDirectPathGen2UnsupportedReason;
	}

	declare const VcHostCapabilityVmDirectPathGen2UnsupportedReason: VcHostCapabilityVmDirectPathGen2UnsupportedReason;

	interface VcHostCertificateManager
	{
		certificateInfo: VcHostCertificateManagerCertificateInfo;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		generateCertificateSigningRequest(arg0?: boolean): String;
		generateCertificateSigningRequestByDn(arg0?: String): String;
		installServerCertificate(arg0?: String): void;
		listCACertificateRevocationLists(): String[];
		listCACertificates(): String[];
		notifyAffectedServices(): void;
		replaceCACertificatesAndCRLs(arg0?: String[], arg1?: String[]): void;
	}

	declare const VcHostCertificateManager: VcHostCertificateManager;

	declare class VcHostCertificateManagerCertificateInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		issuer: String;
		notAfter: Date;
		notBefore: Date;
		status: String;
		subject: String;

		constructor();
		constructor(issuer?: String, notBefore?: Date, notAfter?: Date, subject?: String, status?: String);
	}

	interface VcHostCertificateManagerCertificateInfoCertificateStatus
	{
		readonly expirationImminent: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly expired: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly expiring: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly expiringShortly: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly good: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly id: String;
		readonly name: String;
		readonly revoked: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly unknown: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly value: String;

		fromString(value?: VcHostCertificateManagerCertificateInfoCertificateStatus): VcHostCertificateManagerCertificateInfoCertificateStatus;
	}

	declare const VcHostCertificateManagerCertificateInfoCertificateStatus: VcHostCertificateManagerCertificateInfoCertificateStatus;

	declare class VcHostCnxFailedAccountFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedAlreadyManagedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		serverName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, serverName?: String);
	}

	declare class VcHostCnxFailedBadCcagentEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedBadUsernameEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedBadVersionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedCcagentUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedNetworkErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedNoAccessEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedNoConnectionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedNoLicenseEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedNotFoundEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCnxFailedTimeoutEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostCommunication
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcHostComplianceCheckedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, profile?: VcProfileEventArgument);
	}

	declare class VcHostCompliantEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostConfigAppliedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostConfigChange
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcHostConfigChangeMode
	{
		readonly id: String;
		readonly modify: VcHostConfigChangeMode;
		readonly name: String;
		readonly replace: VcHostConfigChangeMode;
		readonly value: String;

		fromString(value?: VcHostConfigChangeMode): VcHostConfigChangeMode;
	}

	declare const VcHostConfigChangeMode: VcHostConfigChangeMode;

	interface VcHostConfigChangeOperation
	{
		readonly add: VcHostConfigChangeOperation;
		readonly edit: VcHostConfigChangeOperation;
		readonly id: String;
		readonly ignore: VcHostConfigChangeOperation;
		readonly name: String;
		readonly remove: VcHostConfigChangeOperation;
		readonly value: String;

		fromString(value?: VcHostConfigChangeOperation): VcHostConfigChangeOperation;
	}

	declare const VcHostConfigChangeOperation: VcHostConfigChangeOperation;

	declare class VcHostConfigFailed
	{
		failure: VcLocalizedMethodFault[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(failure?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcHostConfigFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcHostConfigInfo
	{
		activeDiagnosticPartition: VcHostDiagnosticPartition;
		adminDisabled: boolean;
		authenticationManagerInfo: VcHostAuthenticationManagerInfo;
		autoStart: VcHostAutoStartManagerConfig;
		cacheConfigurationInfo: VcHostCacheConfigurationInfo[];
		capabilities: VcHostNetCapabilities;
		certificate: Number[];
		consoleReservation: VcServiceConsoleReservationInfo;
		datastoreCapabilities: VcHostDatastoreSystemCapabilities;
		datastorePrincipal: String;
		dateTimeInfo: VcHostDateTimeInfo;
		deploymentInfo: VcHostDeploymentInfo;
		domainList: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		featureCapability: VcHostFeatureCapability[];
		featureVersion: VcHostFeatureVersionInfo[];
		fileSystemVolume: VcHostFileSystemVolumeInfo;
		firewall: VcHostFirewallInfo;
		flags: VcHostFlagInfo;
		graphicsConfig: VcHostGraphicsConfig;
		graphicsInfo: VcHostGraphicsInfo[];
		host: VcHostSystem;
		hyperThread: VcHostHyperThreadScheduleInfo;
		ioFilterInfo: VcHostIoFilterInfo[];
		ipmi: VcHostIpmiInfo;
		localSwapDatastore: VcDatastore;
		lockdownMode: VcHostLockdownMode;
		maskedFeatureCapability: VcHostFeatureCapability[];
		multipathState: VcHostMultipathStateInfo;
		network: VcHostNetworkInfo;
		offloadCapabilities: VcHostNetOffloadCapabilities;
		option: VcOptionValue[];
		optionDef: VcOptionDef[];
		pciPassthruInfo: VcHostPciPassthruInfo[];
		powerSystemCapability: VcPowerSystemCapability;
		powerSystemInfo: VcPowerSystemInfo;
		product: VcAboutInfo;
		service: VcHostServiceInfo;
		sharedPassthruGpuTypes: String[];
		sriovDevicePool: VcHostSriovDevicePoolInfo[];
		sslThumbprintData: VcHostSslThumbprintInfo[];
		sslThumbprintInfo: VcHostSslThumbprintInfo;
		storageDevice: VcHostStorageDeviceInfo;
		systemFile: String[];
		systemResources: VcHostSystemResourceInfo;
		systemSwapConfiguration: VcHostSystemSwapConfiguration;
		vFlashConfigInfo: VcHostVFlashManagerVFlashConfigInfo;
		virtualMachineReservation: VcVirtualMachineMemoryReservationInfo;
		virtualNicManagerInfo: VcHostVirtualNicManagerInfo;
		vmotion: VcHostVMotionInfo;
		vsanHostConfig: VcVsanHostConfigInfo;
		wakeOnLanCapable: boolean;

		constructor();
		isAdminDisabled(): boolean;
		isWakeOnLanCapable(): boolean;
	}

	declare class VcHostConfigManager
	{
		accountManager: VcHostLocalAccountManager;
		advancedOption: VcOptionManager;
		authenticationManager: VcHostAuthenticationManager;
		autoStartManager: VcHostAutoStartManager;
		bootDeviceSystem: VcHostBootDeviceSystem;
		cacheConfigurationManager: VcHostCacheConfigurationManager;
		certificateManager: VcHostCertificateManager;
		cpuScheduler: VcHostCpuSchedulerSystem;
		cryptoManager: VcCryptoManager;
		datastoreSystem: VcHostDatastoreSystem;
		dateTimeSystem: VcHostDateTimeSystem;
		diagnosticSystem: VcHostDiagnosticSystem;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		esxAgentHostManager: VcHostEsxAgentHostManager;
		firewallSystem: VcHostFirewallSystem;
		firmwareSystem: VcHostFirmwareSystem;
		graphicsManager: VcHostGraphicsManager;
		healthStatusSystem: VcHostHealthStatusSystem;
		hostAccessManager: VcHostAccessManager;
		hostUpdateProxyManager: VcHostHostUpdateProxyManager;
		imageConfigManager: VcHostImageConfigManager;
		iscsiManager: VcIscsiManager;
		kernelModuleSystem: VcHostKernelModuleSystem;
		licenseManager: VcLicenseManager;
		memoryManager: VcHostMemorySystem;
		messageBusProxy: VcMessageBusProxy;
		networkSystem: VcHostNetworkSystem;
		patchManager: VcHostPatchManager;
		pciPassthruSystem: VcHostPciPassthruSystem;
		powerSystem: VcHostPowerSystem;
		serviceSystem: VcHostServiceSystem;
		snmpSystem: VcHostSnmpSystem;
		storageSystem: VcHostStorageSystem;
		userDirectory: VcUserDirectory;
		vFlashManager: VcHostVFlashManager;
		virtualNicManager: VcHostVirtualNicManager;
		vmotionSystem: VcHostVMotionSystem;
		vsanInternalSystem: VcHostVsanInternalSystem;
		vsanSystem: VcHostVsanSystem;

		constructor();
		constructor(cpuScheduler?: VcHostCpuSchedulerSystem, datastoreSystem?: VcHostDatastoreSystem, memoryManager?: VcHostMemorySystem, storageSystem?: VcHostStorageSystem, networkSystem?: VcHostNetworkSystem, vmotionSystem?: VcHostVMotionSystem, virtualNicManager?: VcHostVirtualNicManager, serviceSystem?: VcHostServiceSystem, firewallSystem?: VcHostFirewallSystem, advancedOption?: VcOptionManager, diagnosticSystem?: VcHostDiagnosticSystem, autoStartManager?: VcHostAutoStartManager, snmpSystem?: VcHostSnmpSystem, dateTimeSystem?: VcHostDateTimeSystem, patchManager?: VcHostPatchManager, hostUpdateProxyManager?: VcHostHostUpdateProxyManager, imageConfigManager?: VcHostImageConfigManager, bootDeviceSystem?: VcHostBootDeviceSystem, firmwareSystem?: VcHostFirmwareSystem, healthStatusSystem?: VcHostHealthStatusSystem, pciPassthruSystem?: VcHostPciPassthruSystem, licenseManager?: VcLicenseManager, kernelModuleSystem?: VcHostKernelModuleSystem, authenticationManager?: VcHostAuthenticationManager, powerSystem?: VcHostPowerSystem, cacheConfigurationManager?: VcHostCacheConfigurationManager, esxAgentHostManager?: VcHostEsxAgentHostManager, iscsiManager?: VcIscsiManager, vFlashManager?: VcHostVFlashManager, vsanSystem?: VcHostVsanSystem, messageBusProxy?: VcMessageBusProxy, userDirectory?: VcUserDirectory, accountManager?: VcHostLocalAccountManager, hostAccessManager?: VcHostAccessManager, graphicsManager?: VcHostGraphicsManager, vsanInternalSystem?: VcHostVsanInternalSystem, certificateManager?: VcHostCertificateManager, cryptoManager?: VcCryptoManager);
	}

	declare class VcHostConfigSpec
	{
		activeDirectory: VcHostActiveDirectory[];
		datastorePrincipal: String;
		datastorePrincipalPasswd: String;
		datetime: VcHostDateTimeConfig;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		firewall: VcHostFirewallConfig;
		genericConfig: VcKeyAnyValue[];
		graphicsConfig: VcHostGraphicsConfig;
		license: VcHostLicenseSpec;
		memory: VcHostMemorySpec;
		nasDatastore: VcHostNasVolumeConfig[];
		network: VcHostNetworkConfig;
		nicTypeSelection: VcHostVirtualNicManagerNicTypeSelection[];
		option: VcOptionValue[];
		security: VcHostSecuritySpec;
		service: VcHostServiceConfig[];
		storageDevice: VcHostStorageDeviceInfo;
		userAccount: VcHostAccountSpec[];
		usergroupAccount: VcHostAccountSpec[];

		constructor();
		constructor(nasDatastore?: VcHostNasVolumeConfig[], network?: VcHostNetworkConfig, nicTypeSelection?: VcHostVirtualNicManagerNicTypeSelection[], service?: VcHostServiceConfig[], firewall?: VcHostFirewallConfig, option?: VcOptionValue[], datastorePrincipal?: String, datastorePrincipalPasswd?: String, datetime?: VcHostDateTimeConfig, storageDevice?: VcHostStorageDeviceInfo, license?: VcHostLicenseSpec, security?: VcHostSecuritySpec, userAccount?: VcHostAccountSpec[], usergroupAccount?: VcHostAccountSpec[], memory?: VcHostMemorySpec, activeDirectory?: VcHostActiveDirectory[], genericConfig?: VcKeyAnyValue[], graphicsConfig?: VcHostGraphicsConfig);
	}

	declare class VcHostConfigSummary
	{
		agentVmDatastore: VcDatastore;
		agentVmNetwork: VcNetwork;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		faultToleranceEnabled: boolean;
		featureVersion: VcHostFeatureVersionInfo[];
		name: String;
		port: Number;
		product: VcAboutInfo;
		sslThumbprint: String;
		vmotionEnabled: boolean;

		constructor();
		constructor(name?: String, port?: Number, sslThumbprint?: String, product?: VcAboutInfo, vmotionEnabled?: boolean, faultToleranceEnabled?: boolean, featureVersion?: VcHostFeatureVersionInfo[], agentVmDatastore?: VcDatastore, agentVmNetwork?: VcNetwork);
		isFaultToleranceEnabled(): boolean;
	}

	declare class VcHostConnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostConnectFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcHostConnectInfo
	{
		capability: VcHostCapability;
		clusterSupported: boolean;
		datastore: VcHostDatastoreConnectInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostListSummary;
		inDasCluster: boolean;
		license: VcHostLicenseConnectInfo;
		network: VcHostConnectInfoNetworkInfo[];
		serverIp: String;
		vimAccountNameRequired: boolean;
		vm: VcVirtualMachineSummary[];

		constructor();
		constructor(serverIp?: String, inDasCluster?: boolean, host?: VcHostListSummary, vm?: VcVirtualMachineSummary[], vimAccountNameRequired?: boolean, clusterSupported?: boolean, network?: VcHostConnectInfoNetworkInfo[], datastore?: VcHostDatastoreConnectInfo[], license?: VcHostLicenseConnectInfo, capability?: VcHostCapability);
		isClusterSupported(): boolean;
		isInDasCluster(): boolean;
		isVimAccountNameRequired(): boolean;
	}

	declare class VcHostConnectInfoNetworkInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		summary: VcNetworkSummary;

		constructor();
		constructor(summary?: VcNetworkSummary);
	}

	declare class VcHostConnectionLostEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostConnectSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		force: boolean;
		hostGateway: VcHostGatewaySpec;
		hostName: String;
		lockdownMode: VcHostLockdownMode;
		managementIp: String;
		password: String;
		port: Number;
		sslThumbprint: String;
		userName: String;
		vimAccountName: String;
		vimAccountPassword: String;
		vmFolder: VcFolder;

		constructor();
		constructor(hostName?: String, port?: Number, sslThumbprint?: String, userName?: String, password?: String, vmFolder?: VcFolder, force?: boolean, vimAccountName?: String, vimAccountPassword?: String, managementIp?: String, lockdownMode?: VcHostLockdownMode, hostGateway?: VcHostGatewaySpec);
	}

	declare class VcHostCpuIdInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eax: String;
		ebx: String;
		ecx: String;
		edx: String;
		level: Number;
		vendor: String;

		constructor();
		constructor(level?: Number, vendor?: String, eax?: String, ebx?: String, ecx?: String, edx?: String);
	}

	declare class VcHostCpuInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hz: Number;
		numCpuCores: Number;
		numCpuPackages: Number;
		numCpuThreads: Number;

		constructor();
		constructor(numCpuPackages?: Number, numCpuCores?: Number, numCpuThreads?: Number, hz?: Number);
	}

	declare class VcHostCpuPackage
	{
		busHz: Number;
		cpuFeature: VcHostCpuIdInfo[];
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hz: Number;
		index: Number;
		threadId: Number[];
		vendor: String;

		constructor();
		constructor(index?: Number, vendor?: String, hz?: Number, busHz?: Number, description?: String, threadId?: Number[], cpuFeature?: VcHostCpuIdInfo[]);
	}

	interface VcHostCpuPackageVendor
	{
		readonly amd: VcHostCpuPackageVendor;
		readonly arm: VcHostCpuPackageVendor;
		readonly id: String;
		readonly intel: VcHostCpuPackageVendor;
		readonly name: String;
		readonly unknown: VcHostCpuPackageVendor;
		readonly value: String;

		fromString(value?: VcHostCpuPackageVendor): VcHostCpuPackageVendor;
	}

	declare const VcHostCpuPackageVendor: VcHostCpuPackageVendor;

	declare class VcHostCpuPowerManagementInfo
	{
		currentPolicy: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hardwareSupport: String;

		constructor();
		constructor(currentPolicy?: String, hardwareSupport?: String);
	}

	interface VcHostCpuPowerManagementInfoPolicyType
	{
		readonly dynamicPolicy: VcHostCpuPowerManagementInfoPolicyType;
		readonly id: String;
		readonly name: String;
		readonly off: VcHostCpuPowerManagementInfoPolicyType;
		readonly staticPolicy: VcHostCpuPowerManagementInfoPolicyType;
		readonly value: String;

		fromString(value?: VcHostCpuPowerManagementInfoPolicyType): VcHostCpuPowerManagementInfoPolicyType;
	}

	declare const VcHostCpuPowerManagementInfoPolicyType: VcHostCpuPowerManagementInfoPolicyType;

	interface VcHostCpuSchedulerSystem
	{
		readonly availableField: VcCustomFieldDef[];
		hyperthreadInfo: VcHostHyperThreadScheduleInfo;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		disableHyperThreading(): void;
		enableHyperThreading(): void;
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcHostCpuSchedulerSystem: VcHostCpuSchedulerSystem;

	interface VcHostCryptoState
	{
		readonly id: String;
		readonly incapable: VcHostCryptoState;
		readonly name: String;
		readonly prepared: VcHostCryptoState;
		readonly safe: VcHostCryptoState;
		readonly value: String;

		fromString(value?: VcHostCryptoState): VcHostCryptoState;
	}

	declare const VcHostCryptoState: VcHostCryptoState;

	declare class VcHostDasDisabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostDasDisablingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostDasEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostDasEnablingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostDasErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		reason: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String, reason?: String);
	}

	interface VcHostDasErrorEventHostDasErrorReason
	{
		readonly agentFailed: VcHostDasErrorEventHostDasErrorReason;
		readonly agentShutdown: VcHostDasErrorEventHostDasErrorReason;
		readonly communicationInitFailed: VcHostDasErrorEventHostDasErrorReason;
		readonly configFailed: VcHostDasErrorEventHostDasErrorReason;
		readonly healthCheckScriptFailed: VcHostDasErrorEventHostDasErrorReason;
		readonly id: String;
		readonly isolationAddressUnpingable: VcHostDasErrorEventHostDasErrorReason;
		readonly name: String;
		readonly other: VcHostDasErrorEventHostDasErrorReason;
		readonly timeout: VcHostDasErrorEventHostDasErrorReason;
		readonly value: String;

		fromString(value?: VcHostDasErrorEventHostDasErrorReason): VcHostDasErrorEventHostDasErrorReason;
	}

	declare const VcHostDasErrorEventHostDasErrorReason: VcHostDasErrorEventHostDasErrorReason;

	declare class VcHostDasEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostDasOkEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	interface VcHostDatastoreBrowser
	{
		datastore: VcDatastore[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		supportedType: VcFileQuery[];
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteFile(arg0?: String): void;
		searchDatastore_Task(arg0?: String, arg1?: VcHostDatastoreBrowserSearchSpec): VcTask;
		searchDatastoreSubFolders_Task(arg0?: String, arg1?: VcHostDatastoreBrowserSearchSpec): VcTask;
	}

	declare const VcHostDatastoreBrowser: VcHostDatastoreBrowser;

	declare class VcHostDatastoreBrowserSearchResults
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		file: VcFileInfo[];
		folderPath: String;

		constructor();
		constructor(datastore?: VcDatastore, folderPath?: String, file?: VcFileInfo[]);
	}

	declare class VcHostDatastoreBrowserSearchSpec
	{
		details: VcFileQueryFlags;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		matchPattern: String[];
		query: VcFileQuery[];
		searchCaseInsensitive: boolean;
		sortFoldersFirst: boolean;

		constructor();
		constructor(query?: VcFileQuery[], details?: VcFileQueryFlags, searchCaseInsensitive?: boolean, matchPattern?: String[], sortFoldersFirst?: boolean);
		isSearchCaseInsensitive(): boolean;
		isSortFoldersFirst(): boolean;
	}

	declare class VcHostDatastoreConnectInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		summary: VcDatastoreSummary;

		constructor();
		constructor(summary?: VcDatastoreSummary);
	}

	declare class VcHostDatastoreExistsConnectInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		newDatastoreName: String;
		summary: VcDatastoreSummary;

		constructor();
		constructor(summary?: VcDatastoreSummary, newDatastoreName?: String);
	}

	declare class VcHostDatastoreNameConflictConnectInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		newDatastoreName: String;
		summary: VcDatastoreSummary;

		constructor();
		constructor(summary?: VcDatastoreSummary, newDatastoreName?: String);
	}

	interface VcHostDatastoreSystem
	{
		capabilities: VcHostDatastoreSystemCapabilities;
		datastore: VcDatastore[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkVmFileAccessibility(arg0?: String[]): VcHostDatastoreSystemVmFileAccessibilityResult[];
		configureDatastorePrincipal(arg0?: String, arg1?: String): void;
		createLocalDatastore(arg0?: String, arg1?: String): VcDatastore;
		createNasDatastore(arg0?: VcHostNasVolumeSpec): VcDatastore;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVmfsDatastore(arg0?: VcVmfsDatastoreCreateSpec): VcDatastore;
		createVvolDatastore(arg0?: VcHostDatastoreSystemVvolDatastoreSpec): VcDatastore;
		createVvolDatastoreInternal(arg0?: VcVvolDatastoreSpec): VcDatastore;
		expandVmfsDatastore(arg0?: VcDatastore, arg1?: VcVmfsDatastoreExpandSpec): VcDatastore;
		extendVmfsDatastore(arg0?: VcDatastore, arg1?: VcVmfsDatastoreExtendSpec): VcDatastore;
		notifyDatastore(arg0?: String, arg1?: VcDatastore[]): void;
		processVmfsDatastoreUpdate(arg0?: String, arg1?: VcHostDatastoreSystemVmfsEventType): void;
		queryAvailableDisksForVmfs(arg0?: VcDatastore): VcHostScsiDisk[];
		queryUnresolvedVmfsVolumes(): VcHostUnresolvedVmfsVolume[];
		queryVmfsDatastoreCreateOptions(arg0?: String, arg1?: Number): VcVmfsDatastoreOption[];
		queryVmfsDatastoreExpandOptions(arg0?: VcDatastore): VcVmfsDatastoreOption[];
		queryVmfsDatastoreExtendOptions(arg0?: VcDatastore, arg1?: String, arg2?: boolean): VcVmfsDatastoreOption[];
		removeDatastore(arg0?: VcDatastore): void;
		removeDatastoreEx_Task(arg0?: VcDatastore[]): VcTask;
		resignatureUnresolvedVmfsVolume_Task(arg0?: VcHostUnresolvedVmfsResignatureSpec): VcTask;
		updateLocalSwapDatastore(arg0?: VcDatastore): void;
		updateVvolDatastoreInternal(arg0?: VcVvolDatastoreSpec): void;
	}

	declare const VcHostDatastoreSystem: VcHostDatastoreSystem;

	declare class VcHostDatastoreSystemCapabilities
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		localDatastoreSupported: boolean;
		nfsMountCreationRequired: boolean;
		nfsMountCreationSupported: boolean;
		vmfsExtentExpansionSupported: boolean;

		constructor();
		constructor(nfsMountCreationRequired?: boolean, nfsMountCreationSupported?: boolean, localDatastoreSupported?: boolean, vmfsExtentExpansionSupported?: boolean);
		isVmfsExtentExpansionSupported(): boolean;
	}

	interface VcHostDatastoreSystemDatastoreEventType
	{
		readonly FailedUnmount: VcHostDatastoreSystemDatastoreEventType;
		readonly id: String;
		readonly name: String;
		readonly PreUnmount: VcHostDatastoreSystemDatastoreEventType;
		readonly value: String;
		readonly VvolFastPolling: VcHostDatastoreSystemDatastoreEventType;

		fromString(value?: VcHostDatastoreSystemDatastoreEventType): VcHostDatastoreSystemDatastoreEventType;
	}

	declare const VcHostDatastoreSystemDatastoreEventType: VcHostDatastoreSystemDatastoreEventType;

	declare class VcHostDatastoreSystemDatastoreResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		key: VcDatastore;

		constructor();
		constructor(key?: VcDatastore, fault?: VcLocalizedMethodFault);
	}

	declare class VcHostDatastoreSystemVmFileAccessibilityResult
	{
		accessible: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault;
		vmId: String;

		constructor();
		constructor(vmId?: String, accessible?: boolean, error?: VcLocalizedMethodFault);
	}

	interface VcHostDatastoreSystemVmfsEventType
	{
		readonly Create: VcHostDatastoreSystemVmfsEventType;
		readonly Expand: VcHostDatastoreSystemVmfsEventType;
		readonly Extend: VcHostDatastoreSystemVmfsEventType;
		readonly id: String;
		readonly name: String;
		readonly Remove: VcHostDatastoreSystemVmfsEventType;
		readonly value: String;

		fromString(value?: VcHostDatastoreSystemVmfsEventType): VcHostDatastoreSystemVmfsEventType;
	}

	declare const VcHostDatastoreSystemVmfsEventType: VcHostDatastoreSystemVmfsEventType;

	declare class VcHostDatastoreSystemVvolDatastoreSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		scId: String;

		constructor();
		constructor(name?: String, scId?: String);
	}

	declare class VcHostDateTimeConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ntpConfig: VcHostNtpConfig;
		timeZone: String;

		constructor();
		constructor(timeZone?: String, ntpConfig?: VcHostNtpConfig);
	}

	declare class VcHostDateTimeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ntpConfig: VcHostNtpConfig;
		timeZone: VcHostDateTimeSystemTimeZone;

		constructor();
		constructor(timeZone?: VcHostDateTimeSystemTimeZone, ntpConfig?: VcHostNtpConfig);
	}

	interface VcHostDateTimeSystem
	{
		dateTimeInfo: VcHostDateTimeInfo;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryAvailableTimeZones(): VcHostDateTimeSystemTimeZone[];
		queryDateTime(): Date;
		refreshDateTimeSystem(): void;
		updateDateTime(arg0?: Date): void;
		updateDateTimeConfig(arg0?: VcHostDateTimeConfig): void;
	}

	declare const VcHostDateTimeSystem: VcHostDateTimeSystem;

	declare class VcHostDateTimeSystemTimeZone
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gmtOffset: Number;
		key: String;
		name: String;

		constructor();
		constructor(key?: String, name?: String, description?: String, gmtOffset?: Number);
	}

	declare class VcHostDeploymentInfo
	{
		bootedFromStatelessCache: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(bootedFromStatelessCache?: boolean);
		isBootedFromStatelessCache(): boolean;
	}

	declare class VcHostDevice
	{
		deviceName: String;
		deviceType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(deviceName?: String, deviceType?: String);
	}

	declare class VcHostDhcpService
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		spec: VcHostDhcpServiceSpec;

		constructor();
		constructor(key?: String, spec?: VcHostDhcpServiceSpec);
	}

	declare class VcHostDhcpServiceConfig
	{
		changeOperation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		spec: VcHostDhcpServiceSpec;

		constructor();
		constructor(changeOperation?: String, key?: String, spec?: VcHostDhcpServiceSpec);
	}

	declare class VcHostDhcpServiceSpec
	{
		defaultLeaseDuration: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipSubnetAddr: String;
		ipSubnetMask: String;
		leaseBeginIp: String;
		leaseEndIp: String;
		maxLeaseDuration: Number;
		unlimitedLease: boolean;
		virtualSwitch: String;

		constructor();
		constructor(virtualSwitch?: String, defaultLeaseDuration?: Number, leaseBeginIp?: String, leaseEndIp?: String, maxLeaseDuration?: Number, unlimitedLease?: boolean, ipSubnetAddr?: String, ipSubnetMask?: String);
	}

	declare class VcHostDiagnosticPartition
	{
		diagnosticType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcHostScsiDiskPartition;
		slots: Number;
		storageType: String;

		constructor();
		constructor(storageType?: String, diagnosticType?: String, slots?: Number, id?: VcHostScsiDiskPartition);
	}

	declare class VcHostDiagnosticPartitionCreateDescription
	{
		diskUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		layout: VcHostDiskPartitionLayout;
		spec: VcHostDiagnosticPartitionCreateSpec;

		constructor();
		constructor(layout?: VcHostDiskPartitionLayout, diskUuid?: String, spec?: VcHostDiagnosticPartitionCreateSpec);
	}

	declare class VcHostDiagnosticPartitionCreateOption
	{
		diagnosticType: String;
		disk: VcHostScsiDisk;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		storageType: String;

		constructor();
		constructor(storageType?: String, diagnosticType?: String, disk?: VcHostScsiDisk);
	}

	declare class VcHostDiagnosticPartitionCreateSpec
	{
		active: boolean;
		diagnosticType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcHostScsiDiskPartition;
		partition: VcHostDiskPartitionSpec;
		storageType: String;

		constructor();
		constructor(storageType?: String, diagnosticType?: String, id?: VcHostScsiDiskPartition, partition?: VcHostDiskPartitionSpec, active?: boolean);
		isActive(): boolean;
	}

	interface VcHostDiagnosticSystem
	{
		activePartition: VcHostDiagnosticPartition;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createDiagnosticPartition(arg0?: VcHostDiagnosticPartitionCreateSpec): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryAvailablePartition(): VcHostDiagnosticPartition[];
		queryPartitionCreateDesc(arg0?: String, arg1?: String): VcHostDiagnosticPartitionCreateDescription;
		queryPartitionCreateOptions(arg0?: String, arg1?: String): VcHostDiagnosticPartitionCreateOption[];
		selectActivePartition(arg0?: VcHostScsiDiskPartition): void;
	}

	declare const VcHostDiagnosticSystem: VcHostDiagnosticSystem;

	declare class VcHostDigestInfo
	{
		digestMethod: String;
		digestValue: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		objectName: String;

		constructor();
		constructor(digestMethod?: String, digestValue?: Number[], objectName?: String);
	}

	interface VcHostDigestInfoDigestMethodType
	{
		readonly id: String;
		readonly MD5: VcHostDigestInfoDigestMethodType;
		readonly name: String;
		readonly SHA1: VcHostDigestInfoDigestMethodType;
		readonly value: String;

		fromString(value?: VcHostDigestInfoDigestMethodType): VcHostDigestInfoDigestMethodType;
	}

	declare const VcHostDigestInfoDigestMethodType: VcHostDigestInfoDigestMethodType;

	interface VcHostDirectoryStore
	{
		id: String;
		readonly info: VcHostAuthenticationStoreInfo;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostDirectoryStore: VcHostDirectoryStore;

	declare class VcHostDirectoryStoreInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;

		constructor();
		constructor(enabled?: boolean);
	}

	declare class VcHostDisconnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, reason?: String);
		constructor();
	}

	interface VcHostDisconnectedEventReasonCode
	{
		readonly agentOutOfDate: VcHostDisconnectedEventReasonCode;
		readonly agentUpgrade: VcHostDisconnectedEventReasonCode;
		readonly id: String;
		readonly insufficientLicenses: VcHostDisconnectedEventReasonCode;
		readonly licenseExpired: VcHostDisconnectedEventReasonCode;
		readonly name: String;
		readonly passwordDecryptFailure: VcHostDisconnectedEventReasonCode;
		readonly sslThumbprintVerifyFailed: VcHostDisconnectedEventReasonCode;
		readonly unknown: VcHostDisconnectedEventReasonCode;
		readonly userRequest: VcHostDisconnectedEventReasonCode;
		readonly value: String;
		readonly vcVRAMCapacityExceeded: VcHostDisconnectedEventReasonCode;

		fromString(value?: VcHostDisconnectedEventReasonCode): VcHostDisconnectedEventReasonCode;
	}

	declare const VcHostDisconnectedEventReasonCode: VcHostDisconnectedEventReasonCode;

	declare class VcHostDiskBlockInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		granularity: Number;
		map: VcHostDiskBlockInfoMapping[];
		mapLength: Number;
		mapStart: Number;
		minBlockSize: Number;
		provisionBlockSize: Number;
		size: Number;

		constructor();
		constructor(size?: Number, granularity?: Number, minBlockSize?: Number, provisionBlockSize?: Number, mapStart?: Number, mapLength?: Number, map?: VcHostDiskBlockInfoMapping[]);
	}

	declare class VcHostDiskBlockInfoExtent
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lazyZero: boolean;
		length: Number;
		logicalStart: Number;
		physicalStart: Number;
		readOnly: boolean;

		constructor();
		constructor(logicalStart?: Number, physicalStart?: Number, length?: Number, readOnly?: boolean, lazyZero?: boolean);
		isLazyZero(): boolean;
		isReadOnly(): boolean;
	}

	declare class VcHostDiskBlockInfoMapping
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		element: String;
		extent: VcHostDiskBlockInfoExtent[];

		constructor();
		constructor(element?: String, extent?: VcHostDiskBlockInfoExtent[]);
	}

	declare class VcHostDiskBlockInfoScsiMapping
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		element: String;
		extent: VcHostDiskBlockInfoExtent[];

		constructor();
		constructor(element?: String, extent?: VcHostDiskBlockInfoExtent[]);
	}

	declare class VcHostDiskBlockInfoVmfsMapping
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		element: String;
		extent: VcHostDiskBlockInfoExtent[];

		constructor();
		constructor(element?: String, extent?: VcHostDiskBlockInfoExtent[]);
	}

	declare class VcHostDiskConfigurationResult
	{
		devicePath: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		success: boolean;

		constructor();
		constructor(devicePath?: String, success?: boolean, fault?: VcLocalizedMethodFault);
		isSuccess(): boolean;
	}

	declare class VcHostDiskDimensions
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcHostDiskDimensionsChs
	{
		cylinder: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		head: Number;
		sector: Number;

		constructor();
		constructor(cylinder?: Number, head?: Number, sector?: Number);
	}

	declare class VcHostDiskDimensionsLba
	{
		block: Number;
		blockSize: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(blockSize?: Number, block?: Number);
	}

	interface VcHostDiskManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		acquireLease(arg0?: VcVirtualMachineSnapshot, arg1?: String): VcHostDiskManagerLeaseInfo;
		acquireLeaseExt(arg0?: VcVirtualMachineSnapshot, arg1?: String, arg2?: boolean): VcHostDiskManagerLeaseInfo;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		renewAllLeases(): void;
	}

	declare const VcHostDiskManager: VcHostDiskManager;

	interface VcHostDiskManagerLease
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		leaseAllocateBlocks(arg0?: Number, arg1?: Number, arg2?: boolean): VcHostDiskBlockInfo;
		leaseClearLazyZero(arg0?: Number, arg1?: Number, arg2?: boolean): void;
		leaseMapDiskRegion(arg0?: Number, arg1?: Number): VcHostDiskBlockInfo;
		releaseLease(): void;
		renewLease(): void;
	}

	declare const VcHostDiskManagerLease: VcHostDiskManagerLease;

	declare class VcHostDiskManagerLeaseInfo
	{
		blockInfo: VcHostDiskBlockInfo;
		ddbOption: VcOptionValue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lease: VcHostDiskManagerLease;
		leaseTimeout: Number;

		constructor();
		constructor(lease?: VcHostDiskManagerLease, ddbOption?: VcOptionValue[], blockInfo?: VcHostDiskBlockInfo, leaseTimeout?: Number);
	}

	declare class VcHostDiskMappingInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		exclusive: boolean;
		name: String;
		physicalPartition: VcHostDiskMappingPartitionInfo;

		constructor();
		constructor(physicalPartition?: VcHostDiskMappingPartitionInfo, name?: String, exclusive?: boolean);
		isExclusive(): boolean;
	}

	declare class VcHostDiskMappingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		physicalPartition: VcHostDiskMappingPartitionOption[];

		constructor();
		constructor(physicalPartition?: VcHostDiskMappingPartitionOption[], name?: String);
	}

	declare class VcHostDiskMappingPartitionInfo
	{
		capacityInKb: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSystem: String;
		name: String;

		constructor();
		constructor(name?: String, fileSystem?: String, capacityInKb?: Number);
	}

	declare class VcHostDiskMappingPartitionOption
	{
		capacityInKb: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSystem: String;
		name: String;

		constructor();
		constructor(name?: String, fileSystem?: String, capacityInKb?: Number);
	}

	declare class VcHostDiskPartitionAttributes
	{
		attributes: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endSector: Number;
		guid: String;
		logical: boolean;
		partition: Number;
		partitionAlignment: Number;
		startSector: Number;
		type: String;

		constructor();
		constructor(partition?: Number, startSector?: Number, endSector?: Number, type?: String, guid?: String, logical?: boolean, attributes?: Number, partitionAlignment?: Number);
	}

	declare class VcHostDiskPartitionBlockRange
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		end: VcHostDiskDimensionsLba;
		partition: Number;
		start: VcHostDiskDimensionsLba;
		type: String;

		constructor();
		constructor(partition?: Number, type?: String, start?: VcHostDiskDimensionsLba, end?: VcHostDiskDimensionsLba);
	}

	declare class VcHostDiskPartitionInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		layout: VcHostDiskPartitionLayout;
		spec: VcHostDiskPartitionSpec;

		constructor();
		constructor(deviceName?: String, spec?: VcHostDiskPartitionSpec, layout?: VcHostDiskPartitionLayout);
	}

	interface VcHostDiskPartitionInfoPartitionFormat
	{
		readonly gpt: VcHostDiskPartitionInfoPartitionFormat;
		readonly id: String;
		readonly mbr: VcHostDiskPartitionInfoPartitionFormat;
		readonly name: String;
		readonly unknown: VcHostDiskPartitionInfoPartitionFormat;
		readonly value: String;

		fromString(value?: VcHostDiskPartitionInfoPartitionFormat): VcHostDiskPartitionInfoPartitionFormat;
	}

	declare const VcHostDiskPartitionInfoPartitionFormat: VcHostDiskPartitionInfoPartitionFormat;

	interface VcHostDiskPartitionInfoType
	{
		readonly extended: VcHostDiskPartitionInfoType;
		readonly id: String;
		readonly linuxNative: VcHostDiskPartitionInfoType;
		readonly linuxSwap: VcHostDiskPartitionInfoType;
		readonly name: String;
		readonly none: VcHostDiskPartitionInfoType;
		readonly ntfs: VcHostDiskPartitionInfoType;
		readonly value: String;
		readonly vffs: VcHostDiskPartitionInfoType;
		readonly vmfs: VcHostDiskPartitionInfoType;
		readonly vmkDiagnostic: VcHostDiskPartitionInfoType;

		fromString(value?: VcHostDiskPartitionInfoType): VcHostDiskPartitionInfoType;
	}

	declare const VcHostDiskPartitionInfoType: VcHostDiskPartitionInfoType;

	declare class VcHostDiskPartitionLayout
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		partition: VcHostDiskPartitionBlockRange[];
		total: VcHostDiskDimensionsLba;

		constructor();
		constructor(total?: VcHostDiskDimensionsLba, partition?: VcHostDiskPartitionBlockRange[]);
	}

	declare class VcHostDiskPartitionSpec
	{
		chs: VcHostDiskDimensionsChs;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		partition: VcHostDiskPartitionAttributes[];
		partitionFormat: String;
		totalSectors: Number;

		constructor();
		constructor(partitionFormat?: String, chs?: VcHostDiskDimensionsChs, totalSectors?: Number, partition?: VcHostDiskPartitionAttributes[]);
	}

	interface VcHostDistributedVirtualSwitchManager
	{
		distributedVirtualSwitch: String[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		hostDVSClonePort(arg0?: String, arg1?: VcHostDVSPortCloneSpec[]): void;
		hostDVSCreateDVS(arg0?: VcHostDVSCreateSpec): void;
		hostDVSDeletePorts(arg0?: String, arg1?: VcHostDVSPortDeleteSpec[]): void;
		hostDVSGetPortState(arg0?: String, arg1?: String[], arg2?: String): VcHostDVSPortData[];
		hostDVSReconfigure(arg0?: VcHostDVSConfigSpec): void;
		hostDVSRemoveDVS(arg0?: String): void;
		hostDVSSetDvpgList(arg0?: String, arg1?: String[]): void;
		hostDVSSetDVPortgroups(arg0?: String, arg1?: VcHostDVPortgroupConfigSpec[]): void;
		hostDVSSetDvportList(arg0?: String, arg1?: String[]): void;
		hostDVSSetDVS(arg0?: VcHostDVSCreateSpec[]): void;
		hostDVSSetDVSList(arg0?: String[]): void;
		hostDVSSetPorts(arg0?: String, arg1?: VcHostDVSPortData[]): void;
		hostDVSUpdateDVPortgroups(arg0?: String, arg1?: VcHostDVPortgroupConfigSpec[]): void;
		hostDVSUpdatePorts(arg0?: String, arg1?: VcHostDVSPortData[]): void;
		hostExecuteOpaqueCommand(arg0?: String, arg1?: VcDVSOpaqueCommandReqSpec): VcDVSOpaqueCommandResultInfo;
		loadDVPort(arg0?: String, arg1?: String, arg2?: String): void;
		retrieveDVPort(arg0?: String): String[];
		retrieveDVPortgroup(arg0?: String): String[];
		retrieveDVPortgroupConfigSpec(arg0?: String, arg1?: String[]): VcHostDVPortgroupConfigSpec[];
		retrieveDvsConfigSpec(arg0?: String): VcHostDVSConfigSpec;
	}

	declare const VcHostDistributedVirtualSwitchManager: VcHostDistributedVirtualSwitchManager;

	interface VcHostDistributedVirtualSwitchManagerFetchPortOption
	{
		readonly id: String;
		readonly name: String;
		readonly runtimeInfoOnly: VcHostDistributedVirtualSwitchManagerFetchPortOption;
		readonly stateBlobOnly: VcHostDistributedVirtualSwitchManagerFetchPortOption;
		readonly statsOnly: VcHostDistributedVirtualSwitchManagerFetchPortOption;
		readonly value: String;

		fromString(value?: VcHostDistributedVirtualSwitchManagerFetchPortOption): VcHostDistributedVirtualSwitchManagerFetchPortOption;
	}

	declare const VcHostDistributedVirtualSwitchManagerFetchPortOption: VcHostDistributedVirtualSwitchManagerFetchPortOption;

	interface VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey
	{
		readonly faultTolerance: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
		readonly hbr: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
		readonly id: String;
		readonly iSCSI: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
		readonly management: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
		readonly name: String;
		readonly nfs: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
		readonly value: String;
		readonly vdp: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
		readonly virtualMachine: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
		readonly vmotion: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
		readonly vsan: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;

		fromString(value?: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey): VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
	}

	declare const VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey: VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey;

	declare class VcHostDnsConfig
	{
		address: String[];
		dhcp: boolean;
		domainName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostName: String;
		searchDomain: String[];
		virtualNicDevice: String;

		constructor();
		constructor(dhcp?: boolean, virtualNicDevice?: String, hostName?: String, domainName?: String, address?: String[], searchDomain?: String[]);
	}

	declare class VcHostDnsConfigSpec
	{
		address: String[];
		dhcp: boolean;
		domainName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostName: String;
		searchDomain: String[];
		virtualNicConnection: VcHostVirtualNicConnection;
		virtualNicDevice: String;

		constructor();
		constructor(dhcp?: boolean, virtualNicDevice?: String, hostName?: String, domainName?: String, address?: String[], searchDomain?: String[], virtualNicConnection?: VcHostVirtualNicConnection);
	}

	declare class VcHostDvpgNetworkResource
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		networkId: String;
		uplinkNames: String[];

		constructor();
		constructor(networkId?: String, uplinkNames?: String[]);
	}

	declare class VcHostDVPortgroupConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		keyedOpaqueDataList: VcDVSKeyedOpaqueDataList;
		opaqueDataList: VcDVSOpaqueDataList;
		operation: String;
		specification: VcDVPortgroupConfigSpec;

		constructor();
		constructor(operation?: String, key?: String, specification?: VcDVPortgroupConfigSpec, keyedOpaqueDataList?: VcDVSKeyedOpaqueDataList, opaqueDataList?: VcDVSOpaqueDataList);
	}

	declare class VcHostDVSConfigSpec
	{
		backing: VcDistributedVirtualSwitchHostMemberBacking;
		dvsOpaqueDataList: VcDVSOpaqueDataList;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enableNetworkResourceManagement: boolean;
		extraConfig: VcKeyValue[];
		healthCheckConfig: VcDVSHealthCheckConfig[];
		hostInfrastructureTrafficResource: VcDvsHostInfrastructureTrafficResource[];
		hostOpaqueDataList: VcDVSOpaqueDataList;
		keyedOpaqueDataList: VcDVSKeyedOpaqueDataList;
		maxProxySwitchPorts: Number;
		modifyVendorSpecificDvsConfig: boolean;
		modifyVendorSpecificHostMemberConfig: boolean;
		name: String;
		networkResourceControlVersion: String;
		networkResourcePoolKeys: String[];
		pnicCapacityRatioForReservation: Number;
		status: String;
		statusDetail: String;
		switchIpAddress: String;
		uplinkPortgroupKey: String[];
		uplinkPortKey: String[];
		uplinkPortResourceSpec: VcUplinkPortResourceSpec[];
		uuid: String;
		vendorSpecificDvsConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vendorSpecificHostMemberConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vmwareSetting: VcHostDVSVmwareConfigSpec;

		constructor();
		constructor(uuid?: String, name?: String, switchIpAddress?: String, uplinkPortgroupKey?: String[], uplinkPortKey?: String[], modifyVendorSpecificDvsConfig?: boolean, vendorSpecificDvsConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], backing?: VcDistributedVirtualSwitchHostMemberBacking, maxProxySwitchPorts?: Number, modifyVendorSpecificHostMemberConfig?: boolean, vendorSpecificHostMemberConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], healthCheckConfig?: VcDVSHealthCheckConfig[], vmwareSetting?: VcHostDVSVmwareConfigSpec, enableNetworkResourceManagement?: boolean, networkResourcePoolKeys?: String[], uplinkPortResourceSpec?: VcUplinkPortResourceSpec[], hostInfrastructureTrafficResource?: VcDvsHostInfrastructureTrafficResource[], networkResourceControlVersion?: String, pnicCapacityRatioForReservation?: Number, status?: String, statusDetail?: String, keyedOpaqueDataList?: VcDVSKeyedOpaqueDataList, hostOpaqueDataList?: VcDVSOpaqueDataList, dvsOpaqueDataList?: VcDVSOpaqueDataList, extraConfig?: VcKeyValue[]);
		isEnableNetworkResourceManagement(): boolean;
	}

	declare class VcHostDVSCreateSpec
	{
		backing: VcDistributedVirtualSwitchHostMemberBacking;
		dvsOpaqueDataList: VcDVSOpaqueDataList;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enableNetworkResourceManagement: boolean;
		extraConfig: VcKeyValue[];
		healthCheckConfig: VcDVSHealthCheckConfig[];
		hostInfrastructureTrafficResource: VcDvsHostInfrastructureTrafficResource[];
		hostOpaqueDataList: VcDVSOpaqueDataList;
		isOpaque: boolean;
		keyedOpaqueDataList: VcDVSKeyedOpaqueDataList;
		maxProxySwitchPorts: Number;
		modifyVendorSpecificDvsConfig: boolean;
		modifyVendorSpecificHostMemberConfig: boolean;
		name: String;
		networkResourceControlVersion: String;
		networkResourcePoolKeys: String[];
		pnicCapacityRatioForReservation: Number;
		port: VcHostDVSPortData[];
		portgroup: VcHostDVPortgroupConfigSpec[];
		productSpec: VcDistributedVirtualSwitchProductSpec;
		status: String;
		statusDetail: String;
		switchIpAddress: String;
		uplinkPortgroupKey: String[];
		uplinkPortKey: String[];
		uplinkPortResourceSpec: VcUplinkPortResourceSpec[];
		uuid: String;
		vendorSpecificDvsConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vendorSpecificHostMemberConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vmwareSetting: VcHostDVSVmwareConfigSpec;

		constructor();
		constructor(uuid?: String, name?: String, switchIpAddress?: String, uplinkPortgroupKey?: String[], uplinkPortKey?: String[], modifyVendorSpecificDvsConfig?: boolean, vendorSpecificDvsConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], backing?: VcDistributedVirtualSwitchHostMemberBacking, maxProxySwitchPorts?: Number, modifyVendorSpecificHostMemberConfig?: boolean, vendorSpecificHostMemberConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], healthCheckConfig?: VcDVSHealthCheckConfig[], vmwareSetting?: VcHostDVSVmwareConfigSpec, enableNetworkResourceManagement?: boolean, networkResourcePoolKeys?: String[], uplinkPortResourceSpec?: VcUplinkPortResourceSpec[], hostInfrastructureTrafficResource?: VcDvsHostInfrastructureTrafficResource[], networkResourceControlVersion?: String, pnicCapacityRatioForReservation?: Number, status?: String, statusDetail?: String, keyedOpaqueDataList?: VcDVSKeyedOpaqueDataList, hostOpaqueDataList?: VcDVSOpaqueDataList, dvsOpaqueDataList?: VcDVSOpaqueDataList, extraConfig?: VcKeyValue[], port?: VcHostDVSPortData[], portgroup?: VcHostDVPortgroupConfigSpec[], productSpec?: VcDistributedVirtualSwitchProductSpec, isOpaque?: boolean);
		isEnableNetworkResourceManagement(): boolean;
		isIsOpaque(): boolean;
	}

	declare class VcHostDVSPortCloneSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		newPortKey: String;
		oldPortKey: String;
		portPersistenceLocation: String;

		constructor();
		constructor(oldPortKey?: String, newPortKey?: String, portPersistenceLocation?: String);
	}

	declare class VcHostDVSPortData
	{
		connectionCookie: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extraConfig: VcKeyValue[];
		keyedOpaqueDataList: VcDVSKeyedOpaqueDataList;
		name: String;
		opaqueDataList: VcDVSOpaqueDataList;
		opaqueRuntimeDataList: VcDVSKeyedOpaqueDataList;
		portgroupKey: String;
		portKey: String;
		portPersistenceLocation: String;
		runtimeDataList: VcDVSOpaqueDataList;
		setting: VcDVPortSetting;
		shadowPort: boolean;
		state: VcDVPortState;
		vspanConfig: VcVMwareVspanSession[];

		constructor();
		constructor(portKey?: String, portgroupKey?: String, name?: String, state?: VcDVPortState, setting?: VcDVPortSetting, connectionCookie?: Number, portPersistenceLocation?: String, shadowPort?: boolean, keyedOpaqueDataList?: VcDVSKeyedOpaqueDataList, opaqueDataList?: VcDVSOpaqueDataList, opaqueRuntimeDataList?: VcDVSKeyedOpaqueDataList, runtimeDataList?: VcDVSOpaqueDataList, vspanConfig?: VcVMwareVspanSession[], extraConfig?: VcKeyValue[]);
		isShadowPort(): boolean;
	}

	declare class VcHostDVSPortDeleteSpec
	{
		deletePortFile: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		portKey: String;

		constructor();
		constructor(portKey?: String, deletePortFile?: boolean);
	}

	declare class VcHostDVSVmwareConfigSpec
	{
		beacon: VcHostVirtualSwitchBeaconConfig;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipfixConfig: VcVMwareIpfixConfig;
		lacpGroupConfig: VcVMwareDvsLacpGroupConfig[];
		linkDiscoveryProtocolConfig: VcLinkDiscoveryProtocolConfig;
		maxMtu: Number;
		multicastFilteringMode: String;
		promiscuousModeVspanSession: String;
		pvlanConfig: VcVMwareDVSPvlanMapEntry[];
		pvlanConfigSpec: VcVMwareDVSPvlanConfigSpec[];
		vspanConfig: VcVMwareVspanSession[];

		constructor();
		constructor(pvlanConfigSpec?: VcVMwareDVSPvlanConfigSpec[], pvlanConfig?: VcVMwareDVSPvlanMapEntry[], vspanConfig?: VcVMwareVspanSession[], maxMtu?: Number, linkDiscoveryProtocolConfig?: VcLinkDiscoveryProtocolConfig, beacon?: VcHostVirtualSwitchBeaconConfig, ipfixConfig?: VcVMwareIpfixConfig, promiscuousModeVspanSession?: String, lacpGroupConfig?: VcVMwareDvsLacpGroupConfig[], multicastFilteringMode?: String);
	}

	declare class VcHostEnableAdminFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		permissions: VcPermission[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, permissions?: VcPermission[]);
	}

	interface VcHostEsxAgentHostManager
	{
		configInfo: VcHostEsxAgentHostManagerConfigInfo;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		esxAgentHostManagerUpdateConfig(arg0?: VcHostEsxAgentHostManagerConfigInfo): void;
	}

	declare const VcHostEsxAgentHostManager: VcHostEsxAgentHostManager;

	declare class VcHostEsxAgentHostManagerConfigInfo
	{
		agentVmDatastore: VcDatastore;
		agentVmNetwork: VcNetwork;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(agentVmDatastore?: VcDatastore, agentVmNetwork?: VcNetwork);
	}

	declare class VcHostEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		name: String;

		constructor();
		constructor(name?: String, host?: VcHostSystem);
	}

	declare class VcHostExtraNetworksEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ips: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, ips?: String);
	}

	interface VcHostFaultToleranceManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		fTManagerDisableSecondaryVM_Task(arg0?: VcVirtualMachine, arg1?: String): VcTask;
		fTManagerEnableSecondaryVM_Task(arg0?: VcVirtualMachine, arg1?: String): VcTask;
		fTManagerGetPeerVMCompHealth(arg0?: VcVirtualMachine): VcHostFaultToleranceManagerComponentHealthInfo;
		fTManagerGoLivePeerVM(arg0?: VcVirtualMachine): void;
		fTManagerMakePrimaryVM_Task(arg0?: VcVirtualMachine, arg1?: String): VcTask;
		fTManagerRegisterSecondaryVM_Task(arg0?: VcVirtualMachine, arg1?: String, arg2?: String, arg3?: String): VcTask;
		fTManagerSetLocalVMCompHealth(arg0?: VcVirtualMachine, arg1?: VcHostFaultToleranceManagerComponentHealthInfo): void;
		fTManagerStartSecondaryOnRemoteHost_Task(arg0?: VcVirtualMachine, arg1?: String, arg2?: String, arg3?: Number, arg4?: String): VcTask;
		fTManagerTerminateFaultTolerantVM_Task(arg0?: VcVirtualMachine, arg1?: String): VcTask;
		fTManagerUnregisterSecondaryVM_Task(arg0?: VcVirtualMachine, arg1?: String): VcTask;
		fTManagerUnregisterVM(arg0?: VcVirtualMachine): void;
	}

	declare const VcHostFaultToleranceManager: VcHostFaultToleranceManager;

	declare class VcHostFaultToleranceManagerComponentHealthInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		isNetworkHealthy: boolean;
		isStorageHealthy: boolean;

		constructor();
		constructor(isStorageHealthy?: boolean, isNetworkHealthy?: boolean);
	}

	interface VcHostFaultToleranceManagerFaultToleranceType
	{
		readonly fault_tolerance_using_checkpoints: VcHostFaultToleranceManagerFaultToleranceType;
		readonly fault_tolerance_using_recordreplay: VcHostFaultToleranceManagerFaultToleranceType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostFaultToleranceManagerFaultToleranceType): VcHostFaultToleranceManagerFaultToleranceType;
	}

	declare const VcHostFaultToleranceManagerFaultToleranceType: VcHostFaultToleranceManagerFaultToleranceType;

	declare class VcHostFeatureCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		featureName: String;
		key: String;
		value: String;

		constructor();
		constructor(key?: String, featureName?: String, value?: String);
	}

	declare class VcHostFeatureMask
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		featureName: String;
		key: String;
		value: String;

		constructor();
		constructor(key?: String, featureName?: String, value?: String);
	}

	declare class VcHostFeatureVersionInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		value: String;

		constructor();
		constructor(key?: String, value?: String);
	}

	interface VcHostFeatureVersionKey
	{
		readonly faultTolerance: VcHostFeatureVersionKey;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostFeatureVersionKey): VcHostFeatureVersionKey;
	}

	declare const VcHostFeatureVersionKey: VcHostFeatureVersionKey;

	declare class VcHostFibreChannelHba
	{
		bus: Number;
		device: String;
		driver: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		model: String;
		nodeWorldWideName: Number;
		nodeWorldWideNameHex: String;
		pci: String;
		portType: VcFibreChannelPortType;
		portWorldWideName: Number;
		portWorldWideNameHex: String;
		speed: Number;
		status: String;

		constructor();
		constructor(key?: String, device?: String, bus?: Number, status?: String, model?: String, driver?: String, pci?: String, portWorldWideName?: Number, nodeWorldWideName?: Number, portType?: VcFibreChannelPortType, speed?: Number);
	}

	declare class VcHostFibreChannelOverEthernetHba
	{
		bus: Number;
		device: String;
		driver: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		isSoftwareFcoe: boolean;
		key: String;
		linkInfo: VcHostFibreChannelOverEthernetHbaLinkInfo;
		markedForRemoval: boolean;
		model: String;
		nodeWorldWideName: Number;
		pci: String;
		portType: VcFibreChannelPortType;
		portWorldWideName: Number;
		speed: Number;
		status: String;
		underlyingNic: String;

		constructor();
		constructor(key?: String, device?: String, bus?: Number, status?: String, model?: String, driver?: String, pci?: String, portWorldWideName?: Number, nodeWorldWideName?: Number, portType?: VcFibreChannelPortType, speed?: Number, underlyingNic?: String, linkInfo?: VcHostFibreChannelOverEthernetHbaLinkInfo, isSoftwareFcoe?: boolean, markedForRemoval?: boolean);
	}

	declare class VcHostFibreChannelOverEthernetHbaLinkInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fcfMac: String;
		vlanId: Number;
		vnportMac: String;

		constructor();
		constructor(vnportMac?: String, fcfMac?: String, vlanId?: Number);
	}

	declare class VcHostFibreChannelOverEthernetTargetTransport
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fcfMac: String;
		nodeWorldWideName: Number;
		portWorldWideName: Number;
		vlanId: Number;
		vnportMac: String;

		constructor();
		constructor(portWorldWideName?: Number, nodeWorldWideName?: Number, vnportMac?: String, fcfMac?: String, vlanId?: Number);
	}

	declare class VcHostFibreChannelTargetTransport
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nodeWorldWideName: Number;
		portWorldWideName: Number;

		constructor();
		constructor(portWorldWideName?: Number, nodeWorldWideName?: Number);
	}

	declare class VcHostFileAccess
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		what: String;
		who: String;

		constructor();
		constructor(who?: String, what?: String);
	}

	declare class VcHostFileSystemMountInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mountInfo: VcHostMountInfo;
		volume: VcHostFileSystemVolume;
		vStorageSupport: String;

		constructor();
		constructor(mountInfo?: VcHostMountInfo, volume?: VcHostFileSystemVolume, vStorageSupport?: String);
	}

	declare class VcHostFileSystemVolume
	{
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		type: String;

		constructor();
		constructor(type?: String, name?: String, capacity?: Number);
	}

	interface VcHostFileSystemVolumeFileSystemType
	{
		readonly CIFS: VcHostFileSystemVolumeFileSystemType;
		readonly id: String;
		readonly name: String;
		readonly NFS: VcHostFileSystemVolumeFileSystemType;
		readonly NFS41: VcHostFileSystemVolumeFileSystemType;
		readonly OTHER: VcHostFileSystemVolumeFileSystemType;
		readonly PMEM: VcHostFileSystemVolumeFileSystemType;
		readonly value: String;
		readonly VFFS: VcHostFileSystemVolumeFileSystemType;
		readonly VMFS: VcHostFileSystemVolumeFileSystemType;
		readonly vsan: VcHostFileSystemVolumeFileSystemType;
		readonly VVOL: VcHostFileSystemVolumeFileSystemType;

		fromString(value?: VcHostFileSystemVolumeFileSystemType): VcHostFileSystemVolumeFileSystemType;
	}

	declare const VcHostFileSystemVolumeFileSystemType: VcHostFileSystemVolumeFileSystemType;

	declare class VcHostFileSystemVolumeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mountInfo: VcHostFileSystemMountInfo[];
		volumeTypeList: String[];

		constructor();
		constructor(volumeTypeList?: String[], mountInfo?: VcHostFileSystemMountInfo[]);
	}

	declare class VcHostFirewallConfig
	{
		defaultBlockingPolicy: VcHostFirewallDefaultPolicy;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		rule: VcHostFirewallConfigRuleSetConfig[];

		constructor();
		constructor(rule?: VcHostFirewallConfigRuleSetConfig[], defaultBlockingPolicy?: VcHostFirewallDefaultPolicy);
	}

	declare class VcHostFirewallConfigRuleSetConfig
	{
		allowedHosts: VcHostFirewallRulesetIpList;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		rulesetId: String;

		constructor();
		constructor(rulesetId?: String, enabled?: boolean, allowedHosts?: VcHostFirewallRulesetIpList);
	}

	declare class VcHostFirewallDefaultPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		incomingBlocked: boolean;
		outgoingBlocked: boolean;

		constructor();
		constructor(incomingBlocked?: boolean, outgoingBlocked?: boolean);
		isIncomingBlocked(): boolean;
		isOutgoingBlocked(): boolean;
	}

	declare class VcHostFirewallInfo
	{
		defaultPolicy: VcHostFirewallDefaultPolicy;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ruleset: VcHostFirewallRuleset[];

		constructor();
		constructor(defaultPolicy?: VcHostFirewallDefaultPolicy, ruleset?: VcHostFirewallRuleset[]);
	}

	declare class VcHostFirewallRule
	{
		direction: VcHostFirewallRuleDirection;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endPort: Number;
		port: Number;
		portType: VcHostFirewallRulePortType;
		protocol: String;

		constructor();
		constructor(port?: Number, endPort?: Number, direction?: VcHostFirewallRuleDirection, portType?: VcHostFirewallRulePortType, protocol?: String);
	}

	interface VcHostFirewallRuleDirection
	{
		readonly id: String;
		readonly inbound: VcHostFirewallRuleDirection;
		readonly name: String;
		readonly outbound: VcHostFirewallRuleDirection;
		readonly value: String;

		fromString(value?: VcHostFirewallRuleDirection): VcHostFirewallRuleDirection;
	}

	declare const VcHostFirewallRuleDirection: VcHostFirewallRuleDirection;

	interface VcHostFirewallRulePortType
	{
		readonly dst: VcHostFirewallRulePortType;
		readonly id: String;
		readonly name: String;
		readonly src: VcHostFirewallRulePortType;
		readonly value: String;

		fromString(value?: VcHostFirewallRulePortType): VcHostFirewallRulePortType;
	}

	declare const VcHostFirewallRulePortType: VcHostFirewallRulePortType;

	interface VcHostFirewallRuleProtocol
	{
		readonly id: String;
		readonly name: String;
		readonly tcp: VcHostFirewallRuleProtocol;
		readonly udp: VcHostFirewallRuleProtocol;
		readonly value: String;

		fromString(value?: VcHostFirewallRuleProtocol): VcHostFirewallRuleProtocol;
	}

	declare const VcHostFirewallRuleProtocol: VcHostFirewallRuleProtocol;

	declare class VcHostFirewallRuleset
	{
		allowedHosts: VcHostFirewallRulesetIpList;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		key: String;
		label: String;
		required: boolean;
		rule: VcHostFirewallRule[];
		service: String;

		constructor();
		constructor(key?: String, label?: String, required?: boolean, rule?: VcHostFirewallRule[], service?: String, enabled?: boolean, allowedHosts?: VcHostFirewallRulesetIpList);
	}

	declare class VcHostFirewallRulesetIpList
	{
		allIp: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String[];
		ipNetwork: VcHostFirewallRulesetIpNetwork[];

		constructor();
		constructor(ipAddress?: String[], ipNetwork?: VcHostFirewallRulesetIpNetwork[], allIp?: boolean);
	}

	declare class VcHostFirewallRulesetIpNetwork
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		network: String;
		prefixLength: Number;

		constructor();
		constructor(network?: String, prefixLength?: Number);
	}

	declare class VcHostFirewallRulesetRulesetSpec
	{
		allowedHosts: VcHostFirewallRulesetIpList;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(allowedHosts?: VcHostFirewallRulesetIpList);
	}

	interface VcHostFirewallSystem
	{
		readonly availableField: VcCustomFieldDef[];
		firewallInfo: VcHostFirewallInfo;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		disableRuleset(arg0?: String): void;
		enableRuleset(arg0?: String): void;
		refreshFirewall(): void;
		setCustomValue(arg0?: String, arg1?: String): void;
		updateDefaultPolicy(arg0?: VcHostFirewallDefaultPolicy): void;
		updateRuleset(arg0?: String, arg1?: VcHostFirewallRulesetRulesetSpec): void;
	}

	declare const VcHostFirewallSystem: VcHostFirewallSystem;

	interface VcHostFirmwareSystem
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		backupFirmwareConfiguration(): String;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryFirmwareConfigUploadURL(): String;
		queryFirmwareQuantumMinutes(): Number;
		queryFirmwareSyncsPerQuantum(): Number;
		resetFirmwareToFactoryDefaults(): void;
		restoreFirmwareConfiguration(arg0?: boolean): void;
		syncFirmwareConfiguration(): void;
	}

	declare const VcHostFirmwareSystem: VcHostFirmwareSystem;

	declare class VcHostFlagInfo
	{
		backgroundSnapshotsEnabled: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(backgroundSnapshotsEnabled?: boolean);
		isBackgroundSnapshotsEnabled(): boolean;
	}

	interface VcHostFolder
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		childEntity: VcManagedEntity[];
		childType: String[];
		computeResource_ClusterComputeResource: Object[];
		computeResource_ComputeResource: Object[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		folder: Object[];
		folderTypes: Object[];
		id: String;
		name: String;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		wrappedFolder: VcFolder;

		_getRef(): VcManagedObjectReference;
		addStandaloneHost_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		addStandaloneHostWithAdminDisabled_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		addTag(tag?: VcTag[]): void;
		createCluster(name?: String, spec?: VcClusterConfigSpec): VcClusterComputeResource;
		createClusterEx(name?: String, spec?: VcClusterConfigSpecEx): VcClusterComputeResource;
		createDatacenter(name?: String): VcDatacenter;
		createDVS_Task(spec?: VcDVSCreateSpec): VcTask;
		createFolder(name?: String): VcFolder;
		createStoragePod(name?: String): VcStoragePod;
		createVM_Task(config?: VcVirtualMachineConfigSpec, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		destroy_Task(): VcTask;
		isFolder(type?: String): boolean;
		moveIntoFolder_Task(list?: VcManagedEntity[]): VcTask;
		registerVM_Task(path?: String, name?: String, asTemplate?: boolean, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		reload(): void;
		removeTag(tag?: VcTag[]): void;
		rename_Task(newName?: String): VcTask;
		retrieveCustomValues(keys?: Number[]): VcCustomFieldValue[];
		setCustomValue(key?: String, value?: String): void;
		unregisterAndDestroy_Task(): VcTask;
	}

	interface VcHostFolderConstructor {
		new(value?:any): VcHostFolder;
		readonly prototype: VcHostFolder;
	}

	declare const VcHostFolder: VcHostFolderConstructor;

	declare class VcHostForceMountedInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mounted: boolean;
		persist: boolean;

		constructor();
		constructor(persist?: boolean, mounted?: boolean);
	}

	declare class VcHostGatewaySpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gatewayId: String;
		gatewayType: String;
		hostAuthParams: VcKeyValue[];
		trustVerificationToken: String;

		constructor();
		constructor(gatewayType?: String, gatewayId?: String, trustVerificationToken?: String, hostAuthParams?: VcKeyValue[]);
	}

	declare class VcHostGetShortNameFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostGraphicsConfig
	{
		deviceType: VcHostGraphicsConfigDeviceType[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostDefaultGraphicsType: String;
		sharedPassthruAssignmentPolicy: String;

		constructor();
		constructor(hostDefaultGraphicsType?: String, sharedPassthruAssignmentPolicy?: String, deviceType?: VcHostGraphicsConfigDeviceType[]);
	}

	declare class VcHostGraphicsConfigDeviceType
	{
		deviceId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		graphicsType: String;

		constructor();
		constructor(deviceId?: String, graphicsType?: String);
	}

	interface VcHostGraphicsConfigGraphicsType
	{
		readonly id: String;
		readonly name: String;
		readonly shared: VcHostGraphicsConfigGraphicsType;
		readonly sharedDirect: VcHostGraphicsConfigGraphicsType;
		readonly value: String;

		fromString(value?: VcHostGraphicsConfigGraphicsType): VcHostGraphicsConfigGraphicsType;
	}

	declare const VcHostGraphicsConfigGraphicsType: VcHostGraphicsConfigGraphicsType;

	interface VcHostGraphicsConfigSharedPassthruAssignmentPolicy
	{
		readonly consolidation: VcHostGraphicsConfigSharedPassthruAssignmentPolicy;
		readonly id: String;
		readonly name: String;
		readonly performance: VcHostGraphicsConfigSharedPassthruAssignmentPolicy;
		readonly value: String;

		fromString(value?: VcHostGraphicsConfigSharedPassthruAssignmentPolicy): VcHostGraphicsConfigSharedPassthruAssignmentPolicy;
	}

	declare const VcHostGraphicsConfigSharedPassthruAssignmentPolicy: VcHostGraphicsConfigSharedPassthruAssignmentPolicy;

	declare class VcHostGraphicsInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		graphicsType: String;
		memorySizeInKB: Number;
		pciId: String;
		vendorName: String;
		vm: VcVirtualMachine[];

		constructor();
		constructor(deviceName?: String, vendorName?: String, pciId?: String, graphicsType?: String, memorySizeInKB?: Number, vm?: VcVirtualMachine[]);
	}

	interface VcHostGraphicsInfoGraphicsType
	{
		readonly basic: VcHostGraphicsInfoGraphicsType;
		readonly direct: VcHostGraphicsInfoGraphicsType;
		readonly id: String;
		readonly name: String;
		readonly shared: VcHostGraphicsInfoGraphicsType;
		readonly sharedDirect: VcHostGraphicsInfoGraphicsType;
		readonly value: String;

		fromString(value?: VcHostGraphicsInfoGraphicsType): VcHostGraphicsInfoGraphicsType;
	}

	declare const VcHostGraphicsInfoGraphicsType: VcHostGraphicsInfoGraphicsType;

	interface VcHostGraphicsManager
	{
		readonly availableField: VcCustomFieldDef[];
		graphicsConfig: VcHostGraphicsConfig;
		graphicsInfo: VcHostGraphicsInfo[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		sharedGraphicsActive: boolean;
		sharedPassthruGpuTypes: String[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		refreshGraphicsManager(): void;
		setCustomValue(arg0?: String, arg1?: String): void;
		updateGraphicsConfig(arg0?: VcHostGraphicsConfig): void;
	}

	declare const VcHostGraphicsManager: VcHostGraphicsManager;

	declare class VcHostHardwareElementInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		status: VcElementDescription;

		constructor();
		constructor(name?: String, status?: VcElementDescription);
	}

	interface VcHostHardwareElementStatus
	{
		readonly Green: VcHostHardwareElementStatus;
		readonly id: String;
		readonly name: String;
		readonly Red: VcHostHardwareElementStatus;
		readonly Unknown: VcHostHardwareElementStatus;
		readonly value: String;
		readonly Yellow: VcHostHardwareElementStatus;

		fromString(value?: VcHostHardwareElementStatus): VcHostHardwareElementStatus;
	}

	declare const VcHostHardwareElementStatus: VcHostHardwareElementStatus;

	declare class VcHostHardwareInfo
	{
		biosInfo: VcHostBIOSInfo;
		cpuFeature: VcHostCpuIdInfo[];
		cpuInfo: VcHostCpuInfo;
		cpuPkg: VcHostCpuPackage[];
		cpuPowerManagementInfo: VcHostCpuPowerManagementInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memorySize: Number;
		numaInfo: VcHostNumaInfo;
		pciDevice: VcHostPciDevice[];
		persistentMemoryInfo: VcHostPersistentMemoryInfo;
		reliableMemoryInfo: VcHostReliableMemoryInfo;
		smcPresent: boolean;
		systemInfo: VcHostSystemInfo;

		constructor();
		constructor(systemInfo?: VcHostSystemInfo, cpuPowerManagementInfo?: VcHostCpuPowerManagementInfo, cpuInfo?: VcHostCpuInfo, cpuPkg?: VcHostCpuPackage[], memorySize?: Number, numaInfo?: VcHostNumaInfo, smcPresent?: boolean, pciDevice?: VcHostPciDevice[], cpuFeature?: VcHostCpuIdInfo[], biosInfo?: VcHostBIOSInfo, reliableMemoryInfo?: VcHostReliableMemoryInfo, persistentMemoryInfo?: VcHostPersistentMemoryInfo);
		isSmcPresent(): boolean;
	}

	declare class VcHostHardwareStatusInfo
	{
		cpuStatusInfo: VcHostHardwareElementInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memoryStatusInfo: VcHostHardwareElementInfo[];
		storageStatusInfo: VcHostStorageElementInfo[];

		constructor();
		constructor(memoryStatusInfo?: VcHostHardwareElementInfo[], cpuStatusInfo?: VcHostHardwareElementInfo[], storageStatusInfo?: VcHostStorageElementInfo[]);
	}

	declare class VcHostHardwareSummary
	{
		cpuMhz: Number;
		cpuModel: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memorySize: Number;
		model: String;
		numCpuCores: Number;
		numCpuPkgs: Number;
		numCpuThreads: Number;
		numHBAs: Number;
		numNics: Number;
		otherIdentifyingInfo: VcHostSystemIdentificationInfo[];
		uuid: String;
		vendor: String;

		constructor();
		constructor(vendor?: String, model?: String, uuid?: String, otherIdentifyingInfo?: VcHostSystemIdentificationInfo[], memorySize?: Number, cpuModel?: String, cpuMhz?: Number, numCpuPkgs?: Number, numCpuCores?: Number, numCpuThreads?: Number, numNics?: Number, numHBAs?: Number);
	}

	declare class VcHostHasComponentFailure
	{
		componentName: String;
		componentType: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostName?: String, componentType?: String, componentName?: String);
		printStackTrace(): void;
	}

	interface VcHostHasComponentFailureHostComponentType
	{
		readonly Datastore: VcHostHasComponentFailureHostComponentType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostHasComponentFailureHostComponentType): VcHostHasComponentFailureHostComponentType;
	}

	declare const VcHostHasComponentFailureHostComponentType: VcHostHasComponentFailureHostComponentType;

	interface VcHostHealthStatusSystem
	{
		id: String;
		moref: VcManagedObjectReference;
		runtime: VcHealthSystemRuntime;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		clearSystemEventLog(): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		fetchSystemEventLog(): VcSystemEventInfo[];
		refreshHealthStatusSystem(): void;
		resetSystemHealthInfo(): void;
	}

	declare const VcHostHealthStatusSystem: VcHostHealthStatusSystem;

	declare class VcHostHostBusAdapter
	{
		bus: Number;
		device: String;
		driver: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		model: String;
		pci: String;
		status: String;

		constructor();
		constructor(key?: String, device?: String, bus?: Number, status?: String, model?: String, driver?: String, pci?: String);
	}

	interface VcHostHostUpdateProxyManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureHostUpdateProxy(arg0?: VcHostUpdateProxyConfigInfo): void;
		retrieveHostUpdateProxyConfig(): VcHostUpdateProxyConfigInfo;
	}

	declare const VcHostHostUpdateProxyManager: VcHostHostUpdateProxyManager;

	declare class VcHostHyperThreadScheduleInfo
	{
		active: boolean;
		available: boolean;
		config: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(available?: boolean, active?: boolean, config?: boolean);
	}

	interface VcHostImageAcceptanceLevel
	{
		readonly community: VcHostImageAcceptanceLevel;
		readonly id: String;
		readonly name: String;
		readonly partner: VcHostImageAcceptanceLevel;
		readonly value: String;
		readonly vmware_accepted: VcHostImageAcceptanceLevel;
		readonly vmware_certified: VcHostImageAcceptanceLevel;

		fromString(value?: VcHostImageAcceptanceLevel): VcHostImageAcceptanceLevel;
	}

	declare const VcHostImageAcceptanceLevel: VcHostImageAcceptanceLevel;

	interface VcHostImageConfigManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		fetchSoftwarePackages(): VcSoftwarePackage[];
		hostImageConfigGetAcceptance(): String;
		hostImageConfigGetProfile(): VcHostImageProfileSummary;
		installDate(): Date;
		updateHostImageAcceptanceLevel(arg0?: String): void;
	}

	declare const VcHostImageConfigManager: VcHostImageConfigManager;

	declare class VcHostImageProfileSummary
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		vendor: String;

		constructor();
		constructor(name?: String, vendor?: String);
	}

	declare class VcHostInAuditModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostIncompatibleForFaultTolerance
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(hostName?: String, reason?: String);
		printStackTrace(): void;
	}

	interface VcHostIncompatibleForFaultToleranceReason
	{
		readonly id: String;
		readonly name: String;
		readonly processor: VcHostIncompatibleForFaultToleranceReason;
		readonly product: VcHostIncompatibleForFaultToleranceReason;
		readonly value: String;

		fromString(value?: VcHostIncompatibleForFaultToleranceReason): VcHostIncompatibleForFaultToleranceReason;
	}

	declare const VcHostIncompatibleForFaultToleranceReason: VcHostIncompatibleForFaultToleranceReason;

	declare class VcHostIncompatibleForRecordReplay
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(hostName?: String, reason?: String);
		printStackTrace(): void;
	}

	interface VcHostIncompatibleForRecordReplayReason
	{
		readonly id: String;
		readonly name: String;
		readonly processor: VcHostIncompatibleForRecordReplayReason;
		readonly product: VcHostIncompatibleForRecordReplayReason;
		readonly value: String;

		fromString(value?: VcHostIncompatibleForRecordReplayReason): VcHostIncompatibleForRecordReplayReason;
	}

	declare const VcHostIncompatibleForRecordReplayReason: VcHostIncompatibleForRecordReplayReason;

	declare class VcHostInDomain
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcHostIntegrityReport
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		quoteData: VcHostIntegrityReportQuoteData;
		tpmEvents: VcHostTpmEventLogEntry[];
		tpmLogReliable: boolean;

		constructor();
		constructor(quoteData?: VcHostIntegrityReportQuoteData, tpmEvents?: VcHostTpmEventLogEntry[], tpmLogReliable?: boolean);
		isTpmLogReliable(): boolean;
	}

	declare class VcHostIntegrityReportQuoteData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pcrValues: VcHostTpmDigestInfo[];
		quoteInfo: VcHostIntegrityReportQuoteInfo;
		tpmSignature: VcHostSignatureInfo;

		constructor();
		constructor(pcrValues?: VcHostTpmDigestInfo[], quoteInfo?: VcHostIntegrityReportQuoteInfo, tpmSignature?: VcHostSignatureInfo);
	}

	declare class VcHostIntegrityReportQuoteInfo
	{
		digestValue: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalData: Number[];
		fixed: String;
		versionMajor: Number;
		versionMinor: Number;
		versionRevMajor: Number;
		versionRevMinor: Number;

		constructor();
		constructor(versionMajor?: Number, versionMinor?: Number, versionRevMajor?: Number, versionRevMinor?: Number, fixed?: String, digestValue?: Number[], externalData?: Number[]);
	}

	declare class VcHostInternalCapability
	{
		compatibleEVCModeKeys: String[];
		controllableStatsCountersSupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enumerateExtentsSupported: boolean;
		evcSoftwareSupported: boolean;
		fastSuspendResumeSupported: boolean;
		hostProfileEngineSupported: boolean;
		lunDisplayNameSupported: boolean;
		nfcCopyDeltaDiskSupported: boolean;
		nfcCopyRawDiskMappingSupported: boolean;
		operationCleanupManagerSupported: boolean;
		operationCleanupManagerSupportedForCreate: boolean;
		queryMigrationIdsSupported: boolean;
		svmVmxDiskCopySupported: boolean;
		virtualDiskDigestSupported: boolean;
		vmotionHostLogStateSupported: boolean;

		constructor();
		constructor(enumerateExtentsSupported?: boolean, fastSuspendResumeSupported?: boolean, svmVmxDiskCopySupported?: boolean, evcSoftwareSupported?: boolean, compatibleEVCModeKeys?: String[], lunDisplayNameSupported?: boolean, virtualDiskDigestSupported?: boolean, hostProfileEngineSupported?: boolean, controllableStatsCountersSupported?: boolean, nfcCopyRawDiskMappingSupported?: boolean, nfcCopyDeltaDiskSupported?: boolean, vmotionHostLogStateSupported?: boolean, operationCleanupManagerSupported?: boolean, operationCleanupManagerSupportedForCreate?: boolean, queryMigrationIdsSupported?: boolean);
		isControllableStatsCountersSupported(): boolean;
		isHostProfileEngineSupported(): boolean;
		isNfcCopyDeltaDiskSupported(): boolean;
		isNfcCopyRawDiskMappingSupported(): boolean;
		isOperationCleanupManagerSupported(): boolean;
		isOperationCleanupManagerSupportedForCreate(): boolean;
		isQueryMigrationIdsSupported(): boolean;
		isVirtualDiskDigestSupported(): boolean;
		isVmotionHostLogStateSupported(): boolean;
	}

	declare class VcHostInternalConfigManager
	{
		agentManager: VcAgentManager;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		llProvisioningManager: VcHostLowLevelProvisioningManager;
		nvdimmSystem: VcHostNvdimmSystem;
		systemDebugManager: VcHostSystemDebugManager;
		vmotionManager: VcHostVMotionManager;

		constructor();
		constructor(agentManager?: VcAgentManager, systemDebugManager?: VcHostSystemDebugManager, vmotionManager?: VcHostVMotionManager, llProvisioningManager?: VcHostLowLevelProvisioningManager, nvdimmSystem?: VcHostNvdimmSystem);
	}

	declare class VcHostInternetScsiHba
	{
		advancedOptions: VcHostInternetScsiHbaParamValue[];
		authenticationCapabilities: VcHostInternetScsiHbaAuthenticationCapabilities;
		authenticationProperties: VcHostInternetScsiHbaAuthenticationProperties;
		bus: Number;
		canBeDisabled: boolean;
		configuredSendTarget: VcHostInternetScsiHbaSendTarget[];
		configuredStaticTarget: VcHostInternetScsiHbaStaticTarget[];
		currentSpeedMb: Number;
		device: String;
		digestCapabilities: VcHostInternetScsiHbaDigestCapabilities;
		digestProperties: VcHostInternetScsiHbaDigestProperties;
		discoveryCapabilities: VcHostInternetScsiHbaDiscoveryCapabilities;
		discoveryProperties: VcHostInternetScsiHbaDiscoveryProperties;
		driver: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipCapabilities: VcHostInternetScsiHbaIPCapabilities;
		ipProperties: VcHostInternetScsiHbaIPProperties;
		iScsiAlias: String;
		iScsiName: String;
		isSoftwareBased: boolean;
		key: String;
		maxSpeedMb: Number;
		model: String;
		networkBindingSupport: VcHostInternetScsiHbaNetworkBindingSupportType;
		pci: String;
		status: String;
		supportedAdvancedOptions: VcOptionDef[];

		constructor();
		constructor(key?: String, device?: String, bus?: Number, status?: String, model?: String, driver?: String, pci?: String, isSoftwareBased?: boolean, canBeDisabled?: boolean, networkBindingSupport?: VcHostInternetScsiHbaNetworkBindingSupportType, discoveryCapabilities?: VcHostInternetScsiHbaDiscoveryCapabilities, discoveryProperties?: VcHostInternetScsiHbaDiscoveryProperties, authenticationCapabilities?: VcHostInternetScsiHbaAuthenticationCapabilities, authenticationProperties?: VcHostInternetScsiHbaAuthenticationProperties, digestCapabilities?: VcHostInternetScsiHbaDigestCapabilities, digestProperties?: VcHostInternetScsiHbaDigestProperties, ipCapabilities?: VcHostInternetScsiHbaIPCapabilities, ipProperties?: VcHostInternetScsiHbaIPProperties, supportedAdvancedOptions?: VcOptionDef[], advancedOptions?: VcHostInternetScsiHbaParamValue[], iScsiName?: String, iScsiAlias?: String, configuredSendTarget?: VcHostInternetScsiHbaSendTarget[], configuredStaticTarget?: VcHostInternetScsiHbaStaticTarget[], maxSpeedMb?: Number, currentSpeedMb?: Number);
		isCanBeDisabled(): boolean;
	}

	declare class VcHostInternetScsiHbaAuthenticationCapabilities
	{
		chapAuthSettable: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		krb5AuthSettable: boolean;
		mutualChapSettable: boolean;
		spkmAuthSettable: boolean;
		srpAuthSettable: boolean;
		targetChapSettable: boolean;
		targetMutualChapSettable: boolean;

		constructor();
		constructor(chapAuthSettable?: boolean, krb5AuthSettable?: boolean, srpAuthSettable?: boolean, spkmAuthSettable?: boolean, mutualChapSettable?: boolean, targetChapSettable?: boolean, targetMutualChapSettable?: boolean);
		isMutualChapSettable(): boolean;
		isTargetChapSettable(): boolean;
		isTargetMutualChapSettable(): boolean;
	}

	declare class VcHostInternetScsiHbaAuthenticationProperties
	{
		chapAuthEnabled: boolean;
		chapAuthenticationType: String;
		chapInherited: boolean;
		chapName: String;
		chapSecret: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mutualChapAuthenticationType: String;
		mutualChapInherited: boolean;
		mutualChapName: String;
		mutualChapSecret: String;

		constructor();
		constructor(chapAuthEnabled?: boolean, chapName?: String, chapSecret?: String, chapAuthenticationType?: String, chapInherited?: boolean, mutualChapName?: String, mutualChapSecret?: String, mutualChapAuthenticationType?: String, mutualChapInherited?: boolean);
		isChapInherited(): boolean;
		isMutualChapInherited(): boolean;
	}

	interface VcHostInternetScsiHbaChapAuthenticationType
	{
		readonly chapDiscouraged: VcHostInternetScsiHbaChapAuthenticationType;
		readonly chapPreferred: VcHostInternetScsiHbaChapAuthenticationType;
		readonly chapProhibited: VcHostInternetScsiHbaChapAuthenticationType;
		readonly chapRequired: VcHostInternetScsiHbaChapAuthenticationType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostInternetScsiHbaChapAuthenticationType): VcHostInternetScsiHbaChapAuthenticationType;
	}

	declare const VcHostInternetScsiHbaChapAuthenticationType: VcHostInternetScsiHbaChapAuthenticationType;

	declare class VcHostInternetScsiHbaDigestCapabilities
	{
		dataDigestSettable: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		headerDigestSettable: boolean;
		targetDataDigestSettable: boolean;
		targetHeaderDigestSettable: boolean;

		constructor();
		constructor(headerDigestSettable?: boolean, dataDigestSettable?: boolean, targetHeaderDigestSettable?: boolean, targetDataDigestSettable?: boolean);
		isDataDigestSettable(): boolean;
		isHeaderDigestSettable(): boolean;
		isTargetDataDigestSettable(): boolean;
		isTargetHeaderDigestSettable(): boolean;
	}

	declare class VcHostInternetScsiHbaDigestProperties
	{
		dataDigestInherited: boolean;
		dataDigestType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		headerDigestInherited: boolean;
		headerDigestType: String;

		constructor();
		constructor(headerDigestType?: String, headerDigestInherited?: boolean, dataDigestType?: String, dataDigestInherited?: boolean);
		isDataDigestInherited(): boolean;
		isHeaderDigestInherited(): boolean;
	}

	interface VcHostInternetScsiHbaDigestType
	{
		readonly digestDiscouraged: VcHostInternetScsiHbaDigestType;
		readonly digestPreferred: VcHostInternetScsiHbaDigestType;
		readonly digestProhibited: VcHostInternetScsiHbaDigestType;
		readonly digestRequired: VcHostInternetScsiHbaDigestType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostInternetScsiHbaDigestType): VcHostInternetScsiHbaDigestType;
	}

	declare const VcHostInternetScsiHbaDigestType: VcHostInternetScsiHbaDigestType;

	declare class VcHostInternetScsiHbaDiscoveryCapabilities
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		iSnsDiscoverySettable: boolean;
		sendTargetsDiscoverySettable: boolean;
		slpDiscoverySettable: boolean;
		staticTargetDiscoverySettable: boolean;

		constructor();
		constructor(iSnsDiscoverySettable?: boolean, slpDiscoverySettable?: boolean, staticTargetDiscoverySettable?: boolean, sendTargetsDiscoverySettable?: boolean);
	}

	declare class VcHostInternetScsiHbaDiscoveryProperties
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		iSnsDiscoveryEnabled: boolean;
		iSnsDiscoveryMethod: String;
		iSnsHost: String;
		sendTargetsDiscoveryEnabled: boolean;
		slpDiscoveryEnabled: boolean;
		slpDiscoveryMethod: String;
		slpHost: String;
		staticTargetDiscoveryEnabled: boolean;

		constructor();
		constructor(iSnsDiscoveryEnabled?: boolean, iSnsDiscoveryMethod?: String, iSnsHost?: String, slpDiscoveryEnabled?: boolean, slpDiscoveryMethod?: String, slpHost?: String, staticTargetDiscoveryEnabled?: boolean, sendTargetsDiscoveryEnabled?: boolean);
	}

	declare class VcHostInternetScsiHbaIPCapabilities
	{
		addressSettable: boolean;
		alternateDnsServerAddressSettable: boolean;
		arpRedirectSettable: boolean;
		defaultGatewaySettable: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostNameAsTargetAddress: boolean;
		ipConfigurationMethodSettable: boolean;
		ipv4EnableSettable: boolean;
		ipv6DefaultGatewaySettable: boolean;
		ipv6DhcpConfigurationSettable: boolean;
		ipv6EnableSettable: boolean;
		ipv6LinkLocalAutoConfigurationSettable: boolean;
		ipv6MaxStaticAddressesSupported: Number;
		ipv6PrefixLength: Number;
		ipv6PrefixLengthSettable: boolean;
		ipv6RouterAdvertisementConfigurationSettable: boolean;
		ipv6Supported: boolean;
		mtuSettable: boolean;
		nameAliasSettable: boolean;
		primaryDnsServerAddressSettable: boolean;
		subnetMaskSettable: boolean;

		constructor();
		constructor(addressSettable?: boolean, ipConfigurationMethodSettable?: boolean, subnetMaskSettable?: boolean, defaultGatewaySettable?: boolean, primaryDnsServerAddressSettable?: boolean, alternateDnsServerAddressSettable?: boolean, ipv6Supported?: boolean, arpRedirectSettable?: boolean, mtuSettable?: boolean, hostNameAsTargetAddress?: boolean, nameAliasSettable?: boolean, ipv4EnableSettable?: boolean, ipv6EnableSettable?: boolean, ipv6PrefixLengthSettable?: boolean, ipv6PrefixLength?: Number, ipv6DhcpConfigurationSettable?: boolean, ipv6LinkLocalAutoConfigurationSettable?: boolean, ipv6RouterAdvertisementConfigurationSettable?: boolean, ipv6DefaultGatewaySettable?: boolean, ipv6MaxStaticAddressesSupported?: Number);
		isArpRedirectSettable(): boolean;
		isHostNameAsTargetAddress(): boolean;
		isIpv4EnableSettable(): boolean;
		isIpv6DefaultGatewaySettable(): boolean;
		isIpv6DhcpConfigurationSettable(): boolean;
		isIpv6EnableSettable(): boolean;
		isIpv6LinkLocalAutoConfigurationSettable(): boolean;
		isIpv6PrefixLengthSettable(): boolean;
		isIpv6RouterAdvertisementConfigurationSettable(): boolean;
		isIpv6Supported(): boolean;
		isMtuSettable(): boolean;
		isNameAliasSettable(): boolean;
	}

	declare class VcHostInternetScsiHbaIPProperties
	{
		address: String;
		alternateDnsServerAddress: String;
		arpRedirectEnabled: boolean;
		defaultGateway: String;
		dhcpConfigurationEnabled: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipv4Enabled: boolean;
		ipv6Address: String;
		ipv6DefaultGateway: String;
		ipv6Enabled: boolean;
		ipv6properties: VcHostInternetScsiHbaIPv6Properties;
		ipv6SubnetMask: String;
		jumboFramesEnabled: boolean;
		mac: String;
		mtu: Number;
		primaryDnsServerAddress: String;
		subnetMask: String;

		constructor();
		constructor(mac?: String, address?: String, dhcpConfigurationEnabled?: boolean, subnetMask?: String, defaultGateway?: String, primaryDnsServerAddress?: String, alternateDnsServerAddress?: String, ipv6Address?: String, ipv6SubnetMask?: String, ipv6DefaultGateway?: String, arpRedirectEnabled?: boolean, mtu?: Number, jumboFramesEnabled?: boolean, ipv4Enabled?: boolean, ipv6Enabled?: boolean, ipv6properties?: VcHostInternetScsiHbaIPv6Properties);
		isArpRedirectEnabled(): boolean;
		isIpv4Enabled(): boolean;
		isIpv6Enabled(): boolean;
		isJumboFramesEnabled(): boolean;
	}

	declare class VcHostInternetScsiHbaIPv6Properties
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipv6DefaultGateway: String;
		ipv6DhcpConfigurationEnabled: boolean;
		ipv6LinkLocalAutoConfigurationEnabled: boolean;
		ipv6RouterAdvertisementConfigurationEnabled: boolean;
		iscsiIpv6Address: VcHostInternetScsiHbaIscsiIpv6Address[];

		constructor();
		constructor(iscsiIpv6Address?: VcHostInternetScsiHbaIscsiIpv6Address[], ipv6DhcpConfigurationEnabled?: boolean, ipv6LinkLocalAutoConfigurationEnabled?: boolean, ipv6RouterAdvertisementConfigurationEnabled?: boolean, ipv6DefaultGateway?: String);
		isIpv6DhcpConfigurationEnabled(): boolean;
		isIpv6LinkLocalAutoConfigurationEnabled(): boolean;
		isIpv6RouterAdvertisementConfigurationEnabled(): boolean;
	}

	declare class VcHostInternetScsiHbaIscsiIpv6Address
	{
		address: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operation: String;
		origin: String;
		prefixLength: Number;

		constructor();
		constructor(address?: String, prefixLength?: Number, origin?: String, operation?: String);
	}

	interface VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType
	{
		readonly AutoConfigured: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly DHCP: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly id: String;
		readonly name: String;
		readonly Other: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly Static: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly value: String;

		fromString(value?: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType): VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
	}

	declare const VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;

	interface VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation
	{
		readonly add: VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
		readonly id: String;
		readonly name: String;
		readonly remove: VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
		readonly value: String;

		fromString(value?: VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation): VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
	}

	declare const VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation: VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;

	interface VcHostInternetScsiHbaNetworkBindingSupportType
	{
		readonly id: String;
		readonly name: String;
		readonly notsupported: VcHostInternetScsiHbaNetworkBindingSupportType;
		readonly optional: VcHostInternetScsiHbaNetworkBindingSupportType;
		readonly required: VcHostInternetScsiHbaNetworkBindingSupportType;
		readonly value: String;

		fromString(value?: VcHostInternetScsiHbaNetworkBindingSupportType): VcHostInternetScsiHbaNetworkBindingSupportType;
	}

	declare const VcHostInternetScsiHbaNetworkBindingSupportType: VcHostInternetScsiHbaNetworkBindingSupportType;

	declare class VcHostInternetScsiHbaParamValue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		isInherited: boolean;
		key: String;
		value_AnyValue: Object;
		value_FloatValue: Number;
		value_IntValue: Number;
		value_LongValue: Number;

		constructor();
		constructor(key?: String, value?: Object, isInherited?: boolean);
		isIsInherited(): boolean;
	}

	declare class VcHostInternetScsiHbaSendTarget
	{
		address: String;
		advancedOptions: VcHostInternetScsiHbaParamValue[];
		authenticationProperties: VcHostInternetScsiHbaAuthenticationProperties;
		digestProperties: VcHostInternetScsiHbaDigestProperties;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parent: String;
		port: Number;
		supportedAdvancedOptions: VcOptionDef[];

		constructor();
		constructor(address?: String, port?: Number, authenticationProperties?: VcHostInternetScsiHbaAuthenticationProperties, digestProperties?: VcHostInternetScsiHbaDigestProperties, supportedAdvancedOptions?: VcOptionDef[], advancedOptions?: VcHostInternetScsiHbaParamValue[], parent?: String);
	}

	declare class VcHostInternetScsiHbaStaticTarget
	{
		address: String;
		advancedOptions: VcHostInternetScsiHbaParamValue[];
		authenticationProperties: VcHostInternetScsiHbaAuthenticationProperties;
		digestProperties: VcHostInternetScsiHbaDigestProperties;
		discoveryMethod: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		iScsiName: String;
		parent: String;
		port: Number;
		supportedAdvancedOptions: VcOptionDef[];

		constructor();
		constructor(address?: String, port?: Number, iScsiName?: String, discoveryMethod?: String, authenticationProperties?: VcHostInternetScsiHbaAuthenticationProperties, digestProperties?: VcHostInternetScsiHbaDigestProperties, supportedAdvancedOptions?: VcOptionDef[], advancedOptions?: VcHostInternetScsiHbaParamValue[], parent?: String);
	}

	interface VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod
	{
		readonly id: String;
		readonly isnsMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly name: String;
		readonly sendTargetMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly slpMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly staticMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly unknownMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly value: String;

		fromString(value?: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod): VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
	}

	declare const VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;

	declare class VcHostInternetScsiHbaTargetSet
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		sendTargets: VcHostInternetScsiHbaSendTarget[];
		staticTargets: VcHostInternetScsiHbaStaticTarget[];

		constructor();
		constructor(staticTargets?: VcHostInternetScsiHbaStaticTarget[], sendTargets?: VcHostInternetScsiHbaSendTarget[]);
	}

	declare class VcHostInternetScsiTargetTransport
	{
		address: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		iScsiAlias: String;
		iScsiName: String;

		constructor();
		constructor(iScsiName?: String, iScsiAlias?: String, address?: String[]);
	}

	declare class VcHostInventoryFull
	{
		capacity: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor(capacity?: Number);
		constructor();
		printStackTrace(): void;
	}

	declare class VcHostInventoryFullEvent
	{
		capacity: Number;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, capacity?: Number);
		constructor();
	}

	declare class VcHostInventoryUnreadableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostIoFilterInfo
	{
		available: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		name: String;
		releaseDate: String;
		summary: String;
		type: String;
		vendor: String;
		version: String;

		constructor();
		constructor(id?: String, name?: String, vendor?: String, version?: String, type?: String, summary?: String, releaseDate?: String, available?: boolean);
	}

	declare class VcHostIpChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newIP: String;
		oldIP: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, oldIP?: String, newIP?: String);
	}

	declare class VcHostIpConfig
	{
		dhcp: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;
		ipV6Config: VcHostIpConfigIpV6AddressConfiguration;
		subnetMask: String;

		constructor();
		constructor(dhcp?: boolean, ipAddress?: String, subnetMask?: String, ipV6Config?: VcHostIpConfigIpV6AddressConfiguration);
	}

	declare class VcHostIpConfigIpV6Address
	{
		dadState: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;
		lifetime: Date;
		operation: String;
		origin: String;
		prefixLength: Number;

		constructor();
		constructor(ipAddress?: String, prefixLength?: Number, origin?: String, dadState?: String, lifetime?: Date, operation?: String);
	}

	interface VcHostIpConfigIpV6AddressConfigType
	{
		readonly dhcp: VcHostIpConfigIpV6AddressConfigType;
		readonly id: String;
		readonly linklayer: VcHostIpConfigIpV6AddressConfigType;
		readonly manual: VcHostIpConfigIpV6AddressConfigType;
		readonly name: String;
		readonly other: VcHostIpConfigIpV6AddressConfigType;
		readonly random: VcHostIpConfigIpV6AddressConfigType;
		readonly value: String;

		fromString(value?: VcHostIpConfigIpV6AddressConfigType): VcHostIpConfigIpV6AddressConfigType;
	}

	declare const VcHostIpConfigIpV6AddressConfigType: VcHostIpConfigIpV6AddressConfigType;

	declare class VcHostIpConfigIpV6AddressConfiguration
	{
		autoConfigurationEnabled: boolean;
		dhcpV6Enabled: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipV6Address: VcHostIpConfigIpV6Address[];

		constructor();
		constructor(ipV6Address?: VcHostIpConfigIpV6Address[], autoConfigurationEnabled?: boolean, dhcpV6Enabled?: boolean);
		isAutoConfigurationEnabled(): boolean;
		isDhcpV6Enabled(): boolean;
	}

	interface VcHostIpConfigIpV6AddressStatus
	{
		readonly deprecated: VcHostIpConfigIpV6AddressStatus;
		readonly duplicate: VcHostIpConfigIpV6AddressStatus;
		readonly id: String;
		readonly inaccessible: VcHostIpConfigIpV6AddressStatus;
		readonly invalid: VcHostIpConfigIpV6AddressStatus;
		readonly name: String;
		readonly preferred: VcHostIpConfigIpV6AddressStatus;
		readonly tentative: VcHostIpConfigIpV6AddressStatus;
		readonly unknown: VcHostIpConfigIpV6AddressStatus;
		readonly value: String;

		fromString(value?: VcHostIpConfigIpV6AddressStatus): VcHostIpConfigIpV6AddressStatus;
	}

	declare const VcHostIpConfigIpV6AddressStatus: VcHostIpConfigIpV6AddressStatus;

	declare class VcHostIpInconsistentEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ipAddress: String;
		ipAddress2: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, ipAddress?: String, ipAddress2?: String);
	}

	declare class VcHostIpmiInfo
	{
		bmcIpAddress: String;
		bmcMacAddress: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		login: String;
		password: String;

		constructor();
		constructor(bmcIpAddress?: String, bmcMacAddress?: String, login?: String, password?: String);
	}

	declare class VcHostIpRouteConfig
	{
		defaultGateway: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gatewayDevice: String;
		ipV6DefaultGateway: String;
		ipV6GatewayDevice: String;

		constructor();
		constructor(defaultGateway?: String, gatewayDevice?: String, ipV6DefaultGateway?: String, ipV6GatewayDevice?: String);
	}

	declare class VcHostIpRouteConfigSpec
	{
		defaultGateway: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gatewayDevice: String;
		gatewayDeviceConnection: VcHostVirtualNicConnection;
		ipV6DefaultGateway: String;
		ipV6GatewayDevice: String;
		ipV6GatewayDeviceConnection: VcHostVirtualNicConnection;

		constructor();
		constructor(defaultGateway?: String, gatewayDevice?: String, ipV6DefaultGateway?: String, ipV6GatewayDevice?: String, gatewayDeviceConnection?: VcHostVirtualNicConnection, ipV6GatewayDeviceConnection?: VcHostVirtualNicConnection);
	}

	declare class VcHostIpRouteEntry
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gateway: String;
		network: String;
		prefixLength: Number;

		constructor();
		constructor(network?: String, prefixLength?: Number, gateway?: String, deviceName?: String);
	}

	declare class VcHostIpRouteOp
	{
		changeOperation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		route: VcHostIpRouteEntry;

		constructor();
		constructor(changeOperation?: String, route?: VcHostIpRouteEntry);
	}

	declare class VcHostIpRouteTableConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipRoute: VcHostIpRouteOp[];
		ipv6Route: VcHostIpRouteOp[];

		constructor();
		constructor(ipRoute?: VcHostIpRouteOp[], ipv6Route?: VcHostIpRouteOp[]);
	}

	declare class VcHostIpRouteTableInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipRoute: VcHostIpRouteEntry[];
		ipv6Route: VcHostIpRouteEntry[];

		constructor();
		constructor(ipRoute?: VcHostIpRouteEntry[], ipv6Route?: VcHostIpRouteEntry[]);
	}

	declare class VcHostIpToShortNameFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostIsolationIpPingFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		isolationIp: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, isolationIp?: String);
	}

	interface VcHostKernelModuleSystem
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryConfiguredModuleOptionString(arg0?: String): String;
		queryModules(): VcKernelModuleInfo[];
		updateModuleOptionString(arg0?: String, arg1?: String): void;
	}

	declare const VcHostKernelModuleSystem: VcHostKernelModuleSystem;

	declare class VcHostLicensableResourceInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		resource: VcKeyAnyValue[];

		constructor();
		constructor(resource?: VcKeyAnyValue[]);
	}

	interface VcHostLicensableResourceKey
	{
		readonly id: String;
		readonly memoryForVms: VcHostLicensableResourceKey;
		readonly memorySize: VcHostLicensableResourceKey;
		readonly name: String;
		readonly numCpuCores: VcHostLicensableResourceKey;
		readonly numCpuPackages: VcHostLicensableResourceKey;
		readonly numVmsStarted: VcHostLicensableResourceKey;
		readonly numVmsStarting: VcHostLicensableResourceKey;
		readonly value: String;

		fromString(value?: VcHostLicensableResourceKey): VcHostLicensableResourceKey;
	}

	declare const VcHostLicensableResourceKey: VcHostLicensableResourceKey;

	declare class VcHostLicenseConnectInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		evaluation: VcLicenseManagerEvaluationInfo;
		license: VcLicenseManagerLicenseInfo;
		resource: VcHostLicensableResourceInfo;

		constructor();
		constructor(license?: VcLicenseManagerLicenseInfo, evaluation?: VcLicenseManagerEvaluationInfo, resource?: VcHostLicensableResourceInfo);
	}

	declare class VcHostLicenseExpiredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostLicenseSpec
	{
		disabledFeatureKey: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		editionKey: String;
		enabledFeatureKey: String[];
		source: VcLicenseSource;

		constructor();
		constructor(source?: VcLicenseSource, editionKey?: String, disabledFeatureKey?: String[], enabledFeatureKey?: String[]);
	}

	declare class VcHostListSummary
	{
		config: VcHostConfigSummary;
		currentEVCModeKey: String;
		customValue: VcCustomFieldValue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gateway: VcHostListSummaryGatewaySummary;
		hardware: VcHostHardwareSummary;
		host: VcHostSystem;
		managementServerIp: String;
		maxEVCModeKey: String;
		overallStatus: VcManagedEntityStatus;
		quickStats: VcHostListSummaryQuickStats;
		rebootRequired: boolean;
		runtime: VcHostRuntimeInfo;

		constructor();
		constructor(host?: VcHostSystem, hardware?: VcHostHardwareSummary, runtime?: VcHostRuntimeInfo, config?: VcHostConfigSummary, quickStats?: VcHostListSummaryQuickStats, overallStatus?: VcManagedEntityStatus, rebootRequired?: boolean, customValue?: VcCustomFieldValue[], managementServerIp?: String, maxEVCModeKey?: String, currentEVCModeKey?: String, gateway?: VcHostListSummaryGatewaySummary);
	}

	declare class VcHostListSummaryGatewaySummary
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gatewayId: String;
		gatewayType: String;

		constructor();
		constructor(gatewayType?: String, gatewayId?: String);
	}

	declare class VcHostListSummaryQuickStats
	{
		distributedCpuFairness: Number;
		distributedMemoryFairness: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		overallCpuUsage: Number;
		overallMemoryUsage: Number;
		uptime: Number;

		constructor();
		constructor(overallCpuUsage?: Number, overallMemoryUsage?: Number, distributedCpuFairness?: Number, distributedMemoryFairness?: Number, uptime?: Number);
	}

	interface VcHostLocalAccountManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		assignUserToGroup(arg0?: String, arg1?: String): void;
		createGroup(arg0?: VcHostAccountSpec): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createUser(arg0?: VcHostAccountSpec): void;
		removeGroup(arg0?: String): void;
		removeUser(arg0?: String): void;
		unassignUserFromGroup(arg0?: String, arg1?: String): void;
		updateUser(arg0?: VcHostAccountSpec): void;
	}

	declare const VcHostLocalAccountManager: VcHostLocalAccountManager;

	interface VcHostLocalAuthentication
	{
		id: String;
		readonly info: VcHostAuthenticationStoreInfo;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostLocalAuthentication: VcHostLocalAuthentication;

	declare class VcHostLocalAuthenticationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;

		constructor();
		constructor(enabled?: boolean);
	}

	declare class VcHostLocalFileSystemVolume
	{
		capacity: Number;
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		type: String;

		constructor();
		constructor(type?: String, name?: String, capacity?: Number, device?: String);
	}

	declare class VcHostLocalFileSystemVolumeSpec
	{
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		localPath: String;

		constructor();
		constructor(device?: String, localPath?: String);
	}

	declare class VcHostLocalPortCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostLocalPort: VcDVSHostLocalPortInfo;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostLocalPort?: VcDVSHostLocalPortInfo);
	}

	interface VcHostLockdownMode
	{
		readonly id: String;
		readonly lockdownDisabled: VcHostLockdownMode;
		readonly lockdownNormal: VcHostLockdownMode;
		readonly lockdownStrict: VcHostLockdownMode;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostLockdownMode): VcHostLockdownMode;
	}

	declare const VcHostLockdownMode: VcHostLockdownMode;

	interface VcHostLowLevelProvisioningManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteVm_Task(arg0?: VcVirtualMachineConfigInfo): VcTask;
		deleteVmExceptDisks_Task(arg0?: String): VcTask;
		lLPMReconfigVM_Task(arg0?: VcVirtualMachineConfigSpec): VcTask;
		lowLevelConsolidateDisks_Task(arg0?: VcVirtualMachine, arg1?: VcVirtualDisk[]): VcTask;
		lowLevelCreateVm_Task(arg0?: VcVirtualMachineConfigSpec): VcTask;
		lowLevelDeleteFiles(arg0?: VcHostLowLevelProvisioningManagerFileDeleteSpec[]): VcHostLowLevelProvisioningManagerFileDeleteResult[];
		lowLevelExtractNvramContent_Task(arg0?: String, arg1?: String, arg2?: String): VcTask;
		lowLevelPromoteDisks_Task(arg0?: VcVirtualMachine, arg1?: VcHostLowLevelProvisioningManagerPromoteDisksSpec[]): VcTask;
		lowLevelReserveFiles(arg0?: VcHostLowLevelProvisioningManagerFileReserveSpec[]): VcHostLowLevelProvisioningManagerFileReserveResult[];
		relayoutSnapshots_Task(arg0?: String, arg1?: VcHostLowLevelProvisioningManagerSnapshotLayoutSpec[]): VcTask;
		reloadDisks_Task(arg0?: VcVirtualMachine, arg1?: String[]): VcTask;
		retrieveLastVmMigrationStatus_Task(arg0?: String): VcTask;
		retrieveVmRecoveryInfo_Task(arg0?: String): VcTask;
	}

	declare const VcHostLowLevelProvisioningManager: VcHostLowLevelProvisioningManager;

	declare class VcHostLowLevelProvisioningManagerDiskLayoutSpec
	{
		busNumber: Number;
		controllerType: String;
		dstFilename: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		srcFilename: String;
		unitNumber: Number;

		constructor();
		constructor(controllerType?: String, busNumber?: Number, unitNumber?: Number, srcFilename?: String, dstFilename?: String);
	}

	declare class VcHostLowLevelProvisioningManagerFileDeleteResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		fileName: String;

		constructor();
		constructor(fileName?: String, fault?: VcLocalizedMethodFault);
	}

	declare class VcHostLowLevelProvisioningManagerFileDeleteSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;
		fileType: String;

		constructor();
		constructor(fileName?: String, fileType?: String);
	}

	declare class VcHostLowLevelProvisioningManagerFileReserveResult
	{
		baseName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parentDir: String;
		reservedName: String;

		constructor();
		constructor(baseName?: String, parentDir?: String, reservedName?: String);
	}

	declare class VcHostLowLevelProvisioningManagerFileReserveSpec
	{
		baseName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileType: String;
		parentDir: String;
		storageProfile: String;

		constructor();
		constructor(baseName?: String, parentDir?: String, fileType?: String, storageProfile?: String);
	}

	interface VcHostLowLevelProvisioningManagerFileType
	{
		readonly Directory: VcHostLowLevelProvisioningManagerFileType;
		readonly File: VcHostLowLevelProvisioningManagerFileType;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly VirtualDisk: VcHostLowLevelProvisioningManagerFileType;

		fromString(value?: VcHostLowLevelProvisioningManagerFileType): VcHostLowLevelProvisioningManagerFileType;
	}

	declare const VcHostLowLevelProvisioningManagerFileType: VcHostLowLevelProvisioningManagerFileType;

	declare class VcHostLowLevelProvisioningManagerPromoteDisksSpec
	{
		diskId: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		numLinks: Number;
		offsetFromBottom: Number;

		constructor();
		constructor(diskId?: Number, offsetFromBottom?: Number, numLinks?: Number);
	}

	interface VcHostLowLevelProvisioningManagerReloadTarget
	{
		readonly currentConfig: VcHostLowLevelProvisioningManagerReloadTarget;
		readonly id: String;
		readonly name: String;
		readonly snapshotConfig: VcHostLowLevelProvisioningManagerReloadTarget;
		readonly value: String;

		fromString(value?: VcHostLowLevelProvisioningManagerReloadTarget): VcHostLowLevelProvisioningManagerReloadTarget;
	}

	declare const VcHostLowLevelProvisioningManagerReloadTarget: VcHostLowLevelProvisioningManagerReloadTarget;

	declare class VcHostLowLevelProvisioningManagerSnapshotLayoutSpec
	{
		disk: VcHostLowLevelProvisioningManagerDiskLayoutSpec[];
		dstFilename: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: Number;
		srcFilename: String;

		constructor();
		constructor(id?: Number, srcFilename?: String, dstFilename?: String, disk?: VcHostLowLevelProvisioningManagerDiskLayoutSpec[]);
	}

	declare class VcHostLowLevelProvisioningManagerVmMigrationStatus
	{
		consideredSuccessful: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		migrationId: Number;
		source: boolean;
		type: String;

		constructor();
		constructor(migrationId?: Number, type?: String, source?: boolean, consideredSuccessful?: boolean);
	}

	declare class VcHostLowLevelProvisioningManagerVmRecoveryInfo
	{
		biosUUID: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ftInfo: VcFaultToleranceConfigInfo;
		instanceUUID: String;
		version: String;

		constructor();
		constructor(version?: String, biosUUID?: String, instanceUUID?: String, ftInfo?: VcFaultToleranceConfigInfo);
	}

	declare class VcHostMaintenanceSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vsanMode: VcVsanHostDecommissionMode;

		constructor();
		constructor(vsanMode?: VcVsanHostDecommissionMode);
	}

	declare class VcHostMemberHealthCheckResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		summary: String;

		constructor();
		constructor(summary?: String);
	}

	declare class VcHostMemberRuntimeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		healthCheckResult: VcHostMemberHealthCheckResult[];
		host: VcHostSystem;
		status: String;
		statusDetail: String;

		constructor();
		constructor(host?: VcHostSystem, status?: String, statusDetail?: String, healthCheckResult?: VcHostMemberHealthCheckResult[]);
	}

	declare class VcHostMemberSelection
	{
		dvsUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;

		constructor();
		constructor(dvsUuid?: String, host?: VcHostSystem);
	}

	declare class VcHostMemberUplinkHealthCheckResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		summary: String;
		uplinkPortKey: String;

		constructor();
		constructor(summary?: String, uplinkPortKey?: String);
	}

	declare class VcHostMemoryProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcHostMemorySpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		serviceConsoleReservation: Number;

		constructor();
		constructor(serviceConsoleReservation?: Number);
	}

	interface VcHostMemorySystem
	{
		readonly availableField: VcCustomFieldDef[];
		consoleReservationInfo: VcServiceConsoleReservationInfo;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		virtualMachineReservationInfo: VcVirtualMachineMemoryReservationInfo;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureServiceConsoleReservation(arg0?: Number): void;
		reconfigureVirtualMachineReservation(arg0?: VcVirtualMachineMemoryReservationSpec): void;
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcHostMemorySystem: VcHostMemorySystem;

	declare class VcHostMissingNetworksEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ips: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, ips?: String);
	}

	declare class VcHostMonitoringStateChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		prevState: String;
		state: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, state?: String, prevState?: String);
	}

	declare class VcHostMountInfo
	{
		accessible: boolean;
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inaccessibleReason: String;
		mounted: boolean;
		path: String;

		constructor();
		constructor(path?: String, accessMode?: String, mounted?: boolean, accessible?: boolean, inaccessibleReason?: String);
		isAccessible(): boolean;
		isMounted(): boolean;
	}

	interface VcHostMountInfoInaccessibleReason
	{
		readonly AllPathsDown_Start: VcHostMountInfoInaccessibleReason;
		readonly AllPathsDown_Timeout: VcHostMountInfoInaccessibleReason;
		readonly id: String;
		readonly name: String;
		readonly PermanentDeviceLoss: VcHostMountInfoInaccessibleReason;
		readonly value: String;

		fromString(value?: VcHostMountInfoInaccessibleReason): VcHostMountInfoInaccessibleReason;
	}

	declare const VcHostMountInfoInaccessibleReason: VcHostMountInfoInaccessibleReason;

	interface VcHostMountMode
	{
		readonly id: String;
		readonly name: String;
		readonly readOnly: VcHostMountMode;
		readonly readWrite: VcHostMountMode;
		readonly value: String;

		fromString(value?: VcHostMountMode): VcHostMountMode;
	}

	declare const VcHostMountMode: VcHostMountMode;

	declare class VcHostMultipathInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lun: VcHostMultipathInfoLogicalUnit[];

		constructor();
		constructor(lun?: VcHostMultipathInfoLogicalUnit[]);
	}

	declare class VcHostMultipathInfoFixedLogicalUnitPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policy: String;
		prefer: String;

		constructor();
		constructor(policy?: String, prefer?: String);
	}

	declare class VcHostMultipathInfoLogicalUnit
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		key: String;
		lun: String;
		path: VcHostMultipathInfoPath[];
		policy: VcHostMultipathInfoLogicalUnitPolicy;
		storageArrayTypePolicy: VcHostMultipathInfoLogicalUnitStorageArrayTypePolicy;

		constructor();
		constructor(key?: String, id?: String, lun?: String, path?: VcHostMultipathInfoPath[], policy?: VcHostMultipathInfoLogicalUnitPolicy, storageArrayTypePolicy?: VcHostMultipathInfoLogicalUnitStorageArrayTypePolicy);
	}

	declare class VcHostMultipathInfoLogicalUnitPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policy: String;

		constructor();
		constructor(policy?: String);
	}

	declare class VcHostMultipathInfoLogicalUnitStorageArrayTypePolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policy: String;

		constructor();
		constructor(policy?: String);
	}

	declare class VcHostMultipathInfoPath
	{
		adapter: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		isWorkingPath: boolean;
		key: String;
		lun: String;
		name: String;
		pathState: String;
		state: String;
		transport: VcHostTargetTransport;

		constructor();
		constructor(key?: String, name?: String, pathState?: String, state?: String, isWorkingPath?: boolean, adapter?: String, lun?: String, transport?: VcHostTargetTransport);
		isIsWorkingPath(): boolean;
	}

	declare class VcHostMultipathStateInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		path: VcHostMultipathStateInfoPath[];

		constructor(path?: VcHostMultipathStateInfoPath[]);
		constructor();
	}

	declare class VcHostMultipathStateInfoPath
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		pathState: String;

		constructor();
		constructor(name?: String, pathState?: String);
	}

	declare class VcHostNasVolume
	{
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		protocolEndpoint: boolean;
		remoteHost: String;
		remoteHostNames: String[];
		remotePath: String;
		securityType: String;
		type: String;
		userName: String;

		constructor();
		constructor(type?: String, name?: String, capacity?: Number, remoteHost?: String, remotePath?: String, userName?: String, remoteHostNames?: String[], securityType?: String, protocolEndpoint?: boolean);
		isProtocolEndpoint(): boolean;
	}

	declare class VcHostNasVolumeConfig
	{
		changeOperation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		spec: VcHostNasVolumeSpec;

		constructor();
		constructor(changeOperation?: String, spec?: VcHostNasVolumeSpec);
	}

	interface VcHostNasVolumeSecurityType
	{
		readonly AUTH_SYS: VcHostNasVolumeSecurityType;
		readonly id: String;
		readonly name: String;
		readonly SEC_KRB5: VcHostNasVolumeSecurityType;
		readonly SEC_KRB5I: VcHostNasVolumeSecurityType;
		readonly value: String;

		fromString(value?: VcHostNasVolumeSecurityType): VcHostNasVolumeSecurityType;
	}

	declare const VcHostNasVolumeSecurityType: VcHostNasVolumeSecurityType;

	declare class VcHostNasVolumeSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		localPath: String;
		password: String;
		remoteHost: String;
		remoteHostNames: String[];
		remotePath: String;
		securityType: String;
		type: String;
		userName: String;

		constructor();
		constructor(remoteHost?: String, remotePath?: String, localPath?: String, accessMode?: String, type?: String, userName?: String, password?: String, remoteHostNames?: String[], securityType?: String);
	}

	declare class VcHostNasVolumeUserInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		user: String;

		constructor();
		constructor(user?: String);
	}

	declare class VcHostNatService
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		spec: VcHostNatServiceSpec;

		constructor();
		constructor(key?: String, spec?: VcHostNatServiceSpec);
	}

	declare class VcHostNatServiceConfig
	{
		changeOperation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		spec: VcHostNatServiceSpec;

		constructor();
		constructor(changeOperation?: String, key?: String, spec?: VcHostNatServiceSpec);
	}

	declare class VcHostNatServiceNameServiceSpec
	{
		dnsAutoDetect: boolean;
		dnsNameServer: String[];
		dnsPolicy: String;
		dnsRetries: Number;
		dnsTimeout: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nbdsTimeout: Number;
		nbnsRetries: Number;
		nbnsTimeout: Number;

		constructor();
		constructor(dnsAutoDetect?: boolean, dnsPolicy?: String, dnsRetries?: Number, dnsTimeout?: Number, dnsNameServer?: String[], nbdsTimeout?: Number, nbnsRetries?: Number, nbnsTimeout?: Number);
	}

	declare class VcHostNatServicePortForwardSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		guestIpAddress: String;
		guestPort: Number;
		hostPort: Number;
		name: String;
		type: String;

		constructor();
		constructor(type?: String, name?: String, hostPort?: Number, guestPort?: Number, guestIpAddress?: String);
	}

	declare class VcHostNatServiceSpec
	{
		activeFtp: boolean;
		allowAnyOui: boolean;
		configPort: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipGatewayAddress: String;
		nameService: VcHostNatServiceNameServiceSpec;
		portForward: VcHostNatServicePortForwardSpec[];
		udpTimeout: Number;
		virtualSwitch: String;

		constructor();
		constructor(virtualSwitch?: String, activeFtp?: boolean, allowAnyOui?: boolean, configPort?: boolean, ipGatewayAddress?: String, udpTimeout?: Number, portForward?: VcHostNatServicePortForwardSpec[], nameService?: VcHostNatServiceNameServiceSpec);
	}

	declare class VcHostNetCapabilities
	{
		canSetPhysicalNicLinkSpeed: boolean;
		dhcpOnVnicSupported: boolean;
		dnsConfigSupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipRouteConfigSupported: boolean;
		ipV6Supported: boolean;
		maxPortGroupsPerVswitch: Number;
		nicTeamingPolicy: String[];
		supportsNetworkHints: boolean;
		supportsNicTeaming: boolean;
		supportsVlan: boolean;
		usesServiceConsoleNic: boolean;
		vnicConfigSupported: boolean;
		vswitchConfigSupported: boolean;

		constructor();
		constructor(canSetPhysicalNicLinkSpeed?: boolean, supportsNicTeaming?: boolean, nicTeamingPolicy?: String[], supportsVlan?: boolean, usesServiceConsoleNic?: boolean, supportsNetworkHints?: boolean, maxPortGroupsPerVswitch?: Number, vswitchConfigSupported?: boolean, vnicConfigSupported?: boolean, ipRouteConfigSupported?: boolean, dnsConfigSupported?: boolean, dhcpOnVnicSupported?: boolean, ipV6Supported?: boolean);
		isIpV6Supported(): boolean;
	}

	declare class VcHostNetOffloadCapabilities
	{
		csumOffload: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		tcpSegmentation: boolean;
		zeroCopyXmit: boolean;

		constructor();
		constructor(csumOffload?: boolean, tcpSegmentation?: boolean, zeroCopyXmit?: boolean);
		isCsumOffload(): boolean;
		isTcpSegmentation(): boolean;
		isZeroCopyXmit(): boolean;
	}

	declare class VcHostNetStackInstance
	{
		congestionControlAlgorithm: String;
		dnsConfig: VcHostDnsConfig;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipRouteConfig: VcHostIpRouteConfig;
		ipV6Enabled: boolean;
		key: String;
		name: String;
		requestedMaxNumberOfConnections: Number;
		routeTableConfig: VcHostIpRouteTableConfig;

		constructor();
		constructor(key?: String, name?: String, dnsConfig?: VcHostDnsConfig, ipRouteConfig?: VcHostIpRouteConfig, requestedMaxNumberOfConnections?: Number, congestionControlAlgorithm?: String, ipV6Enabled?: boolean, routeTableConfig?: VcHostIpRouteTableConfig);
		isIpV6Enabled(): boolean;
	}

	interface VcHostNetStackInstanceCongestionControlAlgorithmType
	{
		readonly cubic: VcHostNetStackInstanceCongestionControlAlgorithmType;
		readonly id: String;
		readonly name: String;
		readonly newreno: VcHostNetStackInstanceCongestionControlAlgorithmType;
		readonly value: String;

		fromString(value?: VcHostNetStackInstanceCongestionControlAlgorithmType): VcHostNetStackInstanceCongestionControlAlgorithmType;
	}

	declare const VcHostNetStackInstanceCongestionControlAlgorithmType: VcHostNetStackInstanceCongestionControlAlgorithmType;

	interface VcHostNetStackInstanceSystemStackKey
	{
		readonly defaultTcpipStack: VcHostNetStackInstanceSystemStackKey;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmotion: VcHostNetStackInstanceSystemStackKey;
		readonly vSphereProvisioning: VcHostNetStackInstanceSystemStackKey;

		fromString(value?: VcHostNetStackInstanceSystemStackKey): VcHostNetStackInstanceSystemStackKey;
	}

	declare const VcHostNetStackInstanceSystemStackKey: VcHostNetStackInstanceSystemStackKey;

	declare class VcHostNetworkConfig
	{
		consoleIpRouteConfig: VcHostIpRouteConfig;
		consoleVnic: VcHostVirtualNicConfig[];
		dhcp: VcHostDhcpServiceConfig[];
		dnsConfig: VcHostDnsConfig;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipRouteConfig: VcHostIpRouteConfig;
		ipV6Enabled: boolean;
		nat: VcHostNatServiceConfig[];
		netStackSpec: VcHostNetworkConfigNetStackSpec[];
		pnic: VcPhysicalNicConfig[];
		portgroup: VcHostPortGroupConfig[];
		proxySwitch: VcHostProxySwitchConfig[];
		routeTableConfig: VcHostIpRouteTableConfig;
		vnic: VcHostVirtualNicConfig[];
		vswitch: VcHostVirtualSwitchConfig[];

		constructor();
		constructor(vswitch?: VcHostVirtualSwitchConfig[], proxySwitch?: VcHostProxySwitchConfig[], portgroup?: VcHostPortGroupConfig[], pnic?: VcPhysicalNicConfig[], vnic?: VcHostVirtualNicConfig[], consoleVnic?: VcHostVirtualNicConfig[], dnsConfig?: VcHostDnsConfig, ipRouteConfig?: VcHostIpRouteConfig, consoleIpRouteConfig?: VcHostIpRouteConfig, routeTableConfig?: VcHostIpRouteTableConfig, dhcp?: VcHostDhcpServiceConfig[], nat?: VcHostNatServiceConfig[], ipV6Enabled?: boolean, netStackSpec?: VcHostNetworkConfigNetStackSpec[]);
		isIpV6Enabled(): boolean;
	}

	declare class VcHostNetworkConfigNetStackSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		netStackInstance: VcHostNetStackInstance;
		operation: String;

		constructor();
		constructor(netStackInstance?: VcHostNetStackInstance, operation?: String);
	}

	declare class VcHostNetworkConfigResult
	{
		consoleVnicDevice: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vnicDevice: String[];

		constructor();
		constructor(vnicDevice?: String[], consoleVnicDevice?: String[]);
	}

	declare class VcHostNetworkInfo
	{
		atBootIpV6Enabled: boolean;
		consoleIpRouteConfig: VcHostIpRouteConfig;
		consoleVnic: VcHostVirtualNic[];
		dhcp: VcHostDhcpService[];
		dnsConfig: VcHostDnsConfig;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipRouteConfig: VcHostIpRouteConfig;
		ipV6Enabled: boolean;
		nat: VcHostNatService[];
		netStackInstance: VcHostNetStackInstance[];
		opaqueNetwork: VcHostOpaqueNetworkInfo[];
		opaqueSwitch: VcHostOpaqueSwitch[];
		pnic: VcPhysicalNic[];
		portgroup: VcHostPortGroup[];
		proxySwitch: VcHostProxySwitch[];
		routeTableInfo: VcHostIpRouteTableInfo;
		vnic: VcHostVirtualNic[];
		vswitch: VcHostVirtualSwitch[];

		constructor();
		constructor(vswitch?: VcHostVirtualSwitch[], proxySwitch?: VcHostProxySwitch[], portgroup?: VcHostPortGroup[], pnic?: VcPhysicalNic[], vnic?: VcHostVirtualNic[], consoleVnic?: VcHostVirtualNic[], dnsConfig?: VcHostDnsConfig, ipRouteConfig?: VcHostIpRouteConfig, consoleIpRouteConfig?: VcHostIpRouteConfig, routeTableInfo?: VcHostIpRouteTableInfo, dhcp?: VcHostDhcpService[], nat?: VcHostNatService[], ipV6Enabled?: boolean, atBootIpV6Enabled?: boolean, netStackInstance?: VcHostNetStackInstance[], opaqueSwitch?: VcHostOpaqueSwitch[], opaqueNetwork?: VcHostOpaqueNetworkInfo[]);
		isAtBootIpV6Enabled(): boolean;
		isIpV6Enabled(): boolean;
	}

	declare class VcHostNetworkPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nicTeaming: VcHostNicTeamingPolicy;
		offloadPolicy: VcHostNetOffloadCapabilities;
		security: VcHostNetworkSecurityPolicy;
		shapingPolicy: VcHostNetworkTrafficShapingPolicy;

		constructor();
		constructor(security?: VcHostNetworkSecurityPolicy, nicTeaming?: VcHostNicTeamingPolicy, offloadPolicy?: VcHostNetOffloadCapabilities, shapingPolicy?: VcHostNetworkTrafficShapingPolicy);
	}

	declare class VcHostNetworkResource
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		networkId: String;

		constructor();
		constructor(networkId?: String);
	}

	declare class VcHostNetworkResourceRuntime
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pnicResourceInfo: VcHostPnicNetworkResourceInfo[];

		constructor();
		constructor(pnicResourceInfo?: VcHostPnicNetworkResourceInfo[]);
	}

	declare class VcHostNetworkSecurityPolicy
	{
		allowPromiscuous: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		forgedTransmits: boolean;
		macChanges: boolean;

		constructor();
		constructor(allowPromiscuous?: boolean, macChanges?: boolean, forgedTransmits?: boolean);
		isAllowPromiscuous(): boolean;
		isForgedTransmits(): boolean;
		isMacChanges(): boolean;
	}

	interface VcHostNetworkSystem
	{
		readonly availableField: VcCustomFieldDef[];
		capabilities: VcHostNetCapabilities;
		consoleIpRouteConfig: VcHostIpRouteConfig;
		dnsConfig: VcHostDnsConfig;
		id: String;
		ipRouteConfig: VcHostIpRouteConfig;
		moref: VcManagedObjectReference;
		networkConfig: VcHostNetworkConfig;
		networkInfo: VcHostNetworkInfo;
		offloadCapabilities: VcHostNetOffloadCapabilities;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addPortGroup(arg0?: VcHostPortGroupSpec): void;
		addServiceConsoleVirtualNic(arg0?: String, arg1?: VcHostVirtualNicSpec): String;
		addVirtualNic(arg0?: String, arg1?: VcHostVirtualNicSpec): String;
		addVirtualSwitch(arg0?: String, arg1?: VcHostVirtualSwitchSpec): void;
		commitNetworkTransaction(arg0?: String): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		invokeHostNetworkTransactionCall(arg0?: String, arg1?: Number, arg2?: String, arg3?: Object, arg4?: Object, arg5?: Object, arg6?: Object): Object;
		performHostOpaqueNetworkDataOperation(arg0?: String, arg1?: VcHostOpaqueNetworkData[]): VcHostOpaqueNetworkData[];
		queryNetworkHint(arg0?: String[]): VcPhysicalNicHintInfo[];
		refreshNetworkSystem(): void;
		removePortGroup(arg0?: String): void;
		removeServiceConsoleVirtualNic(arg0?: String): void;
		removeVirtualNic(arg0?: String): void;
		removeVirtualSwitch(arg0?: String): void;
		restartServiceConsoleVirtualNic(arg0?: String): void;
		setCustomValue(arg0?: String, arg1?: String): void;
		updateConsoleIpRouteConfig(arg0?: VcHostIpRouteConfig): void;
		updateDnsConfig(arg0?: VcHostDnsConfig): void;
		updateIpRouteConfig(arg0?: VcHostIpRouteConfig): void;
		updateIpRouteTableConfig(arg0?: VcHostIpRouteTableConfig): void;
		updateNetworkConfig(arg0?: VcHostNetworkConfig, arg1?: String): VcHostNetworkConfigResult;
		updatePhysicalNicLinkSpeed(arg0?: String, arg1?: VcPhysicalNicLinkInfo): void;
		updatePortGroup(arg0?: String, arg1?: VcHostPortGroupSpec): void;
		updateServiceConsoleVirtualNic(arg0?: String, arg1?: VcHostVirtualNicSpec): void;
		updateVirtualNic(arg0?: String, arg1?: VcHostVirtualNicSpec): void;
		updateVirtualSwitch(arg0?: String, arg1?: VcHostVirtualSwitchSpec): void;
	}

	declare const VcHostNetworkSystem: VcHostNetworkSystem;

	declare class VcHostNetworkTrafficShapingPolicy
	{
		averageBandwidth: Number;
		burstSize: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		peakBandwidth: Number;

		constructor();
		constructor(enabled?: boolean, averageBandwidth?: Number, peakBandwidth?: Number, burstSize?: Number);
		isEnabled(): boolean;
	}

	declare class VcHostNewNetworkConnectInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		summary: VcNetworkSummary;

		constructor();
		constructor(summary?: VcNetworkSummary);
	}

	declare class VcHostNicFailureCriteria
	{
		checkBeacon: boolean;
		checkDuplex: boolean;
		checkErrorPercent: boolean;
		checkSpeed: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullDuplex: boolean;
		percentage: Number;
		speed: Number;

		constructor();
		constructor(checkSpeed?: String, speed?: Number, checkDuplex?: boolean, fullDuplex?: boolean, checkErrorPercent?: boolean, percentage?: Number, checkBeacon?: boolean);
		isCheckBeacon(): boolean;
		isCheckDuplex(): boolean;
		isCheckErrorPercent(): boolean;
		isFullDuplex(): boolean;
	}

	declare class VcHostNicOrderPolicy
	{
		activeNic: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		standbyNic: String[];

		constructor();
		constructor(activeNic?: String[], standbyNic?: String[]);
	}

	declare class VcHostNicTeamingPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failureCriteria: VcHostNicFailureCriteria;
		nicOrder: VcHostNicOrderPolicy;
		notifySwitches: boolean;
		policy: String;
		reversePolicy: boolean;
		rollingOrder: boolean;

		constructor();
		constructor(policy?: String, reversePolicy?: boolean, notifySwitches?: boolean, rollingOrder?: boolean, failureCriteria?: VcHostNicFailureCriteria, nicOrder?: VcHostNicOrderPolicy);
		isNotifySwitches(): boolean;
		isReversePolicy(): boolean;
		isRollingOrder(): boolean;
	}

	declare class VcHostNoAvailableNetworksEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ips: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, ips?: String);
	}

	declare class VcHostNoHAEnabledPortGroupsEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostNonCompliantEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostNoRedundantManagementNetworkEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostNotConnected
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcHostNotInClusterEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostNotReachable
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcHostNtpConfig
	{
		configFile: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		server: String[];

		constructor();
		constructor(server?: String[], configFile?: String[]);
	}

	declare class VcHostNumaInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		numaNode: VcHostNumaNode[];
		numNodes: Number;
		type: String;

		constructor();
		constructor(type?: String, numNodes?: Number, numaNode?: VcHostNumaNode[]);
	}

	declare class VcHostNumaNode
	{
		cpuID: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memoryRangeBegin: Number;
		memoryRangeLength: Number;
		typeId: Number;

		constructor();
		constructor(typeId?: Number, cpuID?: Number[], memoryRangeBegin?: Number, memoryRangeLength?: Number);
	}

	interface VcHostNumericSensorHealthState
	{
		readonly green: VcHostNumericSensorHealthState;
		readonly id: String;
		readonly name: String;
		readonly red: VcHostNumericSensorHealthState;
		readonly unknown: VcHostNumericSensorHealthState;
		readonly value: String;
		readonly yellow: VcHostNumericSensorHealthState;

		fromString(value?: VcHostNumericSensorHealthState): VcHostNumericSensorHealthState;
	}

	declare const VcHostNumericSensorHealthState: VcHostNumericSensorHealthState;

	declare class VcHostNumericSensorInfo
	{
		baseUnits: String;
		currentReading: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		healthState: VcElementDescription;
		id: String;
		name: String;
		rateUnits: String;
		sensorType: String;
		timeStamp: String;
		unitModifier: Number;

		constructor();
		constructor(name?: String, healthState?: VcElementDescription, currentReading?: Number, unitModifier?: Number, baseUnits?: String, rateUnits?: String, sensorType?: String, id?: String, timeStamp?: String);
	}

	interface VcHostNumericSensorType
	{
		readonly battery: VcHostNumericSensorType;
		readonly bios: VcHostNumericSensorType;
		readonly cable: VcHostNumericSensorType;
		readonly fan: VcHostNumericSensorType;
		readonly id: String;
		readonly memory: VcHostNumericSensorType;
		readonly name: String;
		readonly other: VcHostNumericSensorType;
		readonly power: VcHostNumericSensorType;
		readonly processor: VcHostNumericSensorType;
		readonly storage: VcHostNumericSensorType;
		readonly systemBoard: VcHostNumericSensorType;
		readonly temperature: VcHostNumericSensorType;
		readonly value: String;
		readonly voltage: VcHostNumericSensorType;
		readonly watchdog: VcHostNumericSensorType;

		fromString(value?: VcHostNumericSensorType): VcHostNumericSensorType;
	}

	declare const VcHostNumericSensorType: VcHostNumericSensorType;

	interface VcHostNvdimmSystem
	{
		id: String;
		moref: VcManagedObjectReference;
		nvdimmSystemInfo: VcNvdimmSystemInfo;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createNvdimmNamespace_Task(arg0?: VcNvdimmNamespaceCreateSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteNvdimmBlockNamespaces_Task(): VcTask;
		deleteNvdimmNamespace_Task(arg0?: VcNvdimmNamespaceDeleteSpec): VcTask;
	}

	declare const VcHostNvdimmSystem: VcHostNvdimmSystem;

	declare class VcHostOpaqueNetworkData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extraConfig: VcOptionValue[];
		id: String;
		name: String;
		pnicZone: String[];
		portAttachMode: String;
		type: String;

		constructor();
		constructor(id?: String, name?: String, type?: String, portAttachMode?: String, pnicZone?: String[], extraConfig?: VcOptionValue[]);
	}

	declare class VcHostOpaqueNetworkInfo
	{
		capability: VcOpaqueNetworkCapability;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extraConfig: VcOptionValue[];
		opaqueNetworkId: String;
		opaqueNetworkName: String;
		opaqueNetworkType: String;
		pnicZone: String[];

		constructor();
		constructor(opaqueNetworkId?: String, opaqueNetworkName?: String, opaqueNetworkType?: String, pnicZone?: String[], capability?: VcOpaqueNetworkCapability, extraConfig?: VcOptionValue[]);
	}

	declare class VcHostOpaqueNetworkResource
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		networkId: String;
		pnicZone: String[];

		constructor();
		constructor(networkId?: String, pnicZone?: String[]);
	}

	declare class VcHostOpaqueSwitch
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extraConfig: VcOptionValue[];
		key: String;
		name: String;
		pnic: String[];
		pnicZone: VcHostOpaqueSwitchPhysicalNicZone[];
		status: String;
		vtep: VcHostVirtualNic[];

		constructor();
		constructor(key?: String, name?: String, pnic?: String[], pnicZone?: VcHostOpaqueSwitchPhysicalNicZone[], status?: String, vtep?: VcHostVirtualNic[], extraConfig?: VcOptionValue[]);
	}

	interface VcHostOpaqueSwitchOpaqueSwitchState
	{
		readonly down: VcHostOpaqueSwitchOpaqueSwitchState;
		readonly id: String;
		readonly name: String;
		readonly up: VcHostOpaqueSwitchOpaqueSwitchState;
		readonly value: String;
		readonly warning: VcHostOpaqueSwitchOpaqueSwitchState;

		fromString(value?: VcHostOpaqueSwitchOpaqueSwitchState): VcHostOpaqueSwitchOpaqueSwitchState;
	}

	declare const VcHostOpaqueSwitchOpaqueSwitchState: VcHostOpaqueSwitchOpaqueSwitchState;

	declare class VcHostOpaqueSwitchPhysicalNicZone
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		pnicDevice: String[];

		constructor();
		constructor(key?: String, pnicDevice?: String[]);
	}

	interface VcHostOperationCleanupManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createEntry(arg0?: VcHostOperationCleanupManagerOperationEntry): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryEntry(arg0?: String): VcHostOperationCleanupManagerOperationEntry;
		updateEntry(arg0?: VcHostOperationCleanupManagerOperationEntry): void;
	}

	declare const VcHostOperationCleanupManager: VcHostOperationCleanupManager;

	declare class VcHostOperationCleanupManagerCleanupItemEntry
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		path: String;
		removeUpon: String;
		type: String;

		constructor();
		constructor(path?: String, type?: String, removeUpon?: String);
	}

	interface VcHostOperationCleanupManagerCleanupItemType
	{
		readonly dir: VcHostOperationCleanupManagerCleanupItemType;
		readonly disk: VcHostOperationCleanupManagerCleanupItemType;
		readonly file: VcHostOperationCleanupManagerCleanupItemType;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vm: VcHostOperationCleanupManagerCleanupItemType;

		fromString(value?: VcHostOperationCleanupManagerCleanupItemType): VcHostOperationCleanupManagerCleanupItemType;
	}

	declare const VcHostOperationCleanupManagerCleanupItemType: VcHostOperationCleanupManagerCleanupItemType;

	interface VcHostOperationCleanupManagerOperationActivity
	{
		readonly create: VcHostOperationCleanupManagerOperationActivity;
		readonly id: String;
		readonly name: String;
		readonly nfc: VcHostOperationCleanupManagerOperationActivity;
		readonly value: String;
		readonly vmotion: VcHostOperationCleanupManagerOperationActivity;

		fromString(value?: VcHostOperationCleanupManagerOperationActivity): VcHostOperationCleanupManagerOperationActivity;
	}

	declare const VcHostOperationCleanupManagerOperationActivity: VcHostOperationCleanupManagerOperationActivity;

	declare class VcHostOperationCleanupManagerOperationEntry
	{
		curHostUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hlogFile: String;
		itemList: VcHostOperationCleanupManagerCleanupItemEntry[];
		opActivity: String;
		opId: Number;
		opState: String;

		constructor();
		constructor(hlogFile?: String, opId?: Number, opState?: String, opActivity?: String, curHostUuid?: String, itemList?: VcHostOperationCleanupManagerCleanupItemEntry[]);
	}

	interface VcHostOperationCleanupManagerOperationState
	{
		readonly failure: VcHostOperationCleanupManagerOperationState;
		readonly id: String;
		readonly name: String;
		readonly running: VcHostOperationCleanupManagerOperationState;
		readonly success: VcHostOperationCleanupManagerOperationState;
		readonly value: String;

		fromString(value?: VcHostOperationCleanupManagerOperationState): VcHostOperationCleanupManagerOperationState;
	}

	declare const VcHostOperationCleanupManagerOperationState: VcHostOperationCleanupManagerOperationState;

	declare class VcHostOvercommittedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostParallelScsiHba
	{
		bus: Number;
		device: String;
		driver: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		model: String;
		pci: String;
		status: String;

		constructor();
		constructor(key?: String, device?: String, bus?: Number, status?: String, model?: String, driver?: String, pci?: String);
	}

	declare class VcHostParallelScsiTargetTransport
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcHostPatchManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkHostPatch_Task(arg0?: String[], arg1?: String[], arg2?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		installHostPatch_Task(arg0?: VcHostPatchManagerLocator, arg1?: String, arg2?: boolean): VcTask;
		installHostPatchV2_Task(arg0?: String[], arg1?: String[], arg2?: String[], arg3?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
		queryHostPatch_Task(arg0?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
		scanHostPatch_Task(arg0?: VcHostPatchManagerLocator, arg1?: String[]): VcTask;
		scanHostPatchV2_Task(arg0?: String[], arg1?: String[], arg2?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
		stageHostPatch_Task(arg0?: String[], arg1?: String[], arg2?: String[], arg3?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
		uninstallHostPatch_Task(arg0?: String[], arg1?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
	}

	declare const VcHostPatchManager: VcHostPatchManager;

	interface VcHostPatchManagerInstallState
	{
		readonly hostRestarted: VcHostPatchManagerInstallState;
		readonly id: String;
		readonly imageActive: VcHostPatchManagerInstallState;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostPatchManagerInstallState): VcHostPatchManagerInstallState;
	}

	declare const VcHostPatchManagerInstallState: VcHostPatchManagerInstallState;

	interface VcHostPatchManagerIntegrityStatus
	{
		readonly digestMismatch: VcHostPatchManagerIntegrityStatus;
		readonly id: String;
		readonly keyExpired: VcHostPatchManagerIntegrityStatus;
		readonly keyNotFound: VcHostPatchManagerIntegrityStatus;
		readonly keyRevoked: VcHostPatchManagerIntegrityStatus;
		readonly name: String;
		readonly notEnoughSignatures: VcHostPatchManagerIntegrityStatus;
		readonly validated: VcHostPatchManagerIntegrityStatus;
		readonly validationError: VcHostPatchManagerIntegrityStatus;
		readonly value: String;

		fromString(value?: VcHostPatchManagerIntegrityStatus): VcHostPatchManagerIntegrityStatus;
	}

	declare const VcHostPatchManagerIntegrityStatus: VcHostPatchManagerIntegrityStatus;

	declare class VcHostPatchManagerLocator
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		proxy: String;
		url: String;

		constructor();
		constructor(url?: String, proxy?: String);
	}

	declare class VcHostPatchManagerPatchManagerOperationSpec
	{
		cmdOption: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		password: String;
		port: Number;
		proxy: String;
		userName: String;

		constructor();
		constructor(proxy?: String, port?: Number, userName?: String, password?: String, cmdOption?: String);
	}

	interface VcHostPatchManagerReason
	{
		readonly conflictLib: VcHostPatchManagerReason;
		readonly conflictPatch: VcHostPatchManagerReason;
		readonly hasDependentPatch: VcHostPatchManagerReason;
		readonly id: String;
		readonly missingLib: VcHostPatchManagerReason;
		readonly missingPatch: VcHostPatchManagerReason;
		readonly name: String;
		readonly obsoleted: VcHostPatchManagerReason;
		readonly value: String;

		fromString(value?: VcHostPatchManagerReason): VcHostPatchManagerReason;
	}

	declare const VcHostPatchManagerReason: VcHostPatchManagerReason;

	declare class VcHostPatchManagerResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		status: VcHostPatchManagerStatus[];
		version: String;
		xmlResult: String;

		constructor();
		constructor(version?: String, status?: VcHostPatchManagerStatus[], xmlResult?: String);
	}

	declare class VcHostPatchManagerStatus
	{
		applicable: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		installed: boolean;
		installState: String[];
		integrity: String;
		prerequisitePatch: VcHostPatchManagerStatusPrerequisitePatch[];
		reason: String[];
		reconnectRequired: boolean;
		restartRequired: boolean;
		supersededPatchIds: String[];
		vmOffRequired: boolean;

		constructor();
		constructor(id?: String, applicable?: boolean, reason?: String[], integrity?: String, installed?: boolean, installState?: String[], prerequisitePatch?: VcHostPatchManagerStatusPrerequisitePatch[], restartRequired?: boolean, reconnectRequired?: boolean, vmOffRequired?: boolean, supersededPatchIds?: String[]);
	}

	declare class VcHostPatchManagerStatusPrerequisitePatch
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		installState: String[];

		constructor();
		constructor(id?: String, installState?: String[]);
	}

	declare class VcHostPathSelectionPolicyOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policy: VcElementDescription;

		constructor();
		constructor(policy?: VcElementDescription);
	}

	declare class VcHostPciDevice
	{
		bus: Number;
		classId: Number;
		deviceId: Number;
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		function: Number;
		id: String;
		parentBridge: String;
		physicalSlot: Number;
		slot: Number;
		slotDescription: String;
		subDeviceId: Number;
		subVendorId: Number;
		vendorId: Number;
		vendorName: String;

		constructor();
		constructor(id?: String, classId?: Number, bus?: Number, slot?: Number, physicalSlot?: Number, slotDescription?: String, function?: Number, vendorId?: Number, subVendorId?: Number, vendorName?: String, deviceId?: Number, subDeviceId?: Number, parentBridge?: String, deviceName?: String);
	}

	declare class VcHostPciPassthruConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		passthruEnabled: boolean;

		constructor();
		constructor(id?: String, passthruEnabled?: boolean);
	}

	declare class VcHostPciPassthruInfo
	{
		dependentDevice: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		passthruActive: boolean;
		passthruCapable: boolean;
		passthruEnabled: boolean;

		constructor();
		constructor(id?: String, dependentDevice?: String, passthruEnabled?: boolean, passthruCapable?: boolean, passthruActive?: boolean);
	}

	interface VcHostPciPassthruSystem
	{
		readonly availableField: VcCustomFieldDef[];
		id: String;
		moref: VcManagedObjectReference;
		pciPassthruInfo: VcHostPciPassthruInfo[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		sriovDevicePoolInfo: VcHostSriovDevicePoolInfo[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		refresh(): void;
		setCustomValue(arg0?: String, arg1?: String): void;
		updatePassthruConfig(arg0?: VcHostPciPassthruConfig[]): void;
	}

	declare const VcHostPciPassthruSystem: VcHostPciPassthruSystem;

	declare class VcHostPersistentMemoryInfo
	{
		capacityInMB: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		volumeUUID: String;

		constructor();
		constructor(capacityInMB?: Number, volumeUUID?: String);
	}

	declare class VcHostPlacedVirtualNicIdentifier
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reservation: Number;
		vm: VcVirtualMachine;
		vnicKey: String;

		constructor();
		constructor(vm?: VcVirtualMachine, vnicKey?: String, reservation?: Number);
	}

	declare class VcHostPlugStoreTopology
	{
		adapter: VcHostPlugStoreTopologyAdapter[];
		device: VcHostPlugStoreTopologyDevice[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		path: VcHostPlugStoreTopologyPath[];
		plugin: VcHostPlugStoreTopologyPlugin[];
		target: VcHostPlugStoreTopologyTarget[];

		constructor(adapter?: VcHostPlugStoreTopologyAdapter[], path?: VcHostPlugStoreTopologyPath[], target?: VcHostPlugStoreTopologyTarget[], device?: VcHostPlugStoreTopologyDevice[], plugin?: VcHostPlugStoreTopologyPlugin[]);
		constructor();
	}

	declare class VcHostPlugStoreTopologyAdapter
	{
		adapter: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		path: String[];

		constructor();
		constructor(key?: String, adapter?: String, path?: String[]);
	}

	declare class VcHostPlugStoreTopologyDevice
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		lun: String;
		path: String[];

		constructor();
		constructor(key?: String, lun?: String, path?: String[]);
	}

	declare class VcHostPlugStoreTopologyPath
	{
		adapter: String;
		channelNumber: Number;
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		lunNumber: Number;
		name: String;
		target: String;
		targetNumber: Number;

		constructor();
		constructor(key?: String, name?: String, channelNumber?: Number, targetNumber?: Number, lunNumber?: Number, adapter?: String, target?: String, device?: String);
	}

	declare class VcHostPlugStoreTopologyPlugin
	{
		claimedPath: String[];
		device: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		name: String;

		constructor();
		constructor(key?: String, name?: String, device?: String[], claimedPath?: String[]);
	}

	declare class VcHostPlugStoreTopologyTarget
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		transport: VcHostTargetTransport;

		constructor();
		constructor(key?: String, transport?: VcHostTargetTransport);
	}

	declare class VcHostPMemVolume
	{
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		type: String;
		uuid: String;
		version: String;

		constructor();
		constructor(type?: String, name?: String, capacity?: Number, uuid?: String, version?: String);
	}

	declare class VcHostPnicNetworkResourceInfo
	{
		availableBandwidthForVMTraffic: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		placedVirtualNics: VcHostPlacedVirtualNicIdentifier[];
		pnicDevice: String;
		unusedBandwidthForVMTraffic: Number;

		constructor();
		constructor(pnicDevice?: String, availableBandwidthForVMTraffic?: Number, unusedBandwidthForVMTraffic?: Number, placedVirtualNics?: VcHostPlacedVirtualNicIdentifier[]);
	}

	declare class VcHostPortGroup
	{
		computedPolicy: VcHostNetworkPolicy;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		port: VcHostPortGroupPort[];
		spec: VcHostPortGroupSpec;
		vswitch: String;

		constructor();
		constructor(key?: String, port?: VcHostPortGroupPort[], vswitch?: String, computedPolicy?: VcHostNetworkPolicy, spec?: VcHostPortGroupSpec);
	}

	declare class VcHostPortGroupConfig
	{
		changeOperation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		spec: VcHostPortGroupSpec;

		constructor();
		constructor(changeOperation?: String, spec?: VcHostPortGroupSpec);
	}

	declare class VcHostPortGroupPort
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		mac: String[];
		type: String;

		constructor();
		constructor(key?: String, mac?: String[], type?: String);
	}

	declare class VcHostPortGroupProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		ipConfig: VcIpAddressProfile;
		key: String;
		name: String;
		networkPolicy: VcNetworkPolicyProfile;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;
		vlan: VcVlanProfile;
		vswitch: VcVirtualSwitchSelectionProfile;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String, name?: String, vlan?: VcVlanProfile, vswitch?: VcVirtualSwitchSelectionProfile, networkPolicy?: VcNetworkPolicyProfile, ipConfig?: VcIpAddressProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcHostPortGroupSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		policy: VcHostNetworkPolicy;
		vlanId: Number;
		vswitchName: String;

		constructor();
		constructor(name?: String, vlanId?: Number, vswitchName?: String, policy?: VcHostNetworkPolicy);
	}

	declare class VcHostPosixAccountSpec
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		password: String;
		posixId: Number;
		shellAccess: boolean;

		constructor();
		constructor(id?: String, password?: String, description?: String, posixId?: Number, shellAccess?: boolean);
		isShellAccess(): boolean;
	}

	interface VcHostPowerOperationType
	{
		readonly id: String;
		readonly name: String;
		readonly powerOff: VcHostPowerOperationType;
		readonly powerOn: VcHostPowerOperationType;
		readonly value: String;

		fromString(value?: VcHostPowerOperationType): VcHostPowerOperationType;
	}

	declare const VcHostPowerOperationType: VcHostPowerOperationType;

	declare class VcHostPowerOpFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcHostPowerPolicy
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		name: String;
		shortName: String;

		constructor();
		constructor(key?: Number, name?: String, shortName?: String, description?: String);
	}

	interface VcHostPowerSystem
	{
		capability: VcPowerSystemCapability;
		id: String;
		info: VcPowerSystemInfo;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		configurePowerPolicy(arg0?: Number): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostPowerSystem: VcHostPowerSystem;

	declare class VcHostPrimaryAgentNotShortNameEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		primaryAgent: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, primaryAgent?: String);
	}

	interface VcHostProfile
	{
		readonly complianceStatus: String;
		readonly config: VcProfileConfigInfo;
		readonly createdTime: Date;
		readonly description: VcProfileDescription;
		readonly entity: VcManagedEntity[];
		id: String;
		readonly modifiedTime: Date;
		moref: VcManagedObjectReference;
		readonly name: String;
		referenceHost: VcHostSystem;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		associateProfile(arg0?: VcManagedEntity[]): void;
		checkProfileCompliance_Task(arg0?: VcManagedEntity[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyProfile(): void;
		dissociateProfile(arg0?: VcManagedEntity[]): void;
		executeHostProfile(arg0?: VcHostSystem, arg1?: VcProfileDeferredPolicyOptionParameter[]): VcProfileExecuteResult;
		exportProfile(): String;
		retrieveDescription(): VcProfileDescription;
		updateHostProfile(arg0?: VcHostProfileConfigSpec): void;
		updateReferenceHost(arg0?: VcHostSystem): void;
		validateHostProfile(arg0?: VcHostProfileConfigSpec): void;
	}

	declare const VcHostProfile: VcHostProfile;

	declare class VcHostProfileAppliedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, profile?: VcProfileEventArgument);
	}

	declare class VcHostProfileAttributeCondition
	{
		compareValue_AnyValue: Object;
		compareValue_FloatValue: Number;
		compareValue_IntValue: Number;
		compareValue_LongValue: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operator: String;

		constructor();
		constructor(operator?: String, compareValue?: Object);
	}

	declare class VcHostProfileCompleteConfigSpec
	{
		annotation: String;
		applyProfile: VcHostApplyProfile;
		customComplyProfile: VcComplianceProfile;
		disabledExpressionList: String[];
		disabledExpressionListChanged: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		hostConfig: VcHostProfileConfigInfo;
		name: String;
		validating: boolean;
		validatorHost: VcHostSystem;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean, applyProfile?: VcHostApplyProfile, customComplyProfile?: VcComplianceProfile, disabledExpressionListChanged?: boolean, disabledExpressionList?: String[], validatorHost?: VcHostSystem, validating?: boolean, hostConfig?: VcHostProfileConfigInfo);
		isEnabled(): boolean;
		isValidating(): boolean;
	}

	declare class VcHostProfileConfigInfo
	{
		annotation: String;
		applyProfile: VcHostApplyProfile;
		customComplyProfile: VcComplianceProfile;
		defaultComplyLocator: VcComplianceLocator[];
		defaultComplyProfile: VcComplianceProfile;
		description: VcProfileDescription;
		disabledExpressionList: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean, applyProfile?: VcHostApplyProfile, defaultComplyProfile?: VcComplianceProfile, defaultComplyLocator?: VcComplianceLocator[], customComplyProfile?: VcComplianceProfile, disabledExpressionList?: String[], description?: VcProfileDescription);
	}

	declare class VcHostProfileConfigSpec
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean);
		isEnabled(): boolean;
	}

	declare class VcHostProfileHostBasedConfigSpec
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		host: VcHostSystem;
		name: String;
		profilesToExtract: String[];
		useHostProfileEngine: boolean;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean, host?: VcHostSystem, profilesToExtract?: String[], useHostProfileEngine?: boolean);
		isEnabled(): boolean;
		isUseHostProfileEngine(): boolean;
	}

	interface VcHostProfileManager
	{
		id: String;
		moref: VcManagedObjectReference;
		readonly profile: VcProfile[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		supportedCustomizationFormats: VcExtendedElementDescription[];
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		applyEntitiesConfig_Task(arg0?: VcApplyHostProfileConfigurationSpec[]): VcTask;
		applyHostConfig_Task(arg0?: VcHostSystem, arg1?: VcHostConfigSpec, arg2?: VcProfileDeferredPolicyOptionParameter[]): VcTask;
		checkAnswerFileStatus_Task(arg0?: VcHostSystem[]): VcTask;
		compositeHostProfile_Task(arg0?: VcProfile, arg1?: VcProfile[], arg2?: VcHostApplyProfile, arg3?: VcHostApplyProfile, arg4?: VcHostApplyProfile, arg5?: VcHostApplyProfile): VcTask;
		createDefaultProfile(arg0?: String, arg1?: String, arg2?: VcProfile): VcApplyProfile;
		createProfile(arg0?: VcProfileCreateSpec): VcProfile;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		exportAnswerFile_Task(arg0?: VcHostSystem): VcTask;
		exportHostProfileCustomizations_Task(arg0?: VcManagedEntity[], arg1?: String): VcTask;
		findAssociatedProfile(arg0?: VcManagedEntity): VcProfile[];
		generateConfigTaskList(arg0?: VcHostConfigSpec, arg1?: VcHostSystem): VcHostProfileManagerConfigTaskList;
		generateHostConfigTaskSpec_Task(arg0?: VcStructuredCustomizations[]): VcTask;
		generateHostProfileTaskList_Task(arg0?: VcHostConfigSpec, arg1?: VcHostSystem): VcTask;
		hostProfileQueryMetadata(arg0?: VcProfile[], arg1?: String[]): VcHostProfileManagerHostProfileMetadata[];
		importHostProfileCustomizations_Task(arg0?: VcHostProfilesCustomizationData, arg1?: boolean, arg2?: boolean, arg3?: VcProfile, arg4?: VcManagedEntity[]): VcTask;
		queryAnswerFileStatus(arg0?: VcHostSystem[]): VcAnswerFileStatusResult[];
		queryHostProfileCategoryMetadata(arg0?: String[], arg1?: VcProfile): VcProfileCategoryMetadata[];
		queryHostProfileComponentMetadata(arg0?: String[], arg1?: VcProfile): VcProfileComponentMetadata[];
		queryHostProfileMetadata(arg0?: String[], arg1?: VcProfile): VcProfileMetadata[];
		queryPolicyMetadata(arg0?: String[], arg1?: VcProfile): VcProfilePolicyMetadata[];
		queryProfileStructure(arg0?: VcProfile): VcProfileProfileStructure;
		retrieveAnswerFile(arg0?: VcHostSystem): VcAnswerFile;
		retrieveAnswerFileForProfile(arg0?: VcHostSystem, arg1?: VcHostApplyProfile): VcAnswerFile;
		retrieveHostCustomizations(arg0?: VcHostSystem[]): VcStructuredCustomizations[];
		retrieveHostCustomizationsForProfile(arg0?: VcHostSystem[], arg1?: VcHostApplyProfile): VcStructuredCustomizations[];
		updateAnswerFile_Task(arg0?: VcHostSystem, arg1?: VcAnswerFileCreateSpec): VcTask;
		updateHostCustomizations_Task(arg0?: VcHostProfileManagerHostToConfigSpecMap[]): VcTask;
		validateAnswerFile(arg0?: VcHostSystem, arg1?: VcAnswerFileCreateSpec, arg2?: VcHostApplyProfile): VcAnswerFileValidationResult;
		validateHostCustomizations(arg0?: VcHostProfileManagerHostToConfigSpecMap[], arg1?: VcHostApplyProfile): VcAnswerFileValidationResultMap[];
		validateHostProfileComposition_Task(arg0?: VcProfile, arg1?: VcProfile[], arg2?: VcHostApplyProfile, arg3?: VcHostApplyProfile, arg4?: VcHostApplyProfile, arg5?: VcHostApplyProfile, arg6?: boolean): VcTask;
	}

	declare const VcHostProfileManager: VcHostProfileManager;

	interface VcHostProfileManagerAnswerFileStatus
	{
		readonly id: String;
		readonly invalid: VcHostProfileManagerAnswerFileStatus;
		readonly name: String;
		readonly unknown: VcHostProfileManagerAnswerFileStatus;
		readonly valid: VcHostProfileManagerAnswerFileStatus;
		readonly value: String;

		fromString(value?: VcHostProfileManagerAnswerFileStatus): VcHostProfileManagerAnswerFileStatus;
	}

	declare const VcHostProfileManagerAnswerFileStatus: VcHostProfileManagerAnswerFileStatus;

	declare class VcHostProfileManagerCompositionResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errors: VcLocalizableMessage[];
		results: VcHostProfileManagerCompositionResultResultElement[];

		constructor();
		constructor(errors?: VcLocalizableMessage[], results?: VcHostProfileManagerCompositionResultResultElement[]);
	}

	declare class VcHostProfileManagerCompositionResultResultElement
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errors: VcLocalizableMessage[];
		status: String;
		target: VcProfile;

		constructor();
		constructor(target?: VcProfile, status?: String, errors?: VcLocalizableMessage[]);
	}

	interface VcHostProfileManagerCompositionResultResultElementStatus
	{
		readonly error: VcHostProfileManagerCompositionResultResultElementStatus;
		readonly id: String;
		readonly name: String;
		readonly success: VcHostProfileManagerCompositionResultResultElementStatus;
		readonly value: String;

		fromString(value?: VcHostProfileManagerCompositionResultResultElementStatus): VcHostProfileManagerCompositionResultResultElementStatus;
	}

	declare const VcHostProfileManagerCompositionResultResultElementStatus: VcHostProfileManagerCompositionResultResultElementStatus;

	declare class VcHostProfileManagerCompositionValidationResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errors: VcLocalizableMessage[];
		results: VcHostProfileManagerCompositionValidationResultResultElement[];

		constructor();
		constructor(results?: VcHostProfileManagerCompositionValidationResultResultElement[], errors?: VcLocalizableMessage[]);
	}

	declare class VcHostProfileManagerCompositionValidationResultResultElement
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errors: VcLocalizableMessage[];
		sourceDiffForToBeMerged: VcHostApplyProfile;
		status: String;
		target: VcProfile;
		targetDiffForToBeMerged: VcHostApplyProfile;
		toBeAdded: VcHostApplyProfile;
		toBeDeleted: VcHostApplyProfile;
		toBeDisabled: VcHostApplyProfile;
		toBeEnabled: VcHostApplyProfile;
		toBeReenableCC: VcHostApplyProfile;

		constructor();
		constructor(target?: VcProfile, status?: String, errors?: VcLocalizableMessage[], sourceDiffForToBeMerged?: VcHostApplyProfile, targetDiffForToBeMerged?: VcHostApplyProfile, toBeAdded?: VcHostApplyProfile, toBeDeleted?: VcHostApplyProfile, toBeDisabled?: VcHostApplyProfile, toBeEnabled?: VcHostApplyProfile, toBeReenableCC?: VcHostApplyProfile);
	}

	interface VcHostProfileManagerCompositionValidationResultResultElementStatus
	{
		readonly error: VcHostProfileManagerCompositionValidationResultResultElementStatus;
		readonly id: String;
		readonly name: String;
		readonly success: VcHostProfileManagerCompositionValidationResultResultElementStatus;
		readonly value: String;

		fromString(value?: VcHostProfileManagerCompositionValidationResultResultElementStatus): VcHostProfileManagerCompositionValidationResultResultElementStatus;
	}

	declare const VcHostProfileManagerCompositionValidationResultResultElementStatus: VcHostProfileManagerCompositionValidationResultResultElementStatus;

	declare class VcHostProfileManagerConfigTaskList
	{
		configSpec: VcHostConfigSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		taskDescription: VcLocalizableMessage[];
		taskListRequirement: String[];

		constructor();
		constructor(configSpec?: VcHostConfigSpec, taskDescription?: VcLocalizableMessage[], taskListRequirement?: String[]);
	}

	declare class VcHostProfileManagerExportCustomizationsResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		exportIssues: VcProfileHostHostCustomizationOperationIssues;
		format: String;
		formattedCustomizations: String;

		constructor();
		constructor(entity?: VcManagedEntity, format?: String, formattedCustomizations?: String, exportIssues?: VcProfileHostHostCustomizationOperationIssues);
	}

	declare class VcHostProfileManagerHostProfileMetadata
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policyMetadata: VcProfilePolicyMetadata[];
		profileCategoryMetadata: VcProfileCategoryMetadata[];
		profileComponentMetadata: VcProfileComponentMetadata[];
		profileMetadata: VcProfileMetadata[];

		constructor();
		constructor(profileMetadata?: VcProfileMetadata[], profileCategoryMetadata?: VcProfileCategoryMetadata[], profileComponentMetadata?: VcProfileComponentMetadata[], policyMetadata?: VcProfilePolicyMetadata[]);
	}

	declare class VcHostProfileManagerHostToConfigSpecMap
	{
		configSpec: VcAnswerFileCreateSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;

		constructor();
		constructor(host?: VcHostSystem, configSpec?: VcAnswerFileCreateSpec);
	}

	interface VcHostProfileManagerMetadataTypes
	{
		readonly category: VcHostProfileManagerMetadataTypes;
		readonly component: VcHostProfileManagerMetadataTypes;
		readonly id: String;
		readonly name: String;
		readonly policy: VcHostProfileManagerMetadataTypes;
		readonly profile: VcHostProfileManagerMetadataTypes;
		readonly value: String;

		fromString(value?: VcHostProfileManagerMetadataTypes): VcHostProfileManagerMetadataTypes;
	}

	declare const VcHostProfileManagerMetadataTypes: VcHostProfileManagerMetadataTypes;

	interface VcHostProfileManagerTaskListRequirement
	{
		readonly id: String;
		readonly maintenanceModeRequired: VcHostProfileManagerTaskListRequirement;
		readonly name: String;
		readonly rebootRequired: VcHostProfileManagerTaskListRequirement;
		readonly value: String;

		fromString(value?: VcHostProfileManagerTaskListRequirement): VcHostProfileManagerTaskListRequirement;
	}

	declare const VcHostProfileManagerTaskListRequirement: VcHostProfileManagerTaskListRequirement;

	declare class VcHostProfileMapping
	{
		apiId: String;
		data: VcHostProfileMappingProfileMappingData;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policyMapping: VcHostProfilePolicyMapping[];
		profileTypeName: String;

		constructor();
		constructor(apiId?: String, profileTypeName?: String, data?: VcHostProfileMappingProfileMappingData, policyMapping?: VcHostProfilePolicyMapping[]);
	}

	declare class VcHostProfileMappingData
	{
		attributePath: String;
		basePath: String;
		condition: VcHostProfileAttributeCondition;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lookup: VcHostProfileMappingLookup;

		constructor();
		constructor(basePath?: String, attributePath?: String, condition?: VcHostProfileAttributeCondition, lookup?: VcHostProfileMappingLookup);
	}

	declare class VcHostProfileMappingLookup
	{
		apiMapping: VcHostProfileMappingLookupMappingPair[];
		baseProfilePath: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profileMapping: VcHostProfileMappingLookupMappingPair[];

		constructor();
		constructor(baseProfilePath?: String, apiMapping?: VcHostProfileMappingLookupMappingPair[], profileMapping?: VcHostProfileMappingLookupMappingPair[]);
	}

	declare class VcHostProfileMappingLookupMappingPair
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		sourcePath: String;
		targetProfilePath: String;

		constructor();
		constructor(sourcePath?: String, targetProfilePath?: String);
	}

	declare class VcHostProfileMappingProfileMappingData
	{
		attributePath: String;
		basePath: String;
		condition: VcHostProfileAttributeCondition;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lookup: VcHostProfileMappingLookup;

		constructor();
		constructor(basePath?: String, attributePath?: String, condition?: VcHostProfileAttributeCondition, lookup?: VcHostProfileMappingLookup);
	}

	declare class VcHostProfileParameterMapping
	{
		data: VcHostProfileParameterMappingParameterMappingData;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;

		constructor();
		constructor(id?: String, data?: VcHostProfileParameterMappingParameterMappingData);
	}

	declare class VcHostProfileParameterMappingParameterMappingData
	{
		attributePath: String;
		basePath: String;
		condition: VcHostProfileAttributeCondition;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		isKey: boolean;
		lookup: VcHostProfileMappingLookup;

		constructor();
		constructor(basePath?: String, attributePath?: String, condition?: VcHostProfileAttributeCondition, lookup?: VcHostProfileMappingLookup, isKey?: boolean);
	}

	declare class VcHostProfilePolicyMapping
	{
		data: VcHostProfilePolicyMappingPolicyMappingData;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		policyOptionMapping: VcHostProfilePolicyOptionMapping[];

		constructor();
		constructor(id?: String, data?: VcHostProfilePolicyMappingPolicyMappingData, policyOptionMapping?: VcHostProfilePolicyOptionMapping[]);
	}

	declare class VcHostProfilePolicyMappingPolicyMappingData
	{
		attributePath: String;
		basePath: String;
		condition: VcHostProfileAttributeCondition;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lookup: VcHostProfileMappingLookup;

		constructor();
		constructor(basePath?: String, attributePath?: String, condition?: VcHostProfileAttributeCondition, lookup?: VcHostProfileMappingLookup);
	}

	declare class VcHostProfilePolicyOptionMapping
	{
		data: VcHostProfilePolicyOptionMappingPolicyOptionMappingData;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		parameterMapping: VcHostProfileParameterMapping[];

		constructor();
		constructor(id?: String, data?: VcHostProfilePolicyOptionMappingPolicyOptionMappingData, parameterMapping?: VcHostProfileParameterMapping[]);
	}

	declare class VcHostProfilePolicyOptionMappingPolicyOptionMappingData
	{
		attributePath: String;
		basePath: String;
		condition: VcHostProfileAttributeCondition;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lookup: VcHostProfileMappingLookup;

		constructor();
		constructor(basePath?: String, attributePath?: String, condition?: VcHostProfileAttributeCondition, lookup?: VcHostProfileMappingLookup);
	}

	declare class VcHostProfilesCustomizationData
	{
		customizationsFormat: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityCustomizations: VcHostProfilesEntityCustomizations[];

		constructor();
		constructor(customizationsFormat?: String, entityCustomizations?: VcHostProfilesEntityCustomizations[]);
	}

	declare class VcHostProfilesEntityCustomizations
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcHostProfileSerializedHostProfileSpec
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;
		profileConfigString: String;
		validating: boolean;
		validatorHost: VcHostSystem;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean, profileConfigString?: String, validatorHost?: VcHostSystem, validating?: boolean);
		isEnabled(): boolean;
		isValidating(): boolean;
	}

	declare class VcHostProtocolEndpoint
	{
		deviceId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostKey: VcHostSystem[];
		nfsDir: String;
		nfsServer: String;
		nfsServerAuthType: String;
		nfsServerMajor: String;
		nfsServerScope: String;
		nfsServerUser: String;
		peType: String;
		storageArray: String;
		type: String;
		uuid: String;

		constructor();
		constructor(peType?: String, type?: String, uuid?: String, hostKey?: VcHostSystem[], storageArray?: String, nfsServer?: String, nfsDir?: String, nfsServerScope?: String, nfsServerMajor?: String, nfsServerAuthType?: String, nfsServerUser?: String, deviceId?: String);
	}

	interface VcHostProtocolEndpointPEType
	{
		readonly block: VcHostProtocolEndpointPEType;
		readonly id: String;
		readonly name: String;
		readonly nas: VcHostProtocolEndpointPEType;
		readonly value: String;

		fromString(value?: VcHostProtocolEndpointPEType): VcHostProtocolEndpointPEType;
	}

	declare const VcHostProtocolEndpointPEType: VcHostProtocolEndpointPEType;

	interface VcHostProtocolEndpointProtocolEndpointType
	{
		readonly id: String;
		readonly name: String;
		readonly nfs: VcHostProtocolEndpointProtocolEndpointType;
		readonly nfs4x: VcHostProtocolEndpointProtocolEndpointType;
		readonly scsi: VcHostProtocolEndpointProtocolEndpointType;
		readonly value: String;

		fromString(value?: VcHostProtocolEndpointProtocolEndpointType): VcHostProtocolEndpointProtocolEndpointType;
	}

	declare const VcHostProtocolEndpointProtocolEndpointType: VcHostProtocolEndpointProtocolEndpointType;

	declare class VcHostProxySwitch
	{
		configNumPorts: Number;
		dvsName: String;
		dvsUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostLag: VcHostProxySwitchHostLagConfig[];
		key: String;
		mtu: Number;
		networkReservationSupported: boolean;
		numPorts: Number;
		numPortsAvailable: Number;
		pnic: String[];
		spec: VcHostProxySwitchSpec;
		uplinkPort: VcKeyValue[];

		constructor();
		constructor(dvsUuid?: String, dvsName?: String, key?: String, numPorts?: Number, configNumPorts?: Number, numPortsAvailable?: Number, uplinkPort?: VcKeyValue[], mtu?: Number, pnic?: String[], spec?: VcHostProxySwitchSpec, hostLag?: VcHostProxySwitchHostLagConfig[], networkReservationSupported?: boolean);
		isNetworkReservationSupported(): boolean;
	}

	declare class VcHostProxySwitchConfig
	{
		changeOperation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		spec: VcHostProxySwitchSpec;
		uuid: String;

		constructor();
		constructor(changeOperation?: String, uuid?: String, spec?: VcHostProxySwitchSpec);
	}

	declare class VcHostProxySwitchHostLagConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lagKey: String;
		lagName: String;
		uplinkPort: VcKeyValue[];

		constructor();
		constructor(lagKey?: String, lagName?: String, uplinkPort?: VcKeyValue[]);
	}

	declare class VcHostProxySwitchSpec
	{
		backing: VcDistributedVirtualSwitchHostMemberBacking;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(backing?: VcDistributedVirtualSwitchHostMemberBacking);
	}

	declare class VcHostReconnectionFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostReliableMemoryInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memorySize: Number;

		constructor();
		constructor(memorySize?: Number);
	}

	declare class VcHostRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	interface VcHostReplayUnsupportedReason
	{
		readonly cpuidLimitSet: VcHostReplayUnsupportedReason;
		readonly hvDisabled: VcHostReplayUnsupportedReason;
		readonly id: String;
		readonly incompatibleCpu: VcHostReplayUnsupportedReason;
		readonly incompatibleProduct: VcHostReplayUnsupportedReason;
		readonly name: String;
		readonly oldBIOS: VcHostReplayUnsupportedReason;
		readonly unknown: VcHostReplayUnsupportedReason;
		readonly value: String;

		fromString(value?: VcHostReplayUnsupportedReason): VcHostReplayUnsupportedReason;
	}

	declare const VcHostReplayUnsupportedReason: VcHostReplayUnsupportedReason;

	declare class VcHostResignatureRescanResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		rescan: VcHostVmfsRescanResult[];
		result: VcDatastore;

		constructor();
		constructor(rescan?: VcHostVmfsRescanResult[], result?: VcDatastore);
	}

	declare class VcHostRuntimeInfo
	{
		bootTime: Date;
		connectionState: VcHostSystemConnectionState;
		cpuCapacityForVm: Number;
		cryptoKeyId: VcCryptoKeyId;
		cryptoState: String;
		dasHostState: VcClusterDasFdmHostState;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		healthSystemRuntime: VcHealthSystemRuntime;
		hostMaxVirtualDiskCapacity: Number;
		inMaintenanceMode: boolean;
		inQuarantineMode: boolean;
		memoryCapacityForVm: Number;
		networkRuntimeInfo: VcHostRuntimeInfoNetworkRuntimeInfo;
		powerState: VcHostSystemPowerState;
		standbyMode: String;
		tpmPcrValues: VcHostTpmDigestInfo[];
		vFlashResourceRuntimeInfo: VcHostVFlashManagerVFlashResourceRunTimeInfo;
		vsanRuntimeInfo: VcVsanHostRuntimeInfo;

		constructor();
		constructor(connectionState?: VcHostSystemConnectionState, powerState?: VcHostSystemPowerState, standbyMode?: String, inMaintenanceMode?: boolean, inQuarantineMode?: boolean, bootTime?: Date, healthSystemRuntime?: VcHealthSystemRuntime, dasHostState?: VcClusterDasFdmHostState, tpmPcrValues?: VcHostTpmDigestInfo[], cpuCapacityForVm?: Number, memoryCapacityForVm?: Number, vsanRuntimeInfo?: VcVsanHostRuntimeInfo, networkRuntimeInfo?: VcHostRuntimeInfoNetworkRuntimeInfo, vFlashResourceRuntimeInfo?: VcHostVFlashManagerVFlashResourceRunTimeInfo, hostMaxVirtualDiskCapacity?: Number, cryptoState?: String, cryptoKeyId?: VcCryptoKeyId);
		isInQuarantineMode(): boolean;
	}

	declare class VcHostRuntimeInfoNetStackInstanceRuntimeInfo
	{
		currentIpV6Enabled: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		maxNumberOfConnections: Number;
		netStackInstanceKey: String;
		state: String;
		vmknicKeys: String[];

		constructor();
		constructor(netStackInstanceKey?: String, state?: String, vmknicKeys?: String[], maxNumberOfConnections?: Number, currentIpV6Enabled?: boolean);
		isCurrentIpV6Enabled(): boolean;
	}

	interface VcHostRuntimeInfoNetStackInstanceRuntimeInfoState
	{
		readonly activating: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly active: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly deactivating: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly id: String;
		readonly inactive: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState): VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
	}

	declare const VcHostRuntimeInfoNetStackInstanceRuntimeInfoState: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;

	declare class VcHostRuntimeInfoNetworkRuntimeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		netStackInstanceRuntimeInfo: VcHostRuntimeInfoNetStackInstanceRuntimeInfo[];
		networkResourceRuntime: VcHostNetworkResourceRuntime;

		constructor();
		constructor(netStackInstanceRuntimeInfo?: VcHostRuntimeInfoNetStackInstanceRuntimeInfo[], networkResourceRuntime?: VcHostNetworkResourceRuntime);
	}

	declare class VcHostScsiDisk
	{
		alternateName: VcScsiLunDurableName[];
		canonicalName: String;
		capabilities: VcScsiLunCapabilities;
		capacity: VcHostDiskDimensionsLba;
		descriptor: VcScsiLunDescriptor[];
		deviceName: String;
		devicePath: String;
		deviceType: String;
		displayName: String;
		durableName: VcScsiLunDurableName;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		emulatedDIXDIFEnabled: boolean;
		key: String;
		localDisk: boolean;
		lunType: String;
		model: String;
		operationalState: String[];
		physicalLocation: String[];
		protocolEndpoint: boolean;
		queueDepth: Number;
		revision: String;
		scsiDiskType: String;
		scsiLevel: Number;
		serialNumber: String;
		ssd: boolean;
		standardInquiry: Number[];
		uuid: String;
		vendor: String;
		vsanDiskInfo: VcVsanHostVsanDiskInfo;
		vStorageSupport: String;

		constructor();
		constructor(deviceName?: String, deviceType?: String, key?: String, uuid?: String, descriptor?: VcScsiLunDescriptor[], canonicalName?: String, displayName?: String, lunType?: String, vendor?: String, model?: String, revision?: String, scsiLevel?: Number, serialNumber?: String, durableName?: VcScsiLunDurableName, alternateName?: VcScsiLunDurableName[], standardInquiry?: Number[], queueDepth?: Number, operationalState?: String[], capabilities?: VcScsiLunCapabilities, vStorageSupport?: String, protocolEndpoint?: boolean, capacity?: VcHostDiskDimensionsLba, devicePath?: String, ssd?: boolean, localDisk?: boolean, physicalLocation?: String[], emulatedDIXDIFEnabled?: boolean, vsanDiskInfo?: VcVsanHostVsanDiskInfo, scsiDiskType?: String);
		isEmulatedDIXDIFEnabled(): boolean;
		isLocalDisk(): boolean;
		isProtocolEndpoint(): boolean;
		isSsd(): boolean;
	}

	declare class VcHostScsiDiskPartition
	{
		diskName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		partition: Number;

		constructor();
		constructor(diskName?: String, partition?: Number);
	}

	declare class VcHostScsiTopology
	{
		adapter: VcHostScsiTopologyInterface[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(adapter?: VcHostScsiTopologyInterface[]);
	}

	declare class VcHostScsiTopologyInterface
	{
		adapter: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		target: VcHostScsiTopologyTarget[];

		constructor();
		constructor(key?: String, adapter?: String, target?: VcHostScsiTopologyTarget[]);
	}

	declare class VcHostScsiTopologyLun
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		lun: Number;
		scsiLun: String;

		constructor();
		constructor(key?: String, lun?: Number, scsiLun?: String);
	}

	declare class VcHostScsiTopologyTarget
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		lun: VcHostScsiTopologyLun[];
		target: Number;
		transport: VcHostTargetTransport;

		constructor();
		constructor(key?: String, target?: Number, lun?: VcHostScsiTopologyLun[], transport?: VcHostTargetTransport);
	}

	declare class VcHostSecuritySpec
	{
		addPermission: VcPermission[];
		adminPassword: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		removePermission: VcPermission[];

		constructor();
		constructor(adminPassword?: String, removePermission?: VcPermission[], addPermission?: VcPermission[]);
	}

	declare class VcHostSerialAttachedHba
	{
		bus: Number;
		device: String;
		driver: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		model: String;
		nodeWorldWideName: String;
		pci: String;
		status: String;

		constructor();
		constructor(key?: String, device?: String, bus?: Number, status?: String, model?: String, driver?: String, pci?: String, nodeWorldWideName?: String);
	}

	declare class VcHostSerialAttachedTargetTransport
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcHostService
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		label: String;
		policy: String;
		required: boolean;
		ruleset: String[];
		running: boolean;
		sourcePackage: VcHostServiceSourcePackage;
		uninstallable: boolean;

		constructor();
		constructor(key?: String, label?: String, required?: boolean, uninstallable?: boolean, running?: boolean, ruleset?: String[], policy?: String, sourcePackage?: VcHostServiceSourcePackage);
	}

	declare class VcHostServiceConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		serviceId: String;
		startupPolicy: String;

		constructor();
		constructor(serviceId?: String, startupPolicy?: String);
	}

	declare class VcHostServiceInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		service: VcHostService[];

		constructor();
		constructor(service?: VcHostService[]);
	}

	interface VcHostServicePolicy
	{
		readonly automatic: VcHostServicePolicy;
		readonly id: String;
		readonly name: String;
		readonly off: VcHostServicePolicy;
		readonly on: VcHostServicePolicy;
		readonly value: String;

		fromString(value?: VcHostServicePolicy): VcHostServicePolicy;
	}

	declare const VcHostServicePolicy: VcHostServicePolicy;

	declare class VcHostServiceSourcePackage
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		sourcePackageName: String;

		constructor();
		constructor(sourcePackageName?: String, description?: String);
	}

	interface VcHostServiceSystem
	{
		readonly availableField: VcCustomFieldDef[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		serviceInfo: VcHostServiceInfo;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		refreshServices(): void;
		restartService(arg0?: String): void;
		setCustomValue(arg0?: String, arg1?: String): void;
		startService(arg0?: String): void;
		stopService(arg0?: String): void;
		uninstallService(arg0?: String): void;
		updateServicePolicy(arg0?: String, arg1?: String): void;
	}

	declare const VcHostServiceSystem: VcHostServiceSystem;

	declare class VcHostServiceTicket
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: String;
		port: Number;
		service: String;
		serviceVersion: String;
		sessionId: String;
		sslThumbprint: String;

		constructor();
		constructor(host?: String, port?: Number, sslThumbprint?: String, service?: String, serviceVersion?: String, sessionId?: String);
	}

	declare class VcHostShortNameInconsistentEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		shortName: String;
		shortName2: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, shortName?: String, shortName2?: String);
	}

	declare class VcHostShortNameToIpFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		shortName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, shortName?: String);
	}

	declare class VcHostShutdownEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, reason?: String);
		constructor();
	}

	declare class VcHostSignatureInfo
	{
		dateTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nonce: Number[];
		signatureValue: Number[];
		signingKey: String;
		signingMethod: String;

		constructor();
		constructor(signingMethod?: String, signatureValue?: Number[], signingKey?: String, nonce?: Number[], dateTime?: Date);
	}

	interface VcHostSignatureInfoSigningMethodType
	{
		readonly DSA_SHA1: VcHostSignatureInfoSigningMethodType;
		readonly id: String;
		readonly name: String;
		readonly RSA_MD5: VcHostSignatureInfoSigningMethodType;
		readonly RSA_SHA1: VcHostSignatureInfoSigningMethodType;
		readonly value: String;

		fromString(value?: VcHostSignatureInfoSigningMethodType): VcHostSignatureInfoSigningMethodType;
	}

	declare const VcHostSignatureInfoSigningMethodType: VcHostSignatureInfoSigningMethodType;

	interface VcHostSnmpAgentCapability
	{
		readonly COMPLETE: VcHostSnmpAgentCapability;
		readonly CONFIGURATION: VcHostSnmpAgentCapability;
		readonly DIAGNOSTICS: VcHostSnmpAgentCapability;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostSnmpAgentCapability): VcHostSnmpAgentCapability;
	}

	declare const VcHostSnmpAgentCapability: VcHostSnmpAgentCapability;

	declare class VcHostSnmpConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		option: VcKeyValue[];
		port: Number;
		readOnlyCommunities: String[];
		trapTargets: VcHostSnmpDestination[];

		constructor();
		constructor(enabled?: boolean, port?: Number, readOnlyCommunities?: String[], trapTargets?: VcHostSnmpDestination[], option?: VcKeyValue[]);
		isEnabled(): boolean;
	}

	declare class VcHostSnmpDestination
	{
		community: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostName: String;
		port: Number;

		constructor();
		constructor(hostName?: String, port?: Number, community?: String);
	}

	interface VcHostSnmpSystem
	{
		configuration: VcHostSnmpConfigSpec;
		id: String;
		limits: VcHostSnmpSystemAgentLimits;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureSnmpAgent(arg0?: VcHostSnmpConfigSpec): void;
		sendTestNotification(): void;
	}

	declare const VcHostSnmpSystem: VcHostSnmpSystem;

	declare class VcHostSnmpSystemAgentLimits
	{
		capability: VcHostSnmpAgentCapability;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		maxBufferSize: Number;
		maxCommunityLength: Number;
		maxReadOnlyCommunities: Number;
		maxTrapDestinations: Number;

		constructor();
		constructor(maxReadOnlyCommunities?: Number, maxTrapDestinations?: Number, maxCommunityLength?: Number, maxBufferSize?: Number, capability?: VcHostSnmpAgentCapability);
	}

	declare class VcHostSpecification
	{
		changeID: String;
		createdTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		lastModified: Date;
		subSpecs: VcHostSubSpecification[];

		constructor();
		constructor(createdTime?: Date, lastModified?: Date, host?: VcHostSystem, subSpecs?: VcHostSubSpecification[], changeID?: String);
	}

	interface VcHostSpecificationAgent
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		hostDeleteHostSubSpecification(arg0?: String): void;
		hostRetrieveHostSpecification(): VcHostSpecification;
		hostRetrieveHostSubSpecification(arg0?: String): VcHostSubSpecification;
		hostUpdateHostSubSpecificationByData(arg0?: String, arg1?: Number[]): void;
		hostUpdateHostSubSpecificationByFile(arg0?: String, arg1?: String): void;
	}

	declare const VcHostSpecificationAgent: VcHostSpecificationAgent;

	declare class VcHostSpecificationChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	interface VcHostSpecificationManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteHostSpecification(arg0?: VcHostSystem): void;
		deleteHostSubSpecification(arg0?: VcHostSystem, arg1?: String): void;
		hostSpecGetUpdatedHosts(arg0?: String, arg1?: String): VcHostSystem[];
		retrieveHostSpecification(arg0?: VcHostSystem, arg1?: boolean): VcHostSpecification;
		updateHostSpecification(arg0?: VcHostSystem, arg1?: VcHostSpecification): void;
		updateHostSubSpecification(arg0?: VcHostSystem, arg1?: VcHostSubSpecification): void;
	}

	declare const VcHostSpecificationManager: VcHostSpecificationManager;

	declare class VcHostSpecificationOperationFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcHostSpecificationRequireEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostSpecificationUpdateEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostSpec: VcHostSpecification;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostSpec?: VcHostSpecification);
	}

	declare class VcHostSriovConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		numVirtualFunction: Number;
		passthruEnabled: boolean;
		sriovEnabled: boolean;

		constructor();
		constructor(id?: String, passthruEnabled?: boolean, sriovEnabled?: boolean, numVirtualFunction?: Number);
	}

	declare class VcHostSriovDevicePoolInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;

		constructor(key?: String);
		constructor();
	}

	declare class VcHostSriovInfo
	{
		dependentDevice: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		maxVirtualFunctionSupported: Number;
		numVirtualFunction: Number;
		numVirtualFunctionRequested: Number;
		passthruActive: boolean;
		passthruCapable: boolean;
		passthruEnabled: boolean;
		sriovActive: boolean;
		sriovCapable: boolean;
		sriovEnabled: boolean;

		constructor();
		constructor(id?: String, dependentDevice?: String, passthruEnabled?: boolean, passthruCapable?: boolean, passthruActive?: boolean, sriovEnabled?: boolean, sriovCapable?: boolean, sriovActive?: boolean, numVirtualFunctionRequested?: Number, numVirtualFunction?: Number, maxVirtualFunctionSupported?: Number);
	}

	declare class VcHostSriovNetworkDevicePoolInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		pnic: VcPhysicalNic[];
		switchKey: String;
		switchUuid: String;

		constructor();
		constructor(key?: String, switchKey?: String, switchUuid?: String, pnic?: VcPhysicalNic[]);
	}

	declare class VcHostSslThumbprintInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ownerTag: String;
		principal: String;
		sslThumbprints: String[];

		constructor();
		constructor(principal?: String, ownerTag?: String, sslThumbprints?: String[]);
	}

	interface VcHostStandbyMode
	{
		readonly entering: VcHostStandbyMode;
		readonly exiting: VcHostStandbyMode;
		readonly id: String;
		readonly in: VcHostStandbyMode;
		readonly name: String;
		readonly none: VcHostStandbyMode;
		readonly value: String;

		fromString(value?: VcHostStandbyMode): VcHostStandbyMode;
	}

	declare const VcHostStandbyMode: VcHostStandbyMode;

	declare class VcHostStatusChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newStatus: String;
		oldStatus: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, oldStatus?: String, newStatus?: String);
	}

	declare class VcHostStorageArrayTypePolicyOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policy: VcElementDescription;

		constructor();
		constructor(policy?: VcElementDescription);
	}

	declare class VcHostStorageDeviceInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostBusAdapter: VcHostHostBusAdapter[];
		multipathInfo: VcHostMultipathInfo;
		plugStoreTopology: VcHostPlugStoreTopology;
		scsiLun: VcScsiLun[];
		scsiTopology: VcHostScsiTopology;
		softwareInternetScsiEnabled: boolean;

		constructor();
		constructor(hostBusAdapter?: VcHostHostBusAdapter[], scsiLun?: VcScsiLun[], scsiTopology?: VcHostScsiTopology, multipathInfo?: VcHostMultipathInfo, plugStoreTopology?: VcHostPlugStoreTopology, softwareInternetScsiEnabled?: boolean);
	}

	declare class VcHostStorageElementInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		operationalInfo: VcHostStorageOperationalInfo[];
		status: VcElementDescription;

		constructor();
		constructor(name?: String, status?: VcElementDescription, operationalInfo?: VcHostStorageOperationalInfo[]);
	}

	declare class VcHostStorageOperationalInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		property: String;
		value: String;

		constructor();
		constructor(property?: String, value?: String);
	}

	interface VcHostStorageSystem
	{
		readonly availableField: VcCustomFieldDef[];
		fileSystemVolumeInfo: VcHostFileSystemVolumeInfo;
		id: String;
		moref: VcManagedObjectReference;
		multipathStateInfo: VcHostMultipathStateInfo;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		storageDeviceInfo: VcHostStorageDeviceInfo;
		systemFile: String[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addInternetScsiSendTargets(arg0?: String, arg1?: VcHostInternetScsiHbaSendTarget[]): void;
		addInternetScsiStaticTargets(arg0?: String, arg1?: VcHostInternetScsiHbaStaticTarget[]): void;
		attachScsiLun(arg0?: String): void;
		attachScsiLunEx_Task(arg0?: String[]): VcTask;
		attachVmfsExtent(arg0?: String, arg1?: VcHostScsiDiskPartition): void;
		changeNFSUserPassword(arg0?: String): void;
		clearNFSUser(): void;
		computeDiskPartitionInfo(arg0?: String, arg1?: VcHostDiskPartitionLayout, arg2?: String): VcHostDiskPartitionInfo;
		computeDiskPartitionInfoForResize(arg0?: VcHostScsiDiskPartition, arg1?: VcHostDiskPartitionBlockRange, arg2?: String): VcHostDiskPartitionInfo;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteScsiLunState(arg0?: String): void;
		deleteVffsVolumeState(arg0?: String): void;
		deleteVmfsVolumeState(arg0?: String): void;
		destroyVffs(arg0?: String): void;
		detachScsiLun(arg0?: String): void;
		detachScsiLunEx_Task(arg0?: String[]): VcTask;
		disableMultipathPath(arg0?: String): void;
		discoverFcoeHbas(arg0?: VcFcoeConfigFcoeSpecification): void;
		enableMultipathPath(arg0?: String): void;
		expandVmfsExtent(arg0?: String, arg1?: VcHostScsiDiskPartition): void;
		extendVffs(arg0?: String, arg1?: String, arg2?: VcHostDiskPartitionSpec): void;
		fetchIoFilterSharedSecret(): String;
		formatVffs(arg0?: VcHostVffsSpec): VcHostVffsVolume;
		formatVmfs(arg0?: VcHostVmfsSpec): VcHostVmfsVolume;
		markAsLocal_Task(arg0?: String): VcTask;
		markAsNonLocal_Task(arg0?: String): VcTask;
		markAsNonSsd_Task(arg0?: String): VcTask;
		markAsSsd_Task(arg0?: String): VcTask;
		markForRemoval(arg0?: String, arg1?: boolean): void;
		mountVffsVolume(arg0?: String): void;
		mountVmfsVolume(arg0?: String): void;
		mountVmfsVolumeEx_Task(arg0?: String[]): VcTask;
		queryAvailableSsds(arg0?: String): VcHostScsiDisk[];
		queryIoFilterProviderId(): String;
		queryNFSUser(): VcHostNasVolumeUserInfo;
		queryPathSelectionPolicyOptions(): VcHostPathSelectionPolicyOption[];
		queryStorageArrayTypePolicyOptions(): VcHostStorageArrayTypePolicyOption[];
		queryUnresolvedVmfsVolume(): VcHostUnresolvedVmfsVolume[];
		queryVmfsConfigOption(): VcVmfsConfigOption[];
		refreshStorageSystem(): void;
		removeInternetScsiSendTargets(arg0?: String, arg1?: VcHostInternetScsiHbaSendTarget[]): void;
		removeInternetScsiStaticTargets(arg0?: String, arg1?: VcHostInternetScsiHbaStaticTarget[]): void;
		rescanAllHba(): void;
		rescanHba(arg0?: String): void;
		rescanVffs(): void;
		rescanVmfs(): void;
		resolveMultipleUnresolvedVmfsVolumes(arg0?: VcHostUnresolvedVmfsResolutionSpec[]): VcHostUnresolvedVmfsResolutionResult[];
		resolveMultipleUnresolvedVmfsVolumesEx_Task(arg0?: VcHostUnresolvedVmfsResolutionSpec[]): VcTask;
		retrieveDiskPartitionInfo(arg0?: String[]): VcHostDiskPartitionInfo[];
		setCustomValue(arg0?: String, arg1?: String): void;
		setMultipathLunPolicy(arg0?: String, arg1?: VcHostMultipathInfoLogicalUnitPolicy): void;
		setNFSUser(arg0?: String, arg1?: String): void;
		turnDiskLocatorLedOff_Task(arg0?: String[]): VcTask;
		turnDiskLocatorLedOn_Task(arg0?: String[]): VcTask;
		unmapVmfsVolumeEx_Task(arg0?: String[]): VcTask;
		unmountForceMountedVmfsVolume(arg0?: String): void;
		unmountVffsVolume(arg0?: String): void;
		unmountVmfsVolume(arg0?: String): void;
		unmountVmfsVolumeEx_Task(arg0?: String[]): VcTask;
		updateDiskPartitions(arg0?: String, arg1?: VcHostDiskPartitionSpec): void;
		updateInternetScsiAdvancedOptions(arg0?: String, arg1?: VcHostInternetScsiHbaTargetSet, arg2?: VcHostInternetScsiHbaParamValue[]): void;
		updateInternetScsiAlias(arg0?: String, arg1?: String): void;
		updateInternetScsiAuthenticationProperties(arg0?: String, arg1?: VcHostInternetScsiHbaAuthenticationProperties, arg2?: VcHostInternetScsiHbaTargetSet): void;
		updateInternetScsiDigestProperties(arg0?: String, arg1?: VcHostInternetScsiHbaTargetSet, arg2?: VcHostInternetScsiHbaDigestProperties): void;
		updateInternetScsiDiscoveryProperties(arg0?: String, arg1?: VcHostInternetScsiHbaDiscoveryProperties): void;
		updateInternetScsiIPProperties(arg0?: String, arg1?: VcHostInternetScsiHbaIPProperties): void;
		updateInternetScsiName(arg0?: String, arg1?: String): void;
		updateScsiLunDisplayName(arg0?: String, arg1?: String): void;
		updateSoftwareInternetScsiEnabled(arg0?: boolean): void;
		updateVmfsUnmapPriority(arg0?: String, arg1?: String): void;
		upgradeVmfs(arg0?: String): void;
		upgradeVmLayout(): void;
	}

	declare const VcHostStorageSystem: VcHostStorageSystem;

	declare class VcHostStorageSystemDiskLocatorLedResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		key: String;

		constructor();
		constructor(key?: String, fault?: VcLocalizedMethodFault);
	}

	declare class VcHostStorageSystemScsiLunResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		key: String;

		constructor();
		constructor(key?: String, fault?: VcLocalizedMethodFault);
	}

	declare class VcHostStorageSystemVmfsVolumeResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		key: String;

		constructor();
		constructor(key?: String, fault?: VcLocalizedMethodFault);
	}

	declare class VcHostSubSpecification
	{
		createdTime: Date;
		data: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, createdTime?: Date, data?: Number[]);
	}

	declare class VcHostSubSpecificationDeleteEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		subSpecName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, subSpecName?: String);
	}

	declare class VcHostSubSpecificationUpdateEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostSubSpec: VcHostSubSpecification;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostSubSpec?: VcHostSubSpecification);
	}

	declare class VcHostSyncFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, reason?: VcLocalizedMethodFault);
		constructor();
	}

	interface VcHostSystem
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		capability: VcHostCapability;
		config: VcHostConfigInfo;
		readonly configIssue: VcEvent[];
		configManager: VcHostConfigManager;
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		datastoreBrowser: VcHostDatastoreBrowser;
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		hardware: VcHostHardwareInfo;
		id: String;
		licensableResource: VcHostLicensableResourceInfo;
		moref: VcManagedObjectReference;
		readonly name: String;
		network: VcNetwork[];
		network_DistributedVirtualPortgroup: Object[];
		network_Network: Object[];
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		runtime: VcHostRuntimeInfo;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		state: String;
		summary: VcHostListSummary;
		systemResources: VcHostSystemResourceInfo;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		uuid: String;
		readonly value: VcCustomFieldValue[];
		version: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		vm: VcVirtualMachine[];

		_getRef(): VcManagedObjectReference;
		acquireCimServicesTicket(): VcHostServiceTicket;
		addTag(arg0?: VcTag[]): void;
		applyEvcMode_Task(arg0?: VcEVCMode, arg1?: boolean): VcTask;
		checkCertificateTrusted(arg0?: String): boolean;
		configureCryptoKey(arg0?: VcCryptoKeyId): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		disableAdmin(): void;
		disconnectHost_Task(): VcTask;
		enableAdmin(): void;
		enableCrypto(arg0?: VcCryptoKeyPlain): void;
		enterLockdownMode(): void;
		enterMaintenanceMode_Task(arg0?: Number, arg1?: boolean, arg2?: VcHostMaintenanceSpec): VcTask;
		exitLockdownMode(): void;
		exitMaintenanceMode_Task(arg0?: Number): VcTask;
		powerDownHostToStandBy_Task(arg0?: Number, arg1?: boolean): VcTask;
		powerUpHostFromStandBy_Task(arg0?: Number): VcTask;
		prepareCrypto(): void;
		queryHostConnectionInfo(): VcHostConnectInfo;
		queryMemoryOverhead(arg0?: Number, arg1?: Number, arg2?: Number): Number;
		queryMemoryOverheadEx(arg0?: VcVirtualMachineConfigInfo): Number;
		queryMemoryOverheadEx2(arg0?: VcVirtualMachineConfigInfo): VcVirtualMachineConfigInfoOverheadInfo;
		queryTpmAttestationReport(): VcHostTpmAttestationReport;
		rebootHost_Task(arg0?: boolean): VcTask;
		reconfigureHostForDAS_Task(): VcTask;
		reconnectHost_Task(arg0?: VcHostConnectSpec, arg1?: VcHostSystemReconnectSpec): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		retrieveDynamicTypeManager(): VcInternalDynamicTypeManager;
		retrieveHardwareUptime(): Number;
		retrieveInternalCapability(): VcHostInternalCapability;
		retrieveInternalConfigManager(): VcHostInternalConfigManager;
		retrieveManagedMethodExecuter(): VcReflectManagedMethodExecuter;
		retrievePatchManager(): VcHostPatchManager;
		sendWakeOnLanPacket(arg0?: VcHostWakeOnLanConfig[]): void;
		setCustomValue(arg0?: String, arg1?: String): void;
		shutdownHost_Task(arg0?: boolean): VcTask;
		testEvcMode_Task(arg0?: VcEVCMode): VcTask;
		updateFlags(arg0?: VcHostFlagInfo): void;
		updateIpmi(arg0?: VcHostIpmiInfo): void;
		updateManagementServerIp(arg0?: String): void;
		updateSslThumbprintInfo(arg0?: VcHostSslThumbprintInfo, arg1?: String): void;
		updateSystemResources(arg0?: VcHostSystemResourceInfo): void;
		updateSystemSwapConfiguration(arg0?: VcHostSystemSwapConfiguration): void;
	}

	declare const VcHostSystem: VcHostSystem;

	interface VcHostSystemConnectionState
	{
		readonly connected: VcHostSystemConnectionState;
		readonly disconnected: VcHostSystemConnectionState;
		readonly id: String;
		readonly name: String;
		readonly notResponding: VcHostSystemConnectionState;
		readonly value: String;

		fromString(value?: VcHostSystemConnectionState): VcHostSystemConnectionState;
	}

	declare const VcHostSystemConnectionState: VcHostSystemConnectionState;

	interface VcHostSystemDebugManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryProcessInfo(): VcHostSystemDebugManagerProcessInfo[];
	}

	declare const VcHostSystemDebugManager: VcHostSystemDebugManager;

	declare class VcHostSystemDebugManagerProcessInfo
	{
		cpuPercentage: Number;
		cpuTime: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pid: Number[];
		processKey: String;
		uptime: Number;
		virtualMemSize: Number;

		constructor();
		constructor(processKey?: String, uptime?: Number, virtualMemSize?: Number, pid?: Number[], cpuTime?: Number, cpuPercentage?: Number);
	}

	interface VcHostSystemDebugManagerProcessKey
	{
		readonly hostd: VcHostSystemDebugManagerProcessKey;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcHostSystemDebugManagerProcessKey): VcHostSystemDebugManagerProcessKey;
	}

	declare const VcHostSystemDebugManagerProcessKey: VcHostSystemDebugManagerProcessKey;

	declare class VcHostSystemHealthInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		numericSensorInfo: VcHostNumericSensorInfo[];

		constructor();
		constructor(numericSensorInfo?: VcHostNumericSensorInfo[]);
	}

	declare class VcHostSystemIdentificationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		identifierType: VcElementDescription;
		identifierValue: String;

		constructor();
		constructor(identifierValue?: String, identifierType?: VcElementDescription);
	}

	interface VcHostSystemIdentificationInfoIdentifier
	{
		readonly AssetTag: VcHostSystemIdentificationInfoIdentifier;
		readonly id: String;
		readonly name: String;
		readonly OemSpecificString: VcHostSystemIdentificationInfoIdentifier;
		readonly ServiceTag: VcHostSystemIdentificationInfoIdentifier;
		readonly value: String;

		fromString(value?: VcHostSystemIdentificationInfoIdentifier): VcHostSystemIdentificationInfoIdentifier;
	}

	declare const VcHostSystemIdentificationInfoIdentifier: VcHostSystemIdentificationInfoIdentifier;

	declare class VcHostSystemInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		model: String;
		otherIdentifyingInfo: VcHostSystemIdentificationInfo[];
		uuid: String;
		vendor: String;

		constructor();
		constructor(vendor?: String, model?: String, uuid?: String, otherIdentifyingInfo?: VcHostSystemIdentificationInfo[]);
	}

	interface VcHostSystemPowerState
	{
		readonly id: String;
		readonly name: String;
		readonly poweredOff: VcHostSystemPowerState;
		readonly poweredOn: VcHostSystemPowerState;
		readonly standBy: VcHostSystemPowerState;
		readonly unknown: VcHostSystemPowerState;
		readonly value: String;

		fromString(value?: VcHostSystemPowerState): VcHostSystemPowerState;
	}

	declare const VcHostSystemPowerState: VcHostSystemPowerState;

	declare class VcHostSystemReconnectSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		syncState: boolean;

		constructor();
		constructor(syncState?: boolean);
		isSyncState(): boolean;
	}

	declare class VcHostSystemResourceInfo
	{
		child: VcHostSystemResourceInfo[];
		config: VcResourceConfigSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;

		constructor();
		constructor(key?: String, config?: VcResourceConfigSpec, child?: VcHostSystemResourceInfo[]);
	}

	declare class VcHostSystemSwapConfiguration
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		option: VcHostSystemSwapConfigurationSystemSwapOption[];

		constructor();
		constructor(option?: VcHostSystemSwapConfigurationSystemSwapOption[]);
	}

	declare class VcHostSystemSwapConfigurationDatastoreOption
	{
		datastore: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;

		constructor();
		constructor(key?: Number, datastore?: String);
	}

	declare class VcHostSystemSwapConfigurationDisabledOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;

		constructor();
		constructor(key?: Number);
	}

	declare class VcHostSystemSwapConfigurationHostCacheOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;

		constructor();
		constructor(key?: Number);
	}

	declare class VcHostSystemSwapConfigurationHostLocalSwapOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;

		constructor();
		constructor(key?: Number);
	}

	declare class VcHostSystemSwapConfigurationSystemSwapOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;

		constructor(key?: Number);
		constructor();
	}

	declare class VcHostTargetTransport
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcHostTpmAttestationReport
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		tpmEvents: VcHostTpmEventLogEntry[];
		tpmLogReliable: boolean;
		tpmPcrValues: VcHostTpmDigestInfo[];

		constructor();
		constructor(tpmPcrValues?: VcHostTpmDigestInfo[], tpmEvents?: VcHostTpmEventLogEntry[], tpmLogReliable?: boolean);
	}

	declare class VcHostTpmBootSecurityOptionEventDetails
	{
		bootSecurityOption: String;
		dataHash: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(dataHash?: Number[], bootSecurityOption?: String);
	}

	declare class VcHostTpmCommandEventDetails
	{
		commandLine: String;
		dataHash: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(dataHash?: Number[], commandLine?: String);
	}

	declare class VcHostTpmDigestInfo
	{
		digestMethod: String;
		digestValue: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		objectName: String;
		pcrNumber: Number;

		constructor();
		constructor(digestMethod?: String, digestValue?: Number[], objectName?: String, pcrNumber?: Number);
	}

	declare class VcHostTpmEventDetails
	{
		dataHash: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(dataHash?: Number[]);
	}

	declare class VcHostTpmEventLogEntry
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eventDetails: VcHostTpmEventDetails;
		pcrIndex: Number;

		constructor();
		constructor(pcrIndex?: Number, eventDetails?: VcHostTpmEventDetails);
	}

	interface VcHostTpmManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		generateReport(arg0?: Number[], arg1?: Number[]): VcHostIntegrityReport;
		requestIdentity(arg0?: String, arg1?: String): VcHostTpmManagerEncryptedBlob;
		verifyCredential(arg0?: VcHostTpmManagerEncryptedBlob): String;
	}

	declare const VcHostTpmManager: VcHostTpmManager;

	declare class VcHostTpmManagerEncryptedBlob
	{
		asymAlgorithm: VcHostTpmManagerKeyParams;
		asymBlob: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		symAlgorithm: VcHostTpmManagerKeyParams;
		symBlob: Number[];

		constructor();
		constructor(asymAlgorithm?: VcHostTpmManagerKeyParams, symAlgorithm?: VcHostTpmManagerKeyParams, asymBlob?: Number[], symBlob?: Number[]);
	}

	declare class VcHostTpmManagerKeyParams
	{
		algorithmID: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encScheme: Number;
		params: Number[];
		sigScheme: Number;

		constructor();
		constructor(algorithmID?: Number, encScheme?: Number, sigScheme?: Number, params?: Number[]);
	}

	declare class VcHostTpmOptionEventDetails
	{
		bootOptions: Number[];
		dataHash: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		optionsFileName: String;

		constructor();
		constructor(dataHash?: Number[], optionsFileName?: String, bootOptions?: Number[]);
	}

	declare class VcHostTpmSoftwareComponentEventDetails
	{
		componentName: String;
		dataHash: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vibName: String;
		vibVendor: String;
		vibVersion: String;

		constructor();
		constructor(dataHash?: Number[], componentName?: String, vibName?: String, vibVersion?: String, vibVendor?: String);
	}

	declare class VcHostUnresolvedVmfsExtent
	{
		device: VcHostScsiDiskPartition;
		devicePath: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endBlock: Number;
		isHeadExtent: boolean;
		ordinal: Number;
		reason: String;
		startBlock: Number;
		vmfsUuid: String;

		constructor();
		constructor(device?: VcHostScsiDiskPartition, devicePath?: String, vmfsUuid?: String, isHeadExtent?: boolean, ordinal?: Number, startBlock?: Number, endBlock?: Number, reason?: String);
	}

	interface VcHostUnresolvedVmfsExtentUnresolvedReason
	{
		readonly diskIdMismatch: VcHostUnresolvedVmfsExtentUnresolvedReason;
		readonly id: String;
		readonly name: String;
		readonly uuidConflict: VcHostUnresolvedVmfsExtentUnresolvedReason;
		readonly value: String;

		fromString(value?: VcHostUnresolvedVmfsExtentUnresolvedReason): VcHostUnresolvedVmfsExtentUnresolvedReason;
	}

	declare const VcHostUnresolvedVmfsExtentUnresolvedReason: VcHostUnresolvedVmfsExtentUnresolvedReason;

	declare class VcHostUnresolvedVmfsResignatureSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extentDevicePath: String[];

		constructor();
		constructor(extentDevicePath?: String[]);
	}

	declare class VcHostUnresolvedVmfsResolutionResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		spec: VcHostUnresolvedVmfsResolutionSpec;
		vmfs: VcHostVmfsVolume;

		constructor();
		constructor(spec?: VcHostUnresolvedVmfsResolutionSpec, vmfs?: VcHostVmfsVolume, fault?: VcLocalizedMethodFault);
	}

	declare class VcHostUnresolvedVmfsResolutionSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extentDevicePath: String[];
		uuidResolution: String;

		constructor();
		constructor(extentDevicePath?: String[], uuidResolution?: String);
	}

	interface VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution
	{
		readonly forceMount: VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
		readonly id: String;
		readonly name: String;
		readonly resignature: VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
		readonly value: String;

		fromString(value?: VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution): VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
	}

	declare const VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution: VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution;

	declare class VcHostUnresolvedVmfsVolume
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extent: VcHostUnresolvedVmfsExtent[];
		resolveStatus: VcHostUnresolvedVmfsVolumeResolveStatus;
		totalBlocks: Number;
		vmfsLabel: String;
		vmfsUuid: String;

		constructor();
		constructor(extent?: VcHostUnresolvedVmfsExtent[], vmfsLabel?: String, vmfsUuid?: String, totalBlocks?: Number, resolveStatus?: VcHostUnresolvedVmfsVolumeResolveStatus);
	}

	declare class VcHostUnresolvedVmfsVolumeResolveStatus
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		incompleteExtents: boolean;
		multipleCopies: boolean;
		resolvable: boolean;

		constructor();
		constructor(resolvable?: boolean, incompleteExtents?: boolean, multipleCopies?: boolean);
		isIncompleteExtents(): boolean;
		isMultipleCopies(): boolean;
	}

	declare class VcHostUpdateProxyConfigInfo
	{
		cacheLocation: String;
		cachePruningLimits: Number;
		cacheSize: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		repoLocation: String;

		constructor();
		constructor(repoLocation?: String, cacheLocation?: String, cacheSize?: Number, cachePruningLimits?: Number);
	}

	declare class VcHostUpgradeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostUserWorldSwapNotEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcHostVfatVolume
	{
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		type: String;

		constructor();
		constructor(type?: String, name?: String, capacity?: Number);
	}

	declare class VcHostVffsSpec
	{
		devicePath: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		majorVersion: Number;
		partition: VcHostDiskPartitionSpec;
		volumeName: String;

		constructor();
		constructor(devicePath?: String, partition?: VcHostDiskPartitionSpec, majorVersion?: Number, volumeName?: String);
	}

	declare class VcHostVffsVolume
	{
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extent: VcHostScsiDiskPartition[];
		majorVersion: Number;
		name: String;
		type: String;
		uuid: String;
		version: String;

		constructor();
		constructor(type?: String, name?: String, capacity?: Number, majorVersion?: Number, version?: String, uuid?: String, extent?: VcHostScsiDiskPartition[]);
	}

	interface VcHostVFlashManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vFlashConfigInfo: VcHostVFlashManagerVFlashConfigInfo;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		configureVFlashResourceEx_Task(arg0?: String[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		hostConfigureVFlashResource(arg0?: VcHostVFlashManagerVFlashResourceConfigSpec): void;
		hostConfigVFlashCache(arg0?: VcHostVFlashManagerVFlashCacheConfigSpec): void;
		hostGetVFlashModuleDefaultConfig(arg0?: String): VcVirtualDiskVFlashCacheConfigInfo;
		hostRemoveVFlashResource(): void;
	}

	declare const VcHostVFlashManager: VcHostVFlashManager;

	declare class VcHostVFlashManagerVFlashCacheConfigInfo
	{
		defaultVFlashModule: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		swapCacheReservationInGB: Number;
		vFlashModuleConfigOption: VcHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption[];

		constructor();
		constructor(vFlashModuleConfigOption?: VcHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption[], defaultVFlashModule?: String, swapCacheReservationInGB?: Number);
	}

	declare class VcHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption
	{
		blockSizeInKBOption: VcLongOption;
		cacheConsistencyType: VcChoiceOption;
		cacheMode: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		maxDiskSizeInKB: Number;
		minSupportedModuleVersion: String;
		reservationInMBOption: VcLongOption;
		vFlashModule: String;
		vFlashModuleVersion: String;

		constructor();
		constructor(vFlashModule?: String, vFlashModuleVersion?: String, minSupportedModuleVersion?: String, cacheConsistencyType?: VcChoiceOption, cacheMode?: VcChoiceOption, blockSizeInKBOption?: VcLongOption, reservationInMBOption?: VcLongOption, maxDiskSizeInKB?: Number);
	}

	declare class VcHostVFlashManagerVFlashCacheConfigSpec
	{
		defaultVFlashModule: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		swapCacheReservationInGB: Number;

		constructor();
		constructor(defaultVFlashModule?: String, swapCacheReservationInGB?: Number);
	}

	declare class VcHostVFlashManagerVFlashConfigInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vFlashCacheConfigInfo: VcHostVFlashManagerVFlashCacheConfigInfo;
		vFlashResourceConfigInfo: VcHostVFlashManagerVFlashResourceConfigInfo;

		constructor();
		constructor(vFlashResourceConfigInfo?: VcHostVFlashManagerVFlashResourceConfigInfo, vFlashCacheConfigInfo?: VcHostVFlashManagerVFlashCacheConfigInfo);
	}

	declare class VcHostVFlashManagerVFlashResourceConfigInfo
	{
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vffs: VcHostVffsVolume;

		constructor();
		constructor(vffs?: VcHostVffsVolume, capacity?: Number);
	}

	declare class VcHostVFlashManagerVFlashResourceConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vffsUuid: String;

		constructor();
		constructor(vffsUuid?: String);
	}

	declare class VcHostVFlashManagerVFlashResourceRunTimeInfo
	{
		accessible: boolean;
		capacity: Number;
		capacityForVmCache: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeForVmCache: Number;
		usage: Number;

		constructor();
		constructor(usage?: Number, capacity?: Number, accessible?: boolean, capacityForVmCache?: Number, freeForVmCache?: Number);
	}

	declare class VcHostVFlashResourceConfigurationResult
	{
		devicePath: String[];
		diskConfigurationResult: VcHostDiskConfigurationResult[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vffs: VcHostVffsVolume;

		constructor();
		constructor(devicePath?: String[], vffs?: VcHostVffsVolume, diskConfigurationResult?: VcHostDiskConfigurationResult[]);
	}

	declare class VcHostVirtualNic
	{
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		port: String;
		portgroup: String;
		spec: VcHostVirtualNicSpec;

		constructor();
		constructor(device?: String, key?: String, portgroup?: String, spec?: VcHostVirtualNicSpec, port?: String);
	}

	declare class VcHostVirtualNicConfig
	{
		changeOperation: String;
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		portgroup: String;
		spec: VcHostVirtualNicSpec;

		constructor();
		constructor(changeOperation?: String, device?: String, portgroup?: String, spec?: VcHostVirtualNicSpec);
	}

	declare class VcHostVirtualNicConnection
	{
		dvPort: VcDistributedVirtualSwitchPortConnection;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		portgroup: String;

		constructor();
		constructor(portgroup?: String, dvPort?: VcDistributedVirtualSwitchPortConnection);
	}

	declare class VcHostVirtualNicIpRouteSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipRouteConfig: VcHostIpRouteConfig;

		constructor();
		constructor(ipRouteConfig?: VcHostIpRouteConfig);
	}

	interface VcHostVirtualNicManager
	{
		readonly availableField: VcCustomFieldDef[];
		id: String;
		info: VcHostVirtualNicManagerInfo;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deselectVnicForNicType(arg0?: String, arg1?: String): void;
		queryNetConfig(arg0?: String): VcVirtualNicManagerNetConfig;
		selectVnicForNicType(arg0?: String, arg1?: String): void;
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcHostVirtualNicManager: VcHostVirtualNicManager;

	declare class VcHostVirtualNicManagerInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		netConfig: VcVirtualNicManagerNetConfig[];

		constructor();
		constructor(netConfig?: VcVirtualNicManagerNetConfig[]);
	}

	interface VcHostVirtualNicManagerNicType
	{
		readonly faultToleranceLogging: VcHostVirtualNicManagerNicType;
		readonly id: String;
		readonly management: VcHostVirtualNicManagerNicType;
		readonly name: String;
		readonly value: String;
		readonly vmotion: VcHostVirtualNicManagerNicType;
		readonly vsan: VcHostVirtualNicManagerNicType;
		readonly vsanWitness: VcHostVirtualNicManagerNicType;
		readonly vSphereProvisioning: VcHostVirtualNicManagerNicType;
		readonly vSphereReplication: VcHostVirtualNicManagerNicType;
		readonly vSphereReplicationNFC: VcHostVirtualNicManagerNicType;

		fromString(value?: VcHostVirtualNicManagerNicType): VcHostVirtualNicManagerNicType;
	}

	declare const VcHostVirtualNicManagerNicType: VcHostVirtualNicManagerNicType;

	declare class VcHostVirtualNicManagerNicTypeSelection
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nicType: String[];
		vnic: VcHostVirtualNicConnection;

		constructor();
		constructor(vnic?: VcHostVirtualNicConnection, nicType?: String[]);
	}

	declare class VcHostVirtualNicOpaqueNetworkSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		opaqueNetworkId: String;
		opaqueNetworkType: String;

		constructor();
		constructor(opaqueNetworkId?: String, opaqueNetworkType?: String);
	}

	declare class VcHostVirtualNicSpec
	{
		distributedVirtualPort: VcDistributedVirtualSwitchPortConnection;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		ip: VcHostIpConfig;
		ipRouteSpec: VcHostVirtualNicIpRouteSpec;
		mac: String;
		mtu: Number;
		netStackInstanceKey: String;
		opaqueNetwork: VcHostVirtualNicOpaqueNetworkSpec;
		pinnedPnic: String;
		portgroup: String;
		tsoEnabled: boolean;

		constructor();
		constructor(ip?: VcHostIpConfig, mac?: String, distributedVirtualPort?: VcDistributedVirtualSwitchPortConnection, portgroup?: String, mtu?: Number, tsoEnabled?: boolean, netStackInstanceKey?: String, opaqueNetwork?: VcHostVirtualNicOpaqueNetworkSpec, externalId?: String, pinnedPnic?: String, ipRouteSpec?: VcHostVirtualNicIpRouteSpec);
		isTsoEnabled(): boolean;
	}

	declare class VcHostVirtualSwitch
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		mtu: Number;
		name: String;
		numPorts: Number;
		numPortsAvailable: Number;
		pnic: String[];
		portgroup: String[];
		spec: VcHostVirtualSwitchSpec;

		constructor();
		constructor(name?: String, key?: String, numPorts?: Number, numPortsAvailable?: Number, mtu?: Number, portgroup?: String[], pnic?: String[], spec?: VcHostVirtualSwitchSpec);
	}

	declare class VcHostVirtualSwitchAutoBridge
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		excludedNicDevice: String[];

		constructor();
		constructor(excludedNicDevice?: String[]);
	}

	declare class VcHostVirtualSwitchBeaconConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		interval: Number;

		constructor();
		constructor(interval?: Number);
	}

	declare class VcHostVirtualSwitchBondBridge
	{
		beacon: VcHostVirtualSwitchBeaconConfig;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		linkDiscoveryProtocolConfig: VcLinkDiscoveryProtocolConfig;
		nicDevice: String[];

		constructor();
		constructor(nicDevice?: String[], beacon?: VcHostVirtualSwitchBeaconConfig, linkDiscoveryProtocolConfig?: VcLinkDiscoveryProtocolConfig);
	}

	declare class VcHostVirtualSwitchBridge
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcHostVirtualSwitchConfig
	{
		changeOperation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		spec: VcHostVirtualSwitchSpec;

		constructor();
		constructor(changeOperation?: String, name?: String, spec?: VcHostVirtualSwitchSpec);
	}

	declare class VcHostVirtualSwitchSimpleBridge
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nicDevice: String;

		constructor();
		constructor(nicDevice?: String);
	}

	declare class VcHostVirtualSwitchSpec
	{
		bridge: VcHostVirtualSwitchBridge;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mtu: Number;
		numPorts: Number;
		policy: VcHostNetworkPolicy;

		constructor();
		constructor(numPorts?: Number, bridge?: VcHostVirtualSwitchBridge, policy?: VcHostNetworkPolicy, mtu?: Number);
	}

	interface VcHostVmciAccessManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryAccessToService(arg0?: VcHostSystem, arg1?: String): VcVirtualMachine[];
		retrieveGrantedServices(arg0?: VcVirtualMachine): String[];
		updateAccess(arg0?: VcHostVmciAccessManagerAccessSpec[]): void;
	}

	declare const VcHostVmciAccessManager: VcHostVmciAccessManager;

	declare class VcHostVmciAccessManagerAccessSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mode: String;
		services: String[];
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, services?: String[], mode?: String);
	}

	interface VcHostVmciAccessManagerMode
	{
		readonly grant: VcHostVmciAccessManagerMode;
		readonly id: String;
		readonly name: String;
		readonly replace: VcHostVmciAccessManagerMode;
		readonly revoke: VcHostVmciAccessManagerMode;
		readonly value: String;

		fromString(value?: VcHostVmciAccessManagerMode): VcHostVmciAccessManagerMode;
	}

	declare const VcHostVmciAccessManagerMode: VcHostVmciAccessManagerMode;

	declare class VcHostVmfsRescanResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		host: VcHostSystem;

		constructor();
		constructor(host?: VcHostSystem, fault?: VcLocalizedMethodFault);
	}

	declare class VcHostVmfsSpec
	{
		blockSize: Number;
		blockSizeMb: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extent: VcHostScsiDiskPartition;
		majorVersion: Number;
		unmapGranularity: Number;
		unmapPriority: String;
		volumeName: String;

		constructor();
		constructor(extent?: VcHostScsiDiskPartition, blockSizeMb?: Number, majorVersion?: Number, volumeName?: String, blockSize?: Number, unmapGranularity?: Number, unmapPriority?: String);
	}

	declare class VcHostVmfsVolume
	{
		blockSize: Number;
		blockSizeMb: Number;
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extent: VcHostScsiDiskPartition[];
		forceMountedInfo: VcHostForceMountedInfo;
		local: boolean;
		majorVersion: Number;
		maxBlocks: Number;
		name: String;
		scsiDiskType: String;
		ssd: boolean;
		type: String;
		unmapGranularity: Number;
		unmapPriority: String;
		uuid: String;
		version: String;
		vmfsUpgradable: boolean;

		constructor();
		constructor(type?: String, name?: String, capacity?: Number, blockSizeMb?: Number, blockSize?: Number, unmapGranularity?: Number, unmapPriority?: String, maxBlocks?: Number, majorVersion?: Number, version?: String, uuid?: String, extent?: VcHostScsiDiskPartition[], vmfsUpgradable?: boolean, forceMountedInfo?: VcHostForceMountedInfo, ssd?: boolean, local?: boolean, scsiDiskType?: String);
		isLocal(): boolean;
		isSsd(): boolean;
	}

	interface VcHostVmfsVolumeUnmapPriority
	{
		readonly id: String;
		readonly low: VcHostVmfsVolumeUnmapPriority;
		readonly name: String;
		readonly none: VcHostVmfsVolumeUnmapPriority;
		readonly value: String;

		fromString(value?: VcHostVmfsVolumeUnmapPriority): VcHostVmfsVolumeUnmapPriority;
	}

	declare const VcHostVmfsVolumeUnmapPriority: VcHostVmfsVolumeUnmapPriority;

	declare class VcHostVMotionCompatibility
	{
		compatibility: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;

		constructor();
		constructor(host?: VcHostSystem, compatibility?: String[]);
	}

	declare class VcHostVMotionConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		vmotionNicKey: String;

		constructor();
		constructor(vmotionNicKey?: String, enabled?: boolean);
	}

	declare class VcHostVMotionInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipConfig: VcHostIpConfig;
		netConfig: VcHostVMotionNetConfig;

		constructor();
		constructor(netConfig?: VcHostVMotionNetConfig, ipConfig?: VcHostIpConfig);
	}

	interface VcHostVMotionManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		completeDestination(arg0?: Number): void;
		completeSource(arg0?: Number): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		initiateDestination(arg0?: Number, arg1?: String): VcHostVMotionManagerDestinationState;
		initiateSourceEx_Task(arg0?: Number, arg1?: Number): VcTask;
		prepareDestinationEx_Task(arg0?: VcHostVMotionManagerSpec, arg1?: VcResourcePool): VcTask;
		prepareSourceEx_Task(arg0?: VcHostVMotionManagerSpec, arg1?: VcVirtualMachine): VcTask;
		queryMigrationIds(): Number[];
		updateMemMirrorFlag(arg0?: boolean): void;
		upgradeDestination_Task(arg0?: VcVirtualMachine, arg1?: VcHostVMotionManagerReparentSpec[]): VcTask;
	}

	declare const VcHostVMotionManager: VcHostVMotionManager;

	declare class VcHostVMotionManagerDestinationState
	{
		dstId: Number;
		dstTask: VcTask;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(dstId?: Number, dstTask?: VcTask);
	}

	declare class VcHostVMotionManagerIpAddressSpec
	{
		dstIp: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		srcIp: String;

		constructor();
		constructor(srcIp?: String, dstIp?: String);
	}

	declare class VcHostVMotionManagerReparentSpec
	{
		busNumber: Number;
		controllerType: String;
		diskBackingInfo: VcVirtualDeviceBackingInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filename: String;
		numLinksToConsolidate: Number;
		parentFilename: String;
		parentShared: boolean;
		storagePolicy: String;
		transform: VcVirtualMachineRelocateTransformation;
		unitNumber: Number;

		constructor();
		constructor(busNumber?: Number, unitNumber?: Number, filename?: String, transform?: VcVirtualMachineRelocateTransformation, diskBackingInfo?: VcVirtualDeviceBackingInfo, controllerType?: String, parentFilename?: String, parentShared?: boolean, numLinksToConsolidate?: Number, storagePolicy?: String);
		isParentShared(): boolean;
	}

	declare class VcHostVMotionManagerSpec
	{
		deviceChange: VcVirtualDeviceConfigSpec[];
		diskLocations: VcHostVMotionManagerReparentSpec[];
		dstIp: String;
		dstLoggingIp: String;
		dstManagementIp: String;
		dstSSLThumbprint: String;
		dstUuid: String;
		dstVmDirPath: String;
		dstVmFileName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encryptionKey: String;
		encryptionNonce: Number;
		faultToleranceType: String;
		ftPrimaryIp: String;
		ftSecondaryIp: String;
		ftStreamAddresses: VcHostVMotionManagerIpAddressSpec[];
		layoutSpec: VcHostLowLevelProvisioningManagerSnapshotLayoutSpec[];
		migrationId: Number;
		priority: VcVirtualMachineMovePriority;
		srcIp: String;
		srcLoggingIp: String;
		srcManagementIp: String;
		srcSSLThumbprint: String;
		srcUuid: String;
		srcVmPathName: String;
		streamAddresses: VcHostVMotionManagerIpAddressSpec[];
		type: String;
		unsharedSwap: boolean;

		constructor();
		constructor(migrationId?: Number, srcIp?: String, dstIp?: String, streamAddresses?: VcHostVMotionManagerIpAddressSpec[], srcUuid?: String, dstUuid?: String, priority?: VcVirtualMachineMovePriority, unsharedSwap?: boolean, type?: String, faultToleranceType?: String, diskLocations?: VcHostVMotionManagerReparentSpec[], srcLoggingIp?: String, dstLoggingIp?: String, ftPrimaryIp?: String, ftSecondaryIp?: String, ftStreamAddresses?: VcHostVMotionManagerIpAddressSpec[], srcSSLThumbprint?: String, dstSSLThumbprint?: String, srcManagementIp?: String, dstManagementIp?: String, srcVmPathName?: String, dstVmDirPath?: String, dstVmFileName?: String, layoutSpec?: VcHostLowLevelProvisioningManagerSnapshotLayoutSpec[], deviceChange?: VcVirtualDeviceConfigSpec[], encryptionNonce?: Number, encryptionKey?: String);
		isUnsharedSwap(): boolean;
	}

	declare class VcHostVMotionManagerSrcVMotionResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vmDowntime: Number;
		vmPrecopyBandwidth: Number;
		vmPrecopyStunTime: Number;

		constructor();
		constructor(vmDowntime?: Number, vmPrecopyStunTime?: Number, vmPrecopyBandwidth?: Number);
	}

	declare class VcHostVMotionManagerVMotionDeviceSpec
	{
		backing: VcVirtualDeviceConfigSpecBackingSpec;
		busNumber: Number;
		controllerType: String;
		device: VcVirtualDevice;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileOperation: VcVirtualDeviceConfigSpecFileOperation;
		operation: VcVirtualDeviceConfigSpecOperation;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(operation?: VcVirtualDeviceConfigSpecOperation, fileOperation?: VcVirtualDeviceConfigSpecFileOperation, device?: VcVirtualDevice, profile?: VcVirtualMachineProfileSpec[], backing?: VcVirtualDeviceConfigSpecBackingSpec, busNumber?: Number, controllerType?: String);
	}

	declare class VcHostVMotionManagerVMotionDiskSpec
	{
		backing: VcVirtualDeviceConfigSpecBackingSpec;
		busNumber: Number;
		controllerType: String;
		device: VcVirtualDevice;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileOperation: VcVirtualDeviceConfigSpecFileOperation;
		numLinksToConsolidate: Number;
		operation: VcVirtualDeviceConfigSpecOperation;
		parentFilename: String;
		parentShared: boolean;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(operation?: VcVirtualDeviceConfigSpecOperation, fileOperation?: VcVirtualDeviceConfigSpecFileOperation, device?: VcVirtualDevice, profile?: VcVirtualMachineProfileSpec[], backing?: VcVirtualDeviceConfigSpecBackingSpec, busNumber?: Number, controllerType?: String, parentFilename?: String, parentShared?: boolean, numLinksToConsolidate?: Number);
		isParentShared(): boolean;
	}

	declare class VcHostVMotionManagerVMotionNVDIMMSpec
	{
		backing: VcVirtualDeviceConfigSpecBackingSpec;
		busNumber: Number;
		controllerType: String;
		device: VcVirtualDevice;
		deviceNumber: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filename: String;
		fileOperation: VcVirtualDeviceConfigSpecFileOperation;
		operation: VcVirtualDeviceConfigSpecOperation;
		parentFilename: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(operation?: VcVirtualDeviceConfigSpecOperation, fileOperation?: VcVirtualDeviceConfigSpecFileOperation, device?: VcVirtualDevice, profile?: VcVirtualMachineProfileSpec[], backing?: VcVirtualDeviceConfigSpecBackingSpec, busNumber?: Number, controllerType?: String, deviceNumber?: Number, filename?: String, parentFilename?: String);
	}

	declare class VcHostVMotionManagerVMotionResult
	{
		dstVmId: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vmDowntime: Number;
		vmNumRemotePageFaults: Number;
		vmPagesSrcTime: Number;
		vmStunTime: Number;

		constructor();
		constructor(dstVmId?: Number, vmDowntime?: Number, vmStunTime?: Number, vmPagesSrcTime?: Number, vmNumRemotePageFaults?: Number);
	}

	interface VcHostVMotionManagerVMotionType
	{
		readonly disks_only: VcHostVMotionManagerVMotionType;
		readonly fast_suspend_resume: VcHostVMotionManagerVMotionType;
		readonly fault_tolerance: VcHostVMotionManagerVMotionType;
		readonly id: String;
		readonly memory_mirror: VcHostVMotionManagerVMotionType;
		readonly name: String;
		readonly value: String;
		readonly vmotion: VcHostVMotionManagerVMotionType;

		fromString(value?: VcHostVMotionManagerVMotionType): VcHostVMotionManagerVMotionType;
	}

	declare const VcHostVMotionManagerVMotionType: VcHostVMotionManagerVMotionType;

	declare class VcHostVMotionNetConfig
	{
		candidateVnic: VcHostVirtualNic[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		selectedVnic: String;

		constructor();
		constructor(candidateVnic?: VcHostVirtualNic[], selectedVnic?: String);
	}

	interface VcHostVMotionSystem
	{
		readonly availableField: VcCustomFieldDef[];
		id: String;
		ipConfig: VcHostIpConfig;
		moref: VcManagedObjectReference;
		netConfig: VcHostVMotionNetConfig;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deselectVnic(): void;
		selectVnic(arg0?: String): void;
		setCustomValue(arg0?: String, arg1?: String): void;
		updateIpConfig(arg0?: VcHostIpConfig): void;
	}

	declare const VcHostVMotionSystem: VcHostVMotionSystem;

	declare class VcHostVnicConnectedToCustomizedDVPortEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		prevPortKey: String;
		userName: String;
		vm: VcVmEventArgument;
		vnic: VcVnicPortArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, vnic?: VcVnicPortArgument, prevPortKey?: String);
	}

	interface VcHostVsanInternalSystem
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		abdicateDomOwnership(arg0?: String[]): String[];
		canDecommission(arg0?: VcVsanDecommissioningBatch[]): VcVsanDecommissioningSatisfiability[];
		canProvisionObjects(arg0?: VcVsanNewPolicyBatch[], arg1?: boolean): VcVsanPolicySatisfiability[];
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteVsanObjects(arg0?: String[], arg1?: boolean): VcHostVsanInternalSystemDeleteVsanObjectsResult[];
		getVsanObjExtAttrs(arg0?: String[]): String;
		queryCmmds(arg0?: VcHostVsanInternalSystemCmmdsQuery[]): String;
		queryObjectsOnPhysicalVsanDisk(arg0?: String[]): String;
		queryPhysicalVsanDisks(arg0?: String[]): String;
		querySyncingVsanObjects(arg0?: String[]): String;
		queryVsanObjects(arg0?: String[]): String;
		queryVsanObjectUuidsByFilter(arg0?: String[], arg1?: Number, arg2?: Number): String[];
		queryVsanStatistics(arg0?: String[]): String;
		reconfigurationSatisfiable(arg0?: VcVsanPolicyChangeBatch[], arg1?: boolean): VcVsanPolicySatisfiability[];
		reconfigureDomObject(arg0?: String, arg1?: String): void;
		runVsanPhysicalDiskDiagnostics(arg0?: String[]): VcHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult[];
		upgradeVsanObjects(arg0?: String[], arg1?: Number): VcHostVsanInternalSystemVsanObjectOperationResult[];
	}

	declare const VcHostVsanInternalSystem: VcHostVsanInternalSystem;

	declare class VcHostVsanInternalSystemCmmdsQuery
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		owner: String;
		type: String;
		uuid: String;

		constructor();
		constructor(type?: String, uuid?: String, owner?: String);
	}

	declare class VcHostVsanInternalSystemDeleteVsanObjectsResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failureReason: VcLocalizableMessage[];
		success: boolean;
		uuid: String;

		constructor();
		constructor(uuid?: String, success?: boolean, failureReason?: VcLocalizableMessage[]);
	}

	declare class VcHostVsanInternalSystemVsanObjectOperationResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failureReason: VcLocalizableMessage[];
		uuid: String;

		constructor();
		constructor(uuid?: String, failureReason?: VcLocalizableMessage[]);
	}

	declare class VcHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult
	{
		diskUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failureReason: String;
		success: boolean;

		constructor();
		constructor(diskUuid?: String, success?: boolean, failureReason?: String);
	}

	interface VcHostVsanSystem
	{
		config: VcVsanHostConfigInfo;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addDisks_Task(arg0?: VcHostScsiDisk[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		evacuateVsanNode_Task(arg0?: VcHostMaintenanceSpec, arg1?: Number): VcTask;
		fetchVsanSharedSecret(): String;
		initializeDisks_Task(arg0?: VcVsanHostDiskMapping[]): VcTask;
		queryDisksForVsan(arg0?: String[]): VcVsanHostDiskResult[];
		queryHostStatus(): VcVsanHostClusterStatus;
		recommissionVsanNode_Task(): VcTask;
		removeDisk_Task(arg0?: VcHostScsiDisk[], arg1?: VcHostMaintenanceSpec, arg2?: Number): VcTask;
		removeDiskMapping_Task(arg0?: VcVsanHostDiskMapping[], arg1?: VcHostMaintenanceSpec, arg2?: Number): VcTask;
		unmountDiskMapping_Task(arg0?: VcVsanHostDiskMapping[]): VcTask;
		updateVsan_Task(arg0?: VcVsanHostConfigInfo): VcTask;
	}

	declare const VcHostVsanSystem: VcHostVsanSystem;

	interface VcHostVStorageObjectManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		hostCloneVStorageObject_Task(arg0?: VcID, arg1?: VcDatastore, arg2?: VcVslmCloneSpec): VcTask;
		hostCreateDisk_Task(arg0?: VcVslmCreateSpec): VcTask;
		hostDeleteVStorageObject_Task(arg0?: VcID, arg1?: VcDatastore): VcTask;
		hostExtendDisk_Task(arg0?: VcID, arg1?: VcDatastore, arg2?: Number): VcTask;
		hostInflateDisk_Task(arg0?: VcID, arg1?: VcDatastore): VcTask;
		hostListVStorageObject(arg0?: VcDatastore): VcID[];
		hostReconcileDatastoreInventory_Task(arg0?: VcDatastore): VcTask;
		hostRegisterDisk(arg0?: String, arg1?: String): VcVStorageObject;
		hostRelocateVStorageObject_Task(arg0?: VcID, arg1?: VcDatastore, arg2?: VcVslmRelocateSpec): VcTask;
		hostRenameVStorageObject(arg0?: VcID, arg1?: VcDatastore, arg2?: String): void;
		hostRetrieveVStorageObject(arg0?: VcID, arg1?: VcDatastore): VcVStorageObject;
		hostRetrieveVStorageObjectState(arg0?: VcID, arg1?: VcDatastore): VcVStorageObjectStateInfo;
		hostScheduleReconcileDatastoreInventory(arg0?: VcDatastore): void;
		hostUpdateVStorageObjectPolicy_Task(arg0?: VcID, arg1?: VcDatastore, arg2?: VcVirtualMachineProfileSpec[]): VcTask;
	}

	declare const VcHostVStorageObjectManager: VcHostVStorageObjectManager;

	declare class VcHostVvolVolume
	{
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostPE: VcVVolHostPE[];
		name: String;
		scId: String;
		storageArray: VcVASAStorageArray[];
		type: String;
		vasaProviderInfo: VcVimVasaProviderInfo[];

		constructor();
		constructor(type?: String, name?: String, capacity?: Number, scId?: String, hostPE?: VcVVolHostPE[], vasaProviderInfo?: VcVimVasaProviderInfo[], storageArray?: VcVASAStorageArray[]);
	}

	declare class VcHostVvolVolumeSpecification
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		maxSizeInMB: Number;
		storageArray: VcVASAStorageArray[];
		uuid: String;
		vasaProviderInfo: VcVimVasaProviderInfo[];
		volumeName: String;

		constructor();
		constructor(maxSizeInMB?: Number, volumeName?: String, vasaProviderInfo?: VcVimVasaProviderInfo[], storageArray?: VcVASAStorageArray[], uuid?: String);
	}

	declare class VcHostWakeOnLanConfig
	{
		broadcastAddress: String;
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		macAddress: String[];

		constructor();
		constructor(broadcastAddress?: String, macAddress?: String[], deviceName?: String);
	}

	declare class VcHostWwnChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newNodeWwns: Number[];
		newPortWwns: Number[];
		oldNodeWwns: Number[];
		oldPortWwns: Number[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, oldNodeWwns?: Number[], oldPortWwns?: Number[], newNodeWwns?: Number[], newPortWwns?: Number[]);
	}

	declare class VcHostWwnConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedHosts: VcHostEventArgument[];
		conflictedVms: VcVmEventArgument[];
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;
		wwn: Number;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, conflictedVms?: VcVmEventArgument[], conflictedHosts?: VcHostEventArgument[], wwn?: Number);
	}

	declare class VcHotSnapshotMoveNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcHourlyTaskScheduler
	{
		activeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expireTime: Date;
		interval: Number;
		minute: Number;

		constructor();
		constructor(activeTime?: Date, expireTime?: Date, interval?: Number, minute?: Number);
	}

	declare class VcHttpFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		statusCode: Number;
		statusMessage: String;

		constructor();
		constructor(statusCode?: Number, statusMessage?: String);
		printStackTrace(): void;
	}

	interface VcHttpNfcLease
	{
		capabilities: VcHttpNfcLeaseCapabilities;
		error: VcLocalizedMethodFault;
		id: String;
		info: VcHttpNfcLeaseInfo;
		initializeProgress: Number;
		mode: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		state: VcHttpNfcLeaseState;
		transferProgress: Number;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		httpNfcLeaseAbort(arg0?: VcLocalizedMethodFault): void;
		httpNfcLeaseComplete(): void;
		httpNfcLeaseGetManifest(): VcHttpNfcLeaseManifestEntry[];
		httpNfcLeaseProgress(arg0?: Number): void;
		httpNfcLeasePullFromUrls_Task(arg0?: VcHttpNfcLeaseSourceFile[]): VcTask;
		httpNfcLeaseSetManifestChecksumType(arg0?: VcKeyValue[]): void;
	}

	declare const VcHttpNfcLease: VcHttpNfcLease;

	declare class VcHttpNfcLeaseCapabilities
	{
		corsSupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pullModeSupported: boolean;

		constructor();
		constructor(pullModeSupported?: boolean, corsSupported?: boolean);
	}

	declare class VcHttpNfcLeaseDatastoreLeaseInfo
	{
		datastoreKey: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hosts: VcHttpNfcLeaseHostInfo[];

		constructor();
		constructor(datastoreKey?: String, hosts?: VcHttpNfcLeaseHostInfo[]);
	}

	declare class VcHttpNfcLeaseDeviceUrl
	{
		datastoreKey: String;
		disk: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSize: Number;
		importKey: String;
		key: String;
		sslThumbprint: String;
		targetId: String;
		url: String;

		constructor();
		constructor(key?: String, importKey?: String, url?: String, sslThumbprint?: String, disk?: boolean, targetId?: String, datastoreKey?: String, fileSize?: Number);
		isDisk(): boolean;
	}

	declare class VcHttpNfcLeaseHostInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		sslThumbprint: String;
		url: String;

		constructor();
		constructor(url?: String, sslThumbprint?: String);
	}

	declare class VcHttpNfcLeaseInfo
	{
		deviceUrl: VcHttpNfcLeaseDeviceUrl[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		hostMap: VcHttpNfcLeaseDatastoreLeaseInfo[];
		lease: VcHttpNfcLease;
		leaseTimeout: Number;
		totalDiskCapacityInKB: Number;

		constructor();
		constructor(lease?: VcHttpNfcLease, entity?: VcManagedEntity, deviceUrl?: VcHttpNfcLeaseDeviceUrl[], totalDiskCapacityInKB?: Number, leaseTimeout?: Number, hostMap?: VcHttpNfcLeaseDatastoreLeaseInfo[]);
	}

	declare class VcHttpNfcLeaseManifestEntry
	{
		capacity: Number;
		checksum: String;
		checksumType: String;
		disk: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		populatedSize: Number;
		sha1: String;
		size: Number;

		constructor();
		constructor(key?: String, sha1?: String, checksum?: String, checksumType?: String, size?: Number, disk?: boolean, capacity?: Number, populatedSize?: Number);
	}

	interface VcHttpNfcLeaseManifestEntryChecksumType
	{
		readonly id: String;
		readonly name: String;
		readonly sha1: VcHttpNfcLeaseManifestEntryChecksumType;
		readonly sha256: VcHttpNfcLeaseManifestEntryChecksumType;
		readonly value: String;

		fromString(value?: VcHttpNfcLeaseManifestEntryChecksumType): VcHttpNfcLeaseManifestEntryChecksumType;
	}

	declare const VcHttpNfcLeaseManifestEntryChecksumType: VcHttpNfcLeaseManifestEntryChecksumType;

	interface VcHttpNfcLeaseMode
	{
		readonly id: String;
		readonly name: String;
		readonly pull: VcHttpNfcLeaseMode;
		readonly pushOrGet: VcHttpNfcLeaseMode;
		readonly value: String;

		fromString(value?: VcHttpNfcLeaseMode): VcHttpNfcLeaseMode;
	}

	declare const VcHttpNfcLeaseMode: VcHttpNfcLeaseMode;

	declare class VcHttpNfcLeaseSourceFile
	{
		create: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		httpHeaders: VcKeyValue[];
		memberName: String;
		sslThumbprint: String;
		targetDeviceId: String;
		url: String;

		constructor();
		constructor(targetDeviceId?: String, url?: String, memberName?: String, create?: boolean, sslThumbprint?: String, httpHeaders?: VcKeyValue[]);
	}

	interface VcHttpNfcLeaseState
	{
		readonly done: VcHttpNfcLeaseState;
		readonly error: VcHttpNfcLeaseState;
		readonly id: String;
		readonly initializing: VcHttpNfcLeaseState;
		readonly name: String;
		readonly ready: VcHttpNfcLeaseState;
		readonly value: String;

		fromString(value?: VcHttpNfcLeaseState): VcHttpNfcLeaseState;
	}

	declare const VcHttpNfcLeaseState: VcHttpNfcLeaseState;

	declare class VcID
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;

		constructor();
		constructor(id?: String);
	}

	declare class VcIDEDiskNotSupported
	{
		disk: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(disk?: Number);
		printStackTrace(): void;
	}

	interface VcImageLibraryManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addLibrary(arg0?: String, arg1?: String, arg2?: String): String;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		exportMediaToLibrary_Task(arg0?: VcDatacenter, arg1?: String, arg2?: String, arg3?: VcImageLibraryManagerMediaInfo, arg4?: VcKeyValue[]): VcTask;
		importLibraryMedia_Task(arg0?: String, arg1?: String, arg2?: VcKeyValue[], arg3?: VcDatacenter, arg4?: String, arg5?: boolean): VcTask;
		publishMediaToLibrary_Task(arg0?: VcDatacenter, arg1?: String, arg2?: String, arg3?: VcImageLibraryManagerMediaInfo, arg4?: VcKeyValue[]): VcTask;
		removeLibrary(arg0?: String): void;
		updateLibrary(arg0?: String, arg1?: String, arg2?: String): void;
	}

	declare const VcImageLibraryManager: VcImageLibraryManager;

	declare class VcImageLibraryManagerMediaInfo
	{
		custom: VcKeyValue[];
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyword: String[];
		label: String[];
		name: String;
		type: String;
		version: String;

		constructor();
		constructor(name?: String, type?: String, description?: String, keyword?: String[], version?: String, label?: String[], custom?: VcKeyValue[]);
	}

	interface VcImageLibraryManagerMediaType
	{
		readonly Cust: VcImageLibraryManagerMediaType;
		readonly Flp: VcImageLibraryManagerMediaType;
		readonly Generic: VcImageLibraryManagerMediaType;
		readonly id: String;
		readonly Iso: VcImageLibraryManagerMediaType;
		readonly name: String;
		readonly Ovf: VcImageLibraryManagerMediaType;
		readonly value: String;
		readonly Vmdk: VcImageLibraryManagerMediaType;

		fromString(value?: VcImageLibraryManagerMediaType): VcImageLibraryManagerMediaType;
	}

	declare const VcImageLibraryManagerMediaType: VcImageLibraryManagerMediaType;

	declare class VcImportHostAddFailure
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostIp: String[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostIp?: String[]);
		printStackTrace(): void;
	}

	declare class VcImportHostProfileCustomizationsResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityResults: VcImportHostProfileCustomizationsResultEntityCustomizationsResult[];
		importIssues: VcProfileHostHostCustomizationOperationIssues;
		status: String;

		constructor();
		constructor(status?: String, entityResults?: VcImportHostProfileCustomizationsResultEntityCustomizationsResult[], importIssues?: VcProfileHostHostCustomizationOperationIssues);
	}

	declare class VcImportHostProfileCustomizationsResultEntityCustomizationsResult
	{
		customizations: VcAnswerFile;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		validationResult: VcAnswerFileValidationResult;

		constructor();
		constructor(entity?: VcManagedEntity, validationResult?: VcAnswerFileValidationResult, customizations?: VcAnswerFile);
	}

	declare class VcImportOperationBulkFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		importFaults: VcImportOperationBulkFaultFaultOnImport[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(importFaults?: VcImportOperationBulkFaultFaultOnImport[]);
		printStackTrace(): void;
	}

	declare class VcImportOperationBulkFaultFaultOnImport
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityType: String;
		fault: VcLocalizedMethodFault;
		key: String;

		constructor();
		constructor(entityType?: String, key?: String, fault?: VcLocalizedMethodFault);
	}

	declare class VcImportSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityConfig: VcVAppEntityConfigInfo;
		instantiationOst: VcOvfConsumerOstNode;

		constructor();
		constructor(entityConfig?: VcVAppEntityConfigInfo, instantiationOst?: VcOvfConsumerOstNode);
	}

	declare class VcInaccessibleDatastore
	{
		datastore: VcDatastore;
		detail: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(datastore?: VcDatastore, name?: String, detail?: String);
		printStackTrace(): void;
	}

	declare class VcInaccessibleFTMetadataDatastore
	{
		datastore: VcDatastore;
		detail: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(datastore?: VcDatastore, name?: String, detail?: String);
		printStackTrace(): void;
	}

	declare class VcInaccessibleVFlashSource
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostName?: String);
		printStackTrace(): void;
	}

	declare class VcIncompatibleDefaultDevice
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcIncompatibleHostForFtSecondary
	{
		error: VcLocalizedMethodFault[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem, error?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcIncompatibleHostForVmReplication
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		reason: String;
		vmName: String;

		constructor();
		constructor(vmName?: String, hostName?: String, reason?: String);
		printStackTrace(): void;
	}

	interface VcIncompatibleHostForVmReplicationIncompatibleReason
	{
		readonly id: String;
		readonly name: String;
		readonly netCompression: VcIncompatibleHostForVmReplicationIncompatibleReason;
		readonly rpo: VcIncompatibleHostForVmReplicationIncompatibleReason;
		readonly value: String;

		fromString(value?: VcIncompatibleHostForVmReplicationIncompatibleReason): VcIncompatibleHostForVmReplicationIncompatibleReason;
	}

	declare const VcIncompatibleHostForVmReplicationIncompatibleReason: VcIncompatibleHostForVmReplicationIncompatibleReason;

	declare class VcIncompatibleSetting
	{
		conflictingProperty: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		invalidProperty: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(invalidProperty?: String, conflictingProperty?: String);
		printStackTrace(): void;
	}

	declare class VcIncorrectFileType
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcIncorrectHostInformation
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcIncorrectHostInformationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcIndependentDiskVMotionNotSupported
	{
		atSourceHost: boolean;
		failedHost: VcHostSystem;
		failedHostName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHostName?: String, failedHost?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcInfoUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	declare class VcInheritablePolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;

		constructor();
		constructor(inherited?: boolean);
	}

	declare class VcInstantCloneCustomizationSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcInsufficientAgentVmsDeployed
	{
		currentNumAgentVms: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		requiredNumAgentVms: Number;

		constructor();
		constructor(hostName?: String, requiredNumAgentVms?: Number, currentNumAgentVms?: Number);
		printStackTrace(): void;
	}

	declare class VcInsufficientCpuResourcesFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		requested: Number;
		unreserved: Number;

		constructor();
		constructor(unreserved?: Number, requested?: Number);
		printStackTrace(): void;
	}

	declare class VcInsufficientDisks
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcInsufficientFailoverResourcesEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcInsufficientFailoverResourcesFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInsufficientGraphicsResourcesFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInsufficientHostCapacityFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcInsufficientHostCpuCapacityFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;
		requested: Number;
		unreserved: Number;

		constructor();
		constructor(host?: VcHostSystem, unreserved?: Number, requested?: Number);
		printStackTrace(): void;
	}

	declare class VcInsufficientHostMemoryCapacityFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;
		requested: Number;
		unreserved: Number;

		constructor();
		constructor(host?: VcHostSystem, unreserved?: Number, requested?: Number);
		printStackTrace(): void;
	}

	declare class VcInsufficientMemoryResourcesFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		requested: Number;
		unreserved: Number;

		constructor();
		constructor(unreserved?: Number, requested?: Number);
		printStackTrace(): void;
	}

	declare class VcInsufficientNetworkCapacity
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInsufficientNetworkResourcePoolCapacity
	{
		available: Number;
		device: String[];
		dvsName: String;
		dvsUuid: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		requested: Number;
		resourcePoolKey: String;

		constructor();
		constructor(dvsName?: String, dvsUuid?: String, resourcePoolKey?: String, available?: Number, requested?: Number, device?: String[]);
		printStackTrace(): void;
	}

	declare class VcInsufficientPerCpuCapacity
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcInsufficientResourcesFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInsufficientStandbyCpuResource
	{
		available: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		requested: Number;

		constructor();
		constructor(available?: Number, requested?: Number);
		printStackTrace(): void;
	}

	declare class VcInsufficientStandbyMemoryResource
	{
		available: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		requested: Number;

		constructor();
		constructor(available?: Number, requested?: Number);
		printStackTrace(): void;
	}

	declare class VcInsufficientStandbyResource
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInsufficientStorageIops
	{
		datastoreName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		requestedIops: Number;
		unreservedIops: Number;

		constructor();
		constructor(unreservedIops?: Number, requestedIops?: Number, datastoreName?: String);
		printStackTrace(): void;
	}

	declare class VcInsufficientStorageSpace
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInsufficientVFlashResourcesFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		freeSpace: Number;
		freeSpaceInMB: Number;
		readonly localizedMessage: String;
		message: String;
		requestedSpace: Number;
		requestedSpaceInMB: Number;

		constructor();
		constructor(freeSpaceInMB?: Number, freeSpace?: Number, requestedSpaceInMB?: Number, requestedSpace?: Number);
		printStackTrace(): void;
	}

	interface VcInternalDynamicTypeManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		dynamicTypeMgrQueryMoInstances(arg0?: VcDynamicTypeMgrFilterSpec): VcDynamicTypeMgrMoInstance[];
		dynamicTypeMgrQueryTypeInfo(arg0?: VcDynamicTypeMgrFilterSpec): VcDynamicTypeMgrAllTypeInfo;
	}

	declare const VcInternalDynamicTypeManager: VcInternalDynamicTypeManager;

	interface VcInternalMockupSystem
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		activateMultipathPath(arg0?: String): void;
		addHostBusAdapter(arg0?: VcHostHostBusAdapter): void;
		addPCIDevice(arg0?: VcHostPciDevice): void;
		addPhysicalNic(arg0?: VcPhysicalNic): void;
		addScsiDisk(arg0?: VcHostScsiDisk): void;
		addScsiLun(arg0?: VcScsiLun): void;
		addTopology(arg0?: String, arg1?: Number, arg2?: Number, arg3?: String): void;
		clearNetworkSystem(): void;
		clearStorageSystem(): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		removeHostBusAdapter(arg0?: String): void;
		removePCIDevice(arg0?: String): void;
		removePhysicalNic(arg0?: String): void;
		removeScsiDisk(arg0?: String): void;
		removeScsiLun(arg0?: String): void;
		removeTopology(arg0?: String, arg1?: Number, arg2?: Number, arg3?: String): void;
		setPhysicalNicActualLinkSpeed(arg0?: String, arg1?: VcPhysicalNicLinkInfo): void;
		updateDiskPartitionsMs(arg0?: String, arg1?: VcHostDiskPartitionSpec): void;
	}

	declare const VcInternalMockupSystem: VcInternalMockupSystem;

	interface VcInternalPropertyProviderManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		recordPropertyUpdates(arg0?: VcManagedObject, arg1?: VcPropertyUpdate[]): void;
	}

	declare const VcInternalPropertyProviderManager: VcInternalPropertyProviderManager;

	interface VcInternalPropertyStore
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		clearPropertyStore(): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		retrievePropertyStoreContents(): VcInternalPropertyStoreObjectEntry[];
	}

	declare const VcInternalPropertyStore: VcInternalPropertyStore;

	declare class VcInternalPropertyStoreObjectEntry
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		moType: String;
		properties: VcInternalPropertyStorePropertyEntry[];

		constructor();
		constructor(id?: String, moType?: String, properties?: VcInternalPropertyStorePropertyEntry[]);
	}

	declare class VcInternalPropertyStorePropertyEntry
	{
		accessCount: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entryTime: Date;
		lastAccessTime: Date;
		path: String;
		size: Number;
		val_AnyValue: Object;
		val_FloatValue: Number;
		val_IntValue: Number;
		val_LongValue: Number;

		constructor();
		constructor(path?: String, accessCount?: Number, lastAccessTime?: Date, entryTime?: Date, size?: Number, val?: Object);
	}

	declare class VcInternalServiceInstanceContent
	{
		agentManager: VcAgentManager;
		cbrcManager: VcCbrcManager;
		changeLogCollector: VcCDCChangeLogCollector;
		deploymentInfo: VcDeploymentInfo;
		diskManager: VcHostDiskManager;
		drsStatsManager: VcDrsStatsManager;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		esxAgentConfigManager: VcEsxAgentConfigManager;
		externalStatsManager: VcExternalStatsManager;
		ftManager: VcHostFaultToleranceManager;
		hbrManager: VcHbrManager;
		hostDistributedVirtualSwitchManager: VcHostDistributedVirtualSwitchManager;
		hostProfileEngine: VcProfileHostProfileEngineHostProfileEngine;
		hostSpecAgent: VcHostSpecificationAgent;
		ilManager: VcImageLibraryManager;
		internalStatsCollector: VcInternalStatsCollector;
		legacyTemplateManager: VcLegacyTemplateManager;
		llProvisioningManager: VcHostLowLevelProvisioningManager;
		networkManager: VcNetworkManager;
		nfcService: VcNfcService;
		overheadService: VcOverheadService;
		pauseManager: VcVirtualMachinePauseManager;
		proxyService: VcProxyService;
		resourcePlanningManager: VcResourcePlanningManager;
		serviceDirectory: VcServiceDirectory;
		serviceManager: VcServiceManager;
		toBeDeleted: Number;
		tpmManager: VcHostTpmManager;
		vasaManager: VcVasaVvolManager;
		vmciAccessManager: VcHostVmciAccessManager;
		vmMetadataManager: VcVirtualMachineMetadataManager;
		vmNamespaceManager: VcVirtualMachineNamespaceManager;
		vrpResourceManager: VcVRPResourceManager;

		constructor();
		constructor(agentManager?: VcAgentManager, llProvisioningManager?: VcHostLowLevelProvisioningManager, diskManager?: VcHostDiskManager, nfcService?: VcNfcService, proxyService?: VcProxyService, legacyTemplateManager?: VcLegacyTemplateManager, serviceManager?: VcServiceManager, serviceDirectory?: VcServiceDirectory, ftManager?: VcHostFaultToleranceManager, hostDistributedVirtualSwitchManager?: VcHostDistributedVirtualSwitchManager, networkManager?: VcNetworkManager, ilManager?: VcImageLibraryManager, tpmManager?: VcHostTpmManager, internalStatsCollector?: VcInternalStatsCollector, resourcePlanningManager?: VcResourcePlanningManager, hbrManager?: VcHbrManager, esxAgentConfigManager?: VcEsxAgentConfigManager, drsStatsManager?: VcDrsStatsManager, cbrcManager?: VcCbrcManager, hostProfileEngine?: VcProfileHostProfileEngineHostProfileEngine, vmciAccessManager?: VcHostVmciAccessManager, vmNamespaceManager?: VcVirtualMachineNamespaceManager, vasaManager?: VcVasaVvolManager, overheadService?: VcOverheadService, vmMetadataManager?: VcVirtualMachineMetadataManager, vrpResourceManager?: VcVRPResourceManager, pauseManager?: VcVirtualMachinePauseManager, toBeDeleted?: Number, hostSpecAgent?: VcHostSpecificationAgent, externalStatsManager?: VcExternalStatsManager, changeLogCollector?: VcCDCChangeLogCollector, deploymentInfo?: VcDeploymentInfo);
	}

	interface VcInternalStatsCollector
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		internalQueryLatestVmStats(arg0?: VcVirtualMachine, arg1?: String[]): VcInternalStatsValue[];
	}

	declare const VcInternalStatsCollector: VcInternalStatsCollector;

	interface VcInternalStatsSet
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmFaultToleranceStats: VcInternalStatsSet;
		readonly vmMemoryOverheadStats: VcInternalStatsSet;

		fromString(value?: VcInternalStatsSet): VcInternalStatsSet;
	}

	declare const VcInternalStatsSet: VcInternalStatsSet;

	declare class VcInternalStatsValue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		value: Number;

		constructor();
		constructor(key?: String, value?: Number);
	}

	interface VcInternetScsiSnsDiscoveryMethod
	{
		readonly id: String;
		readonly isnsDhcp: VcInternetScsiSnsDiscoveryMethod;
		readonly isnsSlp: VcInternetScsiSnsDiscoveryMethod;
		readonly isnsStatic: VcInternetScsiSnsDiscoveryMethod;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcInternetScsiSnsDiscoveryMethod): VcInternetScsiSnsDiscoveryMethod;
	}

	declare const VcInternetScsiSnsDiscoveryMethod: VcInternetScsiSnsDiscoveryMethod;

	declare class VcIntExpression
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;
		value: Number;

		constructor();
		constructor(negate?: boolean, value?: Number);
		isNegate(): boolean;
	}

	declare class VcIntOption
	{
		defaultValue: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		max: Number;
		min: Number;
		valueIsReadonly: boolean;

		constructor();
		constructor(valueIsReadonly?: boolean, min?: Number, max?: Number, defaultValue?: Number);
		isValueIsReadonly(): boolean;
	}

	declare class VcIntPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		value: Number;

		constructor();
		constructor(inherited?: boolean, value?: Number);
	}

	declare class VcInUseFeatureManipulationDisallowed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidAffinitySettingFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidArgument
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		invalidProperty: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(invalidProperty?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidBmcRole
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidBundle
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		text: String;

		constructor();
		constructor(text?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidCAMCertificate
	{
		camServer: String;
		errorCode: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(errorCode?: Number, camServer?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidCAMServer
	{
		camServer: String;
		errorCode: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(errorCode?: Number, camServer?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidClientCertificate
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidCollectorVersion
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidController
	{
		controllerKey: Number;
		deviceIndex: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String, deviceIndex?: Number, controllerKey?: Number);
		printStackTrace(): void;
	}

	declare class VcInvalidDasConfigArgument
	{
		clusterName: String;
		entry: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		invalidProperty: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(invalidProperty?: String, entry?: String, clusterName?: String);
		printStackTrace(): void;
	}

	interface VcInvalidDasConfigArgumentEntryForInvalidArgument
	{
		readonly admissionControl: VcInvalidDasConfigArgumentEntryForInvalidArgument;
		readonly id: String;
		readonly name: String;
		readonly userHeartbeatDs: VcInvalidDasConfigArgumentEntryForInvalidArgument;
		readonly value: String;
		readonly vmConfig: VcInvalidDasConfigArgumentEntryForInvalidArgument;

		fromString(value?: VcInvalidDasConfigArgumentEntryForInvalidArgument): VcInvalidDasConfigArgumentEntryForInvalidArgument;
	}

	declare const VcInvalidDasConfigArgumentEntryForInvalidArgument: VcInvalidDasConfigArgumentEntryForInvalidArgument;

	declare class VcInvalidDasRestartPriorityForFtVm
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		invalidProperty: String;
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(invalidProperty?: String, vm?: VcVirtualMachine, vmName?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidDatastore
	{
		datastore: VcDatastore;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(datastore?: VcDatastore, name?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidDatastorePath
	{
		datastore: VcDatastore;
		datastorePath: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(datastore?: VcDatastore, name?: String, datastorePath?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidDatastoreState
	{
		datastoreName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(datastoreName?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidDeviceBacking
	{
		deviceIndex: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String, deviceIndex?: Number);
		printStackTrace(): void;
	}

	declare class VcInvalidDeviceOperation
	{
		badFileOp: VcVirtualDeviceConfigSpecFileOperation;
		badOp: VcVirtualDeviceConfigSpecOperation;
		deviceIndex: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String, deviceIndex?: Number, badOp?: VcVirtualDeviceConfigSpecOperation, badFileOp?: VcVirtualDeviceConfigSpecFileOperation);
		printStackTrace(): void;
	}

	declare class VcInvalidDeviceSpec
	{
		deviceIndex: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String, deviceIndex?: Number);
		printStackTrace(): void;
	}

	declare class VcInvalidDiskFormat
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidDrsBehaviorForFtVm
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		invalidProperty: String;
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(invalidProperty?: String, vm?: VcVirtualMachine, vmName?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidEditionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		feature: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, feature?: String);
	}

	declare class VcInvalidEditionLicense
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		feature: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(feature?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidEvent
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidFolder
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		target: VcManagedEntity;

		constructor();
		constructor(target?: VcManagedEntity);
		printStackTrace(): void;
	}

	declare class VcInvalidFormat
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidGuestLogin
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidHostConnectionState
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcInvalidHostName
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidHostState
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcInvalidIndexArgument
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		invalidProperty: String;
		key: String;
		readonly localizedMessage: String;
		message: String;

		constructor(invalidProperty?: String, key?: String);
		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidIpfixConfig
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidIpmiLoginInfo
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidIpmiMacAddress
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		observedMacAddress: String;
		userProvidedMacAddress: String;

		constructor();
		constructor(userProvidedMacAddress?: String, observedMacAddress?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidKey
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		key: String;
		readonly localizedMessage: String;
		message: String;

		constructor(key?: String);
		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidLibraryResponse
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor(reason?: String);
		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidLicense
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		licenseContent: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(licenseContent?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidLocale
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidLogin
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidName
	{
		entity: VcManagedEntity;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String, entity?: VcManagedEntity);
		printStackTrace(): void;
	}

	declare class VcInvalidNasCredentials
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		userName: String;

		constructor();
		constructor(name?: String, userName?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidNetworkInType
	{
		category: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		id: String;
		label: String;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(id?: String, category?: String, label?: String, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidNetworkResource
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		remoteHost: String;
		remotePath: String;

		constructor();
		constructor(name?: String, remoteHost?: String, remotePath?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidOperationOnSecondaryVm
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		instanceUuid: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(instanceUuid?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidPowerState
	{
		existingState: VcVirtualMachinePowerState;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		requestedState: VcVirtualMachinePowerState;

		constructor();
		constructor(requestedState?: VcVirtualMachinePowerState, existingState?: VcVirtualMachinePowerState);
		printStackTrace(): void;
	}

	declare class VcInvalidPrivilege
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		privilege: String;

		constructor();
		constructor(privilege?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidProfileReferenceHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;
		profile: VcProfile;
		profileName: String;
		reason: String;

		constructor();
		constructor(reason?: String, host?: VcHostSystem, profile?: VcProfile, profileName?: String);
		printStackTrace(): void;
	}

	interface VcInvalidProfileReferenceHostReason
	{
		readonly id: String;
		readonly incompatibleVersion: VcInvalidProfileReferenceHostReason;
		readonly missingReferenceHost: VcInvalidProfileReferenceHostReason;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcInvalidProfileReferenceHostReason): VcInvalidProfileReferenceHostReason;
	}

	declare const VcInvalidProfileReferenceHostReason: VcInvalidProfileReferenceHostReason;

	declare class VcInvalidProperty
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidPropertyType
	{
		category: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		id: String;
		label: String;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(id?: String, category?: String, label?: String, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidPropertyValue
	{
		category: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		id: String;
		label: String;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(id?: String, category?: String, label?: String, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidRequest
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidResourcePoolStructureFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidSnapshotFormat
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidState
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidTicket
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcInvalidType
	{
		argument: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(argument?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidVmConfig
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String);
		printStackTrace(): void;
	}

	declare class VcInvalidVmState
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine);
		printStackTrace(): void;
	}

	declare class VcInventoryDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		numClusters: Number;
		numCpuDev: Number;
		numDiskDev: Number;
		numHosts: Number;
		numNetDev: Number;
		numResourcePools: Number;
		numvCpuDev: Number;
		numvDiskDev: Number;
		numVirtualMachines: Number;
		numvNetDev: Number;

		constructor();
		constructor(numHosts?: Number, numVirtualMachines?: Number, numResourcePools?: Number, numClusters?: Number, numCpuDev?: Number, numNetDev?: Number, numDiskDev?: Number, numvCpuDev?: Number, numvNetDev?: Number, numvDiskDev?: Number);
	}

	declare class VcInventoryHasStandardAloneHosts
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hosts: String[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hosts?: String[]);
		printStackTrace(): void;
	}

	interface VcInventoryView
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly view: VcManagedObject[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		closeInventoryViewFolder(arg0?: VcManagedEntity[]): VcManagedEntity[];
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyView(): void;
		openInventoryViewFolder(arg0?: VcManagedEntity[]): VcManagedEntity[];
	}

	declare const VcInventoryView: VcInventoryView;

	declare class VcIoFilterHostIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		issue: VcLocalizedMethodFault[];

		constructor();
		constructor(host?: VcHostSystem, issue?: VcLocalizedMethodFault[]);
	}

	declare class VcIoFilterInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		name: String;
		releaseDate: String;
		summary: String;
		type: String;
		vendor: String;
		version: String;

		constructor();
		constructor(id?: String, name?: String, vendor?: String, version?: String, type?: String, summary?: String, releaseDate?: String);
	}

	interface VcIoFilterManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		installIoFilter_Task(arg0?: String, arg1?: VcComputeResource): VcTask;
		queryDisksUsingFilter(arg0?: String, arg1?: VcComputeResource): VcVirtualDiskId[];
		queryIoFilterInfo(arg0?: VcComputeResource): VcClusterIoFilterInfo[];
		queryIoFilterIssues(arg0?: String, arg1?: VcComputeResource): VcIoFilterQueryIssueResult;
		resolveInstallationErrorsOnCluster_Task(arg0?: String, arg1?: VcClusterComputeResource): VcTask;
		resolveInstallationErrorsOnHost_Task(arg0?: String, arg1?: VcHostSystem): VcTask;
		uninstallIoFilter_Task(arg0?: String, arg1?: VcComputeResource): VcTask;
		updateIoFilterPolicy(arg0?: String, arg1?: VcSpbmIoFilterInfo[]): void;
		upgradeIoFilter_Task(arg0?: String, arg1?: VcComputeResource, arg2?: String): VcTask;
	}

	declare const VcIoFilterManager: VcIoFilterManager;

	interface VcIoFilterOperation
	{
		readonly id: String;
		readonly install: VcIoFilterOperation;
		readonly name: String;
		readonly uninstall: VcIoFilterOperation;
		readonly upgrade: VcIoFilterOperation;
		readonly value: String;

		fromString(value?: VcIoFilterOperation): VcIoFilterOperation;
	}

	declare const VcIoFilterOperation: VcIoFilterOperation;

	declare class VcIoFilterQueryIssueResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostIssue: VcIoFilterHostIssue[];
		opType: String;

		constructor();
		constructor(opType?: String, hostIssue?: VcIoFilterHostIssue[]);
	}

	interface VcIoFilterType
	{
		readonly cache: VcIoFilterType;
		readonly compression: VcIoFilterType;
		readonly dataProvider: VcIoFilterType;
		readonly datastoreIoControl: VcIoFilterType;
		readonly encryption: VcIoFilterType;
		readonly id: String;
		readonly inspection: VcIoFilterType;
		readonly name: String;
		readonly replication: VcIoFilterType;
		readonly value: String;

		fromString(value?: VcIoFilterType): VcIoFilterType;
	}

	declare const VcIoFilterType: VcIoFilterType;

	declare class VcIORMNotSupportedHostOnDatastore
	{
		datastore: VcDatastore;
		datastoreName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(datastore?: VcDatastore, datastoreName?: String, host?: VcHostSystem[]);
		printStackTrace(): void;
	}

	declare class VcIpAddress
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;

		constructor();
		constructor(negate?: boolean);
		isNegate(): boolean;
	}

	declare class VcIpAddressProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcIpContainer
	{
		containerId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;

		constructor();
		constructor(negate?: boolean, containerId?: String);
		isNegate(): boolean;
	}

	declare class VcIpHostnameGeneratorError
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcIpPool
	{
		allocatedIpv4Addresses: Number;
		allocatedIpv6Addresses: Number;
		availableIpv4Addresses: Number;
		availableIpv6Addresses: Number;
		dnsDomain: String;
		dnsSearchPath: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostPrefix: String;
		httpProxy: String;
		id: Number;
		ipv4Config: VcIpPoolIpPoolConfigInfo;
		ipv6Config: VcIpPoolIpPoolConfigInfo;
		name: String;
		networkAssociation: VcIpPoolAssociation[];

		constructor();
		constructor(id?: Number, name?: String, ipv4Config?: VcIpPoolIpPoolConfigInfo, ipv6Config?: VcIpPoolIpPoolConfigInfo, dnsDomain?: String, dnsSearchPath?: String, hostPrefix?: String, httpProxy?: String, networkAssociation?: VcIpPoolAssociation[], availableIpv4Addresses?: Number, availableIpv6Addresses?: Number, allocatedIpv4Addresses?: Number, allocatedIpv6Addresses?: Number);
	}

	declare class VcIpPoolAssociation
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		network: VcNetwork;
		networkName: String;

		constructor();
		constructor(network?: VcNetwork, networkName?: String);
	}

	declare class VcIpPoolIpPoolConfigInfo
	{
		dhcpServerAvailable: boolean;
		dns: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gateway: String;
		ipPoolEnabled: boolean;
		netmask: String;
		range: String;
		subnetAddress: String;

		constructor();
		constructor(subnetAddress?: String, netmask?: String, gateway?: String, range?: String, dns?: String[], dhcpServerAvailable?: boolean, ipPoolEnabled?: boolean);
		isDhcpServerAvailable(): boolean;
		isIpPoolEnabled(): boolean;
	}

	interface VcIpPoolManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		allocateIpv4Address(arg0?: VcDatacenter, arg1?: Number, arg2?: String): String;
		allocateIpv6Address(arg0?: VcDatacenter, arg1?: Number, arg2?: String): String;
		createIpPool(arg0?: VcDatacenter, arg1?: VcIpPool): Number;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyIpPool(arg0?: VcDatacenter, arg1?: Number, arg2?: boolean): void;
		queryIPAllocations(arg0?: VcDatacenter, arg1?: Number, arg2?: String): VcIpPoolManagerIpAllocation[];
		queryIpPools(arg0?: VcDatacenter): VcIpPool[];
		releaseIpAllocation(arg0?: VcDatacenter, arg1?: Number, arg2?: String): void;
		updateIpPool(arg0?: VcDatacenter, arg1?: VcIpPool): void;
	}

	declare const VcIpPoolManager: VcIpPoolManager;

	declare class VcIpPoolManagerIpAllocation
	{
		allocationId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;

		constructor();
		constructor(ipAddress?: String, allocationId?: String);
	}

	declare class VcIpRange
	{
		addressPrefix: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;
		prefixLength: Number;

		constructor();
		constructor(negate?: boolean, addressPrefix?: String, prefixLength?: Number);
		isNegate(): boolean;
	}

	declare class VcIpRouteProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		staticRoute: VcStaticRouteProfile[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, staticRoute?: VcStaticRouteProfile[]);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcIScsiBootFailureEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcIscsiDependencyEntity
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pnicDevice: String;
		vmhbaName: String;
		vnicDevice: String;

		constructor();
		constructor(pnicDevice?: String, vnicDevice?: String, vmhbaName?: String);
	}

	declare class VcIscsiFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcIscsiFaultInvalidVnic
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcIscsiFaultPnicInUse
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		pnicDevice: String;

		constructor();
		constructor(pnicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcIscsiFaultVnicAlreadyBound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcIscsiFaultVnicHasActivePaths
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcIscsiFaultVnicHasMultipleUplinks
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcIscsiFaultVnicHasNoUplinks
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcIscsiFaultVnicHasWrongUplink
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcIscsiFaultVnicInUse
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcIscsiFaultVnicIsLastPath
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcIscsiFaultVnicNotBound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String);
		printStackTrace(): void;
	}

	declare class VcIscsiFaultVnicNotFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String);
		printStackTrace(): void;
	}

	interface VcIscsiManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		bindVnic(arg0?: String, arg1?: String): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryBoundVnics(arg0?: String): VcIscsiPortInfo[];
		queryCandidateNics(arg0?: String): VcIscsiPortInfo[];
		queryMigrationDependencies(arg0?: String[]): VcIscsiMigrationDependency;
		queryPnicStatus(arg0?: String): VcIscsiStatus;
		queryVnicStatus(arg0?: String): VcIscsiStatus;
		unbindVnic(arg0?: String, arg1?: String, arg2?: boolean): void;
	}

	declare const VcIscsiManager: VcIscsiManager;

	declare class VcIscsiMigrationDependency
	{
		dependency: VcIscsiDependencyEntity[];
		disallowReason: VcIscsiStatus;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		migrationAllowed: boolean;

		constructor();
		constructor(migrationAllowed?: boolean, disallowReason?: VcIscsiStatus, dependency?: VcIscsiDependencyEntity[]);
	}

	declare class VcIscsiPortInfo
	{
		complianceStatus: VcIscsiStatus;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		opaqueNetworkId: String;
		opaqueNetworkName: String;
		opaqueNetworkType: String;
		pathStatus: String;
		pnic: VcPhysicalNic;
		pnicDevice: String;
		portgroupKey: String;
		portgroupName: String;
		portKey: String;
		switchName: String;
		switchUuid: String;
		vnic: VcHostVirtualNic;
		vnicDevice: String;

		constructor();
		constructor(vnicDevice?: String, vnic?: VcHostVirtualNic, pnicDevice?: String, pnic?: VcPhysicalNic, switchName?: String, switchUuid?: String, portgroupName?: String, portgroupKey?: String, portKey?: String, opaqueNetworkId?: String, opaqueNetworkType?: String, opaqueNetworkName?: String, externalId?: String, complianceStatus?: VcIscsiStatus, pathStatus?: String);
	}

	interface VcIscsiPortInfoPathStatus
	{
		readonly active: VcIscsiPortInfoPathStatus;
		readonly id: String;
		readonly lastActive: VcIscsiPortInfoPathStatus;
		readonly name: String;
		readonly notUsed: VcIscsiPortInfoPathStatus;
		readonly standBy: VcIscsiPortInfoPathStatus;
		readonly value: String;

		fromString(value?: VcIscsiPortInfoPathStatus): VcIscsiPortInfoPathStatus;
	}

	declare const VcIscsiPortInfoPathStatus: VcIscsiPortInfoPathStatus;

	declare class VcIscsiStatus
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reason: VcLocalizedMethodFault[];

		constructor(reason?: VcLocalizedMethodFault[]);
		constructor();
	}

	declare class VcIsoImageFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSize: Number;
		friendlyName: String;
		modification: Date;
		owner: String;
		path: String;

		constructor();
		constructor(path?: String, friendlyName?: String, fileSize?: Number, modification?: Date, owner?: String);
	}

	declare class VcIsoImageFileQuery
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcKernelModuleInfo
	{
		bssSection: VcKernelModuleSectionInfo;
		dataSection: VcKernelModuleSectionInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		filename: String;
		id: Number;
		loaded: boolean;
		name: String;
		optionString: String;
		readOnlySection: VcKernelModuleSectionInfo;
		textSection: VcKernelModuleSectionInfo;
		useCount: Number;
		version: String;
		writableSection: VcKernelModuleSectionInfo;

		constructor();
		constructor(id?: Number, name?: String, version?: String, filename?: String, optionString?: String, loaded?: boolean, enabled?: boolean, useCount?: Number, readOnlySection?: VcKernelModuleSectionInfo, writableSection?: VcKernelModuleSectionInfo, textSection?: VcKernelModuleSectionInfo, dataSection?: VcKernelModuleSectionInfo, bssSection?: VcKernelModuleSectionInfo);
	}

	declare class VcKernelModuleSectionInfo
	{
		address: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		length: Number;

		constructor();
		constructor(address?: Number, length?: Number);
	}

	interface VcKeyAnyValue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		value_AnyValue: Object;
		value_FloatValue: Number;
		value_IntValue: Number;
		value_LongValue: Number;

	}

	declare const VcKeyAnyValue: VcKeyAnyValue;

	declare class VcKeyProviderId
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;

		constructor();
		constructor(id?: String);
	}

	declare class VcKeyValue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		value: String;

		constructor();
		constructor(key?: String, value?: String);
	}

	declare class VcKmipClusterInfo
	{
		clusterId: VcKeyProviderId;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		servers: VcKmipServerInfo[];
		useAsDefault: boolean;

		constructor();
		constructor(clusterId?: VcKeyProviderId, servers?: VcKmipServerInfo[], useAsDefault?: boolean);
	}

	declare class VcKmipServerInfo
	{
		address: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		nbio: Number;
		port: Number;
		protocol: String;
		proxyAddress: String;
		proxyPort: Number;
		reconnect: Number;
		timeout: Number;
		userName: String;

		constructor();
		constructor(name?: String, address?: String, port?: Number, proxyAddress?: String, proxyPort?: Number, reconnect?: Number, protocol?: String, nbio?: Number, timeout?: Number, userName?: String);
	}

	declare class VcKmipServerSpec
	{
		clusterId: VcKeyProviderId;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcKmipServerInfo;
		password: String;

		constructor();
		constructor(clusterId?: VcKeyProviderId, info?: VcKmipServerInfo, password?: String);
	}

	declare class VcKmipServerStatus
	{
		clusterId: VcKeyProviderId;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		status: VcManagedEntityStatus;

		constructor();
		constructor(clusterId?: VcKeyProviderId, name?: String, status?: VcManagedEntityStatus, description?: String);
	}

	declare class VcLargeRDMConversionNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcLargeRDMNotSupportedOnDatastore
	{
		datastore: VcDatastore;
		datastoreName: String;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String, datastore?: VcDatastore, datastoreName?: String);
		printStackTrace(): void;
	}

	declare class VcLastEventFilterSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity[];
		type: String[];

		constructor();
		constructor(entity?: VcManagedEntity[], type?: String[]);
	}

	declare class VcLatencySensitivity
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		level: VcLatencySensitivitySensitivityLevel;
		sensitivity: Number;

		constructor();
		constructor(level?: VcLatencySensitivitySensitivityLevel, sensitivity?: Number);
	}

	interface VcLatencySensitivitySensitivityLevel
	{
		readonly custom: VcLatencySensitivitySensitivityLevel;
		readonly high: VcLatencySensitivitySensitivityLevel;
		readonly id: String;
		readonly low: VcLatencySensitivitySensitivityLevel;
		readonly medium: VcLatencySensitivitySensitivityLevel;
		readonly name: String;
		readonly normal: VcLatencySensitivitySensitivityLevel;
		readonly value: String;

		fromString(value?: VcLatencySensitivitySensitivityLevel): VcLatencySensitivitySensitivityLevel;
	}

	declare const VcLatencySensitivitySensitivityLevel: VcLatencySensitivitySensitivityLevel;

	declare class VcLeaseFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcLegacyNetworkInterfaceInUse
	{
		backing: String;
		connected: boolean;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		network: VcNetwork;

		constructor();
		constructor(device?: String, backing?: String, connected?: boolean, network?: VcNetwork);
		printStackTrace(): void;
	}

	interface VcLegacyTemplateManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcLegacyTemplateManager: VcLegacyTemplateManager;

	declare class VcLibraryFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcLibraryOperation
	{
		details: VcLocalizableMessage;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(details?: VcLocalizableMessage);
		printStackTrace(): void;
	}

	declare class VcLicenseAssignmentFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor(reason?: String);
		constructor();
		printStackTrace(): void;
	}

	interface VcLicenseAssignmentFailedReason
	{
		readonly downgradeDisallowed: VcLicenseAssignmentFailedReason;
		readonly hostsUnmanageableByVirtualCenterWithoutLicenseServer: VcLicenseAssignmentFailedReason;
		readonly id: String;
		readonly inventoryNotManageableByVirtualCenter: VcLicenseAssignmentFailedReason;
		readonly keyEntityMismatch: VcLicenseAssignmentFailedReason;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcLicenseAssignmentFailedReason): VcLicenseAssignmentFailedReason;
	}

	declare const VcLicenseAssignmentFailedReason: VcLicenseAssignmentFailedReason;

	interface VcLicenseAssignmentManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		isFeatureAvailable(arg0?: VcLicenseAssignmentManagerEntityFeaturePair[]): VcLicenseAssignmentManagerFeatureLicenseAvailability[];
		queryAssignedLicenses(arg0?: String): VcLicenseAssignmentManagerLicenseAssignment[];
		queryAssignedLicensesEx(arg0?: String[], arg1?: String): VcLicenseAssignmentManagerLicenseAssignment[];
		registerEntity(arg0?: String, arg1?: String, arg2?: String, arg3?: String, arg4?: Number, arg5?: Date, arg6?: String): void;
		removeAssignedLicense(arg0?: String): void;
		unregisterEntity(arg0?: String): void;
		updateAssignedLicense(arg0?: String, arg1?: String, arg2?: String): VcLicenseManagerLicenseInfo;
		updateEntitiesProperties(arg0?: VcLicenseAssignmentManagerEntityArgs[], arg1?: String, arg2?: boolean): VcLicenseAssignmentManagerLicenseAssignment[];
		updateEntity(arg0?: String, arg1?: String, arg2?: VcKeyAnyValue[]): VcLicenseAssignmentManagerLicenseAssignment;
		updateFeatureInUse(arg0?: String, arg1?: String, arg2?: boolean): void;
		updateUsage(arg0?: String, arg1?: Number): void;
		uploadLicenseFile(arg0?: VcLicenseAssignmentManagerLicenseFileDescriptor): void;
	}

	declare const VcLicenseAssignmentManager: VcLicenseAssignmentManager;

	declare class VcLicenseAssignmentManagerEntityArgs
	{
		args: VcKeyAnyValue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityId: String;

		constructor();
		constructor(entityId?: String, args?: VcKeyAnyValue[]);
	}

	declare class VcLicenseAssignmentManagerEntityFeaturePair
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityId: String;
		feature: String;

		constructor();
		constructor(entityId?: String, feature?: String);
	}

	declare class VcLicenseAssignmentManagerFeatureLicenseAvailability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityFeature: VcLicenseAssignmentManagerEntityFeaturePair;
		licensed: boolean;

		constructor();
		constructor(entityFeature?: VcLicenseAssignmentManagerEntityFeaturePair, licensed?: boolean);
	}

	declare class VcLicenseAssignmentManagerLicenseAssignment
	{
		assignedLicense: VcLicenseManagerLicenseInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityDisplayName: String;
		entityId: String;
		properties: VcKeyAnyValue[];
		scope: String;

		constructor();
		constructor(entityId?: String, scope?: String, entityDisplayName?: String, assignedLicense?: VcLicenseManagerLicenseInfo, properties?: VcKeyAnyValue[]);
	}

	declare class VcLicenseAssignmentManagerLicenseFileDescriptor
	{
		content: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		properties: VcKeyAnyValue[];

		constructor();
		constructor(content?: String, name?: String, properties?: VcKeyAnyValue[]);
	}

	declare class VcLicenseAvailabilityInfo
	{
		available: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		feature: VcLicenseFeatureInfo;
		total: Number;

		constructor();
		constructor(feature?: VcLicenseFeatureInfo, total?: Number, available?: Number);
	}

	interface VcLicenseDataManager
	{
		entityLicenseData: VcLicenseDataManagerEntityLicenseData[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		applyAssociatedLicenseData(arg0?: VcManagedEntity): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryAssociatedLicenseData(arg0?: VcManagedEntity, arg1?: boolean): VcLicenseDataManagerLicenseData;
		queryEntityLicenseData(): VcLicenseDataManagerEntityLicenseData[];
		updateAssociatedLicenseData(arg0?: VcManagedEntity, arg1?: VcLicenseDataManagerLicenseData): void;
	}

	declare const VcLicenseDataManager: VcLicenseDataManager;

	declare class VcLicenseDataManagerEntityLicenseData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcManagedEntity;
		licenseData: VcLicenseDataManagerLicenseData;

		constructor();
		constructor(key?: VcManagedEntity, licenseData?: VcLicenseDataManagerLicenseData);
	}

	declare class VcLicenseDataManagerLicenseData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		licenseKeys: VcLicenseDataManagerLicenseKeyEntry[];

		constructor();
		constructor(licenseKeys?: VcLicenseDataManagerLicenseKeyEntry[]);
	}

	declare class VcLicenseDataManagerLicenseKeyEntry
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		value: String;

		constructor();
		constructor(key?: String, value?: String);
	}

	declare class VcLicenseDiagnostics
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lastStatusUpdate: Date;
		licenseFeatureUnknowns: String;
		licenseRequestFailures: String;
		licenseRequests: String;
		opFailureMessage: String;
		opState: VcLicenseManagerState;
		sourceLastChanged: Date;
		sourceLatency: Number;
		sourceLost: String;

		constructor();
		constructor(sourceLastChanged?: Date, sourceLost?: String, sourceLatency?: Number, licenseRequests?: String, licenseRequestFailures?: String, licenseFeatureUnknowns?: String, opState?: VcLicenseManagerState, lastStatusUpdate?: Date, opFailureMessage?: String);
	}

	declare class VcLicenseDowngradeDisallowed
	{
		edition: String;
		entityId: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		features: VcKeyAnyValue[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(edition?: String, entityId?: String, features?: VcKeyAnyValue[]);
		printStackTrace(): void;
	}

	declare class VcLicenseEntityAlreadyExists
	{
		entityId: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(entityId?: String);
		printStackTrace(): void;
	}

	declare class VcLicenseEntityNotFound
	{
		entityId: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(entityId?: String);
		printStackTrace(): void;
	}

	declare class VcLicenseEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcLicenseExpired
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		licenseKey: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(licenseKey?: String);
		printStackTrace(): void;
	}

	declare class VcLicenseExpiredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		feature: VcLicenseFeatureInfo;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, feature?: VcLicenseFeatureInfo);
	}

	declare class VcLicenseFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcLicenseFeatureInfo
	{
		costUnit: String;
		dependentKey: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		edition: boolean;
		expiresOn: Date;
		featureDescription: String;
		featureName: String;
		key: String;
		sourceRestriction: String;
		state: VcLicenseFeatureInfoState;

		constructor();
		constructor(key?: String, featureName?: String, featureDescription?: String, state?: VcLicenseFeatureInfoState, costUnit?: String, sourceRestriction?: String, dependentKey?: String[], edition?: boolean, expiresOn?: Date);
		isEdition(): boolean;
	}

	interface VcLicenseFeatureInfoSourceRestriction
	{
		readonly file: VcLicenseFeatureInfoSourceRestriction;
		readonly id: String;
		readonly name: String;
		readonly served: VcLicenseFeatureInfoSourceRestriction;
		readonly unrestricted: VcLicenseFeatureInfoSourceRestriction;
		readonly value: String;

		fromString(value?: VcLicenseFeatureInfoSourceRestriction): VcLicenseFeatureInfoSourceRestriction;
	}

	declare const VcLicenseFeatureInfoSourceRestriction: VcLicenseFeatureInfoSourceRestriction;

	interface VcLicenseFeatureInfoState
	{
		readonly disabled: VcLicenseFeatureInfoState;
		readonly enabled: VcLicenseFeatureInfoState;
		readonly id: String;
		readonly name: String;
		readonly optional: VcLicenseFeatureInfoState;
		readonly value: String;

		fromString(value?: VcLicenseFeatureInfoState): VcLicenseFeatureInfoState;
	}

	declare const VcLicenseFeatureInfoState: VcLicenseFeatureInfoState;

	interface VcLicenseFeatureInfoUnit
	{
		readonly cpuCore: VcLicenseFeatureInfoUnit;
		readonly cpuPackage: VcLicenseFeatureInfoUnit;
		readonly host: VcLicenseFeatureInfoUnit;
		readonly id: String;
		readonly name: String;
		readonly server: VcLicenseFeatureInfoUnit;
		readonly value: String;
		readonly vm: VcLicenseFeatureInfoUnit;

		fromString(value?: VcLicenseFeatureInfoUnit): VcLicenseFeatureInfoUnit;
	}

	declare const VcLicenseFeatureInfoUnit: VcLicenseFeatureInfoUnit;

	declare class VcLicenseKeyEntityMismatch
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	interface VcLicenseManager
	{
		diagnostics: VcLicenseDiagnostics;
		evaluation: VcLicenseManagerEvaluationInfo;
		featureInfo: VcLicenseFeatureInfo[];
		id: String;
		licenseAssignmentManager: VcLicenseAssignmentManager;
		licensedEdition: String;
		licenses: VcLicenseManagerLicenseInfo[];
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		source: VcLicenseSource;
		sourceAvailable: boolean;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		activateRemoteHardEnforcement(arg0?: Number): void;
		addLicense(arg0?: String, arg1?: VcKeyValue[]): VcLicenseManagerLicenseInfo;
		checkLicenseFeature(arg0?: VcHostSystem, arg1?: String): boolean;
		configureLicenseSource(arg0?: VcHostSystem, arg1?: VcLicenseSource): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		decodeLicense(arg0?: String): VcLicenseManagerLicenseInfo;
		disableFeature(arg0?: VcHostSystem, arg1?: String): boolean;
		enableFeature(arg0?: VcHostSystem, arg1?: String): boolean;
		queryLicenseDataManager(): VcLicenseDataManager;
		queryLicenseSourceAvailability(arg0?: VcHostSystem): VcLicenseAvailabilityInfo[];
		queryLicenseUsage(arg0?: VcHostSystem): VcLicenseUsageInfo;
		querySupportedFeatures(arg0?: VcHostSystem): VcLicenseFeatureInfo[];
		removeLicense(arg0?: String): void;
		removeLicenseLabel(arg0?: String, arg1?: String): void;
		setLicenseEdition(arg0?: VcHostSystem, arg1?: String): void;
		updateLicense(arg0?: String, arg1?: VcKeyValue[]): VcLicenseManagerLicenseInfo;
		updateLicenseLabel(arg0?: String, arg1?: String, arg2?: String): void;
	}

	declare const VcLicenseManager: VcLicenseManager;

	declare class VcLicenseManagerEvaluationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		properties: VcKeyAnyValue[];

		constructor();
		constructor(properties?: VcKeyAnyValue[]);
	}

	declare class VcLicenseManagerLicenseInfo
	{
		costUnit: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		editionKey: String;
		labels: VcKeyValue[];
		licenseKey: String;
		name: String;
		properties: VcKeyAnyValue[];
		total: Number;
		used: Number;

		constructor(licenseKey?: String, editionKey?: String, name?: String, total?: Number, used?: Number, costUnit?: String, properties?: VcKeyAnyValue[], labels?: VcKeyValue[]);
		constructor();
	}

	interface VcLicenseManagerLicenseKey
	{
		readonly backup: VcLicenseManagerLicenseKey;
		readonly das: VcLicenseManagerLicenseKey;
		readonly drs: VcLicenseManagerLicenseKey;
		readonly drsPower: VcLicenseManagerLicenseKey;
		readonly esxExpress: VcLicenseManagerLicenseKey;
		readonly esxFull: VcLicenseManagerLicenseKey;
		readonly esxHost: VcLicenseManagerLicenseKey;
		readonly esxVmtn: VcLicenseManagerLicenseKey;
		readonly gsxHost: VcLicenseManagerLicenseKey;
		readonly id: String;
		readonly iscsi: VcLicenseManagerLicenseKey;
		readonly name: String;
		readonly nas: VcLicenseManagerLicenseKey;
		readonly san: VcLicenseManagerLicenseKey;
		readonly serverHost: VcLicenseManagerLicenseKey;
		readonly value: String;
		readonly vc: VcLicenseManagerLicenseKey;
		readonly vcExpress: VcLicenseManagerLicenseKey;
		readonly vmotion: VcLicenseManagerLicenseKey;
		readonly vsmp: VcLicenseManagerLicenseKey;

		fromString(value?: VcLicenseManagerLicenseKey): VcLicenseManagerLicenseKey;
	}

	declare const VcLicenseManagerLicenseKey: VcLicenseManagerLicenseKey;

	interface VcLicenseManagerState
	{
		readonly fault: VcLicenseManagerState;
		readonly id: String;
		readonly initializing: VcLicenseManagerState;
		readonly marginal: VcLicenseManagerState;
		readonly name: String;
		readonly normal: VcLicenseManagerState;
		readonly value: String;

		fromString(value?: VcLicenseManagerState): VcLicenseManagerState;
	}

	declare const VcLicenseManagerState: VcLicenseManagerState;

	declare class VcLicenseNonComplianceEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		url: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, url?: String);
	}

	declare class VcLicenseReservationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		required: Number;
		state: VcLicenseReservationInfoState;

		constructor();
		constructor(key?: String, state?: VcLicenseReservationInfoState, required?: Number);
	}

	interface VcLicenseReservationInfoState
	{
		readonly id: String;
		readonly licensed: VcLicenseReservationInfoState;
		readonly name: String;
		readonly noLicense: VcLicenseReservationInfoState;
		readonly notUsed: VcLicenseReservationInfoState;
		readonly unlicensedUse: VcLicenseReservationInfoState;
		readonly value: String;

		fromString(value?: VcLicenseReservationInfoState): VcLicenseReservationInfoState;
	}

	declare const VcLicenseReservationInfoState: VcLicenseReservationInfoState;

	declare class VcLicenseRestricted
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcLicenseRestrictedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcLicenseServerAvailableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		licenseServer: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, licenseServer?: String);
	}

	declare class VcLicenseServerSource
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		licenseServer: String;

		constructor();
		constructor(licenseServer?: String);
	}

	declare class VcLicenseServerUnavailable
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		licenseServer: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(licenseServer?: String);
		printStackTrace(): void;
	}

	declare class VcLicenseServerUnavailableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		licenseServer: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, licenseServer?: String);
	}

	declare class VcLicenseSource
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcLicenseSourceUnavailable
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		licenseSource: VcLicenseSource;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(licenseSource?: VcLicenseSource);
		printStackTrace(): void;
	}

	declare class VcLicenseUsageInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		featureInfo: VcLicenseFeatureInfo[];
		reservationInfo: VcLicenseReservationInfo[];
		source: VcLicenseSource;
		sourceAvailable: boolean;

		constructor();
		constructor(source?: VcLicenseSource, sourceAvailable?: boolean, reservationInfo?: VcLicenseReservationInfo[], featureInfo?: VcLicenseFeatureInfo[]);
	}

	declare class VcLimitExceeded
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		limit: Number;
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor(property?: String, limit?: Number);
		constructor();
		printStackTrace(): void;
	}

	declare class VcLinkDiscoveryProtocolConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operation: String;
		protocol: String;

		constructor();
		constructor(protocol?: String, operation?: String);
	}

	interface VcLinkDiscoveryProtocolConfigOperationType
	{
		readonly advertise: VcLinkDiscoveryProtocolConfigOperationType;
		readonly both: VcLinkDiscoveryProtocolConfigOperationType;
		readonly id: String;
		readonly listen: VcLinkDiscoveryProtocolConfigOperationType;
		readonly name: String;
		readonly none: VcLinkDiscoveryProtocolConfigOperationType;
		readonly value: String;

		fromString(value?: VcLinkDiscoveryProtocolConfigOperationType): VcLinkDiscoveryProtocolConfigOperationType;
	}

	declare const VcLinkDiscoveryProtocolConfigOperationType: VcLinkDiscoveryProtocolConfigOperationType;

	interface VcLinkDiscoveryProtocolConfigProtocolType
	{
		readonly cdp: VcLinkDiscoveryProtocolConfigProtocolType;
		readonly id: String;
		readonly lldp: VcLinkDiscoveryProtocolConfigProtocolType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcLinkDiscoveryProtocolConfigProtocolType): VcLinkDiscoveryProtocolConfigProtocolType;
	}

	declare const VcLinkDiscoveryProtocolConfigProtocolType: VcLinkDiscoveryProtocolConfigProtocolType;

	declare class VcLinkLayerDiscoveryProtocolInfo
	{
		chassisId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parameter: VcKeyAnyValue[];
		portId: String;
		timeToLive: Number;

		constructor();
		constructor(chassisId?: String, portId?: String, timeToLive?: Number, parameter?: VcKeyAnyValue[]);
	}

	declare class VcLinkProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcLinuxVolumeNotClean
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	interface VcListView
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly view: VcManagedObject[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyView(): void;
		modifyListView(arg0?: VcManagedObject[], arg1?: VcManagedObject[]): VcManagedObject[];
		resetListView(arg0?: VcManagedObject[]): VcManagedObject[];
		resetListViewFromView(arg0?: VcView): void;
	}

	declare const VcListView: VcListView;

	declare class VcLocalDatastoreCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		datastoreUrl: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument, datastoreUrl?: String);
	}

	declare class VcLocalDatastoreInfo
	{
		containerId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpace: Number;
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxVirtualDiskCapacity: Number;
		name: String;
		path: String;
		timestamp: Date;
		url: String;

		constructor(name?: String, url?: String, freeSpace?: Number, maxFileSize?: Number, maxVirtualDiskCapacity?: Number, maxMemoryFileSize?: Number, timestamp?: Date, containerId?: String, path?: String);
		constructor();
	}

	interface VcLocalizableMessage
	{
		arg: VcKeyAnyValue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		message: String;

	}

	declare const VcLocalizableMessage: VcLocalizableMessage;

	interface VcLocalizationManager
	{
		catalog: VcLocalizationManagerMessageCatalog[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcLocalizationManager: VcLocalizationManager;

	declare class VcLocalizationManagerMessageCatalog
	{
		catalogName: String;
		catalogUri: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lastModified: Date;
		locale: String;
		md5sum: String;
		moduleName: String;
		version: String;

		constructor();
		constructor(moduleName?: String, catalogName?: String, locale?: String, catalogUri?: String, lastModified?: Date, md5sum?: String, version?: String);
	}

	declare class VcLocalizedMethodFault
	{
		fault: VcMethodFault;
		localizedMessage: String;
		message: String;

		constructor(arg0?: String);
		constructor();
		printStackTrace(): void;
	}

	declare class VcLocalLicenseSource
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		licenseKeys: String;

		constructor();
		constructor(licenseKeys?: String);
	}

	declare class VcLocalTSMEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcLockerMisconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument);
	}

	declare class VcLockerReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newDatastore: VcDatastoreEventArgument;
		oldDatastore: VcDatastoreEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, oldDatastore?: VcDatastoreEventArgument, newDatastore?: VcDatastoreEventArgument);
	}

	declare class VcLogBundlingFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcLongOption
	{
		defaultValue: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		max: Number;
		min: Number;
		valueIsReadonly: boolean;

		constructor();
		constructor(valueIsReadonly?: boolean, min?: Number, max?: Number, defaultValue?: Number);
		isValueIsReadonly(): boolean;
	}

	declare class VcLongPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		value: Number;

		constructor();
		constructor(inherited?: boolean, value?: Number);
	}

	declare class VcMacAddress
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;

		constructor();
		constructor(negate?: boolean);
		isNegate(): boolean;
	}

	declare class VcMacContainer
	{
		containerId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;

		constructor();
		constructor(negate?: boolean, containerId?: String);
		isNegate(): boolean;
	}

	declare class VcMacRange
	{
		address: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mask: String;
		negate: boolean;

		constructor();
		constructor(negate?: boolean, address?: String, mask?: String);
		isNegate(): boolean;
	}

	declare class VcMaintenanceModeFileMove
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcManagedByInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extensionKey: String;
		type: String;

		constructor();
		constructor(extensionKey?: String, type?: String);
	}

	interface VcManagedEntity
	{
		alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		name: String;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcManagedEntity: VcManagedEntity;

	declare class VcManagedEntityEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		name: String;

		constructor();
		constructor(name?: String, entity?: VcManagedEntity);
	}

	interface VcManagedEntityStatus
	{
		readonly gray: VcManagedEntityStatus;
		readonly green: VcManagedEntityStatus;
		readonly id: String;
		readonly name: String;
		readonly red: VcManagedEntityStatus;
		readonly value: String;
		readonly yellow: VcManagedEntityStatus;

		fromString(value?: VcManagedEntityStatus): VcManagedEntityStatus;
	}

	declare const VcManagedEntityStatus: VcManagedEntityStatus;

	interface VcManagedObject
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcManagedObject: VcManagedObject;

	declare class VcManagedObjectNotFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		obj: VcManagedObjectReference;

		constructor();
		constructor(obj?: VcManagedObjectReference);
		printStackTrace(): void;
	}

	declare class VcManagedObjectReference
	{
		serverGuid: String;
		type: String;
		value: String;

		constructor(type?: String, value?: String, serverGuid?: String);
		constructor(type?: String, value?: String);
		constructor();
	}

	interface VcManagedObjectView
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		view: VcManagedObject[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyView(): void;
	}

	declare const VcManagedObjectView: VcManagedObjectView;

	declare class VcMemoryFileFormatNotSupportedByDatastore
	{
		datastore: VcDatastore;
		datastoreName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		type: String;

		constructor();
		constructor(datastore?: VcDatastore, datastoreName?: String, type?: String);
		printStackTrace(): void;
	}

	declare class VcMemoryHotPlugNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcMemorySizeNotRecommended
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		maxMemorySizeMB: Number;
		memorySizeMB: Number;
		message: String;
		minMemorySizeMB: Number;

		constructor();
		constructor(memorySizeMB?: Number, minMemorySizeMB?: Number, maxMemorySizeMB?: Number);
		printStackTrace(): void;
	}

	declare class VcMemorySizeNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		maxMemorySizeMB: Number;
		memorySizeMB: Number;
		message: String;
		minMemorySizeMB: Number;

		constructor();
		constructor(memorySizeMB?: Number, minMemorySizeMB?: Number, maxMemorySizeMB?: Number);
		printStackTrace(): void;
	}

	declare class VcMemorySizeNotSupportedByDatastore
	{
		datastore: VcDatastore;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		maxMemorySizeMB: Number;
		memorySizeMB: Number;
		message: String;

		constructor();
		constructor(datastore?: VcDatastore, memorySizeMB?: Number, maxMemorySizeMB?: Number);
		printStackTrace(): void;
	}

	declare class VcMemorySnapshotOnIndependentDisk
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	interface VcMessageBusProxy
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		configureMessageBusProxy(arg0?: VcMessageBusProxyConfigSpec): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reloadMessageBusProxy(): void;
		retrieveMessageBusProxyInfo(): VcMessageBusProxyInfo;
		startMessageBusProxy(): void;
		stopMessageBusProxy(): void;
		unconfigureMessageBusProxy(): void;
	}

	declare const VcMessageBusProxy: VcMessageBusProxy;

	declare class VcMessageBusProxyConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcMessageBusProxyFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcMessageBusProxyInfo
	{
		configured: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		running: boolean;

		constructor();
	}

	declare class VcMethodAction
	{
		argument: VcMethodActionArgument[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, argument?: VcMethodActionArgument[]);
	}

	declare class VcMethodActionArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		value_AnyValue: Object;
		value_FloatValue: Number;
		value_IntValue: Number;
		value_LongValue: Number;

		constructor();
		constructor(value?: Object);
	}

	declare class VcMethodAlreadyDisabledFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		sourceId: String;

		constructor();
		constructor(sourceId?: String);
		printStackTrace(): void;
	}

	declare class VcMethodDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		label: String;
		summary: String;

		constructor(label?: String, summary?: String, key?: String);
		constructor();
	}

	declare class VcMethodDisabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		source: String;

		constructor();
		constructor(source?: String);
		printStackTrace(): void;
	}

	declare class VcMethodFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(message?: String);
		printStackTrace(): void;
	}

	declare class VcMethodNotFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		method: String;
		receiver: VcManagedObjectReference;

		constructor();
		constructor(receiver?: VcManagedObjectReference, method?: String);
		printStackTrace(): void;
	}

	declare class VcMetricAlarmExpression
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		metric: VcPerfMetricId;
		operator: VcMetricAlarmOperator;
		red: Number;
		redInterval: Number;
		type: String;
		yellow: Number;
		yellowInterval: Number;

		constructor();
		constructor(operator?: VcMetricAlarmOperator, type?: String, metric?: VcPerfMetricId, yellow?: Number, yellowInterval?: Number, red?: Number, redInterval?: Number);
	}

	interface VcMetricAlarmOperator
	{
		readonly id: String;
		readonly isAbove: VcMetricAlarmOperator;
		readonly isBelow: VcMetricAlarmOperator;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcMetricAlarmOperator): VcMetricAlarmOperator;
	}

	declare const VcMetricAlarmOperator: VcMetricAlarmOperator;

	declare class VcMigrationDisabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcMigrationErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, fault?: VcLocalizedMethodFault);
	}

	declare class VcMigrationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, fault?: VcLocalizedMethodFault);
	}

	declare class VcMigrationFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcMigrationFeatureNotSupported
	{
		atSourceHost: boolean;
		failedHost: VcHostSystem;
		failedHostName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHostName?: String, failedHost?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcMigrationHostErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dstHost: VcHostEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, fault?: VcLocalizedMethodFault, dstHost?: VcHostEventArgument);
	}

	declare class VcMigrationHostWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dstHost: VcHostEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, fault?: VcLocalizedMethodFault, dstHost?: VcHostEventArgument);
	}

	declare class VcMigrationNotReady
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor(reason?: String);
		constructor();
		printStackTrace(): void;
	}

	declare class VcMigrationResourceErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dstHost: VcHostEventArgument;
		dstPool: VcResourcePoolEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, fault?: VcLocalizedMethodFault, dstPool?: VcResourcePoolEventArgument, dstHost?: VcHostEventArgument);
	}

	declare class VcMigrationResourceWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dstHost: VcHostEventArgument;
		dstPool: VcResourcePoolEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, fault?: VcLocalizedMethodFault, dstPool?: VcResourcePoolEventArgument, dstHost?: VcHostEventArgument);
	}

	declare class VcMigrationWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, fault?: VcLocalizedMethodFault);
	}

	declare class VcMisfeaturedHostsBlockingEVC
	{
		badHardwareHostNames: String[];
		badHardwareHosts: VcHostSystem[];
		badSoftwareHostNames: String[];
		badSoftwareHosts: VcHostSystem[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faults: VcLocalizedMethodFault[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(faults?: VcLocalizedMethodFault[], badHardwareHosts?: VcHostSystem[], badHardwareHostNames?: String[], badSoftwareHosts?: VcHostSystem[], badSoftwareHostNames?: String[]);
		printStackTrace(): void;
	}

	declare class VcMismatchedBundle
	{
		bundleBuildNumber: Number;
		bundleUuid: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostBuildNumber: Number;
		hostUuid: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(bundleUuid?: String, hostUuid?: String, bundleBuildNumber?: Number, hostBuildNumber?: Number);
		printStackTrace(): void;
	}

	declare class VcMismatchedNetworkPolicies
	{
		backing: String;
		connected: boolean;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String, backing?: String, connected?: boolean);
		printStackTrace(): void;
	}

	declare class VcMismatchedVMotionNetworkNames
	{
		destNetwork: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		sourceNetwork: String;

		constructor();
		constructor(sourceNetwork?: String, destNetwork?: String);
		printStackTrace(): void;
	}

	declare class VcMissingBmcSupport
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcMissingController
	{
		deviceIndex: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String, deviceIndex?: Number);
		printStackTrace(): void;
	}

	declare class VcMissingIpPool
	{
		category: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		id: String;
		label: String;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(id?: String, category?: String, label?: String, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcMissingLinuxCustResources
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcMissingNetworkIpConfig
	{
		category: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		id: String;
		label: String;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(id?: String, category?: String, label?: String, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcMissingObject
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		obj: VcManagedObject;

		constructor();
		constructor(obj?: VcManagedObject, fault?: VcLocalizedMethodFault);
	}

	declare class VcMissingPowerOffConfiguration
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcMissingPowerOnConfiguration
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcMissingProperty
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		path: String;

		constructor();
		constructor(path?: String, fault?: VcLocalizedMethodFault);
	}

	declare class VcMissingWindowsCustResources
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcMksConnectionLimitReached
	{
		connectionLimit: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(connectionLimit?: Number);
		printStackTrace(): void;
	}

	declare class VcModeInfo
	{
		admin: String;
		browse: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		full: String;
		modify: String;
		read: String;
		use: String;

		constructor();
		constructor(browse?: String, read?: String, modify?: String, use?: String, admin?: String, full?: String);
	}

	declare class VcMonthlyByDayTaskScheduler
	{
		activeTime: Date;
		day: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expireTime: Date;
		hour: Number;
		interval: Number;
		minute: Number;

		constructor();
		constructor(activeTime?: Date, expireTime?: Date, interval?: Number, minute?: Number, hour?: Number, day?: Number);
	}

	declare class VcMonthlyByWeekdayTaskScheduler
	{
		activeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expireTime: Date;
		hour: Number;
		interval: Number;
		minute: Number;
		offset: VcWeekOfMonth;
		weekday: VcDayOfWeek;

		constructor();
		constructor(activeTime?: Date, expireTime?: Date, interval?: Number, minute?: Number, hour?: Number, offset?: VcWeekOfMonth, weekday?: VcDayOfWeek);
	}

	declare class VcMonthlyTaskScheduler
	{
		activeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expireTime: Date;
		hour: Number;
		interval: Number;
		minute: Number;

		constructor();
		constructor(activeTime?: Date, expireTime?: Date, interval?: Number, minute?: Number, hour?: Number);
	}

	declare class VcMountError
	{
		diskIndex: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, diskIndex?: Number);
		printStackTrace(): void;
	}

	declare class VcMtuMatchEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String, healthResult?: VcHostMemberHealthCheckResult);
	}

	declare class VcMtuMismatchEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String, healthResult?: VcHostMemberHealthCheckResult);
	}

	interface VcMultipathState
	{
		readonly active: VcMultipathState;
		readonly dead: VcMultipathState;
		readonly disabled: VcMultipathState;
		readonly id: String;
		readonly name: String;
		readonly standby: VcMultipathState;
		readonly unknown: VcMultipathState;
		readonly value: String;

		fromString(value?: VcMultipathState): VcMultipathState;
	}

	declare const VcMultipathState: VcMultipathState;

	declare class VcMultipleCertificatesVerifyFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		thumbprintData: VcMultipleCertificatesVerifyFaultThumbprintData[];

		constructor();
		constructor(thumbprintData?: VcMultipleCertificatesVerifyFaultThumbprintData[]);
		printStackTrace(): void;
	}

	declare class VcMultipleCertificatesVerifyFaultThumbprintData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		port: Number;
		thumbprint: String;

		constructor();
		constructor(port?: Number, thumbprint?: String);
	}

	declare class VcMultipleSnapshotsNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcMultiWriterNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcNamePasswordAuthentication
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		interactiveSession: boolean;
		password: String;
		username: String;

		constructor();
		constructor(interactiveSession?: boolean, username?: String, password?: String);
	}

	declare class VcNamespaceFull
	{
		currentMaxSize: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		requiredSize: Number;

		constructor();
		constructor(name?: String, currentMaxSize?: Number, requiredSize?: Number);
		printStackTrace(): void;
	}

	declare class VcNamespaceLimitReached
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		limit: Number;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(limit?: Number);
		printStackTrace(): void;
	}

	declare class VcNamespaceWriteProtected
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String);
		printStackTrace(): void;
	}

	declare class VcNasConfigFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String);
		printStackTrace(): void;
	}

	declare class VcNasConnectionLimitReached
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		remoteHost: String;
		remotePath: String;

		constructor();
		constructor(name?: String, remoteHost?: String, remotePath?: String);
		printStackTrace(): void;
	}

	declare class VcNASDatastoreCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		datastoreUrl: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument, datastoreUrl?: String);
	}

	declare class VcNasDatastoreInfo
	{
		containerId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpace: Number;
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxVirtualDiskCapacity: Number;
		name: String;
		nas: VcHostNasVolume;
		timestamp: Date;
		url: String;

		constructor();
		constructor(name?: String, url?: String, freeSpace?: Number, maxFileSize?: Number, maxVirtualDiskCapacity?: Number, maxMemoryFileSize?: Number, timestamp?: Date, containerId?: String, nas?: VcHostNasVolume);
	}

	declare class VcNasSessionCredentialConflict
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		remoteHost: String;
		remotePath: String;
		userName: String;

		constructor();
		constructor(name?: String, remoteHost?: String, remotePath?: String, userName?: String);
		printStackTrace(): void;
	}

	declare class VcNasStorageProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcNasVolumeNotMounted
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		remoteHost: String;
		remotePath: String;

		constructor();
		constructor(name?: String, remoteHost?: String, remotePath?: String);
		printStackTrace(): void;
	}

	declare class VcNegatableExpression
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;

		constructor();
		constructor(negate?: boolean);
		isNegate(): boolean;
	}

	declare class VcNetBIOSConfigInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mode: String;

		constructor();
		constructor(mode?: String);
	}

	interface VcNetBIOSConfigInfoMode
	{
		readonly disabled: VcNetBIOSConfigInfoMode;
		readonly enabled: VcNetBIOSConfigInfoMode;
		readonly enabledViaDHCP: VcNetBIOSConfigInfoMode;
		readonly id: String;
		readonly name: String;
		readonly unknown: VcNetBIOSConfigInfoMode;
		readonly value: String;

		fromString(value?: VcNetBIOSConfigInfoMode): VcNetBIOSConfigInfoMode;
	}

	declare const VcNetBIOSConfigInfoMode: VcNetBIOSConfigInfoMode;

	declare class VcNetDhcpConfigInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipv4: VcNetDhcpConfigInfoDhcpOptions;
		ipv6: VcNetDhcpConfigInfoDhcpOptions;

		constructor();
		constructor(ipv6?: VcNetDhcpConfigInfoDhcpOptions, ipv4?: VcNetDhcpConfigInfoDhcpOptions);
	}

	declare class VcNetDhcpConfigInfoDhcpOptions
	{
		config: VcKeyValue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enable: boolean;

		constructor();
		constructor(enable?: boolean, config?: VcKeyValue[]);
	}

	declare class VcNetDhcpConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipv4: VcNetDhcpConfigSpecDhcpOptionsSpec;
		ipv6: VcNetDhcpConfigSpecDhcpOptionsSpec;

		constructor();
		constructor(ipv6?: VcNetDhcpConfigSpecDhcpOptionsSpec, ipv4?: VcNetDhcpConfigSpecDhcpOptionsSpec);
	}

	declare class VcNetDhcpConfigSpecDhcpOptionsSpec
	{
		config: VcKeyValue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enable: boolean;
		operation: String;

		constructor();
		constructor(enable?: boolean, config?: VcKeyValue[], operation?: String);
		isEnable(): boolean;
	}

	declare class VcNetDnsConfigInfo
	{
		dhcp: boolean;
		domainName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostName: String;
		ipAddress: String[];
		searchDomain: String[];

		constructor();
		constructor(dhcp?: boolean, hostName?: String, domainName?: String, ipAddress?: String[], searchDomain?: String[]);
	}

	declare class VcNetDnsConfigSpec
	{
		dhcp: boolean;
		domainName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostName: String;
		ipAddress: String[];
		searchDomain: String[];

		constructor();
		constructor(dhcp?: boolean, hostName?: String, domainName?: String, ipAddress?: String[], searchDomain?: String[]);
		isDhcp(): boolean;
	}

	declare class VcNetIpConfigInfo
	{
		autoConfigurationEnabled: boolean;
		dhcp: VcNetDhcpConfigInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: VcNetIpConfigInfoIpAddress[];

		constructor();
		constructor(ipAddress?: VcNetIpConfigInfoIpAddress[], dhcp?: VcNetDhcpConfigInfo, autoConfigurationEnabled?: boolean);
		isAutoConfigurationEnabled(): boolean;
	}

	declare class VcNetIpConfigInfoIpAddress
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;
		lifetime: Date;
		origin: String;
		prefixLength: Number;
		state: String;

		constructor();
		constructor(ipAddress?: String, prefixLength?: Number, origin?: String, state?: String, lifetime?: Date);
	}

	interface VcNetIpConfigInfoIpAddressOrigin
	{
		readonly dhcp: VcNetIpConfigInfoIpAddressOrigin;
		readonly id: String;
		readonly linklayer: VcNetIpConfigInfoIpAddressOrigin;
		readonly manual: VcNetIpConfigInfoIpAddressOrigin;
		readonly name: String;
		readonly other: VcNetIpConfigInfoIpAddressOrigin;
		readonly random: VcNetIpConfigInfoIpAddressOrigin;
		readonly value: String;

		fromString(value?: VcNetIpConfigInfoIpAddressOrigin): VcNetIpConfigInfoIpAddressOrigin;
	}

	declare const VcNetIpConfigInfoIpAddressOrigin: VcNetIpConfigInfoIpAddressOrigin;

	interface VcNetIpConfigInfoIpAddressStatus
	{
		readonly deprecated: VcNetIpConfigInfoIpAddressStatus;
		readonly duplicate: VcNetIpConfigInfoIpAddressStatus;
		readonly id: String;
		readonly inaccessible: VcNetIpConfigInfoIpAddressStatus;
		readonly invalid: VcNetIpConfigInfoIpAddressStatus;
		readonly name: String;
		readonly preferred: VcNetIpConfigInfoIpAddressStatus;
		readonly tentative: VcNetIpConfigInfoIpAddressStatus;
		readonly unknown: VcNetIpConfigInfoIpAddressStatus;
		readonly value: String;

		fromString(value?: VcNetIpConfigInfoIpAddressStatus): VcNetIpConfigInfoIpAddressStatus;
	}

	declare const VcNetIpConfigInfoIpAddressStatus: VcNetIpConfigInfoIpAddressStatus;

	declare class VcNetIpConfigSpec
	{
		autoConfigurationEnabled: boolean;
		dhcp: VcNetDhcpConfigSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: VcNetIpConfigSpecIpAddressSpec[];

		constructor();
		constructor(ipAddress?: VcNetIpConfigSpecIpAddressSpec[], dhcp?: VcNetDhcpConfigSpec, autoConfigurationEnabled?: boolean);
		isAutoConfigurationEnabled(): boolean;
	}

	declare class VcNetIpConfigSpecIpAddressSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;
		operation: String;
		prefixLength: Number;

		constructor();
		constructor(ipAddress?: String, prefixLength?: Number, operation?: String);
	}

	declare class VcNetIpRouteConfigInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipRoute: VcNetIpRouteConfigInfoIpRoute[];

		constructor();
		constructor(ipRoute?: VcNetIpRouteConfigInfoIpRoute[]);
	}

	declare class VcNetIpRouteConfigInfoGateway
	{
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;

		constructor();
		constructor(ipAddress?: String, device?: String);
	}

	declare class VcNetIpRouteConfigInfoIpRoute
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gateway: VcNetIpRouteConfigInfoGateway;
		network: String;
		prefixLength: Number;

		constructor();
		constructor(network?: String, prefixLength?: Number, gateway?: VcNetIpRouteConfigInfoGateway);
	}

	declare class VcNetIpRouteConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipRoute: VcNetIpRouteConfigSpecIpRouteSpec[];

		constructor();
		constructor(ipRoute?: VcNetIpRouteConfigSpecIpRouteSpec[]);
	}

	declare class VcNetIpRouteConfigSpecGatewaySpec
	{
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;

		constructor();
		constructor(ipAddress?: String, device?: String);
	}

	declare class VcNetIpRouteConfigSpecIpRouteSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gateway: VcNetIpRouteConfigSpecGatewaySpec;
		network: String;
		operation: String;
		prefixLength: Number;

		constructor();
		constructor(network?: String, prefixLength?: Number, gateway?: VcNetIpRouteConfigSpecGatewaySpec, operation?: String);
	}

	declare class VcNetIpStackInfo
	{
		defaultRouter: VcNetIpStackInfoDefaultRouter[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		neighbor: VcNetIpStackInfoNetToMedia[];

		constructor();
		constructor(neighbor?: VcNetIpStackInfoNetToMedia[], defaultRouter?: VcNetIpStackInfoDefaultRouter[]);
	}

	declare class VcNetIpStackInfoDefaultRouter
	{
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;
		lifetime: Date;
		preference: String;

		constructor();
		constructor(ipAddress?: String, device?: String, lifetime?: Date, preference?: String);
	}

	interface VcNetIpStackInfoEntryType
	{
		readonly dynamic: VcNetIpStackInfoEntryType;
		readonly id: String;
		readonly invalid: VcNetIpStackInfoEntryType;
		readonly manual: VcNetIpStackInfoEntryType;
		readonly name: String;
		readonly other: VcNetIpStackInfoEntryType;
		readonly value: String;

		fromString(value?: VcNetIpStackInfoEntryType): VcNetIpStackInfoEntryType;
	}

	declare const VcNetIpStackInfoEntryType: VcNetIpStackInfoEntryType;

	declare class VcNetIpStackInfoNetToMedia
	{
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String;
		physicalAddress: String;
		type: String;

		constructor();
		constructor(ipAddress?: String, physicalAddress?: String, device?: String, type?: String);
	}

	interface VcNetIpStackInfoPreference
	{
		readonly high: VcNetIpStackInfoPreference;
		readonly id: String;
		readonly low: VcNetIpStackInfoPreference;
		readonly medium: VcNetIpStackInfoPreference;
		readonly name: String;
		readonly reserved: VcNetIpStackInfoPreference;
		readonly value: String;

		fromString(value?: VcNetIpStackInfoPreference): VcNetIpStackInfoPreference;
	}

	declare const VcNetIpStackInfoPreference: VcNetIpStackInfoPreference;

	declare class VcNetStackInstanceProfile
	{
		copyEnableStatus: boolean;
		dnsConfig: VcNetworkProfileDnsConfigProfile;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		ipRouteConfig: VcIpRouteProfile;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String, dnsConfig?: VcNetworkProfileDnsConfigProfile, ipRouteConfig?: VcIpRouteProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	interface VcNetwork
	{
		accessible: boolean;
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		host: VcHostSystem[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		summary: VcNetworkSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		vm: VcVirtualMachine[];

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		destroyNetwork(): void;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcNetwork: VcNetwork;

	declare class VcNetworkBandwidthAllocationInfo
	{
		distributedVirtualPort: VcDistributedVirtualPort;
		distributedVirtualSwitch: VcDistributedVirtualSwitch;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expandableReservation: boolean;
		inShapingPolicy: VcHostNetworkTrafficShapingPolicy;
		limit: Number;
		outShapingPolicy: VcHostNetworkTrafficShapingPolicy;
		overheadLimit: Number;
		reservation: Number;
		shares: VcSharesInfo;

		constructor();
		constructor(reservation?: Number, expandableReservation?: boolean, limit?: Number, shares?: VcSharesInfo, overheadLimit?: Number, distributedVirtualSwitch?: VcDistributedVirtualSwitch, distributedVirtualPort?: VcDistributedVirtualPort, inShapingPolicy?: VcHostNetworkTrafficShapingPolicy, outShapingPolicy?: VcHostNetworkTrafficShapingPolicy);
		isExpandableReservation(): boolean;
	}

	declare class VcNetworkCopyFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcNetworkDisruptedAndConfigRolledBack
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: String);
		printStackTrace(): void;
	}

	declare class VcNetworkEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		network: VcNetwork;

		constructor();
		constructor(name?: String, network?: VcNetwork);
	}

	interface VcNetworkFolder
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		childEntity: VcManagedEntity[];
		childType: String[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		distributedVirtualSwitch_DistributedVirtualSwitch: Object[];
		distributedVirtualSwitch_VmwareDistributedVirtualSwitch: Object[];
		effectiveRole: Number[];
		folder: Object[];
		folderTypes: Object[];
		id: String;
		name: String;
		network_DistributedVirtualPortgroup: Object[];
		network_Network: Object[];
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		wrappedFolder: VcFolder;

		_getRef(): VcManagedObjectReference;
		addStandaloneHost_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		addStandaloneHostWithAdminDisabled_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		addTag(tag?: VcTag[]): void;
		createCluster(name?: String, spec?: VcClusterConfigSpec): VcClusterComputeResource;
		createClusterEx(name?: String, spec?: VcClusterConfigSpecEx): VcClusterComputeResource;
		createDatacenter(name?: String): VcDatacenter;
		createDVS_Task(spec?: VcDVSCreateSpec): VcTask;
		createFolder(name?: String): VcFolder;
		createStoragePod(name?: String): VcStoragePod;
		createVM_Task(config?: VcVirtualMachineConfigSpec, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		destroy_Task(): VcTask;
		isFolder(type?: String): boolean;
		moveIntoFolder_Task(list?: VcManagedEntity[]): VcTask;
		registerVM_Task(path?: String, name?: String, asTemplate?: boolean, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		reload(): void;
		removeTag(tag?: VcTag[]): void;
		rename_Task(newName?: String): VcTask;
		retrieveCustomValues(keys?: Number[]): VcCustomFieldValue[];
		setCustomValue(key?: String, value?: String): void;
		unregisterAndDestroy_Task(): VcTask;
	}

	interface VcNetworkFolderConstructor {
		new(value?:any): VcNetworkFolder;
		readonly prototype: VcNetworkFolder;
	}

	declare const VcNetworkFolder: VcNetworkFolderConstructor;

	declare class VcNetworkInaccessible
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String);
		printStackTrace(): void;
	}

	interface VcNetworkManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkIfMACAddressInUse(arg0?: String[]): String[];
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		fetchRelocatedMACAddress(): String[];
		reclaimMAC(arg0?: VcServiceLocator[]): String[];
	}

	declare const VcNetworkManager: VcNetworkManager;

	declare class VcNetworkPolicyProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcNetworkProfile
	{
		consoleIpRouteConfig: VcIpRouteProfile;
		copyEnableStatus: boolean;
		dnsConfig: VcNetworkProfileDnsConfigProfile;
		dvsHostNic: VcDvsHostVNicProfile[];
		dvsServiceConsoleNic: VcDvsServiceConsoleVNicProfile[];
		dvswitch: VcDvsProfile[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		hostPortGroup: VcHostPortGroupProfile[];
		ipRouteConfig: VcIpRouteProfile;
		netStackInstance: VcNetStackInstanceProfile[];
		pnic: VcPhysicalNicProfile[];
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		serviceConsolePortGroup: VcServiceConsolePortGroupProfile[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;
		vmPortGroup: VcVmPortGroupProfile[];
		vswitch: VcVirtualSwitchProfile[];

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, vswitch?: VcVirtualSwitchProfile[], vmPortGroup?: VcVmPortGroupProfile[], hostPortGroup?: VcHostPortGroupProfile[], serviceConsolePortGroup?: VcServiceConsolePortGroupProfile[], dnsConfig?: VcNetworkProfileDnsConfigProfile, ipRouteConfig?: VcIpRouteProfile, consoleIpRouteConfig?: VcIpRouteProfile, pnic?: VcPhysicalNicProfile[], dvswitch?: VcDvsProfile[], dvsServiceConsoleNic?: VcDvsServiceConsoleVNicProfile[], dvsHostNic?: VcDvsHostVNicProfile[], netStackInstance?: VcNetStackInstanceProfile[]);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcNetworkProfileDnsConfigProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcNetworkRollbackEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		methodName: String;
		net: VcNetworkEventArgument;
		transactionId: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, methodName?: String, transactionId?: String);
	}

	declare class VcNetworksMayNotBeTheSame
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String);
		printStackTrace(): void;
	}

	declare class VcNetworkSummary
	{
		accessible: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipPoolId: Number;
		ipPoolName: String;
		name: String;
		network: VcNetwork;

		constructor();
		constructor(network?: VcNetwork, name?: String, accessible?: boolean, ipPoolName?: String, ipPoolId?: Number);
	}

	interface VcNfcService
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		nfcFileManagement(arg0?: VcDatastore, arg1?: VcHostSystem): VcHostServiceTicket;
		nfcGetServerNfcLibVersion(arg0?: VcHostSystem): Number;
		nfcGetVmFiles(arg0?: VcVirtualMachine, arg1?: VcHostSystem): VcHostServiceTicket;
		nfcPutVmFiles(arg0?: VcVirtualMachine, arg1?: VcHostSystem): VcHostServiceTicket;
		nfcRandomAccessFile(arg0?: String, arg1?: Number, arg2?: VcHostSystem): VcHostServiceTicket;
		nfcRandomAccessOpenDisk(arg0?: VcVirtualMachine, arg1?: Number, arg2?: VcHostSystem): VcHostServiceTicket;
		nfcRandomAccessOpenReadonly(arg0?: VcVirtualMachine, arg1?: Number, arg2?: VcHostSystem): VcHostServiceTicket;
		nfcSystemManagement(arg0?: VcHostSystem): VcHostServiceTicket;
	}

	declare const VcNfcService: VcNfcService;

	declare class VcNicSettingMismatch
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		numberOfNicsInSpec: Number;
		numberOfNicsInVM: Number;

		constructor();
		constructor(numberOfNicsInSpec?: Number, numberOfNicsInVM?: Number);
		printStackTrace(): void;
	}

	declare class VcNoAccessUserEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ipAddress: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, ipAddress?: String);
	}

	declare class VcNoActiveHostInCluster
	{
		computeResource: VcComputeResource;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(computeResource?: VcComputeResource);
		printStackTrace(): void;
	}

	declare class VcNoAvailableIp
	{
		category: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		id: String;
		label: String;
		readonly localizedMessage: String;
		message: String;
		network: VcNetwork;
		type: String;
		value: String;

		constructor();
		constructor(id?: String, category?: String, label?: String, type?: String, value?: String, network?: VcNetwork);
		printStackTrace(): void;
	}

	declare class VcNoClientCertificate
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoCompatibleDatastore
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoCompatibleHardAffinityHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmName: String;

		constructor();
		constructor(vmName?: String);
		printStackTrace(): void;
	}

	declare class VcNoCompatibleHost
	{
		error: VcLocalizedMethodFault[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem[], error?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcNoCompatibleHostWithAccessToDevice
	{
		error: VcLocalizedMethodFault[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(host?: VcHostSystem[], error?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcNoCompatibleSoftAffinityHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmName: String;

		constructor();
		constructor(vmName?: String);
		printStackTrace(): void;
	}

	declare class VcNoConnectedDatastore
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoDatastoresConfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcNodeDeploymentSpec
	{
		clusterNetworkPortGroup: VcNetwork;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		esxHost: VcHostSystem;
		folder: VcFolder;
		ipSettings: VcCustomizationIPSettings;
		managementVc: VcServiceLocator;
		nodeName: String;
		publicNetworkPortGroup: VcNetwork;
		resourcePool: VcResourcePool;

		constructor();
		constructor(esxHost?: VcHostSystem, datastore?: VcDatastore, publicNetworkPortGroup?: VcNetwork, clusterNetworkPortGroup?: VcNetwork, folder?: VcFolder, resourcePool?: VcResourcePool, managementVc?: VcServiceLocator, nodeName?: String, ipSettings?: VcCustomizationIPSettings);
	}

	declare class VcNodeNetworkSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipSettings: VcCustomizationIPSettings;

		constructor();
		constructor(ipSettings?: VcCustomizationIPSettings);
	}

	declare class VcNoDiskFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoDiskSpace
	{
		datastore: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String, datastore?: String);
		printStackTrace(): void;
	}

	declare class VcNoDisksToCustomize
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoGateway
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoGuestHeartbeat
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String);
		printStackTrace(): void;
	}

	declare class VcNoHostSuitableForFtSecondary
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(vm?: VcVirtualMachine, vmName?: String);
		printStackTrace(): void;
	}

	declare class VcNoLicenseEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		feature: VcLicenseFeatureInfo;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, feature?: VcLicenseFeatureInfo);
	}

	declare class VcNoLicenseServerConfigured
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoMaintenanceModeDrsRecommendationForVM
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcNonADUserRequired
	{
		errorCode: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(errorCode?: Number);
		printStackTrace(): void;
	}

	declare class VcNonHomeRDMVMotionNotSupported
	{
		atSourceHost: boolean;
		device: String;
		failedHost: VcHostSystem;
		failedHostName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHostName?: String, failedHost?: VcHostSystem, device?: String);
		printStackTrace(): void;
	}

	declare class VcNonPersistentDisksNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcNonVIWorkloadDetectedOnDatastoreEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument);
	}

	declare class VcNonVmwareOuiMacNotSupportedHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, hostName?: String);
		printStackTrace(): void;
	}

	declare class VcNoPeerHostFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoPermission
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		object: VcManagedObject;
		privilegeId: String;

		constructor();
		constructor(object?: VcManagedObject, privilegeId?: String);
		printStackTrace(): void;
	}

	declare class VcNoPermissionOnAD
	{
		errorCode: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(errorCode?: Number);
		printStackTrace(): void;
	}

	declare class VcNoPermissionOnHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoPermissionOnNasVolume
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		userName: String;

		constructor();
		constructor(name?: String, userName?: String);
		printStackTrace(): void;
	}

	declare class VcNoRunningPointFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoSubjectName
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNotADirectory
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcNotAFile
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcNotAuthenticated
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		object: VcManagedObject;
		privilegeId: String;

		constructor();
		constructor(object?: VcManagedObject, privilegeId?: String);
		printStackTrace(): void;
	}

	declare class VcNotEnoughCpus
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		numCpuDest: Number;
		numCpuVm: Number;

		constructor();
		constructor(numCpuDest?: Number, numCpuVm?: Number);
		printStackTrace(): void;
	}

	declare class VcNotEnoughLicenses
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNotEnoughLogicalCpus
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;
		numCpuDest: Number;
		numCpuVm: Number;

		constructor();
		constructor(numCpuDest?: Number, numCpuVm?: Number, host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcNotEnoughResourcesToStartVmEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: String);
		constructor();
	}

	declare class VcNotFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNotImplemented
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNotSupportedDeviceForFT
	{
		deviceLabel: String;
		deviceType: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(host?: VcHostSystem, hostName?: String, vm?: VcVirtualMachine, vmName?: String, deviceType?: String, deviceLabel?: String);
		printStackTrace(): void;
	}

	interface VcNotSupportedDeviceForFTDeviceType
	{
		readonly id: String;
		readonly name: String;
		readonly paraVirtualSCSIController: VcNotSupportedDeviceForFTDeviceType;
		readonly value: String;
		readonly virtualVmxnet3: VcNotSupportedDeviceForFTDeviceType;

		fromString(value?: VcNotSupportedDeviceForFTDeviceType): VcNotSupportedDeviceForFTDeviceType;
	}

	declare const VcNotSupportedDeviceForFTDeviceType: VcNotSupportedDeviceForFTDeviceType;

	declare class VcNotSupportedHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String);
		printStackTrace(): void;
	}

	declare class VcNotSupportedHostForChecksum
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNotSupportedHostForVFlash
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, hostName?: String);
		printStackTrace(): void;
	}

	declare class VcNotSupportedHostForVmcp
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, hostName?: String);
		printStackTrace(): void;
	}

	declare class VcNotSupportedHostForVmemFile
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, hostName?: String);
		printStackTrace(): void;
	}

	declare class VcNotSupportedHostForVsan
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, hostName?: String);
		printStackTrace(): void;
	}

	declare class VcNotSupportedHostInCluster
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String);
		printStackTrace(): void;
	}

	declare class VcNotSupportedHostInDvs
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;
		switchProductSpec: VcDistributedVirtualSwitchProductSpec;

		constructor();
		constructor(productName?: String, productVersion?: String, switchProductSpec?: VcDistributedVirtualSwitchProductSpec);
		printStackTrace(): void;
	}

	declare class VcNotSupportedHostInHACluster
	{
		build: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		productName: String;
		productVersion: String;

		constructor();
		constructor(productName?: String, productVersion?: String, hostName?: String, build?: String);
		printStackTrace(): void;
	}

	declare class VcNotUserConfigurableProperty
	{
		category: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		id: String;
		label: String;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(id?: String, category?: String, label?: String, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcNoVcManagedIpConfigured
	{
		category: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		id: String;
		label: String;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(id?: String, category?: String, label?: String, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcNoVirtualNic
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNoVmInVApp
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcNumericRange
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		end: Number;
		start: Number;

		constructor();
		constructor(start?: Number, end?: Number);
	}

	declare class VcNumPortsProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcNumVirtualCoresPerSocketNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		maxSupportedCoresPerSocketDest: Number;
		message: String;
		numCoresPerSocketVm: Number;

		constructor();
		constructor(maxSupportedCoresPerSocketDest?: Number, numCoresPerSocketVm?: Number);
		printStackTrace(): void;
	}

	declare class VcNumVirtualCpusExceedsLimit
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		maxSupportedVcpus: Number;
		message: String;

		constructor();
		constructor(maxSupportedVcpus?: Number);
		printStackTrace(): void;
	}

	declare class VcNumVirtualCpusIncompatible
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		numCpu: Number;
		reason: String;

		constructor();
		constructor(reason?: String, numCpu?: Number);
		printStackTrace(): void;
	}

	interface VcNumVirtualCpusIncompatibleReason
	{
		readonly faultTolerance: VcNumVirtualCpusIncompatibleReason;
		readonly id: String;
		readonly name: String;
		readonly recordReplay: VcNumVirtualCpusIncompatibleReason;
		readonly value: String;

		fromString(value?: VcNumVirtualCpusIncompatibleReason): VcNumVirtualCpusIncompatibleReason;
	}

	declare const VcNumVirtualCpusIncompatibleReason: VcNumVirtualCpusIncompatibleReason;

	declare class VcNumVirtualCpusNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		maxSupportedVcpusDest: Number;
		message: String;
		numCpuVm: Number;

		constructor();
		constructor(maxSupportedVcpusDest?: Number, numCpuVm?: Number);
		printStackTrace(): void;
	}

	declare class VcNvdimmDimmInfo
	{
		availablePersistentCapacity: Number;
		availableVolatileCapacity: Number;
		blockCapacity: Number;
		dimmHandle: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		healthInfo: VcNvdimmHealthInfo;
		persistentCapacity: Number;
		regionInfo: VcNvdimmRegionInfo[];
		totalCapacity: Number;
		volatileCapacity: Number;

		constructor();
		constructor(dimmHandle?: Number, healthInfo?: VcNvdimmHealthInfo, totalCapacity?: Number, persistentCapacity?: Number, availablePersistentCapacity?: Number, volatileCapacity?: Number, availableVolatileCapacity?: Number, blockCapacity?: Number, regionInfo?: VcNvdimmRegionInfo[]);
	}

	declare class VcNvdimmGuid
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		uuid: String;

		constructor();
		constructor(uuid?: String);
	}

	declare class VcNvdimmHealthInfo
	{
		dimmLifespanPercentage: Number;
		dimmTemperature: Number;
		dimmTemperatureThreshold: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		esLifespanPercentage: Number;
		esTemperature: Number;
		esTemperatureThreshold: Number;
		healthInformation: String;
		healthStatus: String;
		spareBlocksPercentage: Number;
		spareBlockThreshold: Number;
		stateFlagInfo: String[];

		constructor();
		constructor(healthStatus?: String, healthInformation?: String, stateFlagInfo?: String[], dimmTemperature?: Number, dimmTemperatureThreshold?: Number, spareBlocksPercentage?: Number, spareBlockThreshold?: Number, dimmLifespanPercentage?: Number, esTemperature?: Number, esTemperatureThreshold?: Number, esLifespanPercentage?: Number);
	}

	interface VcNvdimmHealthStatus
	{
		readonly critical: VcNvdimmHealthStatus;
		readonly fatal: VcNvdimmHealthStatus;
		readonly id: String;
		readonly name: String;
		readonly noncritical: VcNvdimmHealthStatus;
		readonly normal: VcNvdimmHealthStatus;
		readonly value: String;

		fromString(value?: VcNvdimmHealthStatus): VcNvdimmHealthStatus;
	}

	declare const VcNvdimmHealthStatus: VcNvdimmHealthStatus;

	declare class VcNvdimmInterleaveSetInfo
	{
		availableSize: Number;
		baseAddress: Number;
		deviceList: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		rangeType: String;
		setId: Number;
		size: Number;
		state: String;

		constructor();
		constructor(setId?: Number, rangeType?: String, baseAddress?: Number, size?: Number, availableSize?: Number, deviceList?: Number[], state?: String);
	}

	declare class VcNvdimmNamespaceCreateSpec
	{
		blockCount: Number;
		blockSize: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		friendlyName: String;
		locationID: Number;
		type: String;

		constructor();
		constructor(friendlyName?: String, blockSize?: Number, blockCount?: Number, type?: String, locationID?: Number);
	}

	declare class VcNvdimmNamespaceDeleteSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		uuid: String;

		constructor();
		constructor(uuid?: String);
	}

	interface VcNvdimmNamespaceHealthStatus
	{
		readonly badBlockSize: VcNvdimmNamespaceHealthStatus;
		readonly bttCorrupt: VcNvdimmNamespaceHealthStatus;
		readonly id: String;
		readonly interleaveBroken: VcNvdimmNamespaceHealthStatus;
		readonly labelInconsistent: VcNvdimmNamespaceHealthStatus;
		readonly labelMissing: VcNvdimmNamespaceHealthStatus;
		readonly missing: VcNvdimmNamespaceHealthStatus;
		readonly name: String;
		readonly normal: VcNvdimmNamespaceHealthStatus;
		readonly value: String;

		fromString(value?: VcNvdimmNamespaceHealthStatus): VcNvdimmNamespaceHealthStatus;
	}

	declare const VcNvdimmNamespaceHealthStatus: VcNvdimmNamespaceHealthStatus;

	declare class VcNvdimmNamespaceInfo
	{
		blockCount: Number;
		blockSize: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		friendlyName: String;
		locationID: Number;
		namespaceHealthStatus: String;
		state: String;
		type: String;
		uuid: String;

		constructor();
		constructor(uuid?: String, friendlyName?: String, blockSize?: Number, blockCount?: Number, type?: String, namespaceHealthStatus?: String, locationID?: Number, state?: String);
	}

	interface VcNvdimmNamespaceType
	{
		readonly blockNamespace: VcNvdimmNamespaceType;
		readonly id: String;
		readonly name: String;
		readonly persistentNamespace: VcNvdimmNamespaceType;
		readonly value: String;

		fromString(value?: VcNvdimmNamespaceType): VcNvdimmNamespaceType;
	}

	declare const VcNvdimmNamespaceType: VcNvdimmNamespaceType;

	interface VcNvdimmNvdimmHealthInfoState
	{
		readonly error: VcNvdimmNvdimmHealthInfoState;
		readonly id: String;
		readonly name: String;
		readonly normal: VcNvdimmNvdimmHealthInfoState;
		readonly value: String;

		fromString(value?: VcNvdimmNvdimmHealthInfoState): VcNvdimmNvdimmHealthInfoState;
	}

	declare const VcNvdimmNvdimmHealthInfoState: VcNvdimmNvdimmHealthInfoState;

	interface VcNvdimmRangeType
	{
		readonly blockRange: VcNvdimmRangeType;
		readonly controlRange: VcNvdimmRangeType;
		readonly id: String;
		readonly name: String;
		readonly persistentRange: VcNvdimmRangeType;
		readonly persistentVirtualCDRange: VcNvdimmRangeType;
		readonly persistentVirtualDiskRange: VcNvdimmRangeType;
		readonly value: String;
		readonly volatileRange: VcNvdimmRangeType;
		readonly volatileVirtualCDRange: VcNvdimmRangeType;
		readonly volatileVirtualDiskRange: VcNvdimmRangeType;

		fromString(value?: VcNvdimmRangeType): VcNvdimmRangeType;
	}

	declare const VcNvdimmRangeType: VcNvdimmRangeType;

	declare class VcNvdimmRegionInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		offset: Number;
		rangeType: String;
		regionId: Number;
		setId: Number;
		size: Number;
		startAddr: Number;

		constructor();
		constructor(regionId?: Number, setId?: Number, rangeType?: String, startAddr?: Number, size?: Number, offset?: Number);
	}

	interface VcNvdimmState
	{
		readonly id: String;
		readonly invalid: VcNvdimmState;
		readonly name: String;
		readonly unusable: VcNvdimmState;
		readonly usable: VcNvdimmState;
		readonly value: String;

		fromString(value?: VcNvdimmState): VcNvdimmState;
	}

	declare const VcNvdimmState: VcNvdimmState;

	declare class VcNvdimmSummary
	{
		availableCapacity: Number;
		blockCapacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		healthStatus: String;
		numDimms: Number;
		numInterleavesets: Number;
		numNamespaces: Number;
		persistentCapacity: Number;
		totalCapacity: Number;

		constructor();
		constructor(numDimms?: Number, healthStatus?: String, totalCapacity?: Number, persistentCapacity?: Number, blockCapacity?: Number, availableCapacity?: Number, numInterleavesets?: Number, numNamespaces?: Number);
	}

	declare class VcNvdimmSystemInfo
	{
		dimmInfo: VcNvdimmDimmInfo[];
		dimms: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		interleaveSet: Number[];
		iSetInfo: VcNvdimmInterleaveSetInfo[];
		namespace: VcNvdimmGuid[];
		nsInfo: VcNvdimmNamespaceInfo[];
		summary: VcNvdimmSummary;

		constructor();
		constructor(summary?: VcNvdimmSummary, dimms?: Number[], dimmInfo?: VcNvdimmDimmInfo[], interleaveSet?: Number[], iSetInfo?: VcNvdimmInterleaveSetInfo[], namespace?: VcNvdimmGuid[], nsInfo?: VcNvdimmNamespaceInfo[]);
	}

	declare class VcObjectContent
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		missingSet: VcMissingProperty[];
		obj: VcManagedObject;
		propSet: VcDynamicProperty[];

		constructor();
		constructor(obj?: VcManagedObject, propSet?: VcDynamicProperty[], missingSet?: VcMissingProperty[]);
	}

	declare class VcObjectInfo
	{
		createTime: Date;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcID;
		name: String;

		constructor();
		constructor(id?: VcID, datastore?: VcDatastore, name?: String, createTime?: Date);
	}

	declare class VcObjectSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		obj: VcManagedObject;
		selectSet: VcSelectionSpec[];
		skip: boolean;

		constructor();
		constructor(obj?: VcManagedObject, skip?: boolean, selectSet?: VcSelectionSpec[]);
		isSkip(): boolean;
	}

	declare class VcObjectUpdate
	{
		changeSet: VcPropertyChange[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		kind: VcObjectUpdateKind;
		missingSet: VcMissingProperty[];
		obj: VcManagedObject;

		constructor();
		constructor(kind?: VcObjectUpdateKind, obj?: VcManagedObject, changeSet?: VcPropertyChange[], missingSet?: VcMissingProperty[]);
	}

	interface VcObjectUpdateKind
	{
		readonly enter: VcObjectUpdateKind;
		readonly id: String;
		readonly leave: VcObjectUpdateKind;
		readonly modify: VcObjectUpdateKind;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcObjectUpdateKind): VcObjectUpdateKind;
	}

	declare const VcObjectUpdateKind: VcObjectUpdateKind;

	declare class VcOnceTaskScheduler
	{
		activeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expireTime: Date;
		runAt: Date;

		constructor();
		constructor(activeTime?: Date, expireTime?: Date, runAt?: Date);
	}

	interface VcOpaqueNetwork
	{
		accessible: boolean;
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		capability: VcOpaqueNetworkCapability;
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		extraConfig: VcOptionValue[];
		readonly host: VcHostSystem[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly summary: VcNetworkSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		readonly vm: VcVirtualMachine[];

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		destroyNetwork(): void;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcOpaqueNetwork: VcOpaqueNetwork;

	declare class VcOpaqueNetworkCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		networkReservationSupported: boolean;

		constructor();
		constructor(networkReservationSupported?: boolean);
	}

	declare class VcOpaqueNetworkSummary
	{
		accessible: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipPoolId: Number;
		ipPoolName: String;
		name: String;
		network: VcNetwork;
		opaqueNetworkId: String;
		opaqueNetworkType: String;

		constructor();
		constructor(network?: VcNetwork, name?: String, accessible?: boolean, ipPoolName?: String, ipPoolId?: Number, opaqueNetworkId?: String, opaqueNetworkType?: String);
	}

	declare class VcOpaqueNetworkTargetInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		network: VcOpaqueNetworkSummary;
		networkReservationSupported: boolean;

		constructor();
		constructor(name?: String, configurationTag?: String[], network?: VcOpaqueNetworkSummary, networkReservationSupported?: boolean);
		isNetworkReservationSupported(): boolean;
	}

	declare class VcOperationDisabledByGuest
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOperationDisallowedOnHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOperationNotSupportedByGuest
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOptionDef
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		label: String;
		optionType: VcOptionType;
		summary: String;

		constructor();
		constructor(label?: String, summary?: String, key?: String, optionType?: VcOptionType);
	}

	interface VcOptionManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		setting: VcOptionValue[];
		supportedOption: VcOptionDef[];
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryOptions(arg0?: String): VcOptionValue[];
		updateOptions(arg0?: VcOptionValue[]): void;
	}

	declare const VcOptionManager: VcOptionManager;

	declare class VcOptionProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcOptionType
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		valueIsReadonly: boolean;

		constructor();
		constructor(valueIsReadonly?: boolean);
		isValueIsReadonly(): boolean;
	}

	declare class VcOptionValue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		value_AnyValue: Object;
		value_FloatValue: Number;
		value_IntValue: Number;
		value_LongValue: Number;

		constructor();
		constructor(key?: String, value?: Object);
	}

	declare class VcOrAlarmExpression
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expression: VcAlarmExpression[];

		constructor();
		constructor(expression?: VcAlarmExpression[]);
	}

	declare class VcOutOfBounds
	{
		argumentName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(argumentName?: String);
		printStackTrace(): void;
	}

	declare class VcOutOfSyncDvsHost
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostOutOfSync: VcDvsOutOfSyncHostArgument[];
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostOutOfSync?: VcDvsOutOfSyncHostArgument[]);
	}

	interface VcOverheadMemoryManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		lookupVmOverheadMemory(arg0?: VcVirtualMachine, arg1?: VcHostSystem): Number;
	}

	declare const VcOverheadMemoryManager: VcOverheadMemoryManager;

	interface VcOverheadService
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcOverheadService: VcOverheadService;

	declare class VcOvfAttribute
	{
		attributeName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(lineNumber?: Number, elementName?: String, attributeName?: String);
		printStackTrace(): void;
	}

	declare class VcOvfConnectedDevice
	{
		device: VcVirtualDevice;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmPath: String;

		constructor();
		constructor(device?: VcVirtualDevice, vmPath?: String);
		printStackTrace(): void;
	}

	declare class VcOvfConnectedDeviceFloppy
	{
		device: VcVirtualDevice;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		filename: String;
		readonly localizedMessage: String;
		message: String;
		vmPath: String;

		constructor();
		constructor(device?: VcVirtualDevice, vmPath?: String, filename?: String);
		printStackTrace(): void;
	}

	declare class VcOvfConnectedDeviceIso
	{
		device: VcVirtualDevice;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		filename: String;
		readonly localizedMessage: String;
		message: String;
		vmPath: String;

		constructor();
		constructor(device?: VcVirtualDevice, vmPath?: String, filename?: String);
		printStackTrace(): void;
	}

	declare class VcOvfConstraint
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String);
		printStackTrace(): void;
	}

	interface VcOvfConsumer
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		annotateOst(arg0?: VcOvfConsumerContext, arg1?: VcOvfConsumerOstNode, arg2?: VcOvfConsumerOstNode, arg3?: VcKeyValue[]): VcOvfConsumerOstResult;
		cloneEntities(arg0?: VcOvfConsumerContext, arg1?: VcOvfConsumerOstNode, arg2?: VcOvfConsumerOstNode): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		notifyPowerOn(arg0?: VcVirtualMachine, arg1?: VcVirtualApp): String[];
		populateEntityOst(arg0?: VcOvfConsumerContext, arg1?: VcOvfConsumerOstNode): VcOvfConsumerOstResult;
		registerEntities(arg0?: VcOvfConsumerContext, arg1?: VcOvfConsumerOstNode): void;
		retrievePublicOvfEnvironmentSections(arg0?: VcVirtualMachine, arg1?: VcVirtualApp): String[];
		unregisterEntities(arg0?: VcOvfConsumerContext, arg1?: VcManagedEntity[]): void;
		validateInstantiationOst(arg0?: VcOvfConsumerContext, arg1?: VcOvfConsumerOstNode): void;
	}

	declare const VcOvfConsumer: VcOvfConsumer;

	declare class VcOvfConsumerCallbackFault
	{
		extensionKey: String;
		extensionName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(extensionKey?: String, extensionName?: String);
		printStackTrace(): void;
	}

	declare class VcOvfConsumerCommunicationError
	{
		description: String;
		extensionKey: String;
		extensionName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(extensionKey?: String, extensionName?: String, description?: String);
		printStackTrace(): void;
	}

	declare class VcOvfConsumerContext
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		locale: String;
		sessionId: String;
		userName: String;

		constructor();
		constructor(sessionId?: String, userName?: String, locale?: String);
	}

	declare class VcOvfConsumerFault
	{
		errorKey: String;
		extensionKey: String;
		extensionName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		params: VcKeyValue[];

		constructor();
		constructor(extensionKey?: String, extensionName?: String, errorKey?: String, message?: String, params?: VcKeyValue[]);
		printStackTrace(): void;
	}

	declare class VcOvfConsumerInvalidSection
	{
		description: String;
		extensionKey: String;
		extensionName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(extensionKey?: String, extensionName?: String, lineNumber?: Number, description?: String);
		printStackTrace(): void;
	}

	declare class VcOvfConsumerOstNode
	{
		child: VcOvfConsumerOstNode[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		id: String;
		section: VcOvfConsumerOvfSection[];
		type: String;

		constructor();
		constructor(id?: String, type?: String, section?: VcOvfConsumerOvfSection[], child?: VcOvfConsumerOstNode[], entity?: VcManagedEntity);
	}

	interface VcOvfConsumerOstNodeType
	{
		readonly envelope: VcOvfConsumerOstNodeType;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly virtualSystem: VcOvfConsumerOstNodeType;
		readonly virtualSystemCollection: VcOvfConsumerOstNodeType;

		fromString(value?: VcOvfConsumerOstNodeType): VcOvfConsumerOstNodeType;
	}

	declare const VcOvfConsumerOstNodeType: VcOvfConsumerOstNodeType;

	declare class VcOvfConsumerOstResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault[];
		tree: VcOvfConsumerOstNode;
		warning: VcLocalizedMethodFault[];

		constructor();
		constructor(error?: VcLocalizedMethodFault[], warning?: VcLocalizedMethodFault[], tree?: VcOvfConsumerOstNode);
	}

	declare class VcOvfConsumerOvfSection
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lineNumber: Number;
		xml: String;

		constructor();
		constructor(lineNumber?: Number, xml?: String);
	}

	declare class VcOvfConsumerPowerOnFault
	{
		description: String;
		extensionKey: String;
		extensionName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(extensionKey?: String, extensionName?: String, description?: String);
		printStackTrace(): void;
	}

	declare class VcOvfConsumerResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault[];
		warning: VcLocalizedMethodFault[];

		constructor();
		constructor(error?: VcLocalizedMethodFault[], warning?: VcLocalizedMethodFault[]);
	}

	declare class VcOvfConsumerUndeclaredSection
	{
		extensionKey: String;
		extensionName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		qualifiedSectionType: String;

		constructor();
		constructor(extensionKey?: String, extensionName?: String, qualifiedSectionType?: String);
		printStackTrace(): void;
	}

	declare class VcOvfConsumerUndefinedPrefix
	{
		extensionKey: String;
		extensionName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		prefix: String;

		constructor();
		constructor(extensionKey?: String, extensionName?: String, prefix?: String);
		printStackTrace(): void;
	}

	declare class VcOvfConsumerValidationFault
	{
		extensionKey: String;
		extensionName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(extensionKey?: String, extensionName?: String, message?: String);
		printStackTrace(): void;
	}

	declare class VcOvfCpuCompatibility
	{
		desiredRegisterValue: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		level: Number;
		readonly localizedMessage: String;
		message: String;
		registerName: String;
		registerValue: String;

		constructor();
		constructor(registerName?: String, level?: Number, registerValue?: String, desiredRegisterValue?: String);
		printStackTrace(): void;
	}

	declare class VcOvfCpuCompatibilityCheckNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfCreateDescriptorParams
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		exportOption: String[];
		includeImageFiles: boolean;
		name: String;
		ovfFiles: VcOvfFile[];
		snapshot: VcVirtualMachineSnapshot;

		constructor();
		constructor(ovfFiles?: VcOvfFile[], name?: String, description?: String, includeImageFiles?: boolean, exportOption?: String[], snapshot?: VcVirtualMachineSnapshot);
		isIncludeImageFiles(): boolean;
	}

	declare class VcOvfCreateDescriptorResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault[];
		includeImageFiles: boolean;
		ovfDescriptor: String;
		warning: VcLocalizedMethodFault[];

		constructor();
		constructor(ovfDescriptor?: String, error?: VcLocalizedMethodFault[], warning?: VcLocalizedMethodFault[], includeImageFiles?: boolean);
		isIncludeImageFiles(): boolean;
	}

	declare class VcOvfCreateImportSpecParams
	{
		deploymentOption: String;
		diskProvisioning: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityName: String;
		hostSystem: VcHostSystem;
		importOption: String[];
		instantiationOst: VcOvfConsumerOstNode;
		ipAllocationPolicy: String;
		ipProtocol: String;
		locale: String;
		msgBundle: VcKeyValue[];
		networkMapping: VcOvfNetworkMapping[];
		propertyMapping: VcKeyValue[];
		resourceMapping: VcOvfResourceMap[];

		constructor();
		constructor(locale?: String, deploymentOption?: String, msgBundle?: VcKeyValue[], importOption?: String[], entityName?: String, hostSystem?: VcHostSystem, networkMapping?: VcOvfNetworkMapping[], ipAllocationPolicy?: String, ipProtocol?: String, propertyMapping?: VcKeyValue[], resourceMapping?: VcOvfResourceMap[], diskProvisioning?: String, instantiationOst?: VcOvfConsumerOstNode);
	}

	interface VcOvfCreateImportSpecParamsDiskProvisioningType
	{
		readonly eagerZeroedThick: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly flat: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly id: String;
		readonly monolithicFlat: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly monolithicSparse: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly name: String;
		readonly seSparse: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly sparse: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly thick: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly thin: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly twoGbMaxExtentFlat: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly twoGbMaxExtentSparse: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly value: String;

		fromString(value?: VcOvfCreateImportSpecParamsDiskProvisioningType): VcOvfCreateImportSpecParamsDiskProvisioningType;
	}

	declare const VcOvfCreateImportSpecParamsDiskProvisioningType: VcOvfCreateImportSpecParamsDiskProvisioningType;

	declare class VcOvfCreateImportSpecResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault[];
		fileItem: VcOvfFileItem[];
		importSpec: VcImportSpec;
		warning: VcLocalizedMethodFault[];

		constructor();
		constructor(importSpec?: VcImportSpec, fileItem?: VcOvfFileItem[], warning?: VcLocalizedMethodFault[], error?: VcLocalizedMethodFault[]);
	}

	declare class VcOvfDeploymentOption
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		label: String;

		constructor();
		constructor(key?: String, label?: String, description?: String);
	}

	declare class VcOvfDiskMappingNotFound
	{
		diskName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmName: String;

		constructor();
		constructor(diskName?: String, vmName?: String);
		printStackTrace(): void;
	}

	declare class VcOvfDiskOrderConstraint
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String);
		printStackTrace(): void;
	}

	declare class VcOvfDuplicatedElementBoundary
	{
		boundary: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String, boundary?: String);
		printStackTrace(): void;
	}

	declare class VcOvfDuplicatedPropertyIdExport
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		fqid: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(fqid?: String);
		printStackTrace(): void;
	}

	declare class VcOvfDuplicatedPropertyIdImport
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfDuplicateElement
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String);
		printStackTrace(): void;
	}

	declare class VcOvfElement
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String);
		printStackTrace(): void;
	}

	declare class VcOvfElementInvalidValue
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, name?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfExport
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfExportFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfFile
	{
		capacity: Number;
		chunkSize: Number;
		compressionMethod: String;
		deviceId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		path: String;
		populatedSize: Number;
		size: Number;

		constructor(deviceId?: String, path?: String, compressionMethod?: String, chunkSize?: Number, size?: Number, capacity?: Number, populatedSize?: Number);
		constructor();
	}

	declare class VcOvfFileItem
	{
		chunkSize: Number;
		cimType: Number;
		compressionMethod: String;
		create: boolean;
		deviceId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		path: String;
		size: Number;

		constructor(deviceId?: String, path?: String, compressionMethod?: String, chunkSize?: Number, size?: Number, cimType?: Number, create?: boolean);
		constructor();
	}

	declare class VcOvfHardwareCheck
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfHardwareExport
	{
		device: VcVirtualDevice;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmPath: String;

		constructor();
		constructor(device?: VcVirtualDevice, vmPath?: String);
		printStackTrace(): void;
	}

	declare class VcOvfHostResourceConstraint
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, name?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfHostValueNotParsed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;
		value: String;

		constructor();
		constructor(property?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfImport
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfImportFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfInternalError
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfInvalidPackage
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;

		constructor(lineNumber?: Number);
		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfInvalidValue
	{
		attributeName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, elementName?: String, attributeName?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfInvalidValueConfiguration
	{
		attributeName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, elementName?: String, attributeName?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfInvalidValueEmpty
	{
		attributeName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, elementName?: String, attributeName?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfInvalidValueFormatMalformed
	{
		attributeName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, elementName?: String, attributeName?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfInvalidValueReference
	{
		attributeName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, elementName?: String, attributeName?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfInvalidVmName
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String);
		printStackTrace(): void;
	}

	interface VcOvfManager
	{
		id: String;
		moref: VcManagedObjectReference;
		ovfExportOption: VcOvfOptionInfo[];
		ovfImportOption: VcOvfOptionInfo[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createDescriptor(arg0?: VcManagedEntity, arg1?: VcOvfCreateDescriptorParams): VcOvfCreateDescriptorResult;
		createImportSpec(arg0?: String, arg1?: VcResourcePool, arg2?: VcDatastore, arg3?: VcOvfCreateImportSpecParams): VcOvfCreateImportSpecResult;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		exportOvfToUrl_Task(arg0?: VcManagedEntity, arg1?: String, arg2?: VcKeyValue[], arg3?: String): VcTask;
		importOvfAtUrl_Task(arg0?: String, arg1?: VcOvfCreateImportSpecParams, arg2?: VcFolder, arg3?: VcResourcePool, arg4?: VcDatastore, arg5?: VcKeyValue[], arg6?: String): VcTask;
		parseDescriptor(arg0?: String, arg1?: VcOvfParseDescriptorParams): VcOvfParseDescriptorResult;
		parseDescriptorAtUrl_Task(arg0?: String, arg1?: VcOvfParseDescriptorParams, arg2?: VcKeyValue[], arg3?: String): VcTask;
		validateHost(arg0?: String, arg1?: VcHostSystem, arg2?: VcOvfValidateHostParams): VcOvfValidateHostResult;
	}

	declare const VcOvfManager: VcOvfManager;

	declare class VcOvfManagerCommonParams
	{
		deploymentOption: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		importOption: String[];
		locale: String;
		msgBundle: VcKeyValue[];

		constructor();
		constructor(locale?: String, deploymentOption?: String, msgBundle?: VcKeyValue[], importOption?: String[]);
	}

	declare class VcOvfMappedOsId
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		ovfDescription: String;
		ovfId: Number;
		targetDescription: String;

		constructor();
		constructor(ovfId?: Number, ovfDescription?: String, targetDescription?: String);
		printStackTrace(): void;
	}

	declare class VcOvfMissingAttribute
	{
		attributeName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(lineNumber?: Number, elementName?: String, attributeName?: String);
		printStackTrace(): void;
	}

	declare class VcOvfMissingElement
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String);
		printStackTrace(): void;
	}

	declare class VcOvfMissingElementNormalBoundary
	{
		boundary: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String, boundary?: String);
		printStackTrace(): void;
	}

	declare class VcOvfMissingHardware
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		resourceType: Number;

		constructor();
		constructor(name?: String, resourceType?: Number);
		printStackTrace(): void;
	}

	declare class VcOvfNetworkInfo
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, description?: String);
	}

	declare class VcOvfNetworkMapping
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		network: VcNetwork;

		constructor();
		constructor(name?: String, network?: VcNetwork);
	}

	declare class VcOvfNetworkMappingNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfNoHostNic
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(lineNumber?: Number);
		printStackTrace(): void;
	}

	declare class VcOvfNoSpaceOnController
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;
		parent: String;

		constructor();
		constructor(lineNumber?: Number, name?: String, parent?: String);
		printStackTrace(): void;
	}

	declare class VcOvfNoSupportedHardwareFamily
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		version: String;

		constructor();
		constructor(lineNumber?: Number, version?: String);
		printStackTrace(): void;
	}

	declare class VcOvfOptionInfo
	{
		description: VcLocalizableMessage;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		option: String;

		constructor();
		constructor(option?: String, description?: VcLocalizableMessage);
	}

	declare class VcOvfParseDescriptorParams
	{
		deploymentOption: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		importOption: String[];
		locale: String;
		msgBundle: VcKeyValue[];

		constructor();
		constructor(locale?: String, deploymentOption?: String, msgBundle?: VcKeyValue[], importOption?: String[]);
	}

	declare class VcOvfParseDescriptorResult
	{
		annotatedOst: VcOvfConsumerOstNode;
		annotation: String;
		approximateDownloadSize: Number;
		approximateFlatDeploymentSize: Number;
		approximateSparseDeploymentSize: Number;
		defaultDeploymentOption: String;
		defaultEntityName: String;
		deploymentOption: VcOvfDeploymentOption[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityName: VcKeyValue[];
		error: VcLocalizedMethodFault[];
		eula: String[];
		ipAllocationScheme: String[];
		ipProtocols: String[];
		network: VcOvfNetworkInfo[];
		productInfo: VcVAppProductInfo;
		property: VcVAppPropertyInfo[];
		virtualApp: boolean;
		warning: VcLocalizedMethodFault[];

		constructor();
		constructor(eula?: String[], network?: VcOvfNetworkInfo[], ipAllocationScheme?: String[], ipProtocols?: String[], property?: VcVAppPropertyInfo[], productInfo?: VcVAppProductInfo, annotation?: String, approximateDownloadSize?: Number, approximateFlatDeploymentSize?: Number, approximateSparseDeploymentSize?: Number, defaultEntityName?: String, virtualApp?: boolean, deploymentOption?: VcOvfDeploymentOption[], defaultDeploymentOption?: String, entityName?: VcKeyValue[], annotatedOst?: VcOvfConsumerOstNode, error?: VcLocalizedMethodFault[], warning?: VcLocalizedMethodFault[]);
	}

	declare class VcOvfProperty
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfPropertyExport
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfPropertyNetwork
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfPropertyNetworkExport
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		network: String;

		constructor();
		constructor(network?: String);
		printStackTrace(): void;
	}

	declare class VcOvfPropertyQualifier
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		qualifier: String;
		type: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, type?: String, value?: String, qualifier?: String);
		printStackTrace(): void;
	}

	declare class VcOvfPropertyQualifierDuplicate
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		qualifier: String;
		type: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, type?: String, value?: String, qualifier?: String);
		printStackTrace(): void;
	}

	declare class VcOvfPropertyQualifierIgnored
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		qualifier: String;
		type: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, type?: String, value?: String, qualifier?: String);
		printStackTrace(): void;
	}

	declare class VcOvfPropertyType
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfPropertyValue
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfResourceMap
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parent: VcResourcePool;
		resourceSpec: VcResourceConfigSpec;
		source: String;

		constructor();
		constructor(source?: String, parent?: VcResourcePool, resourceSpec?: VcResourceConfigSpec, datastore?: VcDatastore);
	}

	declare class VcOvfSystemFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfToXmlUnsupportedElement
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnableToExportDisk
	{
		device: VcVirtualDevice;
		diskName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmPath: String;

		constructor();
		constructor(device?: VcVirtualDevice, vmPath?: String, diskName?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnexpectedElement
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnknownDevice
	{
		device: VcVirtualDevice;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmName: String;

		constructor();
		constructor(device?: VcVirtualDevice, vmName?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnknownDeviceBacking
	{
		backing: VcVirtualDeviceBackingInfo;
		device: VcVirtualDevice;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmPath: String;

		constructor();
		constructor(device?: VcVirtualDevice, vmPath?: String, backing?: VcVirtualDeviceBackingInfo);
		printStackTrace(): void;
	}

	declare class VcOvfUnknownEntity
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;

		constructor(lineNumber?: Number);
		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedAttribute
	{
		attributeName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(lineNumber?: Number, elementName?: String, attributeName?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedAttributeValue
	{
		attributeName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, elementName?: String, attributeName?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedDeviceBackingInfo
	{
		backingName: String;
		deviceName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		instanceId: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(elementName?: String, instanceId?: String, deviceName?: String, backingName?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedDeviceBackingOption
	{
		backingName: String;
		deviceName: String;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		instanceId: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(elementName?: String, instanceId?: String, deviceName?: String, backingName?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedDeviceExport
	{
		device: VcVirtualDevice;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmPath: String;

		constructor();
		constructor(device?: VcVirtualDevice, vmPath?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedDiskProvisioning
	{
		diskProvisioning: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		supportedDiskProvisioning: String;

		constructor();
		constructor(diskProvisioning?: String, supportedDiskProvisioning?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedElement
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedElementValue
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;
		value: String;

		constructor();
		constructor(lineNumber?: Number, name?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedPackage
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;

		constructor(lineNumber?: Number);
		constructor();
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedSection
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		info: String;
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String, info?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedSubType
	{
		deviceSubType: String;
		deviceType: Number;
		elementName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		instanceId: String;
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(lineNumber?: Number, elementName?: String, instanceId?: String, deviceType?: Number, deviceSubType?: String);
		printStackTrace(): void;
	}

	declare class VcOvfUnsupportedType
	{
		deviceType: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		instanceId: String;
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String, instanceId?: String, deviceType?: Number);
		printStackTrace(): void;
	}

	declare class VcOvfValidateHostParams
	{
		deploymentOption: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		importOption: String[];
		locale: String;
		msgBundle: VcKeyValue[];

		constructor();
		constructor(locale?: String, deploymentOption?: String, msgBundle?: VcKeyValue[], importOption?: String[]);
	}

	declare class VcOvfValidateHostResult
	{
		downloadSize: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault[];
		flatDeploymentSize: Number;
		sparseDeploymentSize: Number;
		supportedDiskProvisioning: String[];
		warning: VcLocalizedMethodFault[];

		constructor();
		constructor(downloadSize?: Number, flatDeploymentSize?: Number, sparseDeploymentSize?: Number, error?: VcLocalizedMethodFault[], warning?: VcLocalizedMethodFault[], supportedDiskProvisioning?: String[]);
	}

	declare class VcOvfWrongElement
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(lineNumber?: Number, name?: String);
		printStackTrace(): void;
	}

	declare class VcOvfWrongNamespace
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;
		namespaceName: String;

		constructor();
		constructor(lineNumber?: Number, namespaceName?: String);
		printStackTrace(): void;
	}

	declare class VcOvfXmlFormat
	{
		description: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		lineNumber: Number;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(lineNumber?: Number, description?: String);
		printStackTrace(): void;
	}

	declare class VcParaVirtualSCSIController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotAddRemove: boolean;
		key: Number;
		scsiCtlrUnitNumber: Number;
		sharedBus: VcVirtualSCSISharing;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[], hotAddRemove?: boolean, sharedBus?: VcVirtualSCSISharing, scsiCtlrUnitNumber?: Number);
		isHotAddRemove(): boolean;
	}

	declare class VcParaVirtualSCSIControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		defaultSharedIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotAddRemove: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSCSICdroms: VcIntOption;
		numSCSIDisks: VcIntOption;
		numSCSIPassthrough: VcIntOption;
		plugAndPlay: boolean;
		scsiCtlrUnitNumber: Number;
		sharing: VcVirtualSCSISharing[];
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numSCSIDisks?: VcIntOption, numSCSICdroms?: VcIntOption, numSCSIPassthrough?: VcIntOption, sharing?: VcVirtualSCSISharing[], defaultSharedIndex?: Number, hotAddRemove?: VcBoolOption, scsiCtlrUnitNumber?: Number);
		isHotRemoveSupported(): boolean;
	}

	declare class VcPassiveNodeDeploymentSpec
	{
		clusterNetworkPortGroup: VcNetwork;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		esxHost: VcHostSystem;
		failoverIpSettings: VcCustomizationIPSettings;
		folder: VcFolder;
		ipSettings: VcCustomizationIPSettings;
		managementVc: VcServiceLocator;
		nodeName: String;
		publicNetworkPortGroup: VcNetwork;
		resourcePool: VcResourcePool;

		constructor();
		constructor(esxHost?: VcHostSystem, datastore?: VcDatastore, publicNetworkPortGroup?: VcNetwork, clusterNetworkPortGroup?: VcNetwork, folder?: VcFolder, resourcePool?: VcResourcePool, managementVc?: VcServiceLocator, nodeName?: String, ipSettings?: VcCustomizationIPSettings, failoverIpSettings?: VcCustomizationIPSettings);
	}

	declare class VcPassiveNodeNetworkSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failoverIpSettings: VcCustomizationIPSettings;
		ipSettings: VcCustomizationIPSettings;

		constructor();
		constructor(ipSettings?: VcCustomizationIPSettings, failoverIpSettings?: VcCustomizationIPSettings);
	}

	declare class VcPasswordField
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		value: String;

		constructor();
		constructor(value?: String);
	}

	declare class VcPatchAlreadyInstalled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		patchID: String;

		constructor();
		constructor(patchID?: String);
		printStackTrace(): void;
	}

	declare class VcPatchBinariesNotFound
	{
		binary: String[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		patchID: String;

		constructor();
		constructor(patchID?: String, binary?: String[]);
		printStackTrace(): void;
	}

	declare class VcPatchInstallFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		rolledBack: boolean;
		text: String;

		constructor();
		constructor(text?: String, rolledBack?: boolean);
		printStackTrace(): void;
	}

	declare class VcPatchIntegrityError
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		text: String;

		constructor();
		constructor(text?: String);
		printStackTrace(): void;
	}

	declare class VcPatchMetadataCorrupted
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		metaData: String[];
		patchID: String;

		constructor();
		constructor(patchID?: String, metaData?: String[]);
		printStackTrace(): void;
	}

	declare class VcPatchMetadataInvalid
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		metaData: String[];
		patchID: String;

		constructor();
		constructor(patchID?: String, metaData?: String[]);
		printStackTrace(): void;
	}

	declare class VcPatchMetadataNotFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		metaData: String[];
		patchID: String;

		constructor();
		constructor(patchID?: String, metaData?: String[]);
		printStackTrace(): void;
	}

	declare class VcPatchMissingDependencies
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		patchID: String;
		prerequisiteLib: String[];
		prerequisitePatch: String[];

		constructor();
		constructor(patchID?: String, prerequisitePatch?: String[], prerequisiteLib?: String[]);
		printStackTrace(): void;
	}

	declare class VcPatchNotApplicable
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		patchID: String;

		constructor();
		constructor(patchID?: String);
		printStackTrace(): void;
	}

	declare class VcPatchSuperseded
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		patchID: String;
		supersede: String[];

		constructor();
		constructor(patchID?: String, supersede?: String[]);
		printStackTrace(): void;
	}

	declare class VcPerfCompositeMetric
	{
		childEntity: VcPerfEntityMetricBase[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcPerfEntityMetricBase;

		constructor();
		constructor(entity?: VcPerfEntityMetricBase, childEntity?: VcPerfEntityMetricBase[]);
	}

	declare class VcPerfCounterInfo
	{
		associatedCounterId: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		groupInfo: VcElementDescription;
		key: Number;
		level: Number;
		nameInfo: VcElementDescription;
		perDeviceLevel: Number;
		rollupType: VcPerfSummaryType;
		statsType: VcPerfStatsType;
		unitInfo: VcElementDescription;

		constructor();
		constructor(key?: Number, nameInfo?: VcElementDescription, groupInfo?: VcElementDescription, unitInfo?: VcElementDescription, rollupType?: VcPerfSummaryType, statsType?: VcPerfStatsType, level?: Number, perDeviceLevel?: Number, associatedCounterId?: Number[]);
	}

	declare class VcPerfCounterInfoInt
	{
		associatedCounterId: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		enabledByDefault: boolean;
		groupInfo: VcElementDescription;
		key: Number;
		level: Number;
		nameInfo: VcElementDescription;
		perDeviceLevel: Number;
		rollupType: VcPerfSummaryType;
		statsType: VcPerfStatsType;
		unitInfo: VcElementDescription;

		constructor();
		constructor(key?: Number, nameInfo?: VcElementDescription, groupInfo?: VcElementDescription, unitInfo?: VcElementDescription, rollupType?: VcPerfSummaryType, statsType?: VcPerfStatsType, level?: Number, perDeviceLevel?: Number, associatedCounterId?: Number[], enabledByDefault?: boolean, enabled?: boolean);
	}

	declare class VcPerfEntityMetric
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedObject;
		sampleInfo: VcPerfSampleInfo[];
		value: VcPerfMetricSeries[];

		constructor();
		constructor(entity?: VcManagedObject, sampleInfo?: VcPerfSampleInfo[], value?: VcPerfMetricSeries[]);
	}

	declare class VcPerfEntityMetricBase
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedObject;

		constructor();
		constructor(entity?: VcManagedObject);
	}

	declare class VcPerfEntityMetricCSV
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedObject;
		sampleInfoCSV: String;
		value: VcPerfMetricSeriesCSV[];

		constructor();
		constructor(entity?: VcManagedObject, sampleInfoCSV?: String, value?: VcPerfMetricSeriesCSV[]);
	}

	interface VcPerfFormat
	{
		readonly csv: VcPerfFormat;
		readonly id: String;
		readonly name: String;
		readonly normal: VcPerfFormat;
		readonly value: String;

		fromString(value?: VcPerfFormat): VcPerfFormat;
	}

	declare const VcPerfFormat: VcPerfFormat;

	declare class VcPerfInterval
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		key: Number;
		length: Number;
		level: Number;
		name: String;
		samplingPeriod: Number;

		constructor();
		constructor(key?: Number, samplingPeriod?: Number, name?: String, length?: Number, level?: Number, enabled?: boolean);
	}

	declare class VcPerfMetricId
	{
		counterId: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		instance: String;

		constructor();
		constructor(counterId?: Number, instance?: String);
	}

	declare class VcPerfMetricIntSeries
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcPerfMetricId;
		value: Number[];

		constructor();
		constructor(id?: VcPerfMetricId, value?: Number[]);
	}

	declare class VcPerfMetricSeries
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcPerfMetricId;

		constructor();
		constructor(id?: VcPerfMetricId);
	}

	declare class VcPerfMetricSeriesCSV
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcPerfMetricId;
		value: String;

		constructor();
		constructor(id?: VcPerfMetricId, value?: String);
	}

	declare class VcPerformanceDescription
	{
		counterType: VcElementDescription[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		statsType: VcElementDescription[];

		constructor();
		constructor(counterType?: VcElementDescription[], statsType?: VcElementDescription[]);
	}

	interface VcPerformanceManager
	{
		description: VcPerformanceDescription;
		historicalInterval: VcPerfInterval[];
		id: String;
		moref: VcManagedObjectReference;
		perfCounter: VcPerfCounterInfo[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createPerfInterval(arg0?: VcPerfInterval): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		perfDisableStat(arg0?: Number[]): void;
		perfEnableStat(arg0?: Number[]): void;
		queryAvailablePerfMetric(arg0?: VcManagedObject, arg1?: Date, arg2?: Date, arg3?: Number): VcPerfMetricId[];
		queryPerf(arg0?: VcPerfQuerySpec[]): VcPerfEntityMetricBase[];
		queryPerfComposite(arg0?: VcPerfQuerySpec): VcPerfCompositeMetric;
		queryPerfCounter(arg0?: Number[]): VcPerfCounterInfo[];
		queryPerfCounterByLevel(arg0?: Number): VcPerfCounterInfo[];
		queryPerfCounterInt(): VcPerfCounterInfoInt[];
		queryPerfProviderSummary(arg0?: VcManagedObject): VcPerfProviderSummary;
		removePerfInterval(arg0?: Number): void;
		resetCounterLevelMapping(arg0?: Number[]): void;
		summarizeStats(arg0?: VcPerfQuerySpec[]): VcPerfEntityMetricCSV[];
		updateCounterLevelMapping(arg0?: VcPerformanceManagerCounterLevelMapping[]): void;
		updatePerfInterval(arg0?: VcPerfInterval): void;
	}

	declare const VcPerformanceManager: VcPerformanceManager;

	declare class VcPerformanceManagerCounterLevelMapping
	{
		aggregateLevel: Number;
		counterId: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		perDeviceLevel: Number;

		constructor();
		constructor(counterId?: Number, aggregateLevel?: Number, perDeviceLevel?: Number);
	}

	interface VcPerformanceManagerUnit
	{
		readonly celsius: VcPerformanceManagerUnit;
		readonly id: String;
		readonly joule: VcPerformanceManagerUnit;
		readonly kiloBytes: VcPerformanceManagerUnit;
		readonly kiloBytesPerSecond: VcPerformanceManagerUnit;
		readonly megaBytes: VcPerformanceManagerUnit;
		readonly megaBytesPerSecond: VcPerformanceManagerUnit;
		readonly megaHertz: VcPerformanceManagerUnit;
		readonly microsecond: VcPerformanceManagerUnit;
		readonly millisecond: VcPerformanceManagerUnit;
		readonly name: String;
		readonly number: VcPerformanceManagerUnit;
		readonly percent: VcPerformanceManagerUnit;
		readonly second: VcPerformanceManagerUnit;
		readonly teraBytes: VcPerformanceManagerUnit;
		readonly value: String;
		readonly watt: VcPerformanceManagerUnit;

		fromString(value?: VcPerformanceManagerUnit): VcPerformanceManagerUnit;
	}

	declare const VcPerformanceManagerUnit: VcPerformanceManagerUnit;

	declare class VcPerformanceStatisticsDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		intervals: VcPerfInterval[];

		constructor();
		constructor(intervals?: VcPerfInterval[]);
	}

	declare class VcPerfProviderSummary
	{
		currentSupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedObject;
		refreshRate: Number;
		summarySupported: boolean;

		constructor();
		constructor(entity?: VcManagedObject, currentSupported?: boolean, summarySupported?: boolean, refreshRate?: Number);
	}

	declare class VcPerfQuerySpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endTime: Date;
		entity: VcManagedObject;
		format: String;
		intervalId: Number;
		maxSample: Number;
		metricId: VcPerfMetricId[];
		startTime: Date;

		constructor();
		constructor(entity?: VcManagedObject, startTime?: Date, endTime?: Date, maxSample?: Number, metricId?: VcPerfMetricId[], intervalId?: Number, format?: String);
	}

	declare class VcPerfSampleInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		interval: Number;
		timestamp: Date;

		constructor();
		constructor(timestamp?: Date, interval?: Number);
	}

	interface VcPerfStatsType
	{
		readonly absolute: VcPerfStatsType;
		readonly delta: VcPerfStatsType;
		readonly id: String;
		readonly name: String;
		readonly rate: VcPerfStatsType;
		readonly value: String;

		fromString(value?: VcPerfStatsType): VcPerfStatsType;
	}

	declare const VcPerfStatsType: VcPerfStatsType;

	interface VcPerfSummaryType
	{
		readonly average: VcPerfSummaryType;
		readonly id: String;
		readonly latest: VcPerfSummaryType;
		readonly maximum: VcPerfSummaryType;
		readonly minimum: VcPerfSummaryType;
		readonly name: String;
		readonly none: VcPerfSummaryType;
		readonly summation: VcPerfSummaryType;
		readonly value: String;

		fromString(value?: VcPerfSummaryType): VcPerfSummaryType;
	}

	declare const VcPerfSummaryType: VcPerfSummaryType;

	declare class VcPermission
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		group: boolean;
		principal: String;
		propagate: boolean;
		roleId: Number;

		constructor();
		constructor(entity?: VcManagedEntity, principal?: String, group?: boolean, roleId?: Number, propagate?: boolean);
	}

	declare class VcPermissionAddedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		principal: String;
		propagate: boolean;
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, entity?: VcManagedEntityEventArgument, principal?: String, group?: boolean, role?: VcRoleEventArgument, propagate?: boolean);
	}

	declare class VcPermissionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		principal: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, entity?: VcManagedEntityEventArgument, principal?: String, group?: boolean);
	}

	declare class VcPermissionProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcPermissionRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		principal: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, entity?: VcManagedEntityEventArgument, principal?: String, group?: boolean);
	}

	declare class VcPermissionUpdatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		prevPropagate: boolean;
		prevRole: VcRoleEventArgument;
		principal: String;
		propagate: boolean;
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, entity?: VcManagedEntityEventArgument, principal?: String, group?: boolean, role?: VcRoleEventArgument, propagate?: boolean, prevRole?: VcRoleEventArgument, prevPropagate?: boolean);
		isPrevPropagate(): boolean;
	}

	declare class VcPhysCompatRDMNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcPhysicalNic
	{
		autoNegotiateSupported: boolean;
		device: String;
		driver: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fcoeConfiguration: VcFcoeConfig;
		key: String;
		linkSpeed: VcPhysicalNicLinkInfo;
		mac: String;
		pci: String;
		resourcePoolSchedulerAllowed: boolean;
		resourcePoolSchedulerDisallowedReason: String[];
		spec: VcPhysicalNicSpec;
		validLinkSpecification: VcPhysicalNicLinkInfo[];
		vmDirectPathGen2Supported: boolean;
		vmDirectPathGen2SupportedMode: String;
		wakeOnLanSupported: boolean;

		constructor();
		constructor(key?: String, device?: String, pci?: String, driver?: String, linkSpeed?: VcPhysicalNicLinkInfo, validLinkSpecification?: VcPhysicalNicLinkInfo[], spec?: VcPhysicalNicSpec, wakeOnLanSupported?: boolean, mac?: String, fcoeConfiguration?: VcFcoeConfig, vmDirectPathGen2Supported?: boolean, vmDirectPathGen2SupportedMode?: String, resourcePoolSchedulerAllowed?: boolean, resourcePoolSchedulerDisallowedReason?: String[], autoNegotiateSupported?: boolean);
		isAutoNegotiateSupported(): boolean;
		isResourcePoolSchedulerAllowed(): boolean;
		isVmDirectPathGen2Supported(): boolean;
	}

	declare class VcPhysicalNicCdpDeviceCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: boolean;
		igmpEnabled: boolean;
		networkSwitch: boolean;
		repeater: boolean;
		router: boolean;
		sourceRouteBridge: boolean;
		transparentBridge: boolean;

		constructor();
		constructor(router?: boolean, transparentBridge?: boolean, sourceRouteBridge?: boolean, networkSwitch?: boolean, host?: boolean, igmpEnabled?: boolean, repeater?: boolean);
	}

	declare class VcPhysicalNicCdpInfo
	{
		address: String;
		cdpVersion: Number;
		deviceCapability: VcPhysicalNicCdpDeviceCapability;
		devId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullDuplex: boolean;
		hardwarePlatform: String;
		ipPrefix: String;
		ipPrefixLen: Number;
		location: String;
		mgmtAddr: String;
		mtu: Number;
		portId: String;
		samples: Number;
		softwareVersion: String;
		systemName: String;
		systemOID: String;
		timeout: Number;
		ttl: Number;
		vlan: Number;

		constructor();
		constructor(cdpVersion?: Number, timeout?: Number, ttl?: Number, samples?: Number, devId?: String, address?: String, portId?: String, deviceCapability?: VcPhysicalNicCdpDeviceCapability, softwareVersion?: String, hardwarePlatform?: String, ipPrefix?: String, ipPrefixLen?: Number, vlan?: Number, fullDuplex?: boolean, mtu?: Number, systemName?: String, systemOID?: String, mgmtAddr?: String, location?: String);
		isFullDuplex(): boolean;
	}

	declare class VcPhysicalNicConfig
	{
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		spec: VcPhysicalNicSpec;

		constructor();
		constructor(device?: String, spec?: VcPhysicalNicSpec);
	}

	declare class VcPhysicalNicHint
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vlanId: Number;

		constructor();
		constructor(vlanId?: Number);
	}

	declare class VcPhysicalNicHintInfo
	{
		connectedSwitchPort: VcPhysicalNicCdpInfo;
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lldpInfo: VcLinkLayerDiscoveryProtocolInfo;
		network: VcPhysicalNicNameHint[];
		subnet: VcPhysicalNicIpHint[];

		constructor();
		constructor(device?: String, subnet?: VcPhysicalNicIpHint[], network?: VcPhysicalNicNameHint[], connectedSwitchPort?: VcPhysicalNicCdpInfo, lldpInfo?: VcLinkLayerDiscoveryProtocolInfo);
	}

	declare class VcPhysicalNicIpHint
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipSubnet: String;
		vlanId: Number;

		constructor();
		constructor(vlanId?: Number, ipSubnet?: String);
	}

	declare class VcPhysicalNicLinkInfo
	{
		duplex: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		speedMb: Number;

		constructor();
		constructor(speedMb?: Number, duplex?: boolean);
	}

	declare class VcPhysicalNicNameHint
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		network: String;
		vlanId: Number;

		constructor();
		constructor(vlanId?: Number, network?: String);
	}

	declare class VcPhysicalNicProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	interface VcPhysicalNicResourcePoolSchedulerDisallowedReason
	{
		readonly hardwareUnsupported: VcPhysicalNicResourcePoolSchedulerDisallowedReason;
		readonly id: String;
		readonly name: String;
		readonly userOptOut: VcPhysicalNicResourcePoolSchedulerDisallowedReason;
		readonly value: String;

		fromString(value?: VcPhysicalNicResourcePoolSchedulerDisallowedReason): VcPhysicalNicResourcePoolSchedulerDisallowedReason;
	}

	declare const VcPhysicalNicResourcePoolSchedulerDisallowedReason: VcPhysicalNicResourcePoolSchedulerDisallowedReason;

	declare class VcPhysicalNicSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ip: VcHostIpConfig;
		linkSpeed: VcPhysicalNicLinkInfo;

		constructor();
		constructor(ip?: VcHostIpConfig, linkSpeed?: VcPhysicalNicLinkInfo);
	}

	interface VcPhysicalNicVmDirectPathGen2SupportedMode
	{
		readonly id: String;
		readonly name: String;
		readonly upt: VcPhysicalNicVmDirectPathGen2SupportedMode;
		readonly value: String;

		fromString(value?: VcPhysicalNicVmDirectPathGen2SupportedMode): VcPhysicalNicVmDirectPathGen2SupportedMode;
	}

	declare const VcPhysicalNicVmDirectPathGen2SupportedMode: VcPhysicalNicVmDirectPathGen2SupportedMode;

	declare class VcPlacementAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		relocateSpec: VcVirtualMachineRelocateSpec;
		target: VcManagedObject;
		targetHost: VcHostSystem;
		type: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(type?: String, target?: VcManagedObject, vm?: VcVirtualMachine, targetHost?: VcHostSystem, relocateSpec?: VcVirtualMachineRelocateSpec);
	}

	declare class VcPlacementAffinityRule
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keys: String[];
		ruleScope: String;
		ruleType: String;
		vms: VcVirtualMachine[];

		constructor();
		constructor(ruleType?: String, ruleScope?: String, vms?: VcVirtualMachine[], keys?: String[]);
	}

	interface VcPlacementAffinityRuleRuleScope
	{
		readonly cluster: VcPlacementAffinityRuleRuleScope;
		readonly datastore: VcPlacementAffinityRuleRuleScope;
		readonly host: VcPlacementAffinityRuleRuleScope;
		readonly id: String;
		readonly name: String;
		readonly storagePod: VcPlacementAffinityRuleRuleScope;
		readonly value: String;

		fromString(value?: VcPlacementAffinityRuleRuleScope): VcPlacementAffinityRuleRuleScope;
	}

	declare const VcPlacementAffinityRuleRuleScope: VcPlacementAffinityRuleRuleScope;

	interface VcPlacementAffinityRuleRuleType
	{
		readonly affinity: VcPlacementAffinityRuleRuleType;
		readonly antiAffinity: VcPlacementAffinityRuleRuleType;
		readonly id: String;
		readonly name: String;
		readonly softAffinity: VcPlacementAffinityRuleRuleType;
		readonly softAntiAffinity: VcPlacementAffinityRuleRuleType;
		readonly value: String;

		fromString(value?: VcPlacementAffinityRuleRuleType): VcPlacementAffinityRuleRuleType;
	}

	declare const VcPlacementAffinityRuleRuleType: VcPlacementAffinityRuleRuleType;

	declare class VcPlacementRankResult
	{
		candidate: VcClusterComputeResource;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		faults: VcLocalizedMethodFault[];
		key: String;
		reservedSpaceMB: Number;
		totalSpaceMB: Number;
		usedSpaceMB: Number;
		utilization: Number;

		constructor();
		constructor(key?: String, candidate?: VcClusterComputeResource, reservedSpaceMB?: Number, usedSpaceMB?: Number, totalSpaceMB?: Number, utilization?: Number, faults?: VcLocalizedMethodFault[]);
	}

	declare class VcPlacementRankSpec
	{
		clusters: VcClusterComputeResource[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		placementRankByVm: VcStorageDrsPlacementRankVmSpec[];
		rules: VcPlacementAffinityRule[];
		specs: VcPlacementSpec[];

		constructor();
		constructor(specs?: VcPlacementSpec[], clusters?: VcClusterComputeResource[], rules?: VcPlacementAffinityRule[], placementRankByVm?: VcStorageDrsPlacementRankVmSpec[]);
	}

	declare class VcPlacementResult
	{
		drsFault: VcClusterDrsFaults;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		recommendations: VcClusterRecommendation[];

		constructor();
		constructor(recommendations?: VcClusterRecommendation[], drsFault?: VcClusterDrsFaults);
	}

	declare class VcPlacementSpec
	{
		cloneName: String;
		cloneSpec: VcVirtualMachineCloneSpec;
		configSpec: VcVirtualMachineConfigSpec;
		datastores: VcDatastore[];
		disallowPrerequisiteMoves: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hosts: VcHostSystem[];
		key: String;
		placementType: String;
		priority: VcVirtualMachineMovePriority;
		relocateSpec: VcVirtualMachineRelocateSpec;
		rules: VcClusterRuleInfo[];
		storagePods: VcStoragePod[];
		vm: VcVirtualMachine;

		constructor();
		constructor(priority?: VcVirtualMachineMovePriority, vm?: VcVirtualMachine, configSpec?: VcVirtualMachineConfigSpec, relocateSpec?: VcVirtualMachineRelocateSpec, hosts?: VcHostSystem[], datastores?: VcDatastore[], storagePods?: VcStoragePod[], disallowPrerequisiteMoves?: boolean, rules?: VcClusterRuleInfo[], key?: String, placementType?: String, cloneSpec?: VcVirtualMachineCloneSpec, cloneName?: String);
		isDisallowPrerequisiteMoves(): boolean;
	}

	interface VcPlacementSpecPlacementType
	{
		readonly clone: VcPlacementSpecPlacementType;
		readonly create: VcPlacementSpecPlacementType;
		readonly id: String;
		readonly name: String;
		readonly reconfigure: VcPlacementSpecPlacementType;
		readonly relocate: VcPlacementSpecPlacementType;
		readonly value: String;

		fromString(value?: VcPlacementSpecPlacementType): VcPlacementSpecPlacementType;
	}

	declare const VcPlacementSpecPlacementType: VcPlacementSpecPlacementType;

	declare class VcPlatformConfigFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		text: String;

		constructor();
		constructor(text?: String);
		printStackTrace(): void;
	}

	interface VcPlugin
	{
		allClusterComputeResources: Object[];
		allComputeResources: Object[];
		allDatacenterFolders: Object[];
		allDatacenters: Object[];
		allDatastoreFolders: Object[];
		allDatastores: Object[];
		allDistributedVirtualPortgroups: Object[];
		allHostFolders: Object[];
		allHostSystems: Object[];
		allNetworkFolders: Object[];
		allNetworks: Object[];
		allRegisteredInstances: Object[];
		allResourcePools: Object[];
		allSdkConnections: Object[];
		allTasks: Object[];
		allVimHosts: Object[];
		allVirtualApps: Object[];
		allVirtualMachines: Object[];
		allVirtualMachineSnapshots: Object[];
		allVmFolders: Object[];
		extensionKey: String;
		vimHosts: Object[];

		convertToVimManagedObject(managedObjectHolder?: Object, object?: Object): Object;
		createCustomizationPasswordFromCredentials(credentials?: Credential, plainText?: boolean): VcCustomizationPassword;
		currentTime(sdkConnection?: VcSdkConnection): Date;
		deepClone(o?: Object): Object;
		findSdkConnectionForUUID(uuid?: String): VcSdkConnection;
		getAllClusterComputeResources(additionalPropertyFilters?: String[], query?: String): VcClusterComputeResource[];
		getAllComputeResources(additionalPropertyFilters?: String[], query?: String): VcComputeResource[];
		getAllDatacenterFolders(additionalPropertyFilters?: String[], query?: String): VcDatacenterFolder[];
		getAllDatacenters(additionalPropertyFilters?: String[], query?: String): VcDatacenter[];
		getAllDatastoreFolders(additionalPropertyFilters?: String[], query?: String): VcDatastoreFolder[];
		getAllDatastores(additionalPropertyFilters?: String[], query?: String): VcDatastore[];
		getAllDistributedVirtualPortgroups(additionalPropertyFilters?: String[], query?: String): VcDistributedVirtualPortgroup[];
		getAllHostFolders(additionalPropertyFilters?: String[], query?: String): VcHostFolder[];
		getAllHostSystems(additionalPropertyFilters?: String[], query?: String): VcHostSystem[];
		getAllNetworkFolders(additionalPropertyFilters?: String[], query?: String): VcNetworkFolder[];
		getAllNetworks(additionalPropertyFilters?: String[], query?: String): VcNetwork[];
		getAllResourcePools(additionalPropertyFilters?: String[], query?: String): VcResourcePool[];
		getAllTasks(additionalPropertyFilters?: String[], query?: String): VcTask[];
		getAllVimManagedObjects(sdkType?: String, additionalFilters?: String[], query?: String): VcManagedObject[];
		getAllVirtualApps(additionalPropertyFilters?: String[], query?: String): VcVirtualApp[];
		getAllVirtualMachines(additionalPropertyFilters?: String[], query?: String): VcVirtualMachine[];
		getAllVirtualMachineSnapshots(additionalPropertyFilters?: String[], query?: String): VcVirtualMachineSnapshot[];
		getAllVmFolders(additionalPropertyFilters?: String[], query?: String): VcVmFolder[];
		getManagedObjectsForIds(sdkType?: String, ids?: String[]): VcManagedObject[];
		getManagedObjectsForTypesAndIds(sdkTypes?: String[], ids?: String[]): VcManagedObject[];
		getManagedObjectsForURIs(uriStrings?: String[]): VcManagedObject[];
		getProvisionedSpace(dataStore?: VcDatastore): Number;
		getRegisteredInstanceProperties(hostUrl?: String): Properties;
		importOvf(ovfUri?: String, hostSystem?: VcHostSystem, importFolder?: VcFolder, vmName?: String, networks?: VcOvfNetworkMapping[], datastore?: VcDatastore, props?: VcKeyValue[]): VcVirtualMachine;
		refreshObjects(obj?: Object): Object;
		registerExtension(sdkConnection?: VcSdkConnection, address?: String): void;
		registerVCenterServerInstance(enabled?: boolean, hostName?: String, port?: Number, path?: String, sessionPerUser?: boolean, userName?: String, password?: String, domain?: String): VcSdkConnection;
		toManagedObject(factoryHolder?: Object, object?: Object): Object;
		toManagedObjectRef(obj?: VcManagedObject): VcManagedObjectReference;
		unregisterExtension(sdkConnection?: VcSdkConnection, key?: String): void;
		unregisterVCenterServerInstance(hostUrl?: String): void;
		updateVCenterServerInstance(hostUrlToUpdate?: String, enabled?: boolean, hostName?: String, port?: Number, path?: String, sessionPerUser?: boolean, userName?: String, password?: String, domain?: String): void;
		validateConnection(hostName?: String, port?: Number, path?: String, userName?: String, password?: String): void;
	}

	declare const VcPlugin: VcPlugin;

	declare class VcPMemDatastoreInfo
	{
		containerId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpace: Number;
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxVirtualDiskCapacity: Number;
		name: String;
		pmem: VcHostPMemVolume;
		timestamp: Date;
		url: String;

		constructor();
		constructor(name?: String, url?: String, freeSpace?: Number, maxFileSize?: Number, maxVirtualDiskCapacity?: Number, maxMemoryFileSize?: Number, timestamp?: Date, containerId?: String, pmem?: VcHostPMemVolume);
	}

	declare class VcPnicUplinkProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcPodDiskLocator
	{
		diskBackingInfo: VcVirtualDeviceBackingInfo;
		diskId: Number;
		diskMoveType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(diskId?: Number, diskMoveType?: String, diskBackingInfo?: VcVirtualDeviceBackingInfo, profile?: VcVirtualMachineProfileSpec[]);
	}

	declare class VcPodStorageDrsEntry
	{
		actionHistory: VcClusterActionHistory[];
		drsFault: VcClusterDrsFaults[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		recommendation: VcClusterRecommendation[];
		storageDrsConfig: VcStorageDrsConfigInfo;

		constructor();
		constructor(storageDrsConfig?: VcStorageDrsConfigInfo, recommendation?: VcClusterRecommendation[], drsFault?: VcClusterDrsFaults[], actionHistory?: VcClusterActionHistory[]);
	}

	declare class VcPolicyDisallowsOperation
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		notSupportedOperation: String;
		policyUrn: String[];

		constructor();
		constructor(policyUrn?: String[], notSupportedOperation?: String);
		printStackTrace(): void;
	}

	declare class VcPolicyOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		parameter: VcKeyAnyValue[];

		constructor();
		constructor(id?: String, parameter?: VcKeyAnyValue[]);
	}

	declare class VcPolicyUrnInvalid
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		urn: String;

		constructor();
		constructor(urn?: String);
		printStackTrace(): void;
	}

	declare class VcPolicyViolated
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reasons: VcLocalizedMethodFault[];

		constructor();
		constructor(reasons?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcPolicyViolatedByValue
	{
		callerValue_AnyValue: Object;
		callerValue_FloatValue: Number;
		callerValue_IntValue: Number;
		callerValue_LongValue: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		policyTarget: String;
		policyTargetProperty: String;
		policyUrn: String[];

		constructor();
		constructor(policyUrn?: String[], callerValue?: Object, policyTarget?: String, policyTargetProperty?: String);
		printStackTrace(): void;
	}

	declare class VcPolicyViolatedDetail
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		policyUrn: String[];

		constructor();
		constructor(policyUrn?: String[]);
		printStackTrace(): void;
	}

	declare class VcPolicyViolatedValueCannotEqual
	{
		callerValue_AnyValue: Object;
		callerValue_FloatValue: Number;
		callerValue_IntValue: Number;
		callerValue_LongValue: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		policyTarget: String;
		policyTargetProperty: String;
		policyUrn: String[];
		policyValue_AnyValue: Object;
		policyValue_FloatValue: Number;
		policyValue_IntValue: Number;
		policyValue_LongValue: Number;

		constructor();
		constructor(policyUrn?: String[], callerValue?: Object, policyTarget?: String, policyTargetProperty?: String, policyValue?: Object);
		printStackTrace(): void;
	}

	declare class VcPolicyViolatedValueNotEqual
	{
		callerValue_AnyValue: Object;
		callerValue_FloatValue: Number;
		callerValue_IntValue: Number;
		callerValue_LongValue: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		policyTarget: String;
		policyTargetProperty: String;
		policyUrn: String[];
		policyValue_AnyValue: Object;
		policyValue_FloatValue: Number;
		policyValue_IntValue: Number;
		policyValue_LongValue: Number;

		constructor();
		constructor(policyUrn?: String[], callerValue?: Object, policyTarget?: String, policyTargetProperty?: String, policyValue?: Object);
		printStackTrace(): void;
	}

	declare class VcPolicyViolatedValueNotInRange
	{
		callerValue_AnyValue: Object;
		callerValue_FloatValue: Number;
		callerValue_IntValue: Number;
		callerValue_LongValue: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		policyMaxValue_AnyValue: Object;
		policyMaxValue_FloatValue: Number;
		policyMaxValue_IntValue: Number;
		policyMaxValue_LongValue: Number;
		policyMinValue_AnyValue: Object;
		policyMinValue_FloatValue: Number;
		policyMinValue_IntValue: Number;
		policyMinValue_LongValue: Number;
		policyTarget: String;
		policyTargetProperty: String;
		policyUrn: String[];

		constructor();
		constructor(policyUrn?: String[], callerValue?: Object, policyTarget?: String, policyTargetProperty?: String, policyMinValue?: Object, policyMaxValue?: Object);
		printStackTrace(): void;
	}

	declare class VcPolicyViolatedValueNotInSet
	{
		callerValue_AnyValue: Object;
		callerValue_FloatValue: Number;
		callerValue_IntValue: Number;
		callerValue_LongValue: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		policyTarget: String;
		policyTargetProperty: String;
		policyUrn: String[];
		policyValue: Object[];

		constructor();
		constructor(policyUrn?: String[], callerValue?: Object, policyTarget?: String, policyTargetProperty?: String, policyValue?: Object[]);
		printStackTrace(): void;
	}

	declare class VcPolicyViolatedValueTooBig
	{
		callerValue_AnyValue: Object;
		callerValue_FloatValue: Number;
		callerValue_IntValue: Number;
		callerValue_LongValue: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		policyTarget: String;
		policyTargetProperty: String;
		policyUrn: String[];
		policyValue_AnyValue: Object;
		policyValue_FloatValue: Number;
		policyValue_IntValue: Number;
		policyValue_LongValue: Number;

		constructor();
		constructor(policyUrn?: String[], callerValue?: Object, policyTarget?: String, policyTargetProperty?: String, policyValue?: Object);
		printStackTrace(): void;
	}

	declare class VcPolicyViolatedValueTooSmall
	{
		callerValue_AnyValue: Object;
		callerValue_FloatValue: Number;
		callerValue_IntValue: Number;
		callerValue_LongValue: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		policyTarget: String;
		policyTargetProperty: String;
		policyUrn: String[];
		policyValue_AnyValue: Object;
		policyValue_FloatValue: Number;
		policyValue_IntValue: Number;
		policyValue_LongValue: Number;

		constructor();
		constructor(policyUrn?: String[], callerValue?: Object, policyTarget?: String, policyTargetProperty?: String, policyValue?: Object);
		printStackTrace(): void;
	}

	interface VcPortGroupConnecteeType
	{
		readonly host: VcPortGroupConnecteeType;
		readonly id: String;
		readonly name: String;
		readonly systemManagement: VcPortGroupConnecteeType;
		readonly unknown: VcPortGroupConnecteeType;
		readonly value: String;
		readonly virtualMachine: VcPortGroupConnecteeType;

		fromString(value?: VcPortGroupConnecteeType): VcPortGroupConnecteeType;
	}

	declare const VcPortGroupConnecteeType: VcPortGroupConnecteeType;

	declare class VcPortGroupProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		name: String;
		networkPolicy: VcNetworkPolicyProfile;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;
		vlan: VcVlanProfile;
		vswitch: VcVirtualSwitchSelectionProfile;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String, name?: String, vlan?: VcVlanProfile, vswitch?: VcVirtualSwitchSelectionProfile, networkPolicy?: VcNetworkPolicyProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcPosixUserSearchResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullName: String;
		group: boolean;
		id: Number;
		principal: String;
		shellAccess: boolean;

		constructor();
		constructor(principal?: String, fullName?: String, group?: boolean, id?: Number, shellAccess?: boolean);
		isShellAccess(): boolean;
	}

	declare class VcPowerOnFtSecondaryFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostErrors: VcLocalizedMethodFault[];
		hostSelectionBy: VcFtIssuesOnHostHostSelectionType;
		readonly localizedMessage: String;
		message: String;
		rootCause: VcLocalizedMethodFault;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(vm?: VcVirtualMachine, vmName?: String, hostSelectionBy?: VcFtIssuesOnHostHostSelectionType, hostErrors?: VcLocalizedMethodFault[], rootCause?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcPowerOnFtSecondaryTimedout
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		timeout: Number;
		vm: VcVirtualMachine;
		vmName: String;

		constructor();
		constructor(vm?: VcVirtualMachine, vmName?: String, timeout?: Number);
		printStackTrace(): void;
	}

	declare class VcPowerSystemCapability
	{
		availablePolicy: VcHostPowerPolicy[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(availablePolicy?: VcHostPowerPolicy[]);
	}

	declare class VcPowerSystemInfo
	{
		currentPolicy: VcHostPowerPolicy;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(currentPolicy?: VcHostPowerPolicy);
	}

	declare class VcPreCallbackResult
	{
		currentResult: VcPreCallbackResultResult;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extensionKey: String;
		fault: VcLocalizedMethodFault;
		instanceId: String;
		percentDone: Number;

		constructor();
		constructor(extensionKey?: String, instanceId?: String, percentDone?: Number, currentResult?: VcPreCallbackResultResult, fault?: VcLocalizedMethodFault);
	}

	interface VcPreCallbackResultResult
	{
		readonly BlockOperation: VcPreCallbackResultResult;
		readonly ContinueWithOperation: VcPreCallbackResultResult;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcPreCallbackResultResult): VcPreCallbackResultResult;
	}

	declare const VcPreCallbackResultResult: VcPreCallbackResultResult;

	declare class VcPrivilegeAvailability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		isGranted: boolean;
		privId: String;

		constructor();
		constructor(privId?: String, isGranted?: boolean);
	}

	declare class VcPrivilegePolicyDef
	{
		createPrivilege: String;
		deletePrivilege: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		readPrivilege: String;
		updatePrivilege: String;

		constructor();
		constructor(createPrivilege?: String, readPrivilege?: String, updatePrivilege?: String, deletePrivilege?: String);
	}

	declare class VcProductComponentInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		name: String;
		release: Number;
		version: String;

		constructor();
		constructor(id?: String, name?: String, version?: String, release?: Number);
	}

	interface VcProfile
	{
		complianceStatus: String;
		config: VcProfileConfigInfo;
		createdTime: Date;
		description: VcProfileDescription;
		entity: VcManagedEntity[];
		id: String;
		modifiedTime: Date;
		moref: VcManagedObjectReference;
		name: String;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		associateProfile(arg0?: VcManagedEntity[]): void;
		checkProfileCompliance_Task(arg0?: VcManagedEntity[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyProfile(): void;
		dissociateProfile(arg0?: VcManagedEntity[]): void;
		exportProfile(): String;
		retrieveDescription(): VcProfileDescription;
	}

	declare const VcProfile: VcProfile;

	declare class VcProfileApplyProfileElement
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcProfileApplyProfileProperty
	{
		array: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profile: VcApplyProfile[];
		propertyName: String;

		constructor();
		constructor(propertyName?: String, array?: boolean, profile?: VcApplyProfile[]);
	}

	declare class VcProfileAssociatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, profile?: VcProfileEventArgument);
	}

	declare class VcProfileCategoryMetadata
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcExtendedElementDescription;
		profileComponents: String[];

		constructor();
		constructor(id?: VcExtendedElementDescription, profileComponents?: String[]);
	}

	declare class VcProfileChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, profile?: VcProfileEventArgument);
	}

	interface VcProfileComplianceManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkCompliance_Task(arg0?: VcProfile[], arg1?: VcManagedEntity[]): VcTask;
		clearComplianceStatus(arg0?: VcProfile[], arg1?: VcManagedEntity[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryComplianceStatus(arg0?: VcProfile[], arg1?: VcManagedEntity[]): VcComplianceResult[];
		queryEntitiesByComplianceStatus(arg0?: String, arg1?: VcManagedEntity[]): VcEntityAndComplianceStatus[];
		queryExpressionMetadata(arg0?: String[], arg1?: VcProfile): VcProfileExpressionMetadata[];
	}

	declare const VcProfileComplianceManager: VcProfileComplianceManager;

	declare class VcProfileComponentMetadata
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcExtendedElementDescription;
		profileCategory: String;
		profilePaths: String[];
		profileTypeNames: String[];

		constructor();
		constructor(id?: VcExtendedElementDescription, profileCategory?: String, profileTypeNames?: String[], profilePaths?: String[]);
	}

	declare class VcProfileCompositeExpression
	{
		displayName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expressionName: String[];
		id: String;
		negated: boolean;
		operator: String;

		constructor();
		constructor(id?: String, displayName?: String, negated?: boolean, operator?: String, expressionName?: String[]);
	}

	declare class VcProfileCompositePolicyOptionMetadata
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcExtendedElementDescription;
		option: String[];
		parameter: VcProfileParameterMetadata[];

		constructor();
		constructor(id?: VcExtendedElementDescription, parameter?: VcProfileParameterMetadata[], option?: String[]);
	}

	declare class VcProfileConfigInfo
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean);
	}

	declare class VcProfileCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, profile?: VcProfileEventArgument);
	}

	declare class VcProfileCreateSpec
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean);
		isEnabled(): boolean;
	}

	declare class VcProfileDeferredPolicyOptionParameter
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inputPath: VcProfilePropertyPath;
		parameter: VcKeyAnyValue[];

		constructor();
		constructor(inputPath?: VcProfilePropertyPath, parameter?: VcKeyAnyValue[]);
	}

	declare class VcProfileDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		section: VcProfileDescriptionSection[];

		constructor();
		constructor(section?: VcProfileDescriptionSection[]);
	}

	declare class VcProfileDescriptionSection
	{
		description: VcExtendedElementDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		message: VcLocalizableMessage[];

		constructor();
		constructor(description?: VcExtendedElementDescription, message?: VcLocalizableMessage[]);
	}

	declare class VcProfileDissociatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, profile?: VcProfileEventArgument);
	}

	declare class VcProfileEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, profile?: VcProfileEventArgument);
	}

	declare class VcProfileEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		profile: VcProfile;

		constructor();
		constructor(profile?: VcProfile, name?: String);
	}

	declare class VcProfileExecuteError
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		message: VcLocalizableMessage;
		path: VcProfilePropertyPath;

		constructor();
		constructor(path?: VcProfilePropertyPath, message?: VcLocalizableMessage);
	}

	declare class VcProfileExecuteResult
	{
		configSpec: VcHostConfigSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcProfileExecuteError[];
		inapplicablePath: String[];
		requireInput: VcProfileDeferredPolicyOptionParameter[];
		status: String;

		constructor();
		constructor(status?: String, configSpec?: VcHostConfigSpec, inapplicablePath?: String[], requireInput?: VcProfileDeferredPolicyOptionParameter[], error?: VcProfileExecuteError[]);
	}

	interface VcProfileExecuteResultStatus
	{
		readonly error: VcProfileExecuteResultStatus;
		readonly id: String;
		readonly name: String;
		readonly needInput: VcProfileExecuteResultStatus;
		readonly success: VcProfileExecuteResultStatus;
		readonly value: String;

		fromString(value?: VcProfileExecuteResultStatus): VcProfileExecuteResultStatus;
	}

	declare const VcProfileExecuteResultStatus: VcProfileExecuteResultStatus;

	declare class VcProfileExpression
	{
		displayName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		negated: boolean;

		constructor();
		constructor(id?: String, displayName?: String, negated?: boolean);
	}

	declare class VcProfileExpressionMetadata
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expressionId: VcExtendedElementDescription;
		parameter: VcProfileParameterMetadata[];

		constructor();
		constructor(expressionId?: VcExtendedElementDescription, parameter?: VcProfileParameterMetadata[]);
	}

	declare class VcProfileHostHostCustomizationOperationIssues
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errors: VcLocalizableMessage[];
		warnings: VcLocalizableMessage[];

		constructor();
		constructor(warnings?: VcLocalizableMessage[], errors?: VcLocalizableMessage[]);
	}

	interface VcProfileHostProfileEngineComplianceManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkHostCompliance(arg0?: VcHostProfileConfigInfo, arg1?: VcProfileHostProfileEngineHostInfo, arg2?: VcProfileDeferredPolicyOptionParameter[]): VcComplianceResult;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		getDefaultCompliance(arg0?: VcHostApplyProfile): VcHostProfileConfigInfo;
		hostdQueryExpressionMetadata(arg0?: String[]): VcProfileHostProfileEngineComplianceManagerExpressionMetaArray;
	}

	declare const VcProfileHostProfileEngineComplianceManager: VcProfileHostProfileEngineComplianceManager;

	declare class VcProfileHostProfileEngineComplianceManagerExpressionMetaArray
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		exprMeta: VcProfileExpressionMetadata[];

		constructor();
		constructor(exprMeta?: VcProfileExpressionMetadata[]);
	}

	declare class VcProfileHostProfileEngineDvPortgroupInfo
	{
		config: VcDVPortgroupConfigInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		portKeys: String[];

		constructor();
		constructor(config?: VcDVPortgroupConfigInfo, portKeys?: String[]);
	}

	declare class VcProfileHostProfileEngineHostInfo
	{
		agentVmDatastoreName: String;
		agentVmNetworkName: String;
		capability: VcHostCapability;
		config: VcHostConfigInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extension: VcExtension[];
		permission: VcPermission[];
		portgroupInfo: VcProfileHostProfileEngineDvPortgroupInfo[];
		role: VcAuthorizationRole[];
		userAccount: VcUserSearchResult[];

		constructor();
		constructor(capability?: VcHostCapability, config?: VcHostConfigInfo, userAccount?: VcUserSearchResult[], portgroupInfo?: VcProfileHostProfileEngineDvPortgroupInfo[], permission?: VcPermission[], role?: VcAuthorizationRole[], extension?: VcExtension[], agentVmDatastoreName?: String, agentVmNetworkName?: String);
	}

	declare class VcProfileHostProfileEngineHostProfileEngine
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostComplianceManager: VcProfileHostProfileEngineComplianceManager;
		hostProfileManager: VcProfileHostProfileEngineHostProfileManager;

		constructor();
		constructor(hostProfileManager?: VcProfileHostProfileEngineHostProfileManager, hostComplianceManager?: VcProfileHostProfileEngineComplianceManager);
	}

	interface VcProfileHostProfileEngineHostProfileManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		bookKeep(arg0?: VcHostProfileConfigInfo): VcHostProfileConfigInfo;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		hostdApplyHostConfig_Task(arg0?: VcHostConfigSpec): VcTask;
		hostdCreateDefaultProfile(arg0?: String, arg1?: String): VcApplyProfile;
		hostdGenerateHostConfigTaskSpec(arg0?: VcProfileHostProfileEngineHostInfo, arg1?: VcHostApplyProfile, arg2?: VcProfileDeferredPolicyOptionParameter[]): VcApplyHostProfileConfigurationSpec;
		hostdGenerateHostProfileTaskList_Task(arg0?: VcProfileHostProfileEngineHostInfo, arg1?: VcHostConfigSpec): VcTask;
		hostdQueryPolicyMetadata(arg0?: String[]): VcProfileHostProfileEngineHostProfileManagerPolicyMetaArray;
		hostdQueryProfileCategoryMetadata(arg0?: String[]): VcProfileHostProfileEngineHostProfileManagerProfileCategoryMetaArray;
		hostdQueryProfileComponentMetadata(arg0?: String[]): VcProfileHostProfileEngineHostProfileManagerProfileComponentMetaArray;
		hostdQueryProfileStructure(): VcProfileProfileStructure;
		prepareExport(arg0?: VcHostProfileConfigInfo): VcHostProfileConfigInfo;
		profileManagerInternalExecute(arg0?: VcHostApplyProfile, arg1?: VcProfileHostProfileEngineHostInfo, arg2?: VcProfileDeferredPolicyOptionParameter[]): VcProfileExecuteResult;
		queryProfileMetadata(arg0?: String[], arg1?: String[]): VcProfileHostProfileEngineHostProfileManagerProfileMetaArray;
		queryState(): VcKeyAnyValue[];
		retrieveProfile(arg0?: VcProfileHostProfileEngineHostInfo): VcHostProfileConfigInfo;
		retrieveProfileDescription(arg0?: VcHostProfileConfigInfo): VcProfileDescription;
		updateTaskConfigSpec(arg0?: VcProfileHostProfileEngineHostInfo, arg1?: VcHostConfigSpec): VcHostProfileManagerConfigTaskList;
		vpxdProfileManagerQueryUserInputPolicyOptions(arg0?: VcHostApplyProfile, arg1?: VcProfileHostProfileEngineHostInfo): VcProfileHostProfileEngineHostProfileManagerUserInputArray;
	}

	declare const VcProfileHostProfileEngineHostProfileManager: VcProfileHostProfileEngineHostProfileManager;

	declare class VcProfileHostProfileEngineHostProfileManagerPolicyMetaArray
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policyMeta: VcProfilePolicyMetadata[];

		constructor();
		constructor(policyMeta?: VcProfilePolicyMetadata[]);
	}

	declare class VcProfileHostProfileEngineHostProfileManagerProfileCategoryMetaArray
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profileCategoryMeta: VcProfileCategoryMetadata[];

		constructor();
		constructor(profileCategoryMeta?: VcProfileCategoryMetadata[]);
	}

	declare class VcProfileHostProfileEngineHostProfileManagerProfileComponentMetaArray
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profileComponentMeta: VcProfileComponentMetadata[];

		constructor();
		constructor(profileComponentMeta?: VcProfileComponentMetadata[]);
	}

	declare class VcProfileHostProfileEngineHostProfileManagerProfileMetaArray
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profileMeta: VcProfileMetadata[];

		constructor();
		constructor(profileMeta?: VcProfileMetadata[]);
	}

	declare class VcProfileHostProfileEngineHostProfileManagerUserInputArray
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		userInputPath: VcProfilePropertyPath[];

		constructor();
		constructor(userInputPath?: VcProfilePropertyPath[]);
	}

	interface VcProfileManager
	{
		id: String;
		moref: VcManagedObjectReference;
		profile: VcProfile[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createProfile(arg0?: VcProfileCreateSpec): VcProfile;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		findAssociatedProfile(arg0?: VcManagedEntity): VcProfile[];
		queryPolicyMetadata(arg0?: String[], arg1?: VcProfile): VcProfilePolicyMetadata[];
	}

	declare const VcProfileManager: VcProfileManager;

	declare class VcProfileMetadata
	{
		description: VcExtendedDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		profileCategory: String;
		profileComponent: String;
		profileTypeName: String;
		sortSpec: VcProfileMetadataProfileSortSpec[];

		constructor();
		constructor(key?: String, profileTypeName?: String, description?: VcExtendedDescription, sortSpec?: VcProfileMetadataProfileSortSpec[], profileCategory?: String, profileComponent?: String);
	}

	declare class VcProfileMetadataProfileSortSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parameter: String;
		policyId: String;

		constructor();
		constructor(policyId?: String, parameter?: String);
	}

	interface VcProfileNumericComparator
	{
		readonly equal: VcProfileNumericComparator;
		readonly greaterThan: VcProfileNumericComparator;
		readonly greaterThanEqual: VcProfileNumericComparator;
		readonly id: String;
		readonly lessThan: VcProfileNumericComparator;
		readonly lessThanEqual: VcProfileNumericComparator;
		readonly name: String;
		readonly notEqual: VcProfileNumericComparator;
		readonly value: String;

		fromString(value?: VcProfileNumericComparator): VcProfileNumericComparator;
	}

	declare const VcProfileNumericComparator: VcProfileNumericComparator;

	declare class VcProfileParameterMetadata
	{
		defaultValue_AnyValue: Object;
		defaultValue_FloatValue: Number;
		defaultValue_IntValue: Number;
		defaultValue_LongValue: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hidden: boolean;
		id: VcExtendedElementDescription;
		optional: boolean;
		readOnly: boolean;
		securitySensitive: boolean;
		type: String;

		constructor();
		constructor(id?: VcExtendedElementDescription, type?: String, optional?: boolean, defaultValue?: Object, hidden?: boolean, securitySensitive?: boolean, readOnly?: boolean);
		isHidden(): boolean;
		isReadOnly(): boolean;
		isSecuritySensitive(): boolean;
	}

	declare class VcProfilePolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		policyOption: VcPolicyOption;

		constructor();
		constructor(id?: String, policyOption?: VcPolicyOption);
	}

	declare class VcProfilePolicyMetadata
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcExtendedElementDescription;
		possibleOption: VcProfilePolicyOptionMetadata[];

		constructor();
		constructor(id?: VcExtendedElementDescription, possibleOption?: VcProfilePolicyOptionMetadata[]);
	}

	declare class VcProfilePolicyOptionMetadata
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcExtendedElementDescription;
		parameter: VcProfileParameterMetadata[];

		constructor();
		constructor(id?: VcExtendedElementDescription, parameter?: VcProfileParameterMetadata[]);
	}

	declare class VcProfileProfileStructure
	{
		child: VcProfileProfileStructureProperty[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mapping: VcHostProfileMapping[];
		profileTypeName: String;

		constructor();
		constructor(profileTypeName?: String, child?: VcProfileProfileStructureProperty[], mapping?: VcHostProfileMapping[]);
	}

	declare class VcProfileProfileStructureProperty
	{
		array: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		element: VcProfileProfileStructure;
		propertyName: String;

		constructor();
		constructor(propertyName?: String, array?: boolean, element?: VcProfileProfileStructure);
	}

	declare class VcProfilePropertyPath
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parameterId: String;
		policyId: String;
		profilePath: String;

		constructor();
		constructor(profilePath?: String, policyId?: String, parameterId?: String);
	}

	declare class VcProfileReferenceHostChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		prevReferenceHostName: String;
		profile: VcProfileEventArgument;
		referenceHost: VcHostSystem;
		referenceHostName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, profile?: VcProfileEventArgument, referenceHost?: VcHostSystem, referenceHostName?: String, prevReferenceHostName?: String);
	}

	declare class VcProfileRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, profile?: VcProfileEventArgument);
	}

	declare class VcProfileSerializedCreateSpec
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;
		profileConfigString: String;

		constructor();
		constructor(name?: String, annotation?: String, enabled?: boolean, profileConfigString?: String);
		isEnabled(): boolean;
	}

	declare class VcProfileSimpleExpression
	{
		displayName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expressionType: String;
		id: String;
		negated: boolean;
		parameter: VcKeyAnyValue[];

		constructor();
		constructor(id?: String, displayName?: String, negated?: boolean, expressionType?: String, parameter?: VcKeyAnyValue[]);
	}

	declare class VcProfileUpdateFailed
	{
		failure: VcProfileUpdateFailedUpdateFailure[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(failure?: VcProfileUpdateFailedUpdateFailure[]);
		printStackTrace(): void;
	}

	declare class VcProfileUpdateFailedUpdateFailure
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		errMsg: VcLocalizableMessage;
		profilePath: VcProfilePropertyPath;

		constructor();
		constructor(profilePath?: VcProfilePropertyPath, errMsg?: VcLocalizableMessage);
	}

	declare class VcPropertyChange
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		op: VcPropertyChangeOp;
		val_AnyValue: Object;
		val_FloatValue: Number;
		val_IntValue: Number;
		val_LongValue: Number;

		constructor();
		constructor(name?: String, op?: VcPropertyChangeOp, val?: Object);
	}

	interface VcPropertyChangeOp
	{
		readonly add: VcPropertyChangeOp;
		readonly assign: VcPropertyChangeOp;
		readonly id: String;
		readonly indirectRemove: VcPropertyChangeOp;
		readonly name: String;
		readonly remove: VcPropertyChangeOp;
		readonly value: String;

		fromString(value?: VcPropertyChangeOp): VcPropertyChangeOp;
	}

	declare const VcPropertyChangeOp: VcPropertyChangeOp;

	interface VcPropertyCollector
	{
		filter: VcPropertyFilter[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		cancelRetrievePropertiesEx(arg0?: String): void;
		cancelWaitForUpdates(): void;
		checkForUpdates(arg0?: String): VcUpdateSet;
		continueRetrievePropertiesEx(arg0?: String): VcRetrieveResult;
		createFilter(arg0?: VcPropertyFilterSpec, arg1?: boolean): VcPropertyFilter;
		createPropertyCollector(): VcPropertyCollector;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyPropertyCollector(): void;
		retrieveProperties(arg0?: VcPropertyFilterSpec[]): VcObjectContent[];
		retrievePropertiesEx(arg0?: VcPropertyFilterSpec[], arg1?: VcRetrieveOptions): VcRetrieveResult;
		waitForUpdates(arg0?: String): VcUpdateSet;
		waitForUpdatesEx(arg0?: String, arg1?: VcWaitOptions): VcUpdateSet;
	}

	declare const VcPropertyCollector: VcPropertyCollector;

	interface VcPropertyFilter
	{
		id: String;
		moref: VcManagedObjectReference;
		partialUpdates: boolean;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		spec: VcPropertyFilterSpec;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyPropertyFilter(): void;
	}

	declare const VcPropertyFilter: VcPropertyFilter;

	declare class VcPropertyFilterSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		objectSet: VcObjectSpec[];
		propSet: VcPropertySpec[];
		reportMissingObjectsInResults: boolean;

		constructor();
		constructor(propSet?: VcPropertySpec[], objectSet?: VcObjectSpec[], reportMissingObjectsInResults?: boolean);
		isReportMissingObjectsInResults(): boolean;
	}

	declare class VcPropertyFilterUpdate
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filter: VcPropertyFilter;
		missingSet: VcMissingObject[];
		objectSet: VcObjectUpdate[];

		constructor();
		constructor(filter?: VcPropertyFilter, objectSet?: VcObjectUpdate[], missingSet?: VcMissingObject[]);
	}

	declare class VcPropertySpec
	{
		all: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pathSet: String[];
		type: String;

		constructor();
		constructor(type?: String, all?: boolean, pathSet?: String[]);
		isAll(): boolean;
	}

	declare class VcPropertyUpdate
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		opType: VcPropertyChangeOp;
		propPath: String;

		constructor();
		constructor(propPath?: String, opType?: VcPropertyChangeOp);
	}

	interface VcProxyService
	{
		endpointList: VcProxyServiceEndpointSpec[];
		httpPort: Number;
		httpsPort: Number;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addEndpoint(arg0?: VcProxyServiceEndpointSpec): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		removeEndpoint(arg0?: VcProxyServiceEndpointSpec): void;
	}

	declare const VcProxyService: VcProxyService;

	interface VcProxyServiceAccessMode
	{
		readonly httpAndHttps: VcProxyServiceAccessMode;
		readonly httpOnly: VcProxyServiceAccessMode;
		readonly httpsOnly: VcProxyServiceAccessMode;
		readonly httpsWithRedirect: VcProxyServiceAccessMode;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcProxyServiceAccessMode): VcProxyServiceAccessMode;
	}

	declare const VcProxyServiceAccessMode: VcProxyServiceAccessMode;

	declare class VcProxyServiceEndpointSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String);
	}

	declare class VcProxyServiceLocalServiceSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		port: Number;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String, port?: Number);
	}

	declare class VcProxyServiceLocalTunnelSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		port: Number;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String, port?: Number);
	}

	declare class VcProxyServiceNamedPipeServiceSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pipeName: String;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String, pipeName?: String);
	}

	declare class VcProxyServiceNamedPipeTunnelSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pipeName: String;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String, pipeName?: String);
	}

	declare class VcProxyServiceRedirectSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostName: String;
		port: Number;
		redirectType: String;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String, redirectType?: String, hostName?: String, port?: Number);
	}

	interface VcProxyServiceRedirectSpecRedirectType
	{
		readonly found: VcProxyServiceRedirectSpecRedirectType;
		readonly id: String;
		readonly name: String;
		readonly permanent: VcProxyServiceRedirectSpecRedirectType;
		readonly value: String;

		fromString(value?: VcProxyServiceRedirectSpecRedirectType): VcProxyServiceRedirectSpecRedirectType;
	}

	declare const VcProxyServiceRedirectSpecRedirectType: VcProxyServiceRedirectSpecRedirectType;

	declare class VcProxyServiceRemoteServiceSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostName: String;
		port: Number;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String, hostName?: String, port?: Number);
	}

	declare class VcProxyServiceRemoteTunnelSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostName: String;
		port: Number;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String, hostName?: String, port?: Number);
	}

	declare class VcProxyServiceServiceSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String);
	}

	declare class VcProxyServiceTicketTunnelSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pipePattern: String;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String, pipePattern?: String);
	}

	declare class VcProxyServiceTunnelSpec
	{
		accessMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		serverNamespace: String;

		constructor();
		constructor(serverNamespace?: String, accessMode?: String);
	}

	declare class VcQuarantineModeFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faultType: String;
		readonly localizedMessage: String;
		message: String;
		vmName: String;

		constructor();
		constructor(vmName?: String, faultType?: String);
		printStackTrace(): void;
	}

	interface VcQuarantineModeFaultFaultType
	{
		readonly CorrectionDisallowed: VcQuarantineModeFaultFaultType;
		readonly CorrectionImpact: VcQuarantineModeFaultFaultType;
		readonly id: String;
		readonly name: String;
		readonly NoCompatibleNonQuarantinedHost: VcQuarantineModeFaultFaultType;
		readonly value: String;

		fromString(value?: VcQuarantineModeFaultFaultType): VcQuarantineModeFaultFaultType;
	}

	declare const VcQuarantineModeFaultFaultType: VcQuarantineModeFaultFaultType;

	declare class VcQuestionPending
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		text: String;

		constructor();
		constructor(text?: String);
		printStackTrace(): void;
	}

	declare class VcQuiesceDatastoreIOForHAFailed
	{
		ds: VcDatastore;
		dsName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		name: String;
		type: String;

		constructor();
		constructor(type?: String, name?: String, host?: VcHostSystem, hostName?: String, ds?: VcDatastore, dsName?: String);
		printStackTrace(): void;
	}

	interface VcQuiesceMode
	{
		readonly application: VcQuiesceMode;
		readonly filesystem: VcQuiesceMode;
		readonly id: String;
		readonly name: String;
		readonly none: VcQuiesceMode;
		readonly value: String;

		fromString(value?: VcQuiesceMode): VcQuiesceMode;
	}

	declare const VcQuiesceMode: VcQuiesceMode;

	declare class VcRawDiskNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcRDMConversionNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcRDMNotPreserved
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcRDMNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcRDMNotSupportedOnDatastore
	{
		datastore: VcDatastore;
		datastoreName: String;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String, datastore?: VcDatastore, datastoreName?: String);
		printStackTrace(): void;
	}

	declare class VcRDMPointsToInaccessibleDisk
	{
		backing: String;
		connected: boolean;
		device: String;
		fault: VcLocalizedMethodFault;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String, backing?: String, connected?: boolean, fault?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcReadHostResourcePoolTreeFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcReadOnlyDisksWithLegacyDestination
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		roDiskCount: Number;
		timeoutDanger: boolean;

		constructor();
		constructor(roDiskCount?: Number, timeoutDanger?: boolean);
		printStackTrace(): void;
	}

	declare class VcRebootRequired
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		patch: String;

		constructor();
		constructor(patch?: String);
		printStackTrace(): void;
	}

	interface VcRecommendationReasonCode
	{
		readonly antiAffin: VcRecommendationReasonCode;
		readonly balanceDatastoreIOLoad: VcRecommendationReasonCode;
		readonly balanceDatastoreIOPSReservation: VcRecommendationReasonCode;
		readonly balanceDatastoreSpaceUsage: VcRecommendationReasonCode;
		readonly balanceNetworkBandwidthUsage: VcRecommendationReasonCode;
		readonly checkResource: VcRecommendationReasonCode;
		readonly colocateCommunicatingVM: VcRecommendationReasonCode;
		readonly datastoreMaint: VcRecommendationReasonCode;
		readonly datastoreSpaceOutage: VcRecommendationReasonCode;
		readonly enterStandby: VcRecommendationReasonCode;
		readonly fairnessCpuAvg: VcRecommendationReasonCode;
		readonly fairnessMemAvg: VcRecommendationReasonCode;
		readonly ftConstraints: VcRecommendationReasonCode;
		readonly hostExitDegradation: VcRecommendationReasonCode;
		readonly hostInDegradation: VcRecommendationReasonCode;
		readonly hostMaint: VcRecommendationReasonCode;
		readonly id: String;
		readonly increaseAllocation: VcRecommendationReasonCode;
		readonly increaseCapacity: VcRecommendationReasonCode;
		readonly iolbDisabledInternal: VcRecommendationReasonCode;
		readonly jointAffin: VcRecommendationReasonCode;
		readonly maxVmsConstraint: VcRecommendationReasonCode;
		readonly name: String;
		readonly networkBandwidthReservation: VcRecommendationReasonCode;
		readonly powerOnVm: VcRecommendationReasonCode;
		readonly powerSaving: VcRecommendationReasonCode;
		readonly reservationCpu: VcRecommendationReasonCode;
		readonly reservationMem: VcRecommendationReasonCode;
		readonly storagePlacement: VcRecommendationReasonCode;
		readonly unreservedCapacity: VcRecommendationReasonCode;
		readonly value: String;
		readonly virtualDiskAntiAffin: VcRecommendationReasonCode;
		readonly virtualDiskJointAffin: VcRecommendationReasonCode;
		readonly vmHostHardAffinity: VcRecommendationReasonCode;
		readonly vmHostSoftAffinity: VcRecommendationReasonCode;
		readonly xvmotionPlacement: VcRecommendationReasonCode;

		fromString(value?: VcRecommendationReasonCode): VcRecommendationReasonCode;
	}

	declare const VcRecommendationReasonCode: VcRecommendationReasonCode;

	interface VcRecommendationType
	{
		readonly id: String;
		readonly name: String;
		readonly V1: VcRecommendationType;
		readonly value: String;

		fromString(value?: VcRecommendationType): VcRecommendationType;
	}

	declare const VcRecommendationType: VcRecommendationType;

	declare class VcRecordReplayDisabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcRecoveryEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dvsUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostName: String;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;
		vnic: String;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostName?: String, portKey?: String, dvsUuid?: String, vnic?: String);
	}

	declare class VcRecurrentTaskScheduler
	{
		activeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expireTime: Date;
		interval: Number;

		constructor();
		constructor(activeTime?: Date, expireTime?: Date, interval?: Number);
	}

	interface VcReflectManagedMethodExecuter
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		executeSoap(arg0?: String, arg1?: String, arg2?: String, arg3?: VcReflectManagedMethodExecuterSoapArgument[]): VcReflectManagedMethodExecuterSoapResult;
		fetchSoap(arg0?: String, arg1?: String, arg2?: String): VcReflectManagedMethodExecuterSoapResult;
	}

	declare const VcReflectManagedMethodExecuter: VcReflectManagedMethodExecuter;

	declare class VcReflectManagedMethodExecuterSoapArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		val: String;

		constructor();
		constructor(name?: String, val?: String);
	}

	declare class VcReflectManagedMethodExecuterSoapFault
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		faultDetail: String;
		faultMsg: String;

		constructor();
		constructor(faultMsg?: String, faultDetail?: String);
	}

	declare class VcReflectManagedMethodExecuterSoapResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcReflectManagedMethodExecuterSoapFault;
		response: String;

		constructor();
		constructor(response?: String, fault?: VcReflectManagedMethodExecuterSoapFault);
	}

	declare class VcRelation
	{
		constraint: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		version: String;

		constructor();
		constructor(constraint?: String, name?: String, version?: String);
	}

	declare class VcRemoteDeviceNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcRemoteTSMEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcRemoveFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcReplicationConfigFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcReplicationConfigSpec
	{
		destination: String;
		disk: VcReplicationInfoDiskSettings[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		generation: Number;
		netCompressionEnabled: boolean;
		oppUpdatesEnabled: boolean;
		paused: boolean;
		port: Number;
		quiesceGuestEnabled: boolean;
		rpo: Number;
		vmReplicationId: String;

		constructor();
		constructor(generation?: Number, vmReplicationId?: String, destination?: String, port?: Number, rpo?: Number, quiesceGuestEnabled?: boolean, paused?: boolean, oppUpdatesEnabled?: boolean, netCompressionEnabled?: boolean, disk?: VcReplicationInfoDiskSettings[]);
		isNetCompressionEnabled(): boolean;
	}

	declare class VcReplicationDiskConfigFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		key: Number;
		readonly localizedMessage: String;
		message: String;
		reason: String;
		vmRef: VcVirtualMachine;

		constructor();
		constructor(reason?: String, vmRef?: VcVirtualMachine, key?: Number);
		printStackTrace(): void;
	}

	interface VcReplicationDiskConfigFaultReasonForFault
	{
		readonly diskNotFound: VcReplicationDiskConfigFaultReasonForFault;
		readonly diskTypeNotSupported: VcReplicationDiskConfigFaultReasonForFault;
		readonly duplicateDiskReplicationId: VcReplicationDiskConfigFaultReasonForFault;
		readonly id: String;
		readonly invalidDiskKey: VcReplicationDiskConfigFaultReasonForFault;
		readonly invalidDiskReplicationId: VcReplicationDiskConfigFaultReasonForFault;
		readonly invalidPersistentFilePath: VcReplicationDiskConfigFaultReasonForFault;
		readonly name: String;
		readonly reconfigureDiskReplicationIdNotAllowed: VcReplicationDiskConfigFaultReasonForFault;
		readonly value: String;

		fromString(value?: VcReplicationDiskConfigFaultReasonForFault): VcReplicationDiskConfigFaultReasonForFault;
	}

	declare const VcReplicationDiskConfigFaultReasonForFault: VcReplicationDiskConfigFaultReasonForFault;

	declare class VcReplicationFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcReplicationGroupId
	{
		deviceGroupId: VcDeviceGroupId;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		faultDomainId: VcFaultDomainId;

		constructor();
		constructor(faultDomainId?: VcFaultDomainId, deviceGroupId?: VcDeviceGroupId);
	}

	declare class VcReplicationIncompatibleWithFT
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcReplicationInfoDiskSettings
	{
		diskReplicationId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;

		constructor();
		constructor(key?: Number, diskReplicationId?: String);
	}

	declare class VcReplicationInvalidOptions
	{
		entity: VcManagedEntity;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		options: String;

		constructor();
		constructor(options?: String, entity?: VcManagedEntity);
		printStackTrace(): void;
	}

	declare class VcReplicationNotSupportedOnHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcReplicationSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		replicationGroupId: VcReplicationGroupId;

		constructor();
		constructor(replicationGroupId?: VcReplicationGroupId);
	}

	declare class VcReplicationVmConfigFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;
		vmRef: VcVirtualMachine;

		constructor();
		constructor(reason?: String, vmRef?: VcVirtualMachine);
		printStackTrace(): void;
	}

	interface VcReplicationVmConfigFaultReasonForFault
	{
		readonly cannotRetrieveVmReplicationConfiguration: VcReplicationVmConfigFaultReasonForFault;
		readonly encryptedVm: VcReplicationVmConfigFaultReasonForFault;
		readonly id: String;
		readonly incompatibleHwVersion: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidDestinationIpAddress: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidDestinationPort: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidExtraVmOptions: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidGenerationNumber: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidPriorConfiguration: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidVmReplicationId: VcReplicationVmConfigFaultReasonForFault;
		readonly name: String;
		readonly outOfBoundsRpoValue: VcReplicationVmConfigFaultReasonForFault;
		readonly reconfigureVmReplicationIdNotAllowed: VcReplicationVmConfigFaultReasonForFault;
		readonly replicationAlreadyEnabled: VcReplicationVmConfigFaultReasonForFault;
		readonly replicationConfigurationFailed: VcReplicationVmConfigFaultReasonForFault;
		readonly replicationNotEnabled: VcReplicationVmConfigFaultReasonForFault;
		readonly staleGenerationNumber: VcReplicationVmConfigFaultReasonForFault;
		readonly value: String;

		fromString(value?: VcReplicationVmConfigFaultReasonForFault): VcReplicationVmConfigFaultReasonForFault;
	}

	declare const VcReplicationVmConfigFaultReasonForFault: VcReplicationVmConfigFaultReasonForFault;

	declare class VcReplicationVmFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		instanceId: String;
		readonly localizedMessage: String;
		message: String;
		reason: String;
		state: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(reason?: String, state?: String, instanceId?: String, vm?: VcVirtualMachine);
		printStackTrace(): void;
	}

	interface VcReplicationVmFaultReasonForFault
	{
		readonly closeDiskError: VcReplicationVmFaultReasonForFault;
		readonly groupExist: VcReplicationVmFaultReasonForFault;
		readonly id: String;
		readonly invalidInstanceId: VcReplicationVmFaultReasonForFault;
		readonly invalidState: VcReplicationVmFaultReasonForFault;
		readonly name: String;
		readonly notConfigured: VcReplicationVmFaultReasonForFault;
		readonly offlineReplicating: VcReplicationVmFaultReasonForFault;
		readonly poweredOff: VcReplicationVmFaultReasonForFault;
		readonly poweredOn: VcReplicationVmFaultReasonForFault;
		readonly suspended: VcReplicationVmFaultReasonForFault;
		readonly value: String;

		fromString(value?: VcReplicationVmFaultReasonForFault): VcReplicationVmFaultReasonForFault;
	}

	declare const VcReplicationVmFaultReasonForFault: VcReplicationVmFaultReasonForFault;

	declare class VcReplicationVmInProgressFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		inProgressActivity: String;
		instanceId: String;
		readonly localizedMessage: String;
		message: String;
		reason: String;
		requestedActivity: String;
		state: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(reason?: String, state?: String, instanceId?: String, vm?: VcVirtualMachine, requestedActivity?: String, inProgressActivity?: String);
		printStackTrace(): void;
	}

	interface VcReplicationVmInProgressFaultActivity
	{
		readonly delta: VcReplicationVmInProgressFaultActivity;
		readonly fullSync: VcReplicationVmInProgressFaultActivity;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcReplicationVmInProgressFaultActivity): VcReplicationVmInProgressFaultActivity;
	}

	declare const VcReplicationVmInProgressFaultActivity: VcReplicationVmInProgressFaultActivity;

	declare class VcReplicationVmProgressInfo
	{
		bytesToTransfer: Number;
		bytesTransferred: Number;
		checksumComparedBytes: Number;
		checksumTotalBytes: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		progress: Number;

		constructor();
		constructor(progress?: Number, bytesTransferred?: Number, bytesToTransfer?: Number, checksumTotalBytes?: Number, checksumComparedBytes?: Number);
	}

	interface VcReplicationVmState
	{
		readonly active: VcReplicationVmState;
		readonly error: VcReplicationVmState;
		readonly id: String;
		readonly idle: VcReplicationVmState;
		readonly name: String;
		readonly none: VcReplicationVmState;
		readonly paused: VcReplicationVmState;
		readonly syncing: VcReplicationVmState;
		readonly value: String;

		fromString(value?: VcReplicationVmState): VcReplicationVmState;
	}

	declare const VcReplicationVmState: VcReplicationVmState;

	declare class VcRequestCanceled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcResourceAllocationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expandableReservation: boolean;
		limit: Number;
		overheadLimit: Number;
		reservation: Number;
		shares: VcSharesInfo;

		constructor();
		constructor(reservation?: Number, expandableReservation?: boolean, limit?: Number, shares?: VcSharesInfo, overheadLimit?: Number);
		isExpandableReservation(): boolean;
	}

	declare class VcResourceAllocationOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		sharesOption: VcSharesOption;

		constructor();
		constructor(sharesOption?: VcSharesOption);
	}

	declare class VcResourceConfigOption
	{
		cpuAllocationOption: VcResourceAllocationOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memoryAllocationOption: VcResourceAllocationOption;

		constructor();
		constructor(cpuAllocationOption?: VcResourceAllocationOption, memoryAllocationOption?: VcResourceAllocationOption);
	}

	declare class VcResourceConfigSpec
	{
		changeVersion: String;
		cpuAllocation: VcResourceAllocationInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		lastModified: Date;
		memoryAllocation: VcResourceAllocationInfo;
		networkBandwidthAllocation: VcNetworkBandwidthAllocationInfo[];

		constructor();
		constructor(entity?: VcManagedEntity, changeVersion?: String, lastModified?: Date, cpuAllocation?: VcResourceAllocationInfo, memoryAllocation?: VcResourceAllocationInfo, networkBandwidthAllocation?: VcNetworkBandwidthAllocationInfo[]);
	}

	declare class VcResourceInUse
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		type: String;

		constructor();
		constructor(type?: String, name?: String);
		printStackTrace(): void;
	}

	declare class VcResourceNotAvailable
	{
		containerName: String;
		containerType: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		type: String;

		constructor();
		constructor(containerType?: String, containerName?: String, type?: String);
		printStackTrace(): void;
	}

	interface VcResourcePlanningManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		estimateDatabaseSize(arg0?: VcDatabaseSizeParam): VcDatabaseSizeEstimate;
	}

	declare const VcResourcePlanningManager: VcResourcePlanningManager;

	interface VcResourcePool
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		childConfiguration: VcResourceConfigSpec[];
		config: VcResourceConfigSpec;
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		cpuReservation: String;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		memoryReservation: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		owner: VcComputeResource;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		resourcePool: VcResourcePool[];
		runtime: VcResourcePoolRuntimeInfo;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		summary: VcResourcePoolSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		vm: VcVirtualMachine[];

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createChildVM_Task(arg0?: VcVirtualMachineConfigSpec, arg1?: VcHostSystem): VcTask;
		createResourcePool(arg0?: String, arg1?: VcResourceConfigSpec): VcResourcePool;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVApp(arg0?: String, arg1?: VcResourceConfigSpec, arg2?: VcVAppConfigSpec, arg3?: VcFolder): VcVirtualApp;
		destroy_Task(): VcTask;
		destroyChildren(): void;
		importVApp(arg0?: VcImportSpec, arg1?: VcFolder, arg2?: VcHostSystem): VcHttpNfcLease;
		moveIntoResourcePool(arg0?: VcManagedEntity[]): void;
		queryResourceConfigOption(): VcResourceConfigOption;
		refreshRuntime(): void;
		registerChildVM_Task(arg0?: String, arg1?: String, arg2?: VcHostSystem): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
		updateChildResourceConfiguration(arg0?: VcResourceConfigSpec[]): void;
		updateConfig(arg0?: String, arg1?: VcResourceConfigSpec): void;
	}

	declare const VcResourcePool: VcResourcePool;

	declare class VcResourcePoolCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		parent: VcResourcePoolEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, resourcePool?: VcResourcePoolEventArgument, parent?: VcResourcePoolEventArgument);
	}

	declare class VcResourcePoolDestroyedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, resourcePool?: VcResourcePoolEventArgument);
	}

	declare class VcResourcePoolEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, resourcePool?: VcResourcePoolEventArgument);
	}

	declare class VcResourcePoolEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		resourcePool: VcResourcePool;

		constructor();
		constructor(name?: String, resourcePool?: VcResourcePool);
	}

	declare class VcResourcePoolMovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newParent: VcResourcePoolEventArgument;
		oldParent: VcResourcePoolEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, resourcePool?: VcResourcePoolEventArgument, oldParent?: VcResourcePoolEventArgument, newParent?: VcResourcePoolEventArgument);
	}

	declare class VcResourcePoolQuickStats
	{
		balloonedMemory: Number;
		compressedMemory: Number;
		consumedOverheadMemory: Number;
		distributedCpuEntitlement: Number;
		distributedMemoryEntitlement: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		guestMemoryUsage: Number;
		hostMemoryUsage: Number;
		overallCpuDemand: Number;
		overallCpuUsage: Number;
		overheadMemory: Number;
		privateMemory: Number;
		sharedMemory: Number;
		staticCpuEntitlement: Number;
		staticMemoryEntitlement: Number;
		swappedMemory: Number;

		constructor();
		constructor(overallCpuUsage?: Number, overallCpuDemand?: Number, guestMemoryUsage?: Number, hostMemoryUsage?: Number, distributedCpuEntitlement?: Number, distributedMemoryEntitlement?: Number, staticCpuEntitlement?: Number, staticMemoryEntitlement?: Number, privateMemory?: Number, sharedMemory?: Number, swappedMemory?: Number, balloonedMemory?: Number, overheadMemory?: Number, consumedOverheadMemory?: Number, compressedMemory?: Number);
	}

	declare class VcResourcePoolReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configChanges: VcChangesInfoEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, resourcePool?: VcResourcePoolEventArgument, configChanges?: VcChangesInfoEventArgument);
	}

	declare class VcResourcePoolResourceUsage
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		maxUsage: Number;
		overallUsage: Number;
		reservationUsed: Number;
		reservationUsedForVm: Number;
		unreservedForPool: Number;
		unreservedForVm: Number;

		constructor();
		constructor(reservationUsed?: Number, reservationUsedForVm?: Number, unreservedForPool?: Number, unreservedForVm?: Number, overallUsage?: Number, maxUsage?: Number);
	}

	declare class VcResourcePoolRuntimeInfo
	{
		cpu: VcResourcePoolResourceUsage;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memory: VcResourcePoolResourceUsage;
		overallStatus: VcManagedEntityStatus;

		constructor();
		constructor(memory?: VcResourcePoolResourceUsage, cpu?: VcResourcePoolResourceUsage, overallStatus?: VcManagedEntityStatus);
	}

	declare class VcResourcePoolSummary
	{
		config: VcResourceConfigSpec;
		configuredMemoryMB: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		quickStats: VcResourcePoolQuickStats;
		runtime: VcResourcePoolRuntimeInfo;

		constructor();
		constructor(name?: String, config?: VcResourceConfigSpec, runtime?: VcResourcePoolRuntimeInfo, quickStats?: VcResourcePoolQuickStats, configuredMemoryMB?: Number);
	}

	interface VcResourceType
	{
		readonly cpu: VcResourceType;
		readonly id: String;
		readonly memory: VcResourceType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcResourceType): VcResourceType;
	}

	declare const VcResourceType: VcResourceType;

	declare class VcResourceViolatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, resourcePool?: VcResourcePoolEventArgument);
	}

	declare class VcRestrictedByAdministrator
	{
		details: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(details?: String);
		printStackTrace(): void;
	}

	declare class VcRestrictedVersion
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcRetrieveCustomizationsResult
	{
		customizations: VcAnswerFile;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		fault: VcLocalizedMethodFault;

		constructor();
		constructor(entity?: VcManagedEntity, customizations?: VcAnswerFile, fault?: VcLocalizedMethodFault);
	}

	declare class VcRetrieveOptions
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		maxObjects: Number;

		constructor();
		constructor(maxObjects?: Number);
	}

	declare class VcRetrieveResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		objects: VcObjectContent[];
		token: String;

		constructor();
		constructor(token?: String, objects?: VcObjectContent[]);
	}

	declare class VcRoleAddedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		privilegeList: String[];
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, role?: VcRoleEventArgument, privilegeList?: String[]);
	}

	declare class VcRoleEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, role?: VcRoleEventArgument);
	}

	declare class VcRoleEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		roleId: Number;

		constructor();
		constructor(roleId?: Number, name?: String);
	}

	declare class VcRoleRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, role?: VcRoleEventArgument);
	}

	declare class VcRoleUpdatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		prevRoleName: String;
		privilegeList: String[];
		privilegesAdded: String[];
		privilegesRemoved: String[];
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, role?: VcRoleEventArgument, privilegeList?: String[], prevRoleName?: String, privilegesAdded?: String[], privilegesRemoved?: String[]);
	}

	declare class VcRollbackEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostName: String;
		key: Number;
		methodName: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, hostName?: String, methodName?: String);
	}

	declare class VcRollbackFailure
	{
		entityName: String;
		entityType: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(entityName?: String, entityType?: String);
		printStackTrace(): void;
	}

	declare class VcRuleViolation
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;
		rule: VcClusterRuleInfo;

		constructor();
		constructor(host?: VcHostSystem, rule?: VcClusterRuleInfo);
		printStackTrace(): void;
	}

	declare class VcRunScriptAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		script: String;

		constructor();
		constructor(script?: String);
	}

	declare class VcRuntimeFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		localizedMessage: String;
		message: String;

		constructor();
		constructor(message?: String);
		printStackTrace(): void;
	}

	declare class VcSAMLTokenAuthentication
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		interactiveSession: boolean;
		token: String;
		username: String;

		constructor();
		constructor(interactiveSession?: boolean, token?: String, username?: String);
	}

	declare class VcScheduledHardwareUpgradeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		scheduledHardwareUpgradeStatus: String;
		upgradePolicy: String;
		versionKey: String;

		constructor();
		constructor(upgradePolicy?: String, versionKey?: String, scheduledHardwareUpgradeStatus?: String, fault?: VcLocalizedMethodFault);
	}

	interface VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy
	{
		readonly always: VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
		readonly id: String;
		readonly name: String;
		readonly never: VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
		readonly onSoftPowerOff: VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
		readonly value: String;

		fromString(value?: VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy): VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
	}

	declare const VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy: VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;

	interface VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus
	{
		readonly failed: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly id: String;
		readonly name: String;
		readonly none: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly pending: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly success: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly value: String;

		fromString(value?: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus): VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
	}

	declare const VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;

	interface VcScheduledTask
	{
		readonly availableField: VcCustomFieldDef[];
		id: String;
		info: VcScheduledTaskInfo;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureScheduledTask(arg0?: VcScheduledTaskSpec): void;
		removeScheduledTask(): void;
		runScheduledTask(): void;
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcScheduledTask: VcScheduledTask;

	declare class VcScheduledTaskCompletedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, scheduledTask?: VcScheduledTaskEventArgument, entity?: VcManagedEntityEventArgument);
	}

	declare class VcScheduledTaskCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, scheduledTask?: VcScheduledTaskEventArgument, entity?: VcManagedEntityEventArgument);
	}

	declare class VcScheduledTaskDescription
	{
		action: VcTypeDescription[];
		dayOfWeek: VcElementDescription[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		schedulerInfo: VcScheduledTaskDetail[];
		state: VcElementDescription[];
		weekOfMonth: VcElementDescription[];

		constructor();
		constructor(action?: VcTypeDescription[], schedulerInfo?: VcScheduledTaskDetail[], state?: VcElementDescription[], dayOfWeek?: VcElementDescription[], weekOfMonth?: VcElementDescription[]);
	}

	declare class VcScheduledTaskDetail
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		frequency: String;
		key: String;
		label: String;
		summary: String;

		constructor();
		constructor(label?: String, summary?: String, key?: String, frequency?: String);
	}

	declare class VcScheduledTaskEmailCompletedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		to: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, scheduledTask?: VcScheduledTaskEventArgument, entity?: VcManagedEntityEventArgument, to?: String);
	}

	declare class VcScheduledTaskEmailFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		scheduledTask: VcScheduledTaskEventArgument;
		to: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, scheduledTask?: VcScheduledTaskEventArgument, entity?: VcManagedEntityEventArgument, to?: String, reason?: VcLocalizedMethodFault);
	}

	declare class VcScheduledTaskEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, scheduledTask?: VcScheduledTaskEventArgument, entity?: VcManagedEntityEventArgument);
	}

	declare class VcScheduledTaskEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		scheduledTask: VcScheduledTask;

		constructor();
		constructor(name?: String, scheduledTask?: VcScheduledTask);
	}

	declare class VcScheduledTaskFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, scheduledTask?: VcScheduledTaskEventArgument, entity?: VcManagedEntityEventArgument, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcScheduledTaskInfo
	{
		action: VcAction;
		activeTask: VcTask;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		entity: VcManagedEntity;
		error: VcLocalizedMethodFault;
		lastModifiedTime: Date;
		lastModifiedUser: String;
		name: String;
		nextRunTime: Date;
		notification: String;
		prevRunTime: Date;
		progress: Number;
		result_AnyValue: Object;
		result_FloatValue: Number;
		result_IntValue: Number;
		result_LongValue: Number;
		scheduledTask: VcScheduledTask;
		scheduler: VcTaskScheduler;
		state: VcTaskInfoState;
		taskObject: VcManagedObject;

		constructor();
		constructor(name?: String, description?: String, enabled?: boolean, scheduler?: VcTaskScheduler, action?: VcAction, notification?: String, scheduledTask?: VcScheduledTask, entity?: VcManagedEntity, lastModifiedTime?: Date, lastModifiedUser?: String, nextRunTime?: Date, prevRunTime?: Date, state?: VcTaskInfoState, error?: VcLocalizedMethodFault, result?: Object, progress?: Number, activeTask?: VcTask, taskObject?: VcManagedObject);
	}

	interface VcScheduledTaskManager
	{
		description: VcScheduledTaskDescription;
		id: String;
		moref: VcManagedObjectReference;
		scheduledTask: VcScheduledTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createObjectScheduledTask(arg0?: VcManagedObject, arg1?: VcScheduledTaskSpec): VcScheduledTask;
		createScheduledTask(arg0?: VcManagedEntity, arg1?: VcScheduledTaskSpec): VcScheduledTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		retrieveEntityScheduledTask(arg0?: VcManagedEntity): VcScheduledTask[];
		retrieveObjectScheduledTask(arg0?: VcManagedObject): VcScheduledTask[];
	}

	declare const VcScheduledTaskManager: VcScheduledTaskManager;

	declare class VcScheduledTaskReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configChanges: VcChangesInfoEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, scheduledTask?: VcScheduledTaskEventArgument, entity?: VcManagedEntityEventArgument, configChanges?: VcChangesInfoEventArgument);
	}

	declare class VcScheduledTaskRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, scheduledTask?: VcScheduledTaskEventArgument, entity?: VcManagedEntityEventArgument);
	}

	declare class VcScheduledTaskSpec
	{
		action: VcAction;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		name: String;
		notification: String;
		scheduler: VcTaskScheduler;

		constructor();
		constructor(name?: String, description?: String, enabled?: boolean, scheduler?: VcTaskScheduler, action?: VcAction, notification?: String);
	}

	declare class VcScheduledTaskStartedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, scheduledTask?: VcScheduledTaskEventArgument, entity?: VcManagedEntityEventArgument);
	}

	interface VcScsiDiskType
	{
		readonly emulated512: VcScsiDiskType;
		readonly id: String;
		readonly name: String;
		readonly native4k: VcScsiDiskType;
		readonly native512: VcScsiDiskType;
		readonly SoftwareEmulated4k: VcScsiDiskType;
		readonly unknown: VcScsiDiskType;
		readonly value: String;

		fromString(value?: VcScsiDiskType): VcScsiDiskType;
	}

	declare const VcScsiDiskType: VcScsiDiskType;

	declare class VcScsiLun
	{
		alternateName: VcScsiLunDurableName[];
		canonicalName: String;
		capabilities: VcScsiLunCapabilities;
		descriptor: VcScsiLunDescriptor[];
		deviceName: String;
		deviceType: String;
		displayName: String;
		durableName: VcScsiLunDurableName;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		lunType: String;
		model: String;
		operationalState: String[];
		protocolEndpoint: boolean;
		queueDepth: Number;
		revision: String;
		scsiLevel: Number;
		serialNumber: String;
		standardInquiry: Number[];
		uuid: String;
		vendor: String;
		vStorageSupport: String;

		constructor(deviceName?: String, deviceType?: String, key?: String, uuid?: String, descriptor?: VcScsiLunDescriptor[], canonicalName?: String, displayName?: String, lunType?: String, vendor?: String, model?: String, revision?: String, scsiLevel?: Number, serialNumber?: String, durableName?: VcScsiLunDurableName, alternateName?: VcScsiLunDurableName[], standardInquiry?: Number[], queueDepth?: Number, operationalState?: String[], capabilities?: VcScsiLunCapabilities, vStorageSupport?: String, protocolEndpoint?: boolean);
		constructor();
		isProtocolEndpoint(): boolean;
	}

	declare class VcScsiLunCapabilities
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		updateDisplayNameSupported: boolean;

		constructor();
		constructor(updateDisplayNameSupported?: boolean);
	}

	declare class VcScsiLunDescriptor
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		quality: String;

		constructor();
		constructor(quality?: String, id?: String);
	}

	interface VcScsiLunDescriptorQuality
	{
		readonly highQuality: VcScsiLunDescriptorQuality;
		readonly id: String;
		readonly lowQuality: VcScsiLunDescriptorQuality;
		readonly mediumQuality: VcScsiLunDescriptorQuality;
		readonly name: String;
		readonly unknownQuality: VcScsiLunDescriptorQuality;
		readonly value: String;

		fromString(value?: VcScsiLunDescriptorQuality): VcScsiLunDescriptorQuality;
	}

	declare const VcScsiLunDescriptorQuality: VcScsiLunDescriptorQuality;

	declare class VcScsiLunDurableName
	{
		data: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		namespace: String;
		namespaceId: Number;

		constructor();
		constructor(namespace?: String, namespaceId?: Number, data?: Number[]);
	}

	interface VcScsiLunState
	{
		readonly degraded: VcScsiLunState;
		readonly error: VcScsiLunState;
		readonly id: String;
		readonly lostCommunication: VcScsiLunState;
		readonly name: String;
		readonly off: VcScsiLunState;
		readonly ok: VcScsiLunState;
		readonly quiesced: VcScsiLunState;
		readonly timeout: VcScsiLunState;
		readonly unknownState: VcScsiLunState;
		readonly value: String;

		fromString(value?: VcScsiLunState): VcScsiLunState;
	}

	declare const VcScsiLunState: VcScsiLunState;

	interface VcScsiLunType
	{
		readonly cdrom: VcScsiLunType;
		readonly communications: VcScsiLunType;
		readonly disk: VcScsiLunType;
		readonly enclosure: VcScsiLunType;
		readonly id: String;
		readonly mediaChanger: VcScsiLunType;
		readonly name: String;
		readonly opticalDevice: VcScsiLunType;
		readonly printer: VcScsiLunType;
		readonly processor: VcScsiLunType;
		readonly scanner: VcScsiLunType;
		readonly storageArrayController: VcScsiLunType;
		readonly tape: VcScsiLunType;
		readonly unknown: VcScsiLunType;
		readonly value: String;
		readonly worm: VcScsiLunType;

		fromString(value?: VcScsiLunType): VcScsiLunType;
	}

	declare const VcScsiLunType: VcScsiLunType;

	interface VcScsiLunVStorageSupportStatus
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vStorageSupported: VcScsiLunVStorageSupportStatus;
		readonly vStorageUnknown: VcScsiLunVStorageSupportStatus;
		readonly vStorageUnsupported: VcScsiLunVStorageSupportStatus;

		fromString(value?: VcScsiLunVStorageSupportStatus): VcScsiLunVStorageSupportStatus;
	}

	declare const VcScsiLunVStorageSupportStatus: VcScsiLunVStorageSupportStatus;

	declare class VcSdkConnection
	{
		about: VcAboutInfo;
		aboutInfo: VcAboutInfo;
		accountManager: VcHostLocalAccountManager;
		alarmManager: VcAlarmManager;
		allClusterComputeResources: Object[];
		allComputeResources: Object[];
		allDatacenterFolders: Object[];
		allDatacenters: Object[];
		allDatastoreFolders: Object[];
		allDatastores: Object[];
		allDistributedVirtualPortgroups: Object[];
		allHostFolders: Object[];
		allHostSystems: Object[];
		allNetworkFolders: Object[];
		allNetworks: Object[];
		allResourcePools: Object[];
		allTasks: Object[];
		allVirtualApps: Object[];
		allVirtualMachines: Object[];
		allVirtualMachineSnapshots: Object[];
		allVmFolders: Object[];
		authorizationManager: VcAuthorizationManager;
		clusterProfileManager: VcProfileManager;
		complianceManager: VcProfileComplianceManager;
		customFieldsManager: VcCustomFieldsManager;
		customizationSpecManager: VcCustomizationSpecManager;
		diagnosticManager: VcDiagnosticManager;
		displayName: String;
		dvSwitchManager: VcDistributedVirtualSwitchManager;
		eventManager: VcEventManager;
		extensionManager: VcExtensionManager;
		fileManager: VcFileManager;
		guestOperationsManager: VcGuestOperationsManager;
		hostLocalAccountManager: VcHostLocalAccountManager;
		hostProfileManager: VcProfileManager;
		id: String;
		instanceUuid: String;
		ipPoolManager: VcIpPoolManager;
		licenseManager: VcLicenseManager;
		localizationManager: VcLocalizationManager;
		name: String;
		optionManager: VcOptionManager;
		ovfManager: VcOvfManager;
		perfManager: VcPerformanceManager;
		performanceManager: VcPerformanceManager;
		propertyCollector: VcPropertyCollector;
		rootFolder: VcFolder;
		scheduledTaskManager: VcScheduledTaskManager;
		sdkId: String;
		searchIndex: VcSearchIndex;
		serviceInstance: VcServiceInstance;
		sessionManager: VcSessionManager;
		setting: VcOptionManager;
		snmpSystem: VcHostSnmpSystem;
		storageResourceManager: VcStorageResourceManager;
		taskManager: VcTaskManager;
		userDirectory: VcUserDirectory;
		version: String;
		viewManager: VcViewManager;
		virtualDiskManager: VcVirtualDiskManager;
		virtualizationManager: VcVirtualizationManager;
		virtualizationManger: VcVirtualizationManager;
		vmCompatibilityChecker: VcVirtualMachineCompatibilityChecker;
		vmProvisioningChecker: VcVirtualMachineProvisioningChecker;

		constructor();
		getAllClusterComputeResources(additionalPropertyFilters?: String[], query?: String): VcClusterComputeResource[];
		getAllComputeResources(additionalPropertyFilters?: String[], query?: String): VcComputeResource[];
		getAllDatacenterFolders(additionalPropertyFilters?: String[], query?: String): VcDatacenterFolder[];
		getAllDatacenters(additionalPropertyFilters?: String[], query?: String): VcDatacenter[];
		getAllDatastoreFolders(additionalPropertyFilters?: String[], query?: String): VcDatastoreFolder[];
		getAllDatastores(additionalPropertyFilters?: String[], query?: String): VcDatastore[];
		getAllDistributedVirtualPortgroups(additionalPropertyFilters?: String[], query?: String): VcDistributedVirtualPortgroup[];
		getAllHostFolders(additionalPropertyFilters?: String[], query?: String): VcHostFolder[];
		getAllHostSystems(additionalPropertyFilters?: String[], query?: String): VcHostSystem[];
		getAllNetworkFolders(additionalPropertyFilters?: String[], query?: String): VcNetworkFolder[];
		getAllNetworks(additionalPropertyFilters?: String[], query?: String): VcNetwork[];
		getAllResourcePools(additionalPropertyFilters?: String[], query?: String): VcResourcePool[];
		getAllTasks(additionalPropertyFilters?: String[], query?: String): VcTask[];
		getAllVimManagedObjects(sdkType?: String, additionalFilters?: String[], query?: String): VcManagedObject[];
		getAllVirtualApps(additionalPropertyFilters?: String[], query?: String): VcVirtualApp[];
		getAllVirtualMachines(additionalPropertyFilters?: String[], query?: String): VcVirtualMachine[];
		getAllVirtualMachineSnapshots(additionalPropertyFilters?: String[], query?: String): VcVirtualMachineSnapshot[];
		getAllVmFolders(additionalPropertyFilters?: String[], query?: String): VcVmFolder[];
		getManagedObjects(ids?: String[], sdkType?: String): VcManagedObject[];
	}

	interface VcSearchIndex
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		findAllByDnsName(arg0?: VcDatacenter, arg1?: String, arg2?: boolean): VcManagedEntity[];
		findAllByIp(arg0?: VcDatacenter, arg1?: String, arg2?: boolean): VcManagedEntity[];
		findAllByUuid(arg0?: VcDatacenter, arg1?: String, arg2?: boolean, arg3?: boolean): VcManagedEntity[];
		findByDatastorePath(arg0?: VcDatacenter, arg1?: String): VcVirtualMachine;
		findByDnsName(arg0?: VcDatacenter, arg1?: String, arg2?: boolean): VcManagedEntity;
		findByInventoryPath(arg0?: String): VcManagedEntity;
		findByIp(arg0?: VcDatacenter, arg1?: String, arg2?: boolean): VcManagedEntity;
		findByUuid(arg0?: VcDatacenter, arg1?: String, arg2?: boolean, arg3?: boolean): VcManagedEntity;
		findChild(arg0?: VcManagedEntity, arg1?: String): VcManagedEntity;
	}

	declare const VcSearchIndex: VcSearchIndex;

	declare class VcSecondaryVmAlreadyDisabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		instanceUuid: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(instanceUuid?: String);
		printStackTrace(): void;
	}

	declare class VcSecondaryVmAlreadyEnabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		instanceUuid: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(instanceUuid?: String);
		printStackTrace(): void;
	}

	declare class VcSecondaryVmAlreadyRegistered
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		instanceUuid: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(instanceUuid?: String);
		printStackTrace(): void;
	}

	declare class VcSecondaryVmNotRegistered
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		instanceUuid: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(instanceUuid?: String);
		printStackTrace(): void;
	}

	declare class VcSecurityError
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSecurityProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		permission: VcPermissionProfile[];
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, permission?: VcPermissionProfile[]);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcSelectionSet
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcSelectionSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String);
	}

	declare class VcSendEmailAction
	{
		body: String;
		ccList: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		subject: String;
		toList: String;

		constructor();
		constructor(toList?: String, ccList?: String, subject?: String, body?: String);
	}

	declare class VcSendSNMPAction
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcServerLicenseExpiredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		product: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, product?: String);
	}

	declare class VcServerStartedSessionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcServiceConsolePortGroupProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		ipConfig: VcIpAddressProfile;
		key: String;
		name: String;
		networkPolicy: VcNetworkPolicyProfile;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;
		vlan: VcVlanProfile;
		vswitch: VcVirtualSwitchSelectionProfile;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String, name?: String, vlan?: VcVlanProfile, vswitch?: VcVirtualSwitchSelectionProfile, networkPolicy?: VcNetworkPolicyProfile, ipConfig?: VcIpAddressProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcServiceConsoleReservationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		serviceConsoleReserved: Number;
		serviceConsoleReservedCfg: Number;
		unreserved: Number;

		constructor();
		constructor(serviceConsoleReservedCfg?: Number, serviceConsoleReserved?: Number, unreserved?: Number);
	}

	declare class VcServiceContent
	{
		about: VcAboutInfo;
		accountManager: VcHostLocalAccountManager;
		alarmManager: VcAlarmManager;
		authorizationManager: VcAuthorizationManager;
		certificateManager: VcCertificateManager;
		clusterProfileManager: VcClusterProfileManager;
		complianceManager: VcProfileComplianceManager;
		cryptoManager: VcCryptoManager;
		customFieldsManager: VcCustomFieldsManager;
		customizationSpecManager: VcCustomizationSpecManager;
		datastoreNamespaceManager: VcDatastoreNamespaceManager;
		diagnosticManager: VcDiagnosticManager;
		dvSwitchManager: VcDistributedVirtualSwitchManager;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eventManager: VcEventManager;
		extensionManager: VcExtensionManager;
		failoverClusterConfigurator: VcFailoverClusterConfigurator;
		failoverClusterManager: VcFailoverClusterManager;
		fileManager: VcFileManager;
		guestOperationsManager: VcGuestOperationsManager;
		healthUpdateManager: VcHealthUpdateManager;
		hostProfileManager: VcHostProfileManager;
		hostSpecManager: VcHostSpecificationManager;
		ioFilterManager: VcIoFilterManager;
		ipPoolManager: VcIpPoolManager;
		licenseManager: VcLicenseManager;
		localizationManager: VcLocalizationManager;
		overheadMemoryManager: VcOverheadMemoryManager;
		ovfManager: VcOvfManager;
		perfManager: VcPerformanceManager;
		propertyCollector: VcPropertyCollector;
		rootFolder: VcFolder;
		scheduledTaskManager: VcScheduledTaskManager;
		searchIndex: VcSearchIndex;
		serviceManager: VcServiceManager;
		sessionManager: VcSessionManager;
		setting: VcOptionManager;
		snmpSystem: VcHostSnmpSystem;
		storageResourceManager: VcStorageResourceManager;
		taskManager: VcTaskManager;
		userDirectory: VcUserDirectory;
		viewManager: VcViewManager;
		virtualDiskManager: VcVirtualDiskManager;
		virtualizationManager: VcVirtualizationManager;
		vmCompatibilityChecker: VcVirtualMachineCompatibilityChecker;
		vmProvisioningChecker: VcVirtualMachineProvisioningChecker;
		vStorageObjectManager: VcVStorageObjectManagerBase;

		constructor();
		constructor(rootFolder?: VcFolder, propertyCollector?: VcPropertyCollector, viewManager?: VcViewManager, about?: VcAboutInfo, setting?: VcOptionManager, userDirectory?: VcUserDirectory, sessionManager?: VcSessionManager, authorizationManager?: VcAuthorizationManager, serviceManager?: VcServiceManager, perfManager?: VcPerformanceManager, scheduledTaskManager?: VcScheduledTaskManager, alarmManager?: VcAlarmManager, eventManager?: VcEventManager, taskManager?: VcTaskManager, extensionManager?: VcExtensionManager, customizationSpecManager?: VcCustomizationSpecManager, customFieldsManager?: VcCustomFieldsManager, accountManager?: VcHostLocalAccountManager, diagnosticManager?: VcDiagnosticManager, licenseManager?: VcLicenseManager, searchIndex?: VcSearchIndex, fileManager?: VcFileManager, datastoreNamespaceManager?: VcDatastoreNamespaceManager, virtualDiskManager?: VcVirtualDiskManager, virtualizationManager?: VcVirtualizationManager, snmpSystem?: VcHostSnmpSystem, vmProvisioningChecker?: VcVirtualMachineProvisioningChecker, vmCompatibilityChecker?: VcVirtualMachineCompatibilityChecker, ovfManager?: VcOvfManager, ipPoolManager?: VcIpPoolManager, dvSwitchManager?: VcDistributedVirtualSwitchManager, hostProfileManager?: VcHostProfileManager, clusterProfileManager?: VcClusterProfileManager, complianceManager?: VcProfileComplianceManager, localizationManager?: VcLocalizationManager, storageResourceManager?: VcStorageResourceManager, guestOperationsManager?: VcGuestOperationsManager, overheadMemoryManager?: VcOverheadMemoryManager, certificateManager?: VcCertificateManager, ioFilterManager?: VcIoFilterManager, vStorageObjectManager?: VcVStorageObjectManagerBase, hostSpecManager?: VcHostSpecificationManager, cryptoManager?: VcCryptoManager, healthUpdateManager?: VcHealthUpdateManager, failoverClusterConfigurator?: VcFailoverClusterConfigurator, failoverClusterManager?: VcFailoverClusterManager);
	}

	interface VcServiceDirectory
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		service: VcServiceEndpoint[];
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryServiceEndpointList(): VcServiceEndpoint[];
		registerService(arg0?: VcServiceEndpoint): void;
		unregisterService(arg0?: String): void;
	}

	declare const VcServiceDirectory: VcServiceDirectory;

	declare class VcServiceEndpoint
	{
		certificate: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		instanceName: String;
		instanceUuid: String;
		key: String;
		protocol: String;
		sslThumbprint: String;
		url: String;
		vcInstanceId: Number;

		constructor();
		constructor(key?: String, instanceUuid?: String, instanceName?: String, vcInstanceId?: Number, protocol?: String, url?: String, sslThumbprint?: String, certificate?: String);
	}

	interface VcServiceInstance
	{
		capability: VcCapability;
		content: VcServiceContent;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		serverClock: Date;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		currentTime(): Date;
		queryVMotionCompatibility(arg0?: VcVirtualMachine, arg1?: VcHostSystem[], arg2?: String[]): VcHostVMotionCompatibility[];
		retrieveInternalContent(): VcInternalServiceInstanceContent;
		retrieveProductComponents(): VcProductComponentInfo[];
		retrieveServiceContent(): VcServiceContent;
		validateMigration(arg0?: VcVirtualMachine[], arg1?: VcVirtualMachinePowerState, arg2?: String[], arg3?: VcResourcePool, arg4?: VcHostSystem): VcEvent[];
	}

	declare const VcServiceInstance: VcServiceInstance;

	declare class VcServiceLocator
	{
		credential: VcServiceLocatorCredential;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		instanceUuid: String;
		sslThumbprint: String;
		url: String;

		constructor();
		constructor(instanceUuid?: String, url?: String, credential?: VcServiceLocatorCredential, sslThumbprint?: String);
	}

	declare class VcServiceLocatorCredential
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcServiceLocatorNamePassword
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		password: String;
		username: String;

		constructor();
		constructor(username?: String, password?: String);
	}

	declare class VcServiceLocatorSAMLCredential
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		token: String;

		constructor();
		constructor(token?: String);
	}

	interface VcServiceManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		service: VcServiceManagerServiceInfo[];
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryServiceList(arg0?: String, arg1?: String[]): VcServiceManagerServiceInfo[];
	}

	declare const VcServiceManager: VcServiceManager;

	declare class VcServiceManagerServiceInfo
	{
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		location: String[];
		service: VcManagedObject;
		serviceName: String;

		constructor();
		constructor(serviceName?: String, location?: String[], service?: VcManagedObject, description?: String);
	}

	declare class VcServiceProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	interface VcServiceProtocol
	{
		readonly id: String;
		readonly name: String;
		readonly unknown: VcServiceProtocol;
		readonly value: String;
		readonly viImageLibrary: VcServiceProtocol;
		readonly vimApi: VcServiceProtocol;
		readonly vimWebServices: VcServiceProtocol;

		fromString(value?: VcServiceProtocol): VcServiceProtocol;
	}

	declare const VcServiceProtocol: VcServiceProtocol;

	declare class VcSeSparseVirtualDiskSpec
	{
		adapterType: String;
		capacityKb: Number;
		crypto: VcCryptoSpec;
		diskType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		grainSizeKb: Number;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(diskType?: String, adapterType?: String, capacityKb?: Number, profile?: VcVirtualMachineProfileSpec[], crypto?: VcCryptoSpec, grainSizeKb?: Number);
	}

	declare class VcSessionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	interface VcSessionManager
	{
		currentSession: VcUserSession;
		defaultLocale: String;
		id: String;
		message: String;
		messageLocaleList: String[];
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		sessionList: VcUserSession[];
		supportedLocaleList: String[];
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		acquireCloneTicket(): String;
		acquireGenericServiceTicket(arg0?: VcSessionManagerServiceRequestSpec): VcSessionManagerGenericServiceTicket;
		acquireLocalTicket(arg0?: String): VcSessionManagerLocalTicket;
		acquireSessionTicket(arg0?: String): String;
		cloneSession(arg0?: String): VcUserSession;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		impersonateUser(arg0?: String, arg1?: String): VcUserSession;
		login(arg0?: String, arg1?: String, arg2?: String): VcUserSession;
		loginBySessionTicket(arg0?: String): VcUserSession;
		loginBySSLThumbprint(arg0?: String): VcUserSession;
		loginBySSPI(arg0?: String, arg1?: String): VcUserSession;
		loginByToken(arg0?: String): VcUserSession;
		loginExtensionByCertificate(arg0?: String, arg1?: String): VcUserSession;
		loginExtensionBySubjectName(arg0?: String, arg1?: String): VcUserSession;
		logout(): void;
		sessionIsActive(arg0?: String, arg1?: String): boolean;
		terminateSession(arg0?: String[]): void;
		updateServiceMessage(arg0?: String): void;
	}

	declare const VcSessionManager: VcSessionManager;

	declare class VcSessionManagerGenericServiceTicket
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostName: String;
		id: String;
		sslThumbprint: String;

		constructor();
		constructor(id?: String, hostName?: String, sslThumbprint?: String);
	}

	declare class VcSessionManagerHttpServiceRequestSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		method: String;
		url: String;

		constructor();
		constructor(method?: String, url?: String);
	}

	interface VcSessionManagerHttpServiceRequestSpecMethod
	{
		readonly httpConnect: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpDelete: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpGet: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpHead: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpOptions: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpPost: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpPut: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpTrace: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcSessionManagerHttpServiceRequestSpecMethod): VcSessionManagerHttpServiceRequestSpecMethod;
	}

	declare const VcSessionManagerHttpServiceRequestSpecMethod: VcSessionManagerHttpServiceRequestSpecMethod;

	declare class VcSessionManagerLocalTicket
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		passwordFilePath: String;
		userName: String;

		constructor();
		constructor(userName?: String, passwordFilePath?: String);
	}

	declare class VcSessionManagerServiceRequestSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcSessionManagerVmomiServiceRequestSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		method: String;

		constructor(method?: String);
		constructor();
	}

	declare class VcSessionTerminatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sessionId: String;
		terminatedUsername: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, sessionId?: String, terminatedUsername?: String);
	}

	declare class VcSharedBusControllerNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcSharesInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		level: VcSharesLevel;
		shares: Number;

		constructor();
		constructor(shares?: Number, level?: VcSharesLevel);
	}

	interface VcSharesLevel
	{
		readonly custom: VcSharesLevel;
		readonly high: VcSharesLevel;
		readonly id: String;
		readonly low: VcSharesLevel;
		readonly name: String;
		readonly normal: VcSharesLevel;
		readonly value: String;

		fromString(value?: VcSharesLevel): VcSharesLevel;
	}

	declare const VcSharesLevel: VcSharesLevel;

	declare class VcSharesOption
	{
		defaultLevel: VcSharesLevel;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		sharesOption: VcIntOption;

		constructor();
		constructor(sharesOption?: VcIntOption, defaultLevel?: VcSharesLevel);
	}

	declare class VcShrinkDiskFault
	{
		diskId: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(diskId?: Number);
		printStackTrace(): void;
	}

	interface VcSimpleCommand
	{
		encodingType: VcSimpleCommandEncoding;
		entity: VcServiceManagerServiceInfo;
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		executeSimpleCommand(arg0?: String[]): String;
	}

	declare const VcSimpleCommand: VcSimpleCommand;

	interface VcSimpleCommandEncoding
	{
		readonly CSV: VcSimpleCommandEncoding;
		readonly HEX: VcSimpleCommandEncoding;
		readonly id: String;
		readonly name: String;
		readonly STRING: VcSimpleCommandEncoding;
		readonly value: String;

		fromString(value?: VcSimpleCommandEncoding): VcSimpleCommandEncoding;
	}

	declare const VcSimpleCommandEncoding: VcSimpleCommandEncoding;

	declare class VcSingleIp
	{
		address: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;

		constructor();
		constructor(negate?: boolean, address?: String);
		isNegate(): boolean;
	}

	declare class VcSingleMac
	{
		address: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;

		constructor();
		constructor(negate?: boolean, address?: String);
		isNegate(): boolean;
	}

	interface VcSlpDiscoveryMethod
	{
		readonly id: String;
		readonly name: String;
		readonly slpAutoMulticast: VcSlpDiscoveryMethod;
		readonly slpAutoUnicast: VcSlpDiscoveryMethod;
		readonly slpDhcp: VcSlpDiscoveryMethod;
		readonly slpManual: VcSlpDiscoveryMethod;
		readonly value: String;

		fromString(value?: VcSlpDiscoveryMethod): VcSlpDiscoveryMethod;
	}

	declare const VcSlpDiscoveryMethod: VcSlpDiscoveryMethod;

	declare class VcSnapshotCloneNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSnapshotCopyNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSnapshotDisabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSnapshotFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSnapshotIncompatibleDeviceInVm
	{
		fault: VcLocalizedMethodFault;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(fault?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcSnapshotLocked
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSnapshotMoveFromNonHomeNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSnapshotMoveNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSnapshotMoveToNonHomeNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSnapshotNoChange
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSnapshotRevertIssue
	{
		errors: boolean;
		event: VcEvent[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		snapshotName: String;

		constructor();
		constructor(snapshotName?: String, event?: VcEvent[], errors?: boolean);
		printStackTrace(): void;
	}

	declare class VcSoftRuleVioCorrectionDisallowed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmName: String;

		constructor();
		constructor(vmName?: String);
		printStackTrace(): void;
	}

	declare class VcSoftRuleVioCorrectionImpact
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		vmName: String;

		constructor();
		constructor(vmName?: String);
		printStackTrace(): void;
	}

	declare class VcSoftwarePackage
	{
		acceptanceLevel: String;
		capability: VcSoftwarePackageCapability;
		conflicts: VcRelation[];
		creationDate: Date;
		depends: VcRelation[];
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hardwarePlatformsRequired: String[];
		maintenanceModeRequired: boolean;
		name: String;
		payload: String[];
		provides: String[];
		referenceURL: String[];
		replaces: VcRelation[];
		summary: String;
		tag: String[];
		type: String;
		vendor: String;
		version: String;

		constructor();
		constructor(name?: String, version?: String, type?: String, vendor?: String, acceptanceLevel?: String, summary?: String, description?: String, referenceURL?: String[], creationDate?: Date, depends?: VcRelation[], conflicts?: VcRelation[], replaces?: VcRelation[], provides?: String[], maintenanceModeRequired?: boolean, hardwarePlatformsRequired?: String[], capability?: VcSoftwarePackageCapability, tag?: String[], payload?: String[]);
		isMaintenanceModeRequired(): boolean;
	}

	declare class VcSoftwarePackageCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		liveInstallAllowed: boolean;
		liveRemoveAllowed: boolean;
		overlay: boolean;
		statelessReady: boolean;

		constructor();
		constructor(liveInstallAllowed?: boolean, liveRemoveAllowed?: boolean, statelessReady?: boolean, overlay?: boolean);
		isLiveInstallAllowed(): boolean;
		isLiveRemoveAllowed(): boolean;
		isOverlay(): boolean;
		isStatelessReady(): boolean;
	}

	interface VcSoftwarePackageConstraint
	{
		readonly equals: VcSoftwarePackageConstraint;
		readonly greaterThan: VcSoftwarePackageConstraint;
		readonly greaterThanEqual: VcSoftwarePackageConstraint;
		readonly id: String;
		readonly lessThan: VcSoftwarePackageConstraint;
		readonly lessThanEqual: VcSoftwarePackageConstraint;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcSoftwarePackageConstraint): VcSoftwarePackageConstraint;
	}

	declare const VcSoftwarePackageConstraint: VcSoftwarePackageConstraint;

	interface VcSoftwarePackageVibType
	{
		readonly bootbank: VcSoftwarePackageVibType;
		readonly id: String;
		readonly meta: VcSoftwarePackageVibType;
		readonly name: String;
		readonly tools: VcSoftwarePackageVibType;
		readonly value: String;

		fromString(value?: VcSoftwarePackageVibType): VcSoftwarePackageVibType;
	}

	declare const VcSoftwarePackageVibType: VcSoftwarePackageVibType;

	declare class VcSourceNodeSpec
	{
		activeVc: VcVirtualMachine;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		managementVc: VcServiceLocator;

		constructor();
		constructor(managementVc?: VcServiceLocator, activeVc?: VcVirtualMachine);
	}

	declare class VcSpbmIoFilterInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		type: String;

		constructor();
		constructor(id?: String, type?: String);
	}

	declare class VcSsdDiskNotAvailable
	{
		devicePath: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(devicePath?: String);
		printStackTrace(): void;
	}

	declare class VcSSLDisabledFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSSLVerifyFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		selfSigned: boolean;
		thumbprint: String;

		constructor();
		constructor(selfSigned?: boolean, thumbprint?: String);
		printStackTrace(): void;
	}

	declare class VcSSPIAuthentication
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		interactiveSession: boolean;
		sspiToken: String;

		constructor();
		constructor(interactiveSession?: boolean, sspiToken?: String);
	}

	declare class VcSSPIChallenge
	{
		base64Token: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(base64Token?: String);
		printStackTrace(): void;
	}

	declare class VcStateAlarmExpression
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operator: VcStateAlarmOperator;
		red: String;
		statePath: String;
		type: String;
		yellow: String;

		constructor();
		constructor(operator?: VcStateAlarmOperator, type?: String, statePath?: String, yellow?: String, red?: String);
	}

	interface VcStateAlarmOperator
	{
		readonly id: String;
		readonly isEqual: VcStateAlarmOperator;
		readonly isUnequal: VcStateAlarmOperator;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcStateAlarmOperator): VcStateAlarmOperator;
	}

	declare const VcStateAlarmOperator: VcStateAlarmOperator;

	declare class VcStaticRouteProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcStorageDrsAutomationConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ioLoadBalanceAutomationMode: String;
		policyEnforcementAutomationMode: String;
		ruleEnforcementAutomationMode: String;
		spaceLoadBalanceAutomationMode: String;
		vmEvacuationAutomationMode: String;

		constructor();
		constructor(spaceLoadBalanceAutomationMode?: String, ioLoadBalanceAutomationMode?: String, ruleEnforcementAutomationMode?: String, policyEnforcementAutomationMode?: String, vmEvacuationAutomationMode?: String);
	}

	declare class VcStorageDrsCannotMoveDiskInMultiWriterMode
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsCannotMoveFTVm
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsCannotMoveIndependentDisk
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsCannotMoveManuallyPlacedSwapFile
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsCannotMoveManuallyPlacedVm
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsCannotMoveSharedDisk
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsCannotMoveTemplate
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsCannotMoveVmInUserFolder
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsCannotMoveVmWithMountedCDROM
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsCannotMoveVmWithNoFilesInLayout
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsConfigInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		podConfig: VcStorageDrsPodConfigInfo;
		vmConfig: VcStorageDrsVmConfigInfo[];

		constructor();
		constructor(podConfig?: VcStorageDrsPodConfigInfo, vmConfig?: VcStorageDrsVmConfigInfo[]);
	}

	declare class VcStorageDrsConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		podConfigSpec: VcStorageDrsPodConfigSpec;
		vmConfigSpec: VcStorageDrsVmConfigSpec[];

		constructor();
		constructor(podConfigSpec?: VcStorageDrsPodConfigSpec, vmConfigSpec?: VcStorageDrsVmConfigSpec[]);
	}

	declare class VcStorageDrsDatacentersCannotShareDatastore
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsDisabledOnVm
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsHbrDiskNotMovable
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		nonMovableDiskIds: String;

		constructor();
		constructor(nonMovableDiskIds?: String);
		printStackTrace(): void;
	}

	declare class VcStorageDrsHmsMoveInProgress
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsHmsUnreachable
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsIolbDisabledInternally
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsIoLoadBalanceConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ioLatencyThreshold: Number;
		ioLoadImbalanceThreshold: Number;
		reservableIopsThreshold: Number;
		reservablePercentThreshold: Number;
		reservableThresholdMode: String;

		constructor();
		constructor(reservablePercentThreshold?: Number, reservableIopsThreshold?: Number, reservableThresholdMode?: String, ioLatencyThreshold?: Number, ioLoadImbalanceThreshold?: Number);
	}

	declare class VcStorageDrsOptionSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operation: VcArrayUpdateOperation;
		option: VcOptionValue;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, option?: VcOptionValue);
	}

	declare class VcStorageDrsPlacementRankVmSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vmClusters: VcClusterComputeResource[];
		vmPlacementSpec: VcPlacementSpec;

		constructor();
		constructor(vmPlacementSpec?: VcPlacementSpec, vmClusters?: VcClusterComputeResource[]);
	}

	declare class VcStorageDrsPodConfigInfo
	{
		automationOverrides: VcStorageDrsAutomationConfig;
		defaultIntraVmAffinity: boolean;
		defaultVmBehavior: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		ioLoadBalanceConfig: VcStorageDrsIoLoadBalanceConfig;
		ioLoadBalanceEnabled: boolean;
		loadBalanceInterval: Number;
		option: VcOptionValue[];
		rule: VcClusterRuleInfo[];
		spaceLoadBalanceConfig: VcStorageDrsSpaceLoadBalanceConfig;

		constructor();
		constructor(enabled?: boolean, ioLoadBalanceEnabled?: boolean, defaultVmBehavior?: String, loadBalanceInterval?: Number, defaultIntraVmAffinity?: boolean, spaceLoadBalanceConfig?: VcStorageDrsSpaceLoadBalanceConfig, ioLoadBalanceConfig?: VcStorageDrsIoLoadBalanceConfig, automationOverrides?: VcStorageDrsAutomationConfig, rule?: VcClusterRuleInfo[], option?: VcOptionValue[]);
		isDefaultIntraVmAffinity(): boolean;
	}

	interface VcStorageDrsPodConfigInfoBehavior
	{
		readonly automated: VcStorageDrsPodConfigInfoBehavior;
		readonly id: String;
		readonly manual: VcStorageDrsPodConfigInfoBehavior;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcStorageDrsPodConfigInfoBehavior): VcStorageDrsPodConfigInfoBehavior;
	}

	declare const VcStorageDrsPodConfigInfoBehavior: VcStorageDrsPodConfigInfoBehavior;

	declare class VcStorageDrsPodConfigSpec
	{
		automationOverrides: VcStorageDrsAutomationConfig;
		defaultIntraVmAffinity: boolean;
		defaultVmBehavior: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		ioLoadBalanceConfig: VcStorageDrsIoLoadBalanceConfig;
		ioLoadBalanceEnabled: boolean;
		loadBalanceInterval: Number;
		option: VcStorageDrsOptionSpec[];
		rule: VcClusterRuleSpec[];
		spaceLoadBalanceConfig: VcStorageDrsSpaceLoadBalanceConfig;

		constructor();
		constructor(enabled?: boolean, ioLoadBalanceEnabled?: boolean, defaultVmBehavior?: String, loadBalanceInterval?: Number, defaultIntraVmAffinity?: boolean, spaceLoadBalanceConfig?: VcStorageDrsSpaceLoadBalanceConfig, ioLoadBalanceConfig?: VcStorageDrsIoLoadBalanceConfig, automationOverrides?: VcStorageDrsAutomationConfig, rule?: VcClusterRuleSpec[], option?: VcStorageDrsOptionSpec[]);
		isDefaultIntraVmAffinity(): boolean;
		isEnabled(): boolean;
		isIoLoadBalanceEnabled(): boolean;
	}

	declare class VcStorageDrsPodSelectionSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		initialVmConfig: VcVmPodConfigForPlacement[];
		storagePod: VcStoragePod;

		constructor();
		constructor(initialVmConfig?: VcVmPodConfigForPlacement[], storagePod?: VcStoragePod);
	}

	declare class VcStorageDrsRelocateDisabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsSpaceLoadBalanceConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpaceThresholdGB: Number;
		minSpaceUtilizationDifference: Number;
		spaceThresholdMode: String;
		spaceUtilizationThreshold: Number;

		constructor();
		constructor(spaceThresholdMode?: String, spaceUtilizationThreshold?: Number, freeSpaceThresholdGB?: Number, minSpaceUtilizationDifference?: Number);
	}

	interface VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode
	{
		readonly freeSpace: VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
		readonly id: String;
		readonly name: String;
		readonly utilization: VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
		readonly value: String;

		fromString(value?: VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode): VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
	}

	declare const VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode: VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;

	declare class VcStorageDrsStaleHmsCollection
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsUnableToMoveFiles
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcStorageDrsVmConfigInfo
	{
		behavior: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		intraVmAffinity: boolean;
		intraVmAffinityDisks: VcVirtualDiskAffinityRuleSpec;
		intraVmAntiAffinity: VcVirtualDiskAntiAffinityRuleSpec;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, enabled?: boolean, behavior?: String, intraVmAffinity?: boolean, intraVmAffinityDisks?: VcVirtualDiskAffinityRuleSpec, intraVmAntiAffinity?: VcVirtualDiskAntiAffinityRuleSpec);
		isEnabled(): boolean;
		isIntraVmAffinity(): boolean;
	}

	declare class VcStorageDrsVmConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcStorageDrsVmConfigInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcStorageDrsVmConfigInfo);
	}

	declare class VcStorageIOAllocationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		limit: Number;
		reservation: Number;
		shares: VcSharesInfo;

		constructor();
		constructor(limit?: Number, shares?: VcSharesInfo, reservation?: Number);
	}

	declare class VcStorageIOAllocationOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		limitOption: VcLongOption;
		sharesOption: VcSharesOption;

		constructor();
		constructor(limitOption?: VcLongOption, sharesOption?: VcSharesOption);
	}

	declare class VcStorageIORMConfigOption
	{
		congestionThresholdOption: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabledOption: VcBoolOption;
		reservationEnabledOption: VcBoolOption;
		statsCollectionEnabledOption: VcBoolOption;

		constructor();
		constructor(enabledOption?: VcBoolOption, congestionThresholdOption?: VcIntOption, statsCollectionEnabledOption?: VcBoolOption, reservationEnabledOption?: VcBoolOption);
	}

	declare class VcStorageIORMConfigSpec
	{
		congestionThreshold: Number;
		congestionThresholdMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		percentOfPeakThroughput: Number;
		reservableIopsThreshold: Number;
		reservationEnabled: boolean;
		statsAggregationDisabled: boolean;
		statsCollectionEnabled: boolean;

		constructor();
		constructor(enabled?: boolean, congestionThresholdMode?: String, congestionThreshold?: Number, percentOfPeakThroughput?: Number, statsCollectionEnabled?: boolean, reservationEnabled?: boolean, statsAggregationDisabled?: boolean, reservableIopsThreshold?: Number);
		isEnabled(): boolean;
		isReservationEnabled(): boolean;
		isStatsAggregationDisabled(): boolean;
		isStatsCollectionEnabled(): boolean;
	}

	declare class VcStorageIORMDeviceModel
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lqIntercept: Number;
		lqSlope: Number;

		constructor();
		constructor(lqSlope?: Number, lqIntercept?: Number);
	}

	declare class VcStorageIORMInfo
	{
		congestionThreshold: Number;
		congestionThresholdMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		percentOfPeakThroughput: Number;
		reservableIopsThreshold: Number;
		reservationEnabled: boolean;
		statsAggregationDisabled: boolean;
		statsCollectionEnabled: boolean;

		constructor();
		constructor(enabled?: boolean, congestionThresholdMode?: String, congestionThreshold?: Number, percentOfPeakThroughput?: Number, statsCollectionEnabled?: boolean, reservationEnabled?: boolean, statsAggregationDisabled?: boolean, reservableIopsThreshold?: Number);
		isReservationEnabled(): boolean;
		isStatsAggregationDisabled(): boolean;
		isStatsCollectionEnabled(): boolean;
	}

	interface VcStorageIORMThresholdMode
	{
		readonly automatic: VcStorageIORMThresholdMode;
		readonly id: String;
		readonly manual: VcStorageIORMThresholdMode;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcStorageIORMThresholdMode): VcStorageIORMThresholdMode;
	}

	declare const VcStorageIORMThresholdMode: VcStorageIORMThresholdMode;

	declare class VcStorageMigrationAction
	{
		destination: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ioLatencyDstBefore: Number;
		ioLatencySrcBefore: Number;
		relocateSpec: VcVirtualMachineRelocateSpec;
		sizeTransferred: Number;
		source: VcDatastore;
		spaceUtilDstAfter: Number;
		spaceUtilDstBefore: Number;
		spaceUtilSrcAfter: Number;
		spaceUtilSrcBefore: Number;
		target: VcManagedObject;
		type: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(type?: String, target?: VcManagedObject, vm?: VcVirtualMachine, relocateSpec?: VcVirtualMachineRelocateSpec, source?: VcDatastore, destination?: VcDatastore, sizeTransferred?: Number, spaceUtilSrcBefore?: Number, spaceUtilDstBefore?: Number, spaceUtilSrcAfter?: Number, spaceUtilDstAfter?: Number, ioLatencySrcBefore?: Number, ioLatencyDstBefore?: Number);
	}

	declare class VcStoragePerformanceSummary
	{
		datastoreReadIops: Number[];
		datastoreReadLatency: Number[];
		datastoreVmLatency: Number[];
		datastoreWriteIops: Number[];
		datastoreWriteLatency: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		interval: Number;
		percentile: Number[];
		siocActivityDuration: Number;

		constructor();
		constructor(interval?: Number, percentile?: Number[], datastoreReadLatency?: Number[], datastoreWriteLatency?: Number[], datastoreVmLatency?: Number[], datastoreReadIops?: Number[], datastoreWriteIops?: Number[], siocActivityDuration?: Number);
	}

	declare class VcStoragePlacementAction
	{
		destination: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ioLatencyBefore: Number;
		relocateSpec: VcVirtualMachineRelocateSpec;
		spaceDemandAfter: Number;
		spaceDemandBefore: Number;
		spaceUtilAfter: Number;
		spaceUtilBefore: Number;
		target: VcManagedObject;
		type: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(type?: String, target?: VcManagedObject, vm?: VcVirtualMachine, relocateSpec?: VcVirtualMachineRelocateSpec, destination?: VcDatastore, spaceUtilBefore?: Number, spaceDemandBefore?: Number, spaceUtilAfter?: Number, spaceDemandAfter?: Number, ioLatencyBefore?: Number);
	}

	declare class VcStoragePlacementResult
	{
		drsFault: VcClusterDrsFaults;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		recommendations: VcClusterRecommendation[];
		task: VcTask;

		constructor();
		constructor(recommendations?: VcClusterRecommendation[], drsFault?: VcClusterDrsFaults, task?: VcTask);
	}

	declare class VcStoragePlacementSpec
	{
		cloneName: String;
		cloneSpec: VcVirtualMachineCloneSpec;
		configSpec: VcVirtualMachineConfigSpec;
		disallowPrerequisiteMoves: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		folder: VcFolder;
		host: VcHostSystem;
		podSelectionSpec: VcStorageDrsPodSelectionSpec;
		priority: VcVirtualMachineMovePriority;
		relocateSpec: VcVirtualMachineRelocateSpec;
		resourceLeaseDurationSec: Number;
		resourcePool: VcResourcePool;
		type: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(type?: String, priority?: VcVirtualMachineMovePriority, vm?: VcVirtualMachine, podSelectionSpec?: VcStorageDrsPodSelectionSpec, cloneSpec?: VcVirtualMachineCloneSpec, cloneName?: String, configSpec?: VcVirtualMachineConfigSpec, relocateSpec?: VcVirtualMachineRelocateSpec, resourcePool?: VcResourcePool, host?: VcHostSystem, folder?: VcFolder, disallowPrerequisiteMoves?: boolean, resourceLeaseDurationSec?: Number);
		isDisallowPrerequisiteMoves(): boolean;
	}

	interface VcStoragePlacementSpecPlacementType
	{
		readonly clone: VcStoragePlacementSpecPlacementType;
		readonly create: VcStoragePlacementSpecPlacementType;
		readonly expandDisk: VcStoragePlacementSpecPlacementType;
		readonly id: String;
		readonly name: String;
		readonly reconfigure: VcStoragePlacementSpecPlacementType;
		readonly relocate: VcStoragePlacementSpecPlacementType;
		readonly value: String;

		fromString(value?: VcStoragePlacementSpecPlacementType): VcStoragePlacementSpecPlacementType;
	}

	declare const VcStoragePlacementSpecPlacementType: VcStoragePlacementSpecPlacementType;

	interface VcStoragePod
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly childEntity: VcManagedEntity[];
		readonly childType: String[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		podStorageDrsEntry: VcPodStorageDrsEntry;
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		summary: VcStoragePodSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addStandaloneHost_Task(arg0?: VcHostConnectSpec, arg1?: VcComputeResourceConfigSpec, arg2?: boolean, arg3?: String): VcTask;
		addStandaloneHostWithAdminDisabled_Task(arg0?: VcHostConnectSpec, arg1?: VcComputeResourceConfigSpec, arg2?: boolean, arg3?: String): VcTask;
		addTag(arg0?: VcTag[]): void;
		createCluster(arg0?: String, arg1?: VcClusterConfigSpec): VcClusterComputeResource;
		createClusterEx(arg0?: String, arg1?: VcClusterConfigSpecEx): VcClusterComputeResource;
		createDatacenter(arg0?: String): VcDatacenter;
		createDVS_Task(arg0?: VcDVSCreateSpec): VcTask;
		createFolder(arg0?: String): VcFolder;
		createStoragePod(arg0?: String): VcStoragePod;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVM_Task(arg0?: VcVirtualMachineConfigSpec, arg1?: VcResourcePool, arg2?: VcHostSystem): VcTask;
		destroy_Task(): VcTask;
		moveIntoFolder_Task(arg0?: VcManagedEntity[]): VcTask;
		registerVM_Task(arg0?: String, arg1?: String, arg2?: boolean, arg3?: VcResourcePool, arg4?: VcHostSystem): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
		unregisterAndDestroy_Task(): VcTask;
	}

	declare const VcStoragePod: VcStoragePod;

	declare class VcStoragePodSummary
	{
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpace: Number;
		name: String;

		constructor();
		constructor(name?: String, capacity?: Number, freeSpace?: Number);
	}

	declare class VcStorageProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		nasStorage: VcNasStorageProfile[];
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, nasStorage?: VcNasStorageProfile[]);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcStorageRequirement
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpaceRequiredInKb: Number;

		constructor();
		constructor(datastore?: VcDatastore, freeSpaceRequiredInKb?: Number);
	}

	interface VcStorageResourceManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		applyStorageDrsRecommendation_Task(arg0?: String[]): VcTask;
		applyStorageDrsRecommendationToPod_Task(arg0?: VcStoragePod, arg1?: String): VcTask;
		cancelStorageDrsRecommendation(arg0?: String[]): void;
		configureDatastoreIORM_Task(arg0?: VcDatastore, arg1?: VcStorageIORMConfigSpec): VcTask;
		configureDatastoreIORMOnHost(arg0?: VcDatastore, arg1?: VcStorageIORMConfigSpec): void;
		configureStorageDrsForPod_Task(arg0?: VcStoragePod, arg1?: VcStorageDrsConfigSpec, arg2?: boolean): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		getStorageIORMDeviceModel(arg0?: VcDatastore): VcStorageIORMDeviceModel;
		queryDatastorePerformanceSummary(arg0?: VcDatastore): VcStoragePerformanceSummary[];
		queryIORMConfigOption(arg0?: VcHostSystem): VcStorageIORMConfigOption;
		queryStorageStatisticsByProfile(arg0?: VcClusterComputeResource[]): VcStorageResourceManagerStorageProfileStatistics[];
		rankForPlacement(arg0?: VcPlacementRankSpec): VcPlacementRankResult[];
		recommendDatastores(arg0?: VcStoragePlacementSpec): VcStoragePlacementResult;
		refreshStorageDrsRecommendation(arg0?: VcStoragePod): void;
		refreshStorageDrsRecommendationsForPod_Task(arg0?: VcStoragePod): VcTask;
	}

	declare const VcStorageResourceManager: VcStorageResourceManager;

	declare class VcStorageResourceManagerStorageProfileStatistics
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profileId: String;
		totalSpaceMB: Number;
		usedSpaceMB: Number;

		constructor();
		constructor(profileId?: String, totalSpaceMB?: Number, usedSpaceMB?: Number);
	}

	declare class VcStorageVmotionIncompatible
	{
		datastore: VcDatastore;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(datastore?: VcDatastore);
		printStackTrace(): void;
	}

	declare class VcStorageVMotionNotSupported
	{
		atSourceHost: boolean;
		failedHost: VcHostSystem;
		failedHostName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHostName?: String, failedHost?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcStringExpression
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		negate: boolean;
		value: String;

		constructor();
		constructor(negate?: boolean, value?: String);
		isNegate(): boolean;
	}

	declare class VcStringOption
	{
		defaultValue: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		validCharacters: String;
		valueIsReadonly: boolean;

		constructor();
		constructor(valueIsReadonly?: boolean, defaultValue?: String, validCharacters?: String);
		isValueIsReadonly(): boolean;
	}

	declare class VcStringPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		value: String;

		constructor();
		constructor(inherited?: boolean, value?: String);
	}

	declare class VcStructuredCustomizations
	{
		customizations: VcAnswerFile;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;

		constructor();
		constructor(entity?: VcManagedEntity, customizations?: VcAnswerFile);
	}

	declare class VcSuspendedRelocateNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSwapDatastoreNotWritableOnHost
	{
		datastore: VcDatastore;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(datastore?: VcDatastore, name?: String, host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcSwapDatastoreUnset
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSwapPlacementOverrideNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String);
		printStackTrace(): void;
	}

	declare class VcSwitchIpUnset
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSwitchNotInUpgradeMode
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcSystemError
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor(reason?: String);
		constructor();
		printStackTrace(): void;
	}

	declare class VcSystemEventInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		message: String;
		recordId: Number;
		selType: Number;
		sensorNumber: Number;
		when: String;

		constructor();
		constructor(recordId?: Number, when?: String, selType?: Number, message?: String, sensorNumber?: Number);
	}

	declare class VcTag
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;

		constructor(key?: String);
		constructor();
	}

	interface VcTagPolicy
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcTagPolicy: VcTagPolicy;

	interface VcTagPolicyOption
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcTagPolicyOption: VcTagPolicyOption;

	interface VcTask
	{
		readonly availableField: VcCustomFieldDef[];
		id: String;
		info: VcTaskInfo;
		moref: VcManagedObjectReference;
		name: String;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		state: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		cancelTask(): void;
		createEndOfTaskTrigger(timeout?: Number): Trigger;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		setCustomValue(arg0?: String, arg1?: String): void;
		setTaskState(arg0?: VcTaskInfoState, arg1?: Object, arg2?: VcLocalizedMethodFault): void;
		updateProgress(arg0?: Number): void;
	}

	declare const VcTask: VcTask;

	declare class VcTaskDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		methodInfo: VcElementDescription[];
		reason: VcTypeDescription[];
		state: VcElementDescription[];

		constructor();
		constructor(methodInfo?: VcElementDescription[], state?: VcElementDescription[], reason?: VcTypeDescription[]);
	}

	declare class VcTaskEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		info: VcTaskInfo;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, info?: VcTaskInfo);
	}

	declare class VcTaskFilterSpec
	{
		activationId: String[];
		alarm: VcAlarm;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcTaskFilterSpecByEntity;
		eventChainId: Number[];
		parentTaskKey: String[];
		rootTaskKey: String[];
		scheduledTask: VcScheduledTask;
		state: VcTaskInfoState[];
		tag: String[];
		time: VcTaskFilterSpecByTime;
		userName: VcTaskFilterSpecByUsername;

		constructor();
		constructor(entity?: VcTaskFilterSpecByEntity, time?: VcTaskFilterSpecByTime, userName?: VcTaskFilterSpecByUsername, activationId?: String[], state?: VcTaskInfoState[], alarm?: VcAlarm, scheduledTask?: VcScheduledTask, eventChainId?: Number[], tag?: String[], parentTaskKey?: String[], rootTaskKey?: String[]);
	}

	declare class VcTaskFilterSpecByEntity
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		recursion: VcTaskFilterSpecRecursionOption;

		constructor();
		constructor(entity?: VcManagedEntity, recursion?: VcTaskFilterSpecRecursionOption);
	}

	declare class VcTaskFilterSpecByTime
	{
		beginTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endTime: Date;
		timeType: VcTaskFilterSpecTimeOption;

		constructor();
		constructor(timeType?: VcTaskFilterSpecTimeOption, beginTime?: Date, endTime?: Date);
	}

	declare class VcTaskFilterSpecByUsername
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		systemUser: boolean;
		userList: String[];

		constructor();
		constructor(systemUser?: boolean, userList?: String[]);
	}

	interface VcTaskFilterSpecRecursionOption
	{
		readonly all: VcTaskFilterSpecRecursionOption;
		readonly children: VcTaskFilterSpecRecursionOption;
		readonly id: String;
		readonly name: String;
		readonly self: VcTaskFilterSpecRecursionOption;
		readonly value: String;

		fromString(value?: VcTaskFilterSpecRecursionOption): VcTaskFilterSpecRecursionOption;
	}

	declare const VcTaskFilterSpecRecursionOption: VcTaskFilterSpecRecursionOption;

	interface VcTaskFilterSpecTimeOption
	{
		readonly completedTime: VcTaskFilterSpecTimeOption;
		readonly id: String;
		readonly name: String;
		readonly queuedTime: VcTaskFilterSpecTimeOption;
		readonly startedTime: VcTaskFilterSpecTimeOption;
		readonly value: String;

		fromString(value?: VcTaskFilterSpecTimeOption): VcTaskFilterSpecTimeOption;
	}

	declare const VcTaskFilterSpecTimeOption: VcTaskFilterSpecTimeOption;

	interface VcTaskHistoryCollector
	{
		readonly filter_AnyValue: Object;
		readonly filter_FloatValue: Number;
		readonly filter_IntValue: Number;
		readonly filter_LongValue: Number;
		id: String;
		latestPage: VcTaskInfo[];
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyCollector(): void;
		readNextTasks(arg0?: Number): VcTaskInfo[];
		readPreviousTasks(arg0?: Number): VcTaskInfo[];
		resetCollector(): void;
		rewindCollector(): void;
	}

	declare const VcTaskHistoryCollector: VcTaskHistoryCollector;

	declare class VcTaskInfo
	{
		activationId: String;
		cancelable: boolean;
		cancelled: boolean;
		changeTag: String;
		completeTime: Date;
		description: VcLocalizableMessage;
		descriptionId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		entityName: String;
		error: VcLocalizedMethodFault;
		eventChainId: Number;
		key: String;
		locked: VcManagedEntity[];
		name: String;
		parentTaskKey: String;
		progress: Number;
		queueTime: Date;
		reason: VcTaskReason;
		result_AnyValue: Object;
		result_FloatValue: Number;
		result_IntValue: Number;
		result_LongValue: Number;
		rootTaskKey: String;
		startTime: Date;
		state: VcTaskInfoState;
		task: VcTask;

		constructor();
		constructor(key?: String, task?: VcTask, description?: VcLocalizableMessage, name?: String, descriptionId?: String, entity?: VcManagedEntity, entityName?: String, locked?: VcManagedEntity[], state?: VcTaskInfoState, cancelled?: boolean, cancelable?: boolean, error?: VcLocalizedMethodFault, result?: Object, progress?: Number, reason?: VcTaskReason, queueTime?: Date, startTime?: Date, completeTime?: Date, eventChainId?: Number, changeTag?: String, parentTaskKey?: String, rootTaskKey?: String, activationId?: String);
	}

	interface VcTaskInfoState
	{
		readonly error: VcTaskInfoState;
		readonly id: String;
		readonly name: String;
		readonly queued: VcTaskInfoState;
		readonly running: VcTaskInfoState;
		readonly success: VcTaskInfoState;
		readonly value: String;

		fromString(value?: VcTaskInfoState): VcTaskInfoState;
	}

	declare const VcTaskInfoState: VcTaskInfoState;

	declare class VcTaskInProgress
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		task: VcTask;

		constructor();
		constructor(task?: VcTask);
		printStackTrace(): void;
	}

	interface VcTaskManager
	{
		description: VcTaskDescription;
		id: String;
		maxCollector: Number;
		moref: VcManagedObjectReference;
		recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createCollectorForTasks(arg0?: VcTaskFilterSpec): VcTaskHistoryCollector;
		createTask(arg0?: VcManagedObject, arg1?: String, arg2?: String, arg3?: boolean, arg4?: String, arg5?: String): VcTaskInfo;
		createTaskWithEntityName(arg0?: VcManagedObject, arg1?: String, arg2?: String, arg3?: String, arg4?: boolean, arg5?: String, arg6?: String): VcTaskInfo;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcTaskManager: VcTaskManager;

	declare class VcTaskReason
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcTaskReasonAlarm
	{
		alarm: VcAlarm;
		alarmName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		entityName: String;

		constructor();
		constructor(alarmName?: String, alarm?: VcAlarm, entityName?: String, entity?: VcManagedEntity);
	}

	declare class VcTaskReasonSchedule
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		scheduledTask: VcScheduledTask;

		constructor();
		constructor(name?: String, scheduledTask?: VcScheduledTask);
	}

	declare class VcTaskReasonSystem
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcTaskReasonUser
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		userName: String;

		constructor();
		constructor(userName?: String);
	}

	declare class VcTaskScheduler
	{
		activeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expireTime: Date;

		constructor();
		constructor(activeTime?: Date, expireTime?: Date);
	}

	declare class VcTaskTimeoutEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		info: VcTaskInfo;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, info?: VcTaskInfo);
	}

	declare class VcTeamingMatchEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String, healthResult?: VcHostMemberHealthCheckResult);
	}

	declare class VcTeamingMisMatchEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String, healthResult?: VcHostMemberHealthCheckResult);
	}

	declare class VcTemplateBeingUpgradedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		legacyTemplate: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, legacyTemplate?: String);
	}

	declare class VcTemplateConfigFileInfo
	{
		configVersion: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encryption: VcVmConfigFileEncryptionInfo;
		fileSize: Number;
		friendlyName: String;
		modification: Date;
		owner: String;
		path: String;

		constructor();
		constructor(path?: String, friendlyName?: String, fileSize?: Number, modification?: Date, owner?: String, configVersion?: Number, encryption?: VcVmConfigFileEncryptionInfo);
	}

	declare class VcTemplateConfigFileQuery
	{
		details: VcVmConfigFileQueryFlags;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filter: VcVmConfigFileQueryFilter;

		constructor();
		constructor(filter?: VcVmConfigFileQueryFilter, details?: VcVmConfigFileQueryFlags);
	}

	declare class VcTemplateUpgradedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		legacyTemplate: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, legacyTemplate?: String);
	}

	declare class VcTemplateUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		legacyTemplate: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, legacyTemplate?: String);
	}

	declare class VcTemplateUpgradeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		legacyTemplate: String;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, legacyTemplate?: String, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcThirdPartyLicenseAssignmentFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;
		module: String;
		reason: String;

		constructor();
		constructor(host?: VcHostSystem, module?: String, reason?: String);
		printStackTrace(): void;
	}

	interface VcThirdPartyLicenseAssignmentFailedReason
	{
		readonly id: String;
		readonly licenseAssignmentFailed: VcThirdPartyLicenseAssignmentFailedReason;
		readonly moduleNotInstalled: VcThirdPartyLicenseAssignmentFailedReason;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcThirdPartyLicenseAssignmentFailedReason): VcThirdPartyLicenseAssignmentFailedReason;
	}

	declare const VcThirdPartyLicenseAssignmentFailedReason: VcThirdPartyLicenseAssignmentFailedReason;

	declare class VcTicketedSessionAuthentication
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		interactiveSession: boolean;
		ticket: String;

		constructor();
		constructor(interactiveSession?: boolean, ticket?: String);
	}

	declare class VcTimedout
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcTimedOutHostOperationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcToolsAlreadyUpgraded
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcToolsAutoUpgradeNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcToolsConfigInfo
	{
		afterPowerOn: boolean;
		afterResume: boolean;
		beforeGuestReboot: boolean;
		beforeGuestShutdown: boolean;
		beforeGuestStandby: boolean;
		customizationKeyId: VcCryptoKeyId;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lastInstallInfo: VcToolsConfigInfoToolsLastInstallInfo;
		pendingCustomization: String;
		syncTimeWithHost: boolean;
		toolsInstallType: String;
		toolsUpgradePolicy: String;
		toolsVersion: Number;
		upgradeRebootPredict: boolean;

		constructor();
		constructor(toolsVersion?: Number, toolsInstallType?: String, afterPowerOn?: boolean, afterResume?: boolean, beforeGuestStandby?: boolean, beforeGuestShutdown?: boolean, beforeGuestReboot?: boolean, toolsUpgradePolicy?: String, pendingCustomization?: String, customizationKeyId?: VcCryptoKeyId, syncTimeWithHost?: boolean, lastInstallInfo?: VcToolsConfigInfoToolsLastInstallInfo, upgradeRebootPredict?: boolean);
		isAfterPowerOn(): boolean;
		isAfterResume(): boolean;
		isBeforeGuestReboot(): boolean;
		isBeforeGuestShutdown(): boolean;
		isBeforeGuestStandby(): boolean;
		isSyncTimeWithHost(): boolean;
		isUpgradeRebootPredict(): boolean;
	}

	declare class VcToolsConfigInfoToolsLastInstallInfo
	{
		counter: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;

		constructor();
		constructor(counter?: Number, fault?: VcLocalizedMethodFault);
	}

	declare class VcToolsImageCopyFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcToolsImageNotAvailable
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcToolsImageSignatureCheckFailed
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcToolsInstallationInProgress
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcToolsUnavailable
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcToolsUpgradeCancelled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcTooManyConcurrentNativeClones
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcTooManyConsecutiveOverrides
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcTooManyDevices
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;

		constructor();
		constructor(property?: String);
		printStackTrace(): void;
	}

	declare class VcTooManyDisksOnLegacyHost
	{
		diskCount: Number;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		timeoutDanger: boolean;

		constructor();
		constructor(diskCount?: Number, timeoutDanger?: boolean);
		printStackTrace(): void;
	}

	declare class VcTooManyGuestLogons
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcTooManyHosts
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcTooManyNativeCloneLevels
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcTooManyNativeClonesOnFile
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		file: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(file?: String);
		printStackTrace(): void;
	}

	declare class VcTooManySnapshotLevels
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcTooManyTickets
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcTooManyWrites
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcTpmFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcTpmTrustNotEstablished
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcTraversalSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		path: String;
		selectSet: VcSelectionSpec[];
		skip: boolean;
		type: String;

		constructor();
		constructor(name?: String, type?: String, path?: String, skip?: boolean, selectSet?: VcSelectionSpec[]);
		isSkip(): boolean;
	}

	declare class VcTypeDescription
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		label: String;
		summary: String;

		constructor(label?: String, summary?: String, key?: String);
		constructor();
	}

	declare class VcUnableToPlaceAtomicVmGroup
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcUnableToPlacePrerequisiteGroup
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcUncommittedUndoableDisk
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcUnconfiguredPropertyValue
	{
		category: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		id: String;
		label: String;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(id?: String, category?: String, label?: String, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcUncustomizableGuest
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		uncustomizableGuestOS: String;

		constructor();
		constructor(uncustomizableGuestOS?: String);
		printStackTrace(): void;
	}

	declare class VcUnexpectedCustomizationFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcUnexpectedFault
	{
		fault: VcLocalizedMethodFault;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		faultName: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(faultName?: String, fault?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcUnlicensedVirtualMachinesEvent
	{
		available: Number;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		unlicensed: Number;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, unlicensed?: Number, available?: Number);
	}

	declare class VcUnlicensedVirtualMachinesFoundEvent
	{
		available: Number;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, available?: Number);
	}

	declare class VcUnrecognizedHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostName?: String);
		printStackTrace(): void;
	}

	declare class VcUnsharedSwapVMotionNotSupported
	{
		atSourceHost: boolean;
		failedHost: VcHostSystem;
		failedHostName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHostName?: String, failedHost?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcUnsupportedDatastore
	{
		datastore: VcDatastore;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(datastore?: VcDatastore);
		printStackTrace(): void;
	}

	declare class VcUnSupportedDatastoreForVFlash
	{
		datastore: VcDatastore;
		datastoreName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		type: String;

		constructor();
		constructor(datastore?: VcDatastore, datastoreName?: String, type?: String);
		printStackTrace(): void;
	}

	declare class VcUnsupportedGuest
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		property: String;
		unsupportedGuestOS: String;

		constructor();
		constructor(property?: String, unsupportedGuestOS?: String);
		printStackTrace(): void;
	}

	declare class VcUnsupportedVimApiVersion
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		version: String;

		constructor();
		constructor(version?: String);
		printStackTrace(): void;
	}

	declare class VcUnsupportedVmxLocation
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcUnusedVirtualDiskBlocksNotScrubbed
	{
		backing: String;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String, backing?: String);
		printStackTrace(): void;
	}

	declare class VcUpdatedAgentBeingRestartedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcUpdateSet
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filterSet: VcPropertyFilterUpdate[];
		truncated: boolean;
		version: String;

		constructor();
		constructor(version?: String, filterSet?: VcPropertyFilterUpdate[], truncated?: boolean);
		isTruncated(): boolean;
	}

	declare class VcUpdateVirtualMachineFilesResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failedVmFile: VcUpdateVirtualMachineFilesResultFailedVmFileInfo[];

		constructor();
		constructor(failedVmFile?: VcUpdateVirtualMachineFilesResultFailedVmFileInfo[]);
	}

	declare class VcUpdateVirtualMachineFilesResultFailedVmFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		vmFile: String;

		constructor();
		constructor(vmFile?: String, fault?: VcLocalizedMethodFault);
	}

	declare class VcUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	interface VcUpgradePolicy
	{
		readonly id: String;
		readonly manual: VcUpgradePolicy;
		readonly name: String;
		readonly upgradeAtPowerCycle: VcUpgradePolicy;
		readonly value: String;

		fromString(value?: VcUpgradePolicy): VcUpgradePolicy;
	}

	declare const VcUpgradePolicy: VcUpgradePolicy;

	declare class VcUPITAlreadyEnabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;
		runningPoint: String;

		constructor();
		constructor(name?: String, runningPoint?: String);
		printStackTrace(): void;
	}

	declare class VcUplinkPortMtuNotSupportEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String, healthResult?: VcHostMemberHealthCheckResult);
	}

	declare class VcUplinkPortMtuSupportEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String, healthResult?: VcHostMemberHealthCheckResult);
	}

	declare class VcUplinkPortResourceSpec
	{
		configSpec: VcDVSNetworkResourcePoolConfigSpec[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		uplinkPortKey: String;

		constructor();
		constructor(uplinkPortKey?: String, configSpec?: VcDVSNetworkResourcePoolConfigSpec[]);
	}

	declare class VcUplinkPortVlanTrunkedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String, healthResult?: VcHostMemberHealthCheckResult);
	}

	declare class VcUplinkPortVlanUntrunkedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, switchUuid?: String, healthResult?: VcHostMemberHealthCheckResult);
	}

	declare class VcUsbScanCodeSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyEvents: VcUsbScanCodeSpecKeyEvent[];

		constructor();
		constructor(keyEvents?: VcUsbScanCodeSpecKeyEvent[]);
	}

	declare class VcUsbScanCodeSpecKeyEvent
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		modifiers: VcUsbScanCodeSpecModifierType;
		usbHidCode: Number;

		constructor();
		constructor(usbHidCode?: Number, modifiers?: VcUsbScanCodeSpecModifierType);
	}

	declare class VcUsbScanCodeSpecModifierType
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		leftAlt: boolean;
		leftControl: boolean;
		leftGui: boolean;
		leftShift: boolean;
		rightAlt: boolean;
		rightControl: boolean;
		rightGui: boolean;
		rightShift: boolean;

		constructor();
		constructor(leftControl?: boolean, leftShift?: boolean, leftAlt?: boolean, leftGui?: boolean, rightControl?: boolean, rightShift?: boolean, rightAlt?: boolean, rightGui?: boolean);
		isLeftAlt(): boolean;
		isLeftControl(): boolean;
		isLeftGui(): boolean;
		isLeftShift(): boolean;
		isRightAlt(): boolean;
		isRightControl(): boolean;
		isRightGui(): boolean;
		isRightShift(): boolean;
	}

	declare class VcUserAssignedToGroup
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		group: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userLogin: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, userLogin?: String, group?: String);
	}

	interface VcUserDirectory
	{
		domainList: String[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkGroupMembership(arg0?: String, arg1?: String[]): boolean[];
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		retrieveUserGroups(arg0?: String, arg1?: String, arg2?: String, arg3?: String, arg4?: boolean, arg5?: boolean, arg6?: boolean): VcUserSearchResult[];
	}

	declare const VcUserDirectory: VcUserDirectory;

	declare class VcUserGroupProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcUserInputRequiredParameterMetadata
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcExtendedElementDescription;
		parameter: VcProfileParameterMetadata[];
		userInputParameter: VcProfileParameterMetadata[];

		constructor();
		constructor(id?: VcExtendedElementDescription, parameter?: VcProfileParameterMetadata[], userInputParameter?: VcProfileParameterMetadata[]);
	}

	declare class VcUserLoginSessionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ipAddress: String;
		key: Number;
		locale: String;
		net: VcNetworkEventArgument;
		sessionId: String;
		userAgent: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, ipAddress?: String, userAgent?: String, locale?: String, sessionId?: String);
	}

	declare class VcUserLogoutSessionEvent
	{
		callCount: Number;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ipAddress: String;
		key: Number;
		loginTime: Date;
		net: VcNetworkEventArgument;
		sessionId: String;
		userAgent: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, ipAddress?: String, userAgent?: String, callCount?: Number, sessionId?: String, loginTime?: Date);
	}

	declare class VcUserNotFound
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		principal: String;
		unresolved: boolean;

		constructor();
		constructor(principal?: String, unresolved?: boolean);
		printStackTrace(): void;
	}

	declare class VcUserPasswordChanged
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userLogin: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, userLogin?: String);
	}

	declare class VcUserPrivilegeResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entity: VcManagedEntity;
		privileges: String[];

		constructor();
		constructor(entity?: VcManagedEntity, privileges?: String[]);
	}

	declare class VcUserProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String);
		constructor();
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcUserSearchResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullName: String;
		group: boolean;
		principal: String;

		constructor();
		constructor(principal?: String, fullName?: String, group?: boolean);
	}

	declare class VcUserSession
	{
		callCount: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extensionSession: boolean;
		fullName: String;
		ipAddress: String;
		key: String;
		lastActiveTime: Date;
		locale: String;
		loginTime: Date;
		messageLocale: String;
		userAgent: String;
		userName: String;

		constructor();
		constructor(key?: String, userName?: String, fullName?: String, loginTime?: Date, lastActiveTime?: Date, locale?: String, messageLocale?: String, extensionSession?: boolean, ipAddress?: String, userAgent?: String, callCount?: Number);
		isExtensionSession(): boolean;
	}

	declare class VcUserUnassignedFromGroup
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		group: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userLogin: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, userLogin?: String, group?: String);
	}

	declare class VcUserUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	interface VcValidateMigrationTestType
	{
		readonly compatibilityTests: VcValidateMigrationTestType;
		readonly diskAccessibilityTests: VcValidateMigrationTestType;
		readonly id: String;
		readonly name: String;
		readonly resourceTests: VcValidateMigrationTestType;
		readonly sourceTests: VcValidateMigrationTestType;
		readonly value: String;

		fromString(value?: VcValidateMigrationTestType): VcValidateMigrationTestType;
	}

	declare const VcValidateMigrationTestType: VcValidateMigrationTestType;

	interface VcVAppAutoStartAction
	{
		readonly guestShutdown: VcVAppAutoStartAction;
		readonly id: String;
		readonly name: String;
		readonly none: VcVAppAutoStartAction;
		readonly powerOff: VcVAppAutoStartAction;
		readonly powerOn: VcVAppAutoStartAction;
		readonly suspend: VcVAppAutoStartAction;
		readonly value: String;

		fromString(value?: VcVAppAutoStartAction): VcVAppAutoStartAction;
	}

	declare const VcVAppAutoStartAction: VcVAppAutoStartAction;

	declare class VcVAppCloneSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		location: VcDatastore;
		networkMapping: VcVAppCloneSpecNetworkMappingPair[];
		property: VcKeyValue[];
		provisioning: String;
		resourceMapping: VcVAppCloneSpecResourceMap[];
		resourceSpec: VcResourceConfigSpec;
		vmFolder: VcFolder;

		constructor();
		constructor(location?: VcDatastore, host?: VcHostSystem, resourceSpec?: VcResourceConfigSpec, vmFolder?: VcFolder, networkMapping?: VcVAppCloneSpecNetworkMappingPair[], property?: VcKeyValue[], resourceMapping?: VcVAppCloneSpecResourceMap[], provisioning?: String);
	}

	declare class VcVAppCloneSpecNetworkMappingPair
	{
		destination: VcNetwork;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		source: VcNetwork;

		constructor();
		constructor(source?: VcNetwork, destination?: VcNetwork);
	}

	interface VcVAppCloneSpecProvisioningType
	{
		readonly id: String;
		readonly name: String;
		readonly sameAsSource: VcVAppCloneSpecProvisioningType;
		readonly thick: VcVAppCloneSpecProvisioningType;
		readonly thin: VcVAppCloneSpecProvisioningType;
		readonly value: String;

		fromString(value?: VcVAppCloneSpecProvisioningType): VcVAppCloneSpecProvisioningType;
	}

	declare const VcVAppCloneSpecProvisioningType: VcVAppCloneSpecProvisioningType;

	declare class VcVAppCloneSpecResourceMap
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		location: VcDatastore;
		parent: VcResourcePool;
		resourceSpec: VcResourceConfigSpec;
		source: VcManagedEntity;

		constructor();
		constructor(source?: VcManagedEntity, parent?: VcResourcePool, resourceSpec?: VcResourceConfigSpec, location?: VcDatastore);
	}

	declare class VcVAppConfigFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVAppConfigInfo
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityConfig: VcVAppEntityConfigInfo[];
		eula: String[];
		installBootRequired: boolean;
		installBootStopDelay: Number;
		instanceUuid: String;
		ipAssignment: VcVAppIPAssignmentInfo;
		managedBy: VcManagedByInfo;
		ovfEnvironmentTransport: String[];
		ovfSection: VcVAppOvfSectionInfo[];
		product: VcVAppProductInfo[];
		property: VcVAppPropertyInfo[];

		constructor();
		constructor(product?: VcVAppProductInfo[], property?: VcVAppPropertyInfo[], ipAssignment?: VcVAppIPAssignmentInfo, eula?: String[], ovfSection?: VcVAppOvfSectionInfo[], ovfEnvironmentTransport?: String[], installBootRequired?: boolean, installBootStopDelay?: Number, entityConfig?: VcVAppEntityConfigInfo[], annotation?: String, instanceUuid?: String, managedBy?: VcManagedByInfo);
	}

	declare class VcVAppConfigSpec
	{
		annotation: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityConfig: VcVAppEntityConfigInfo[];
		eula: String[];
		installBootRequired: boolean;
		installBootStopDelay: Number;
		instanceUuid: String;
		ipAssignment: VcVAppIPAssignmentInfo;
		managedBy: VcManagedByInfo;
		ovfEnvironmentTransport: String[];
		ovfSection: VcVAppOvfSectionSpec[];
		product: VcVAppProductSpec[];
		property: VcVAppPropertySpec[];

		constructor();
		constructor(product?: VcVAppProductSpec[], property?: VcVAppPropertySpec[], ipAssignment?: VcVAppIPAssignmentInfo, eula?: String[], ovfSection?: VcVAppOvfSectionSpec[], ovfEnvironmentTransport?: String[], installBootRequired?: boolean, installBootStopDelay?: Number, entityConfig?: VcVAppEntityConfigInfo[], annotation?: String, instanceUuid?: String, managedBy?: VcManagedByInfo);
		isInstallBootRequired(): boolean;
	}

	declare class VcVAppEntityConfigInfo
	{
		destroyWithParent: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcManagedEntity;
		startAction: String;
		startDelay: Number;
		startOrder: Number;
		stopAction: String;
		stopDelay: Number;
		tag: String;
		waitingForGuest: boolean;

		constructor();
		constructor(key?: VcManagedEntity, tag?: String, startOrder?: Number, startDelay?: Number, waitingForGuest?: boolean, startAction?: String, stopDelay?: Number, stopAction?: String, destroyWithParent?: boolean);
		isDestroyWithParent(): boolean;
		isWaitingForGuest(): boolean;
	}

	declare class VcVAppIPAssignmentInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAllocationPolicy: String;
		ipProtocol: String;
		supportedAllocationScheme: String[];
		supportedIpProtocol: String[];

		constructor();
		constructor(supportedAllocationScheme?: String[], ipAllocationPolicy?: String, supportedIpProtocol?: String[], ipProtocol?: String);
	}

	interface VcVAppIPAssignmentInfoAllocationSchemes
	{
		readonly dhcp: VcVAppIPAssignmentInfoAllocationSchemes;
		readonly id: String;
		readonly name: String;
		readonly ovfenv: VcVAppIPAssignmentInfoAllocationSchemes;
		readonly value: String;

		fromString(value?: VcVAppIPAssignmentInfoAllocationSchemes): VcVAppIPAssignmentInfoAllocationSchemes;
	}

	declare const VcVAppIPAssignmentInfoAllocationSchemes: VcVAppIPAssignmentInfoAllocationSchemes;

	interface VcVAppIPAssignmentInfoIpAllocationPolicy
	{
		readonly dhcpPolicy: VcVAppIPAssignmentInfoIpAllocationPolicy;
		readonly fixedAllocatedPolicy: VcVAppIPAssignmentInfoIpAllocationPolicy;
		readonly fixedPolicy: VcVAppIPAssignmentInfoIpAllocationPolicy;
		readonly id: String;
		readonly name: String;
		readonly transientPolicy: VcVAppIPAssignmentInfoIpAllocationPolicy;
		readonly value: String;

		fromString(value?: VcVAppIPAssignmentInfoIpAllocationPolicy): VcVAppIPAssignmentInfoIpAllocationPolicy;
	}

	declare const VcVAppIPAssignmentInfoIpAllocationPolicy: VcVAppIPAssignmentInfoIpAllocationPolicy;

	interface VcVAppIPAssignmentInfoProtocols
	{
		readonly id: String;
		readonly IPv4: VcVAppIPAssignmentInfoProtocols;
		readonly IPv6: VcVAppIPAssignmentInfoProtocols;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVAppIPAssignmentInfoProtocols): VcVAppIPAssignmentInfoProtocols;
	}

	declare const VcVAppIPAssignmentInfoProtocols: VcVAppIPAssignmentInfoProtocols;

	declare class VcVAppNotRunning
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVAppOperationInProgress
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVAppOvfSectionInfo
	{
		atEnvelopeLevel: boolean;
		contents: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		namespace: String;
		type: String;

		constructor();
		constructor(key?: Number, namespace?: String, type?: String, atEnvelopeLevel?: boolean, contents?: String);
		isAtEnvelopeLevel(): boolean;
	}

	declare class VcVAppOvfSectionSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcVAppOvfSectionInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcVAppOvfSectionInfo);
	}

	declare class VcVAppProductInfo
	{
		appUrl: String;
		classId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullVersion: String;
		instanceId: String;
		key: Number;
		name: String;
		productUrl: String;
		vendor: String;
		vendorUrl: String;
		version: String;

		constructor();
		constructor(key?: Number, classId?: String, instanceId?: String, name?: String, vendor?: String, version?: String, fullVersion?: String, vendorUrl?: String, productUrl?: String, appUrl?: String);
	}

	declare class VcVAppProductSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcVAppProductInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcVAppProductInfo);
	}

	declare class VcVAppPropertyFault
	{
		category: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		id: String;
		label: String;
		readonly localizedMessage: String;
		message: String;
		type: String;
		value: String;

		constructor();
		constructor(id?: String, category?: String, label?: String, type?: String, value?: String);
		printStackTrace(): void;
	}

	declare class VcVAppPropertyInfo
	{
		category: String;
		classId: String;
		defaultValue: String;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		instanceId: String;
		key: Number;
		label: String;
		type: String;
		typeReference: String;
		userConfigurable: boolean;
		value: String;

		constructor();
		constructor(key?: Number, classId?: String, instanceId?: String, id?: String, category?: String, label?: String, type?: String, typeReference?: String, userConfigurable?: boolean, defaultValue?: String, value?: String, description?: String);
		isUserConfigurable(): boolean;
	}

	declare class VcVAppPropertySpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcVAppPropertyInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcVAppPropertyInfo);
	}

	declare class VcVAppTaskInProgress
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		task: VcTask;

		constructor();
		constructor(task?: VcTask);
		printStackTrace(): void;
	}

	declare class VcVasaClientContextSpec
	{
		domainId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(domainId?: String);
	}

	declare class VcVasaProviderContainerSpec
	{
		deleted: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		scId: String;
		vasaProviderInfo: VcVimVasaProviderInfo[];

		constructor();
		constructor(vasaProviderInfo?: VcVimVasaProviderInfo[], scId?: String, deleted?: boolean);
	}

	declare class VcVASAStorageArray
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		modelId: String;
		name: String;
		uuid: String;
		vendorId: String;

		constructor();
		constructor(name?: String, uuid?: String, vendorId?: String, modelId?: String);
	}

	interface VcVasaVvolManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVvolDatastoreOnHosts_Task(arg0?: VcHostDatastoreSystemVvolDatastoreSpec, arg1?: VcHostSystem[]): VcTask;
		removeVVolDatastore_Task(arg0?: VcDatastore, arg1?: VcHostSystem[]): VcTask;
		updateVasaClientContext(arg0?: VcVasaClientContextSpec): void;
		updateVasaProviderState(arg0?: VcVasaProviderContainerSpec[], arg1?: boolean): void;
	}

	declare const VcVasaVvolManager: VcVasaVvolManager;

	declare class VcVcAgentUninstalledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcVcAgentUninstallFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, reason?: String);
		constructor();
	}

	declare class VcVcAgentUpgradedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcVcAgentUpgradeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, reason?: String);
		constructor();
	}

	interface VcVcenterVStorageObjectManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		attachTagToVStorageObject(arg0?: VcID, arg1?: String, arg2?: String): void;
		cloneVStorageObject_Task(arg0?: VcID, arg1?: VcDatastore, arg2?: VcVslmCloneSpec): VcTask;
		createDisk_Task(arg0?: VcVslmCreateSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteVStorageObject_Task(arg0?: VcID, arg1?: VcDatastore): VcTask;
		detachTagFromVStorageObject(arg0?: VcID, arg1?: String, arg2?: String): void;
		extendDisk_Task(arg0?: VcID, arg1?: VcDatastore, arg2?: Number): VcTask;
		inflateDisk_Task(arg0?: VcID, arg1?: VcDatastore): VcTask;
		listTagsAttachedToVStorageObject(arg0?: VcID): VcVslmTagEntry[];
		listVStorageObject(arg0?: VcDatastore): VcID[];
		listVStorageObjectsAttachedToTag(arg0?: String, arg1?: String): VcID[];
		reconcileDatastoreInventory_Task(arg0?: VcDatastore): VcTask;
		registerDisk(arg0?: String, arg1?: String): VcVStorageObject;
		relocateVStorageObject_Task(arg0?: VcID, arg1?: VcDatastore, arg2?: VcVslmRelocateSpec): VcTask;
		renameVStorageObject(arg0?: VcID, arg1?: VcDatastore, arg2?: String): void;
		retrieveVStorageObject(arg0?: VcID, arg1?: VcDatastore): VcVStorageObject;
		retrieveVStorageObjectAssociations(arg0?: VcID[]): VcVStorageObjectAssociations[];
		retrieveVStorageObjectState(arg0?: VcID, arg1?: VcDatastore): VcVStorageObjectStateInfo;
		scheduleReconcileDatastoreInventory(arg0?: VcDatastore): void;
		updateVStorageObjectPolicy_Task(arg0?: VcID, arg1?: VcDatastore, arg2?: VcVirtualMachineProfileSpec[]): VcTask;
	}

	declare const VcVcenterVStorageObjectManager: VcVcenterVStorageObjectManager;

	declare class VcVchaClusterConfigInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failoverNodeInfo1: VcFailoverNodeInfo;
		failoverNodeInfo2: VcFailoverNodeInfo;
		state: String;
		witnessNodeInfo: VcWitnessNodeInfo;

		constructor();
		constructor(failoverNodeInfo1?: VcFailoverNodeInfo, failoverNodeInfo2?: VcFailoverNodeInfo, witnessNodeInfo?: VcWitnessNodeInfo, state?: String);
	}

	declare class VcVchaClusterConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		passiveIp: String;
		witnessIp: String;

		constructor();
		constructor(passiveIp?: String, witnessIp?: String);
	}

	declare class VcVchaClusterDeploymentSpec
	{
		activeVcNetworkConfig: VcClusterNetworkConfigSpec;
		activeVcSpec: VcSourceNodeSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		passiveDeploymentSpec: VcPassiveNodeDeploymentSpec;
		witnessDeploymentSpec: VcNodeDeploymentSpec;

		constructor();
		constructor(passiveDeploymentSpec?: VcPassiveNodeDeploymentSpec, witnessDeploymentSpec?: VcNodeDeploymentSpec, activeVcSpec?: VcSourceNodeSpec, activeVcNetworkConfig?: VcClusterNetworkConfigSpec);
	}

	declare class VcVchaClusterHealth
	{
		additionalInformation: VcLocalizableMessage[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		healthMessages: VcLocalizableMessage[];
		runtimeInfo: VcVchaClusterRuntimeInfo;

		constructor();
		constructor(runtimeInfo?: VcVchaClusterRuntimeInfo, healthMessages?: VcLocalizableMessage[], additionalInformation?: VcLocalizableMessage[]);
	}

	interface VcVchaClusterMode
	{
		readonly disabled: VcVchaClusterMode;
		readonly enabled: VcVchaClusterMode;
		readonly id: String;
		readonly maintenance: VcVchaClusterMode;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVchaClusterMode): VcVchaClusterMode;
	}

	declare const VcVchaClusterMode: VcVchaClusterMode;

	declare class VcVchaClusterNetworkSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		passiveNetworkSpec: VcPassiveNodeNetworkSpec;
		witnessNetworkSpec: VcNodeNetworkSpec;

		constructor();
		constructor(witnessNetworkSpec?: VcNodeNetworkSpec, passiveNetworkSpec?: VcPassiveNodeNetworkSpec);
	}

	declare class VcVchaClusterRuntimeInfo
	{
		clusterMode: String;
		clusterState: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nodeInfo: VcVchaNodeRuntimeInfo[];

		constructor();
		constructor(clusterState?: String, nodeInfo?: VcVchaNodeRuntimeInfo[], clusterMode?: String);
	}

	interface VcVchaClusterState
	{
		readonly degraded: VcVchaClusterState;
		readonly healthy: VcVchaClusterState;
		readonly id: String;
		readonly isolated: VcVchaClusterState;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVchaClusterState): VcVchaClusterState;
	}

	declare const VcVchaClusterState: VcVchaClusterState;

	interface VcVchaNodeRole
	{
		readonly active: VcVchaNodeRole;
		readonly id: String;
		readonly name: String;
		readonly passive: VcVchaNodeRole;
		readonly value: String;
		readonly witness: VcVchaNodeRole;

		fromString(value?: VcVchaNodeRole): VcVchaNodeRole;
	}

	declare const VcVchaNodeRole: VcVchaNodeRole;

	declare class VcVchaNodeRuntimeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nodeIp: String;
		nodeRole: String;
		nodeState: String;

		constructor();
		constructor(nodeState?: String, nodeRole?: String, nodeIp?: String);
	}

	interface VcVchaNodeState
	{
		readonly down: VcVchaNodeState;
		readonly id: String;
		readonly name: String;
		readonly up: VcVchaNodeState;
		readonly value: String;

		fromString(value?: VcVchaNodeState): VcVchaNodeState;
	}

	declare const VcVchaNodeState: VcVchaNodeState;

	interface VcVchaState
	{
		readonly configured: VcVchaState;
		readonly id: String;
		readonly invalid: VcVchaState;
		readonly name: String;
		readonly notConfigured: VcVchaState;
		readonly prepared: VcVchaState;
		readonly value: String;

		fromString(value?: VcVchaState): VcVchaState;
	}

	declare const VcVchaState: VcVchaState;

	interface VcVdcsIpAddressingMode
	{
		readonly DHCP: VcVdcsIpAddressingMode;
		readonly id: String;
		readonly MANUAL: VcVdcsIpAddressingMode;
		readonly name: String;
		readonly POOL: VcVdcsIpAddressingMode;
		readonly value: String;

		fromString(value?: VcVdcsIpAddressingMode): VcVdcsIpAddressingMode;
	}

	declare const VcVdcsIpAddressingMode: VcVdcsIpAddressingMode;

	interface VcVdcsIpAddressType
	{
		readonly id: String;
		readonly IPV4: VcVdcsIpAddressType;
		readonly IPV6: VcVdcsIpAddressType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVdcsIpAddressType): VcVdcsIpAddressType;
	}

	declare const VcVdcsIpAddressType: VcVdcsIpAddressType;

	declare class VcVdcsIpAllocationInfo
	{
		address: String;
		addressType: String;
		allocationId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityId: String;
		networkId: String;
		subnetId: String;

		constructor();
		constructor(allocationId?: String, entityId?: String, networkId?: String, subnetId?: String, addressType?: String, address?: String);
	}

	declare class VcVdcsIpAllocationRequest
	{
		address: String;
		addressType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityId: String;
		networkId: String;
		subnetId: String;

		constructor();
		constructor(entityId?: String, networkId?: String, subnetId?: String, addressType?: String, address?: String);
	}

	interface VcVdcsIpManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		vdcsGetIpNetworkSettings(arg0?: String): VcVdcsNetworkIpSettings;
		vdcsIpAllocate(arg0?: String, arg1?: VcVdcsIpAllocationRequest): VcVdcsIpAllocationInfo;
		vdcsIpQueryAll(arg0?: String): VcVdcsIpAllocationInfo[];
		vdcsIpRelease(arg0?: String, arg1?: String, arg2?: String, arg3?: String): void;
		vdcsIpReleaseAll(arg0?: String): void;
	}

	declare const VcVdcsIpManager: VcVdcsIpManager;

	declare class VcVdcsNetworkIpSettings
	{
		dnsSearchPath: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostPrefix: String;
		httpProxy: String;
		ipSubnetConfigurations: VcVdcsNetworkIpSettingsIpSubnetConfig[];
		supportedIpAddressingModes: String[];

		constructor();
		constructor(supportedIpAddressingModes?: String[], ipSubnetConfigurations?: VcVdcsNetworkIpSettingsIpSubnetConfig[], hostPrefix?: String, httpProxy?: String, dnsSearchPath?: String);
	}

	declare class VcVdcsNetworkIpSettingsIpAddressRange
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endAddress: String;
		startAddress: String;

		constructor();
		constructor(startAddress?: String, endAddress?: String);
	}

	declare class VcVdcsNetworkIpSettingsIpSubnetConfig
	{
		dnsSuffix: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		gateway: String;
		id: String;
		ipAddressRanges: VcVdcsNetworkIpSettingsIpAddressRange[];
		ipAddressType: String;
		nameServer1: String;
		nameServer2: String;
		subnetMask: String;

		constructor();
		constructor(id?: String, dnsSuffix?: String, gateway?: String, nameServer1?: String, nameServer2?: String, subnetMask?: String, ipAddressType?: String, ipAddressRanges?: VcVdcsNetworkIpSettingsIpAddressRange[]);
	}

	interface VcVdcsNicManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		vdcsBindNic(arg0?: String, arg1?: String): void;
		vdcsUnbindNic(arg0?: String, arg1?: String): void;
		vdcsValidateNic(arg0?: String, arg1?: String): void;
	}

	declare const VcVdcsNicManager: VcVdcsNicManager;

	declare class VcVFlashCacheHotConfigNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVFlashModuleNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		moduleName: String;
		reason: String;
		vmName: String;

		constructor();
		constructor(vmName?: String, moduleName?: String, reason?: String, hostName?: String);
		printStackTrace(): void;
	}

	interface VcVFlashModuleNotSupportedReason
	{
		readonly CacheBlockSizeNotSupported: VcVFlashModuleNotSupportedReason;
		readonly CacheConsistencyTypeNotSupported: VcVFlashModuleNotSupportedReason;
		readonly CacheModeNotSupported: VcVFlashModuleNotSupportedReason;
		readonly CacheReservationNotSupported: VcVFlashModuleNotSupportedReason;
		readonly DiskSizeNotSupported: VcVFlashModuleNotSupportedReason;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVFlashModuleNotSupportedReason): VcVFlashModuleNotSupportedReason;
	}

	declare const VcVFlashModuleNotSupportedReason: VcVFlashModuleNotSupportedReason;

	declare class VcVFlashModuleVersionIncompatible
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostMinSupportedVerson: String;
		hostModuleVersion: String;
		readonly localizedMessage: String;
		message: String;
		moduleName: String;
		vmRequestModuleVersion: String;

		constructor();
		constructor(moduleName?: String, vmRequestModuleVersion?: String, hostMinSupportedVerson?: String, hostModuleVersion?: String);
		printStackTrace(): void;
	}

	interface VcView
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyView(): void;
	}

	declare const VcView: VcView;

	interface VcViewManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		viewList: VcView[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createContainerView(arg0?: VcManagedEntity, arg1?: String[], arg2?: boolean): VcContainerView;
		createInventoryView(): VcInventoryView;
		createListView(arg0?: VcManagedObject[]): VcListView;
		createListViewFromView(arg0?: VcView): VcListView;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcViewManager: VcViewManager;

	declare class VcVimAccountPasswordChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcVimFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVimVasaProvider
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		selfSignedCertificate: String;
		url: String;

		constructor();
		constructor(url?: String, name?: String, selfSignedCertificate?: String);
	}

	declare class VcVimVasaProviderInfo
	{
		arrayState: VcVimVasaProviderStatePerArray[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		provider: VcVimVasaProvider;

		constructor();
		constructor(provider?: VcVimVasaProvider, arrayState?: VcVimVasaProviderStatePerArray[]);
	}

	declare class VcVimVasaProviderStatePerArray
	{
		active: boolean;
		arrayId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		priority: Number;

		constructor();
		constructor(priority?: Number, arrayId?: String, active?: boolean);
	}

	declare class VcVirtualAHCIController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[]);
	}

	declare class VcVirtualAHCIControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSATACdroms: VcIntOption;
		numSATADisks: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numSATADisks?: VcIntOption, numSATACdroms?: VcIntOption);
		isHotRemoveSupported(): boolean;
	}

	interface VcVirtualApp
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly childConfiguration: VcResourceConfigSpec[];
		childLink: VcVirtualAppLinkInfo[];
		readonly config: VcResourceConfigSpec;
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		cpuReservation: String;
		readonly customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		memoryReservation: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		network: VcNetwork[];
		readonly overallStatus: VcManagedEntityStatus;
		readonly owner: VcComputeResource;
		readonly parent: VcManagedEntity;
		parentFolder: VcFolder;
		parentVApp: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		readonly resourcePool: VcResourcePool[];
		readonly runtime: VcResourcePoolRuntimeInfo;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly summary: VcResourcePoolSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vAppConfig: VcVAppConfigInfo;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		readonly vm: VcVirtualMachine[];

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		cloneVApp_Task(arg0?: String, arg1?: VcResourcePool, arg2?: VcVAppCloneSpec): VcTask;
		createChildVM_Task(arg0?: VcVirtualMachineConfigSpec, arg1?: VcHostSystem): VcTask;
		createResourcePool(arg0?: String, arg1?: VcResourceConfigSpec): VcResourcePool;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVApp(arg0?: String, arg1?: VcResourceConfigSpec, arg2?: VcVAppConfigSpec, arg3?: VcFolder): VcVirtualApp;
		destroy_Task(): VcTask;
		destroyChildren(): void;
		exportVApp(): VcHttpNfcLease;
		importVApp(arg0?: VcImportSpec, arg1?: VcFolder, arg2?: VcHostSystem): VcHttpNfcLease;
		moveIntoResourcePool(arg0?: VcManagedEntity[]): void;
		powerOffVApp_Task(arg0?: boolean): VcTask;
		powerOnVApp_Task(): VcTask;
		queryResourceConfigOption(): VcResourceConfigOption;
		refreshRuntime(): void;
		registerChildVM_Task(arg0?: String, arg1?: String, arg2?: VcHostSystem): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
		suspendVApp_Task(): VcTask;
		unregisterVApp_Task(): VcTask;
		updateChildResourceConfiguration(arg0?: VcResourceConfigSpec[]): void;
		updateConfig(arg0?: String, arg1?: VcResourceConfigSpec): void;
		updateLinkedChildren(arg0?: VcVirtualAppLinkInfo[], arg1?: VcManagedEntity[]): void;
		updateVAppConfig(arg0?: VcVAppConfigSpec): void;
	}

	declare const VcVirtualApp: VcVirtualApp;

	declare class VcVirtualAppImportSpec
	{
		child: VcImportSpec[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityConfig: VcVAppEntityConfigInfo;
		instantiationOst: VcOvfConsumerOstNode;
		name: String;
		resourcePoolSpec: VcResourceConfigSpec;
		vAppConfigSpec: VcVAppConfigSpec;

		constructor();
		constructor(entityConfig?: VcVAppEntityConfigInfo, instantiationOst?: VcOvfConsumerOstNode, name?: String, vAppConfigSpec?: VcVAppConfigSpec, resourcePoolSpec?: VcResourceConfigSpec, child?: VcImportSpec[]);
	}

	declare class VcVirtualAppLinkInfo
	{
		destroyWithParent: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcManagedEntity;

		constructor();
		constructor(key?: VcManagedEntity, destroyWithParent?: boolean);
		isDestroyWithParent(): boolean;
	}

	declare class VcVirtualAppSummary
	{
		config: VcResourceConfigSpec;
		configuredMemoryMB: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		installBootRequired: boolean;
		instanceUuid: String;
		name: String;
		product: VcVAppProductInfo;
		quickStats: VcResourcePoolQuickStats;
		runtime: VcResourcePoolRuntimeInfo;
		suspended: boolean;
		vAppState: VcVirtualAppVAppState;

		constructor();
		constructor(name?: String, config?: VcResourceConfigSpec, runtime?: VcResourcePoolRuntimeInfo, quickStats?: VcResourcePoolQuickStats, configuredMemoryMB?: Number, product?: VcVAppProductInfo, vAppState?: VcVirtualAppVAppState, suspended?: boolean, installBootRequired?: boolean, instanceUuid?: String);
		isInstallBootRequired(): boolean;
		isSuspended(): boolean;
	}

	interface VcVirtualAppVAppState
	{
		readonly id: String;
		readonly name: String;
		readonly started: VcVirtualAppVAppState;
		readonly starting: VcVirtualAppVAppState;
		readonly stopped: VcVirtualAppVAppState;
		readonly stopping: VcVirtualAppVAppState;
		readonly value: String;

		fromString(value?: VcVirtualAppVAppState): VcVirtualAppVAppState;
	}

	declare const VcVirtualAppVAppState: VcVirtualAppVAppState;

	declare class VcVirtualBusLogicController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotAddRemove: boolean;
		key: Number;
		scsiCtlrUnitNumber: Number;
		sharedBus: VcVirtualSCSISharing;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[], hotAddRemove?: boolean, sharedBus?: VcVirtualSCSISharing, scsiCtlrUnitNumber?: Number);
		isHotAddRemove(): boolean;
	}

	declare class VcVirtualBusLogicControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		defaultSharedIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotAddRemove: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSCSICdroms: VcIntOption;
		numSCSIDisks: VcIntOption;
		numSCSIPassthrough: VcIntOption;
		plugAndPlay: boolean;
		scsiCtlrUnitNumber: Number;
		sharing: VcVirtualSCSISharing[];
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numSCSIDisks?: VcIntOption, numSCSICdroms?: VcIntOption, numSCSIPassthrough?: VcIntOption, sharing?: VcVirtualSCSISharing[], defaultSharedIndex?: Number, hotAddRemove?: VcBoolOption, scsiCtlrUnitNumber?: Number);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualCdrom
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualCdromAtapiBackingInfo
	{
		description: String;
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean, description?: String);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualCdromAtapiBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualCdromIsoBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String);
	}

	declare class VcVirtualCdromIsoBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileNameExtensions: VcChoiceOption;
		type: String;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption);
	}

	declare class VcVirtualCdromOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualCdromPassthroughBackingInfo
	{
		description: String;
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		exclusive: boolean;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean, exclusive?: boolean, description?: String);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualCdromPassthroughBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		exclusive: VcBoolOption;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption, exclusive?: VcBoolOption);
	}

	declare class VcVirtualCdromRemoteAtapiBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualCdromRemoteAtapiBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualCdromRemotePassthroughBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		exclusive: boolean;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean, exclusive?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualCdromRemotePassthroughBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		exclusive: VcBoolOption;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption, exclusive?: VcBoolOption);
	}

	declare class VcVirtualController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[]);
	}

	declare class VcVirtualControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[]);
		isHotRemoveSupported(): boolean;
	}

	interface VcVirtualDatacenter
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly recentTask: VcTask[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addTag(arg0?: VcTag[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		reload(): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcVirtualDatacenter: VcVirtualDatacenter;

	declare class VcVirtualDevice
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualDeviceBackingInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVirtualDeviceBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String);
	}

	declare class VcVirtualDeviceBusSlotInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVirtualDeviceBusSlotOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String);
	}

	declare class VcVirtualDeviceConfigSpec
	{
		backing: VcVirtualDeviceConfigSpecBackingSpec;
		device: VcVirtualDevice;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileOperation: VcVirtualDeviceConfigSpecFileOperation;
		operation: VcVirtualDeviceConfigSpecOperation;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(operation?: VcVirtualDeviceConfigSpecOperation, fileOperation?: VcVirtualDeviceConfigSpecFileOperation, device?: VcVirtualDevice, profile?: VcVirtualMachineProfileSpec[], backing?: VcVirtualDeviceConfigSpecBackingSpec);
	}

	declare class VcVirtualDeviceConfigSpecBackingSpec
	{
		crypto: VcCryptoSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parent: VcVirtualDeviceConfigSpecBackingSpec;

		constructor();
		constructor(parent?: VcVirtualDeviceConfigSpecBackingSpec, crypto?: VcCryptoSpec);
	}

	interface VcVirtualDeviceConfigSpecFileOperation
	{
		readonly create: VcVirtualDeviceConfigSpecFileOperation;
		readonly destroy: VcVirtualDeviceConfigSpecFileOperation;
		readonly id: String;
		readonly name: String;
		readonly replace: VcVirtualDeviceConfigSpecFileOperation;
		readonly value: String;

		fromString(value?: VcVirtualDeviceConfigSpecFileOperation): VcVirtualDeviceConfigSpecFileOperation;
	}

	declare const VcVirtualDeviceConfigSpecFileOperation: VcVirtualDeviceConfigSpecFileOperation;

	interface VcVirtualDeviceConfigSpecOperation
	{
		readonly add: VcVirtualDeviceConfigSpecOperation;
		readonly edit: VcVirtualDeviceConfigSpecOperation;
		readonly id: String;
		readonly name: String;
		readonly remove: VcVirtualDeviceConfigSpecOperation;
		readonly value: String;

		fromString(value?: VcVirtualDeviceConfigSpecOperation): VcVirtualDeviceConfigSpecOperation;
	}

	declare const VcVirtualDeviceConfigSpecOperation: VcVirtualDeviceConfigSpecOperation;

	declare class VcVirtualDeviceConnectInfo
	{
		allowGuestControl: boolean;
		connected: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		startConnected: boolean;
		status: String;

		constructor();
		constructor(startConnected?: boolean, allowGuestControl?: boolean, connected?: boolean, status?: String);
	}

	interface VcVirtualDeviceConnectInfoStatus
	{
		readonly id: String;
		readonly name: String;
		readonly ok: VcVirtualDeviceConnectInfoStatus;
		readonly recoverableError: VcVirtualDeviceConnectInfoStatus;
		readonly unrecoverableError: VcVirtualDeviceConnectInfoStatus;
		readonly untried: VcVirtualDeviceConnectInfoStatus;
		readonly value: String;

		fromString(value?: VcVirtualDeviceConnectInfoStatus): VcVirtualDeviceConnectInfoStatus;
	}

	declare const VcVirtualDeviceConnectInfoStatus: VcVirtualDeviceConnectInfoStatus;

	declare class VcVirtualDeviceConnectOption
	{
		allowGuestControl: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		startConnected: VcBoolOption;

		constructor();
		constructor(startConnected?: VcBoolOption, allowGuestControl?: VcBoolOption);
	}

	declare class VcVirtualDeviceDeviceBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualDeviceDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualDeviceFileBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String);
	}

	declare class VcVirtualDeviceFileBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileNameExtensions: VcChoiceOption;
		type: String;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption);
	}

	interface VcVirtualDeviceFileExtension
	{
		readonly dsk: VcVirtualDeviceFileExtension;
		readonly flp: VcVirtualDeviceFileExtension;
		readonly id: String;
		readonly iso: VcVirtualDeviceFileExtension;
		readonly name: String;
		readonly rdm: VcVirtualDeviceFileExtension;
		readonly value: String;
		readonly vmdk: VcVirtualDeviceFileExtension;

		fromString(value?: VcVirtualDeviceFileExtension): VcVirtualDeviceFileExtension;
	}

	declare const VcVirtualDeviceFileExtension: VcVirtualDeviceFileExtension;

	declare class VcVirtualDeviceOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualDevicePciBusSlotInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pciSlotNumber: Number;

		constructor();
		constructor(pciSlotNumber?: Number);
	}

	declare class VcVirtualDevicePipeBackingInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		pipeName: String;

		constructor();
		constructor(pipeName?: String);
	}

	declare class VcVirtualDevicePipeBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String);
	}

	declare class VcVirtualDeviceRemoteDeviceBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualDeviceRemoteDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualDeviceURIBackingInfo
	{
		direction: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		proxyURI: String;
		serviceURI: String;

		constructor();
		constructor(serviceURI?: String, direction?: String, proxyURI?: String);
	}

	declare class VcVirtualDeviceURIBackingOption
	{
		directions: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, directions?: VcChoiceOption);
	}

	interface VcVirtualDeviceURIBackingOptionDirection
	{
		readonly client: VcVirtualDeviceURIBackingOptionDirection;
		readonly id: String;
		readonly name: String;
		readonly server: VcVirtualDeviceURIBackingOptionDirection;
		readonly value: String;

		fromString(value?: VcVirtualDeviceURIBackingOptionDirection): VcVirtualDeviceURIBackingOptionDirection;
	}

	declare const VcVirtualDeviceURIBackingOptionDirection: VcVirtualDeviceURIBackingOptionDirection;

	declare class VcVirtualDisk
	{
		backing: VcVirtualDeviceBackingInfo;
		capacityInBytes: Number;
		capacityInKB: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		diskObjectId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		iofilter: String[];
		key: Number;
		shares: VcSharesInfo;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		storageIOAllocation: VcStorageIOAllocationInfo;
		unitNumber: Number;
		vDiskId: VcID;
		vFlashCacheConfigInfo: VcVirtualDiskVFlashCacheConfigInfo;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, capacityInKB?: Number, capacityInBytes?: Number, shares?: VcSharesInfo, storageIOAllocation?: VcStorageIOAllocationInfo, diskObjectId?: String, vFlashCacheConfigInfo?: VcVirtualDiskVFlashCacheConfigInfo, iofilter?: String[], vDiskId?: VcID);
	}

	interface VcVirtualDiskAdapterType
	{
		readonly busLogic: VcVirtualDiskAdapterType;
		readonly id: String;
		readonly ide: VcVirtualDiskAdapterType;
		readonly lsiLogic: VcVirtualDiskAdapterType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualDiskAdapterType): VcVirtualDiskAdapterType;
	}

	declare const VcVirtualDiskAdapterType: VcVirtualDiskAdapterType;

	declare class VcVirtualDiskAffinityRuleSpec
	{
		diskId: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;

		constructor();
		constructor(key?: Number, status?: VcManagedEntityStatus, enabled?: boolean, name?: String, mandatory?: boolean, userCreated?: boolean, inCompliance?: boolean, ruleUuid?: String, diskId?: Number[]);
		isEnabled(): boolean;
		isInCompliance(): boolean;
		isMandatory(): boolean;
		isUserCreated(): boolean;
	}

	declare class VcVirtualDiskAntiAffinityRuleSpec
	{
		diskId: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;

		constructor();
		constructor(key?: Number, status?: VcManagedEntityStatus, enabled?: boolean, name?: String, mandatory?: boolean, userCreated?: boolean, inCompliance?: boolean, ruleUuid?: String, diskId?: Number[]);
		isEnabled(): boolean;
		isInCompliance(): boolean;
		isMandatory(): boolean;
		isUserCreated(): boolean;
	}

	declare class VcVirtualDiskBlocksNotFullyProvisioned
	{
		backing: String;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String, backing?: String);
		printStackTrace(): void;
	}

	interface VcVirtualDiskCompatibilityMode
	{
		readonly id: String;
		readonly name: String;
		readonly physicalMode: VcVirtualDiskCompatibilityMode;
		readonly value: String;
		readonly virtualMode: VcVirtualDiskCompatibilityMode;

		fromString(value?: VcVirtualDiskCompatibilityMode): VcVirtualDiskCompatibilityMode;
	}

	declare const VcVirtualDiskCompatibilityMode: VcVirtualDiskCompatibilityMode;

	declare class VcVirtualDiskConfigSpec
	{
		backing: VcVirtualDeviceConfigSpecBackingSpec;
		device: VcVirtualDevice;
		diskMoveType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileOperation: VcVirtualDeviceConfigSpecFileOperation;
		migrateCache: boolean;
		operation: VcVirtualDeviceConfigSpecOperation;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(operation?: VcVirtualDeviceConfigSpecOperation, fileOperation?: VcVirtualDeviceConfigSpecFileOperation, device?: VcVirtualDevice, profile?: VcVirtualMachineProfileSpec[], backing?: VcVirtualDeviceConfigSpecBackingSpec, diskMoveType?: String, migrateCache?: boolean);
		isMigrateCache(): boolean;
	}

	interface VcVirtualDiskDeltaDiskFormat
	{
		readonly id: String;
		readonly name: String;
		readonly nativeFormat: VcVirtualDiskDeltaDiskFormat;
		readonly redoLogFormat: VcVirtualDiskDeltaDiskFormat;
		readonly seSparseFormat: VcVirtualDiskDeltaDiskFormat;
		readonly value: String;

		fromString(value?: VcVirtualDiskDeltaDiskFormat): VcVirtualDiskDeltaDiskFormat;
	}

	declare const VcVirtualDiskDeltaDiskFormat: VcVirtualDiskDeltaDiskFormat;

	declare class VcVirtualDiskDeltaDiskFormatsSupported
	{
		datastoreType: String;
		deltaDiskFormat: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(datastoreType?: String, deltaDiskFormat?: VcChoiceOption);
	}

	interface VcVirtualDiskDeltaDiskFormatVariant
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmfsSparseVariant: VcVirtualDiskDeltaDiskFormatVariant;
		readonly vsanSparseVariant: VcVirtualDiskDeltaDiskFormatVariant;

		fromString(value?: VcVirtualDiskDeltaDiskFormatVariant): VcVirtualDiskDeltaDiskFormatVariant;
	}

	declare const VcVirtualDiskDeltaDiskFormatVariant: VcVirtualDiskDeltaDiskFormatVariant;

	declare class VcVirtualDiskFlatVer1BackingInfo
	{
		backingObjectId: String;
		contentId: String;
		datastore: VcDatastore;
		diskMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;
		parent: VcVirtualDiskFlatVer1BackingInfo;
		split: boolean;
		writeThrough: boolean;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String, diskMode?: String, split?: boolean, writeThrough?: boolean, contentId?: String, parent?: VcVirtualDiskFlatVer1BackingInfo);
		isSplit(): boolean;
		isWriteThrough(): boolean;
	}

	declare class VcVirtualDiskFlatVer1BackingOption
	{
		diskMode: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		split: VcBoolOption;
		type: String;
		writeThrough: VcBoolOption;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption, diskMode?: VcChoiceOption, split?: VcBoolOption, writeThrough?: VcBoolOption, growable?: boolean);
	}

	declare class VcVirtualDiskFlatVer2BackingInfo
	{
		backingObjectId: String;
		changeId: String;
		contentId: String;
		datastore: VcDatastore;
		deltaDiskFormat: String;
		deltaDiskFormatVariant: String;
		deltaGrainSize: Number;
		digestEnabled: boolean;
		diskMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eagerlyScrub: boolean;
		fileName: String;
		keyId: VcCryptoKeyId;
		parent: VcVirtualDiskFlatVer2BackingInfo;
		sharing: String;
		split: boolean;
		thinProvisioned: boolean;
		uuid: String;
		writeThrough: boolean;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String, diskMode?: String, split?: boolean, writeThrough?: boolean, thinProvisioned?: boolean, eagerlyScrub?: boolean, uuid?: String, contentId?: String, changeId?: String, parent?: VcVirtualDiskFlatVer2BackingInfo, deltaDiskFormat?: String, digestEnabled?: boolean, deltaGrainSize?: Number, deltaDiskFormatVariant?: String, sharing?: String, keyId?: VcCryptoKeyId);
		isDigestEnabled(): boolean;
		isEagerlyScrub(): boolean;
		isSplit(): boolean;
		isThinProvisioned(): boolean;
		isWriteThrough(): boolean;
	}

	declare class VcVirtualDiskFlatVer2BackingOption
	{
		deltaDiskFormat: VcChoiceOption;
		deltaDiskFormatsSupported: VcVirtualDiskDeltaDiskFormatsSupported[];
		diskMode: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eagerlyScrub: VcBoolOption;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		hotGrowable: boolean;
		split: VcBoolOption;
		thinProvisioned: VcBoolOption;
		type: String;
		uuid: boolean;
		writeThrough: VcBoolOption;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption, diskMode?: VcChoiceOption, split?: VcBoolOption, writeThrough?: VcBoolOption, growable?: boolean, hotGrowable?: boolean, uuid?: boolean, thinProvisioned?: VcBoolOption, eagerlyScrub?: VcBoolOption, deltaDiskFormat?: VcChoiceOption, deltaDiskFormatsSupported?: VcVirtualDiskDeltaDiskFormatsSupported[]);
	}

	declare class VcVirtualDiskId
	{
		diskId: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, diskId?: Number);
	}

	declare class VcVirtualDiskInfo
	{
		diskType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parent: String;
		unit: VcVirtualDiskManagerDiskUnit;

		constructor();
		constructor(unit?: VcVirtualDiskManagerDiskUnit, diskType?: String, parent?: String);
	}

	declare class VcVirtualDiskLocalPMemBackingInfo
	{
		backingObjectId: String;
		changeId: String;
		contentId: String;
		datastore: VcDatastore;
		diskMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;
		parent: VcVirtualDiskLocalPMemBackingInfo;
		uuid: String;
		volumeUUID: String;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String, diskMode?: String, uuid?: String, volumeUUID?: String, contentId?: String, changeId?: String, parent?: VcVirtualDiskLocalPMemBackingInfo);
	}

	declare class VcVirtualDiskLocalPMemBackingOption
	{
		diskMode: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		hotGrowable: boolean;
		type: String;
		uuid: boolean;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption, diskMode?: VcChoiceOption, growable?: boolean, hotGrowable?: boolean, uuid?: boolean);
	}

	interface VcVirtualDiskManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		consolidateDisks_Task(arg0?: VcVirtualDiskManagerDiskUnit[], arg1?: boolean): VcTask;
		copyVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter, arg2?: String, arg3?: VcDatacenter, arg4?: VcVirtualDiskSpec, arg5?: boolean): VcTask;
		createChildDisk_Task(arg0?: String, arg1?: VcDatacenter, arg2?: String, arg3?: VcDatacenter, arg4?: boolean): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter, arg2?: VcVirtualDiskSpec): VcTask;
		defragmentVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter): VcTask;
		deleteVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter): VcTask;
		disableUPIT_Task(arg0?: String, arg1?: VcDatacenter, arg2?: String, arg3?: boolean): VcTask;
		eagerZeroVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter): VcTask;
		enableUPIT_Task(arg0?: String, arg1?: VcDatacenter): VcTask;
		extendVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter, arg2?: Number, arg3?: boolean): VcTask;
		importUnmanagedSnapshot(arg0?: String, arg1?: VcDatacenter, arg2?: String): void;
		inflateVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter): VcTask;
		moveVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter, arg2?: String, arg3?: VcDatacenter, arg4?: boolean, arg5?: VcVirtualMachineProfileSpec[]): VcTask;
		optimizeEagerZeroVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter): VcTask;
		queryObjectInfo_Task(arg0?: String, arg1?: VcDatacenter, arg2?: boolean): VcTask;
		queryObjectTypes(): String[];
		queryVirtualDiskFragmentation(arg0?: String, arg1?: VcDatacenter): Number;
		queryVirtualDiskGeometry(arg0?: String, arg1?: VcDatacenter): VcHostDiskDimensionsChs;
		queryVirtualDiskInfo_Task(arg0?: String, arg1?: VcDatacenter, arg2?: boolean): VcTask;
		queryVirtualDiskUuid(arg0?: String, arg1?: VcDatacenter): String;
		releaseManagedSnapshot(arg0?: String, arg1?: VcDatacenter): void;
		reparentDisks_Task(arg0?: VcVirtualDiskManagerReparentSpec[]): VcTask;
		revertToChildDisk_Task(arg0?: String, arg1?: VcDatacenter, arg2?: String, arg3?: VcDatacenter): VcTask;
		setVirtualDiskUuid(arg0?: String, arg1?: VcDatacenter, arg2?: String): void;
		shrinkVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter, arg2?: boolean): VcTask;
		zeroFillVirtualDisk_Task(arg0?: String, arg1?: VcDatacenter): VcTask;
	}

	declare const VcVirtualDiskManager: VcVirtualDiskManager;

	declare class VcVirtualDiskManagerDiskUnit
	{
		datacenter: VcDatacenter;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, datacenter?: VcDatacenter);
	}

	declare class VcVirtualDiskManagerReparentSpec
	{
		childDatacenter: VcDatacenter;
		childFilename: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		markParentShared: boolean;
		parentDatacenter: VcDatacenter;
		parentFilename: String;

		constructor();
		constructor(childFilename?: String, childDatacenter?: VcDatacenter, parentFilename?: String, parentDatacenter?: VcDatacenter, markParentShared?: boolean);
	}

	interface VcVirtualDiskMode
	{
		readonly append: VcVirtualDiskMode;
		readonly id: String;
		readonly independent_nonpersistent: VcVirtualDiskMode;
		readonly independent_persistent: VcVirtualDiskMode;
		readonly name: String;
		readonly nonpersistent: VcVirtualDiskMode;
		readonly persistent: VcVirtualDiskMode;
		readonly undoable: VcVirtualDiskMode;
		readonly value: String;

		fromString(value?: VcVirtualDiskMode): VcVirtualDiskMode;
	}

	declare const VcVirtualDiskMode: VcVirtualDiskMode;

	declare class VcVirtualDiskModeNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		mode: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String, mode?: String);
		printStackTrace(): void;
	}

	declare class VcVirtualDiskOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		capacityInKB: VcLongOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		ioAllocationOption: VcStorageIOAllocationOption;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;
		vFlashCacheConfigOption: VcVirtualDiskOptionVFlashCacheConfigOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, capacityInKB?: VcLongOption, ioAllocationOption?: VcStorageIOAllocationOption, vFlashCacheConfigOption?: VcVirtualDiskOptionVFlashCacheConfigOption);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualDiskOptionVFlashCacheConfigOption
	{
		blockSizeInKB: VcLongOption;
		cacheConsistencyType: VcChoiceOption;
		cacheMode: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reservationInMB: VcLongOption;

		constructor();
		constructor(cacheConsistencyType?: VcChoiceOption, cacheMode?: VcChoiceOption, reservationInMB?: VcLongOption, blockSizeInKB?: VcLongOption);
	}

	declare class VcVirtualDiskPartitionedRawDiskVer2BackingInfo
	{
		changeId: String;
		descriptorFileName: String;
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		partition: Number[];
		sharing: String;
		useAutoDetect: boolean;
		uuid: String;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean, descriptorFileName?: String, uuid?: String, changeId?: String, sharing?: String, partition?: Number[]);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualDiskPartitionedRawDiskVer2BackingOption
	{
		autoDetectAvailable: VcBoolOption;
		descriptorFileNameExtensions: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;
		uuid: boolean;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption, descriptorFileNameExtensions?: VcChoiceOption, uuid?: boolean);
	}

	declare class VcVirtualDiskRawDiskMappingVer1BackingInfo
	{
		backingObjectId: String;
		changeId: String;
		compatibilityMode: String;
		contentId: String;
		datastore: VcDatastore;
		deltaDiskFormat: String;
		deltaGrainSize: Number;
		deviceName: String;
		diskMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;
		lunUuid: String;
		parent: VcVirtualDiskRawDiskMappingVer1BackingInfo;
		sharing: String;
		uuid: String;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String, lunUuid?: String, deviceName?: String, compatibilityMode?: String, diskMode?: String, uuid?: String, contentId?: String, changeId?: String, parent?: VcVirtualDiskRawDiskMappingVer1BackingInfo, deltaDiskFormat?: String, deltaGrainSize?: Number, sharing?: String);
	}

	declare class VcVirtualDiskRawDiskMappingVer1BackingOption
	{
		autoDetectAvailable: VcBoolOption;
		compatibilityMode: VcChoiceOption;
		descriptorFileNameExtensions: VcChoiceOption;
		diskMode: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;
		uuid: boolean;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption, descriptorFileNameExtensions?: VcChoiceOption, compatibilityMode?: VcChoiceOption, diskMode?: VcChoiceOption, uuid?: boolean);
	}

	declare class VcVirtualDiskRawDiskVer2BackingInfo
	{
		changeId: String;
		descriptorFileName: String;
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		sharing: String;
		useAutoDetect: boolean;
		uuid: String;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean, descriptorFileName?: String, uuid?: String, changeId?: String, sharing?: String);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualDiskRawDiskVer2BackingOption
	{
		autoDetectAvailable: VcBoolOption;
		descriptorFileNameExtensions: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;
		uuid: boolean;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption, descriptorFileNameExtensions?: VcChoiceOption, uuid?: boolean);
	}

	declare class VcVirtualDiskSeSparseBackingInfo
	{
		backingObjectId: String;
		changeId: String;
		contentId: String;
		datastore: VcDatastore;
		deltaDiskFormat: String;
		digestEnabled: boolean;
		diskMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;
		grainSize: Number;
		keyId: VcCryptoKeyId;
		parent: VcVirtualDiskSeSparseBackingInfo;
		uuid: String;
		writeThrough: boolean;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String, diskMode?: String, writeThrough?: boolean, uuid?: String, contentId?: String, changeId?: String, parent?: VcVirtualDiskSeSparseBackingInfo, deltaDiskFormat?: String, digestEnabled?: boolean, grainSize?: Number, keyId?: VcCryptoKeyId);
		isDigestEnabled(): boolean;
		isWriteThrough(): boolean;
	}

	declare class VcVirtualDiskSeSparseBackingOption
	{
		deltaDiskFormatsSupported: VcVirtualDiskDeltaDiskFormatsSupported[];
		diskMode: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		hotGrowable: boolean;
		type: String;
		uuid: boolean;
		writeThrough: VcBoolOption;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption, diskMode?: VcChoiceOption, writeThrough?: VcBoolOption, growable?: boolean, hotGrowable?: boolean, uuid?: boolean, deltaDiskFormatsSupported?: VcVirtualDiskDeltaDiskFormatsSupported[]);
	}

	interface VcVirtualDiskSharing
	{
		readonly id: String;
		readonly name: String;
		readonly sharingMultiWriter: VcVirtualDiskSharing;
		readonly sharingNone: VcVirtualDiskSharing;
		readonly value: String;

		fromString(value?: VcVirtualDiskSharing): VcVirtualDiskSharing;
	}

	declare const VcVirtualDiskSharing: VcVirtualDiskSharing;

	declare class VcVirtualDiskSparseVer1BackingInfo
	{
		backingObjectId: String;
		contentId: String;
		datastore: VcDatastore;
		diskMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;
		parent: VcVirtualDiskSparseVer1BackingInfo;
		spaceUsedInKB: Number;
		split: boolean;
		writeThrough: boolean;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String, diskMode?: String, split?: boolean, writeThrough?: boolean, spaceUsedInKB?: Number, contentId?: String, parent?: VcVirtualDiskSparseVer1BackingInfo);
		isSplit(): boolean;
		isWriteThrough(): boolean;
	}

	declare class VcVirtualDiskSparseVer1BackingOption
	{
		diskModes: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		split: VcBoolOption;
		type: String;
		writeThrough: VcBoolOption;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption, diskModes?: VcChoiceOption, split?: VcBoolOption, writeThrough?: VcBoolOption, growable?: boolean);
	}

	declare class VcVirtualDiskSparseVer2BackingInfo
	{
		backingObjectId: String;
		changeId: String;
		contentId: String;
		datastore: VcDatastore;
		diskMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;
		keyId: VcCryptoKeyId;
		parent: VcVirtualDiskSparseVer2BackingInfo;
		spaceUsedInKB: Number;
		split: boolean;
		uuid: String;
		writeThrough: boolean;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String, diskMode?: String, split?: boolean, writeThrough?: boolean, spaceUsedInKB?: Number, uuid?: String, contentId?: String, changeId?: String, parent?: VcVirtualDiskSparseVer2BackingInfo, keyId?: VcCryptoKeyId);
		isSplit(): boolean;
		isWriteThrough(): boolean;
	}

	declare class VcVirtualDiskSparseVer2BackingOption
	{
		diskMode: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		hotGrowable: boolean;
		split: VcBoolOption;
		type: String;
		uuid: boolean;
		writeThrough: VcBoolOption;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption, diskMode?: VcChoiceOption, split?: VcBoolOption, writeThrough?: VcBoolOption, growable?: boolean, hotGrowable?: boolean, uuid?: boolean);
	}

	declare class VcVirtualDiskSpec
	{
		adapterType: String;
		diskType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(diskType?: String, adapterType?: String);
	}

	interface VcVirtualDiskType
	{
		readonly delta: VcVirtualDiskType;
		readonly eagerZeroedThick: VcVirtualDiskType;
		readonly flatMonolithic: VcVirtualDiskType;
		readonly id: String;
		readonly name: String;
		readonly preallocated: VcVirtualDiskType;
		readonly raw: VcVirtualDiskType;
		readonly rdm: VcVirtualDiskType;
		readonly rdmp: VcVirtualDiskType;
		readonly seSparse: VcVirtualDiskType;
		readonly sparse2Gb: VcVirtualDiskType;
		readonly sparseMonolithic: VcVirtualDiskType;
		readonly thick: VcVirtualDiskType;
		readonly thick2Gb: VcVirtualDiskType;
		readonly thin: VcVirtualDiskType;
		readonly value: String;

		fromString(value?: VcVirtualDiskType): VcVirtualDiskType;
	}

	declare const VcVirtualDiskType: VcVirtualDiskType;

	declare class VcVirtualDiskVFlashCacheConfigInfo
	{
		blockSizeInKB: Number;
		cacheConsistencyType: String;
		cacheMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reservationInMB: Number;
		vFlashModule: String;

		constructor();
		constructor(vFlashModule?: String, reservationInMB?: Number, cacheConsistencyType?: String, cacheMode?: String, blockSizeInKB?: Number);
	}

	interface VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType
	{
		readonly id: String;
		readonly name: String;
		readonly strong: VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType;
		readonly value: String;
		readonly weak: VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType;

		fromString(value?: VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType): VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType;
	}

	declare const VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType: VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType;

	interface VcVirtualDiskVFlashCacheConfigInfoCacheMode
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly write_back: VcVirtualDiskVFlashCacheConfigInfoCacheMode;
		readonly write_thru: VcVirtualDiskVFlashCacheConfigInfoCacheMode;

		fromString(value?: VcVirtualDiskVFlashCacheConfigInfoCacheMode): VcVirtualDiskVFlashCacheConfigInfoCacheMode;
	}

	declare const VcVirtualDiskVFlashCacheConfigInfoCacheMode: VcVirtualDiskVFlashCacheConfigInfoCacheMode;

	declare class VcVirtualE1000
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, addressType?: String, macAddress?: String, wakeOnLanEnabled?: boolean, resourceAllocation?: VcVirtualEthernetCardResourceAllocation, externalId?: String, uptCompatibilityEnabled?: boolean);
		isUptCompatibilityEnabled(): boolean;
		isWakeOnLanEnabled(): boolean;
	}

	declare class VcVirtualE1000e
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, addressType?: String, macAddress?: String, wakeOnLanEnabled?: boolean, resourceAllocation?: VcVirtualEthernetCardResourceAllocation, externalId?: String, uptCompatibilityEnabled?: boolean);
		isUptCompatibilityEnabled(): boolean;
		isWakeOnLanEnabled(): boolean;
	}

	declare class VcVirtualE1000eOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, supportedOUI?: VcChoiceOption, macType?: VcChoiceOption, wakeOnLanEnabled?: VcBoolOption, vmDirectPathGen2Supported?: boolean, uptCompatibilityEnabled?: VcBoolOption);
		isHotRemoveSupported(): boolean;
		isVmDirectPathGen2Supported(): boolean;
	}

	declare class VcVirtualE1000Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, supportedOUI?: VcChoiceOption, macType?: VcChoiceOption, wakeOnLanEnabled?: VcBoolOption, vmDirectPathGen2Supported?: boolean, uptCompatibilityEnabled?: VcBoolOption);
		isHotRemoveSupported(): boolean;
		isVmDirectPathGen2Supported(): boolean;
	}

	declare class VcVirtualEnsoniq1371
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualEnsoniq1371Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualEthernetCard
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, addressType?: String, macAddress?: String, wakeOnLanEnabled?: boolean, resourceAllocation?: VcVirtualEthernetCardResourceAllocation, externalId?: String, uptCompatibilityEnabled?: boolean);
		isUptCompatibilityEnabled(): boolean;
		isWakeOnLanEnabled(): boolean;
	}

	declare class VcVirtualEthernetCardDistributedVirtualPortBackingInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		port: VcDistributedVirtualSwitchPortConnection;

		constructor();
		constructor(port?: VcDistributedVirtualSwitchPortConnection);
	}

	declare class VcVirtualEthernetCardDVPortBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String);
	}

	declare class VcVirtualEthernetCardLegacyNetworkBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualEthernetCardLegacyNetworkBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	interface VcVirtualEthernetCardLegacyNetworkDeviceName
	{
		readonly bridged: VcVirtualEthernetCardLegacyNetworkDeviceName;
		readonly hostonly: VcVirtualEthernetCardLegacyNetworkDeviceName;
		readonly id: String;
		readonly name: String;
		readonly nat: VcVirtualEthernetCardLegacyNetworkDeviceName;
		readonly value: String;

		fromString(value?: VcVirtualEthernetCardLegacyNetworkDeviceName): VcVirtualEthernetCardLegacyNetworkDeviceName;
	}

	declare const VcVirtualEthernetCardLegacyNetworkDeviceName: VcVirtualEthernetCardLegacyNetworkDeviceName;

	interface VcVirtualEthernetCardMacType
	{
		readonly assigned: VcVirtualEthernetCardMacType;
		readonly generated: VcVirtualEthernetCardMacType;
		readonly id: String;
		readonly manual: VcVirtualEthernetCardMacType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualEthernetCardMacType): VcVirtualEthernetCardMacType;
	}

	declare const VcVirtualEthernetCardMacType: VcVirtualEthernetCardMacType;

	declare class VcVirtualEthernetCardNetworkBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inPassthroughMode: boolean;
		network: VcNetwork;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean, network?: VcNetwork, inPassthroughMode?: boolean);
		isInPassthroughMode(): boolean;
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualEthernetCardNetworkBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualEthernetCardNotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcVirtualEthernetCardOpaqueNetworkBackingInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		opaqueNetworkId: String;
		opaqueNetworkType: String;

		constructor();
		constructor(opaqueNetworkId?: String, opaqueNetworkType?: String);
	}

	declare class VcVirtualEthernetCardOpaqueNetworkBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String);
	}

	declare class VcVirtualEthernetCardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, supportedOUI?: VcChoiceOption, macType?: VcChoiceOption, wakeOnLanEnabled?: VcBoolOption, vmDirectPathGen2Supported?: boolean, uptCompatibilityEnabled?: VcBoolOption);
		isHotRemoveSupported(): boolean;
		isVmDirectPathGen2Supported(): boolean;
	}

	declare class VcVirtualEthernetCardResourceAllocation
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		limit: Number;
		reservation: Number;
		share: VcSharesInfo;

		constructor();
		constructor(reservation?: Number, share?: VcSharesInfo, limit?: Number);
	}

	declare class VcVirtualFloppy
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualFloppyDeviceBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualFloppyDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualFloppyImageBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String);
	}

	declare class VcVirtualFloppyImageBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileNameExtensions: VcChoiceOption;
		type: String;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption);
	}

	declare class VcVirtualFloppyOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualFloppyRemoteDeviceBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualFloppyRemoteDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualHardware
	{
		device: VcVirtualDevice[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memoryMB: Number;
		numCoresPerSocket: Number;
		numCPU: Number;
		virtualICH7MPresent: boolean;
		virtualSMCPresent: boolean;

		constructor();
		constructor(numCPU?: Number, numCoresPerSocket?: Number, memoryMB?: Number, virtualICH7MPresent?: boolean, virtualSMCPresent?: boolean, device?: VcVirtualDevice[]);
		isVirtualICH7MPresent(): boolean;
		isVirtualSMCPresent(): boolean;
	}

	declare class VcVirtualHardwareCompatibilityIssue
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVirtualHardwareOption
	{
		deviceListReadonly: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hwVersion: Number;
		licensingLimit: String[];
		memoryMB: VcLongOption;
		numCoresPerSocket: VcIntOption;
		numCPU: Number[];
		numCpuReadonly: boolean;
		numIDEControllers: VcIntOption;
		numNVDIMMControllers: VcIntOption;
		numPCIControllers: VcIntOption;
		numPS2Controllers: VcIntOption;
		numSIOControllers: VcIntOption;
		numSupportedWwnNodes: VcIntOption;
		numSupportedWwnPorts: VcIntOption;
		numUSBControllers: VcIntOption;
		numUSBXHCIControllers: VcIntOption;
		resourceConfigOption: VcResourceConfigOption;
		virtualDeviceOption: VcVirtualDeviceOption[];

		constructor();
		constructor(hwVersion?: Number, virtualDeviceOption?: VcVirtualDeviceOption[], deviceListReadonly?: boolean, numCPU?: Number[], numCoresPerSocket?: VcIntOption, numCpuReadonly?: boolean, memoryMB?: VcLongOption, numPCIControllers?: VcIntOption, numIDEControllers?: VcIntOption, numUSBControllers?: VcIntOption, numUSBXHCIControllers?: VcIntOption, numSIOControllers?: VcIntOption, numPS2Controllers?: VcIntOption, licensingLimit?: String[], numSupportedWwnPorts?: VcIntOption, numSupportedWwnNodes?: VcIntOption, resourceConfigOption?: VcResourceConfigOption, numNVDIMMControllers?: VcIntOption);
	}

	declare class VcVirtualHardwareVersionNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		hostName: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostName?: String, host?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcVirtualHdAudioCard
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualHdAudioCardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualIDEController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[]);
	}

	declare class VcVirtualIDEControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numIDECdroms: VcIntOption;
		numIDEDisks: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numIDEDisks?: VcIntOption, numIDECdroms?: VcIntOption);
		isHotRemoveSupported(): boolean;
	}

	interface VcVirtualizationManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcVirtualizationManager: VcVirtualizationManager;

	declare class VcVirtualKeyboard
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualKeyboardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualLsiLogicController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotAddRemove: boolean;
		key: Number;
		scsiCtlrUnitNumber: Number;
		sharedBus: VcVirtualSCSISharing;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[], hotAddRemove?: boolean, sharedBus?: VcVirtualSCSISharing, scsiCtlrUnitNumber?: Number);
		isHotAddRemove(): boolean;
	}

	declare class VcVirtualLsiLogicControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		defaultSharedIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotAddRemove: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSCSICdroms: VcIntOption;
		numSCSIDisks: VcIntOption;
		numSCSIPassthrough: VcIntOption;
		plugAndPlay: boolean;
		scsiCtlrUnitNumber: Number;
		sharing: VcVirtualSCSISharing[];
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numSCSIDisks?: VcIntOption, numSCSICdroms?: VcIntOption, numSCSIPassthrough?: VcIntOption, sharing?: VcVirtualSCSISharing[], defaultSharedIndex?: Number, hotAddRemove?: VcBoolOption, scsiCtlrUnitNumber?: Number);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualLsiLogicSASController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotAddRemove: boolean;
		key: Number;
		scsiCtlrUnitNumber: Number;
		sharedBus: VcVirtualSCSISharing;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[], hotAddRemove?: boolean, sharedBus?: VcVirtualSCSISharing, scsiCtlrUnitNumber?: Number);
		isHotAddRemove(): boolean;
	}

	declare class VcVirtualLsiLogicSASControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		defaultSharedIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotAddRemove: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSCSICdroms: VcIntOption;
		numSCSIDisks: VcIntOption;
		numSCSIPassthrough: VcIntOption;
		plugAndPlay: boolean;
		scsiCtlrUnitNumber: Number;
		sharing: VcVirtualSCSISharing[];
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numSCSIDisks?: VcIntOption, numSCSICdroms?: VcIntOption, numSCSIPassthrough?: VcIntOption, sharing?: VcVirtualSCSISharing[], defaultSharedIndex?: Number, hotAddRemove?: VcBoolOption, scsiCtlrUnitNumber?: Number);
		isHotRemoveSupported(): boolean;
	}

	interface VcVirtualMachine
	{
		readonly alarmActionsEnabled: boolean;
		annotation: String;
		readonly availableField: VcCustomFieldDef[];
		biosId: String;
		capability: VcVirtualMachineCapability;
		committedStorage: String;
		config: VcVirtualMachineConfigInfo;
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		connectionState: String;
		cpu: String;
		readonly customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		readonly declaredAlarmState: VcAlarmState[];
		readonly disabledMethod: String[];
		displayName: String;
		readonly effectiveRole: Number[];
		environmentBrowser: VcEnvironmentBrowser;
		guest: VcGuestInfo;
		guestHeartbeatStatus: VcManagedEntityStatus;
		guestMemoryUsage: String;
		guestOS: String;
		hostMemoryUsage: String;
		hostName: String;
		id: String;
		instanceId: String;
		ipAddress: String;
		isTemplate: boolean;
		layout: VcVirtualMachineFileLayout;
		layoutEx: VcVirtualMachineFileLayoutEx;
		mem: String;
		memory: String;
		memoryOverhead: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		nativeSnapshotCapable: boolean;
		network: VcNetwork[];
		overallCpuUsage: String;
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		parentVApp: VcManagedEntity;
		readonly permission: VcPermission[];
		productFullVersion: String;
		productName: String;
		productVendor: String;
		readonly recentTask: VcTask[];
		resourceConfig: VcResourceConfigSpec;
		resourcePool: VcResourcePool;
		rootSnapshot: VcVirtualMachineSnapshot[];
		runtime: VcVirtualMachineRuntimeInfo;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		snapshot: VcVirtualMachineSnapshotInfo;
		state: String;
		storage: VcVirtualMachineStorageInfo;
		summary: VcVirtualMachineSummary;
		readonly tag: VcTag[];
		totalStorage: String;
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		unsharedStorage: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		vmSnapshot: Object[];
		vmToolsStatus: String;
		vmToolsVersionStatus: String;
		vmVersion: String;

		_getRef(): VcManagedObjectReference;
		acquireMksTicket(): VcVirtualMachineMksTicket;
		acquireTicket(arg0?: String): VcVirtualMachineTicket;
		addTag(arg0?: VcTag[]): void;
		answerVM(arg0?: String, arg1?: String): void;
		applyEvcModeVM_Task(arg0?: VcHostFeatureMask[]): VcTask;
		attachDisk_Task(arg0?: VcID, arg1?: VcDatastore, arg2?: Number, arg3?: Number): VcTask;
		checkCustomizationSpec(arg0?: VcCustomizationSpec): void;
		cloneVM_Task(arg0?: VcFolder, arg1?: String, arg2?: VcVirtualMachineCloneSpec): VcTask;
		configureQuorumFilePathPrefix_Task(arg0?: String): VcTask;
		consolidateVMDisks_Task(): VcTask;
		createImportLease(): VcHttpNfcLease;
		createScreenshot_Task(): VcTask;
		createSecondaryVM_Task(arg0?: VcHostSystem): VcTask;
		createSecondaryVMEx_Task(arg0?: VcHostSystem, arg1?: VcFaultToleranceConfigSpec): VcTask;
		createSnapshot_Task(arg0?: String, arg1?: String, arg2?: boolean, arg3?: boolean): VcTask;
		createSnapshotEx_Task(arg0?: String, arg1?: String, arg2?: boolean, arg3?: VcVirtualMachineGuestQuiesceSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		customizeVM_Task(arg0?: VcCustomizationSpec): VcTask;
		defragmentAllDisks(): void;
		destroy_Task(): VcTask;
		detachDisk_Task(arg0?: VcID): VcTask;
		disableSecondaryVM_Task(arg0?: VcVirtualMachine): VcTask;
		enableSecondaryVM_Task(arg0?: VcVirtualMachine, arg1?: VcHostSystem): VcTask;
		estimateStorageForConsolidateSnapshots_Task(): VcTask;
		exportVm(): VcHttpNfcLease;
		extractOvfEnvironment(): String;
		injectOvfEnvironment(arg0?: String, arg1?: String): void;
		instantClone_Task(arg0?: VcVirtualMachineInstantCloneSpec): VcTask;
		invokeFSR_Task(): VcTask;
		makePrimaryVM_Task(arg0?: VcVirtualMachine): VcTask;
		markAsTemplate(): void;
		markAsVirtualMachine(arg0?: VcResourcePool, arg1?: VcHostSystem): void;
		migrateVM_Task(arg0?: VcResourcePool, arg1?: VcHostSystem, arg2?: VcVirtualMachineMovePriority, arg3?: VcVirtualMachinePowerState): VcTask;
		mountToolsInstaller(): void;
		mountToolsInstallerImage(arg0?: VcVirtualDeviceBackingInfo, arg1?: VcGuestAuthentication): void;
		powerOffVM_Task(): VcTask;
		powerOnVM_Task(arg0?: VcHostSystem): VcTask;
		promoteDisks_Task(arg0?: boolean, arg1?: VcVirtualDisk[]): VcTask;
		putUsbScanCodes(arg0?: VcUsbScanCodeSpec): Number;
		queryChangedDiskAreas(arg0?: VcVirtualMachineSnapshot, arg1?: Number, arg2?: Number, arg3?: String): VcDiskChangeInfo;
		queryFaultToleranceCompatibility(): VcLocalizedMethodFault[];
		queryFaultToleranceCompatibilityEx(arg0?: boolean): VcLocalizedMethodFault[];
		queryUnownedFiles(): String[];
		rebootGuest(): void;
		reconfigVM_Task(arg0?: VcVirtualMachineConfigSpec): VcTask;
		refreshStorageInfo(): void;
		reload(): void;
		reloadEx_Task(): VcTask;
		reloadVirtualMachineFromPath_Task(arg0?: String): VcTask;
		relocateVM_Task(arg0?: VcVirtualMachineRelocateSpec, arg1?: VcVirtualMachineMovePriority): VcTask;
		removeAllSnapshots_Task(arg0?: boolean): VcTask;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		resetGuestInformation(): void;
		resetVM_Task(): VcTask;
		retrieveBackupAgent(): VcVirtualMachineBackupAgent;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		retrieveQuorumFilePathPrefix(): String;
		revertToCurrentSnapshot_Task(arg0?: VcHostSystem, arg1?: boolean): VcTask;
		sendNMI(): void;
		setCustomValue(arg0?: String, arg1?: String): void;
		setScreenResolution(arg0?: Number, arg1?: Number): void;
		shrinkDisk_Task(arg0?: Number[]): VcTask;
		shutdownGuest(): void;
		standbyGuest(): void;
		startRecording_Task(arg0?: String, arg1?: String): VcTask;
		startReplaying_Task(arg0?: VcVirtualMachineSnapshot): VcTask;
		stopRecording_Task(): VcTask;
		stopReplaying_Task(): VcTask;
		suspendVM_Task(): VcTask;
		terminateFaultTolerantVM_Task(arg0?: VcVirtualMachine): VcTask;
		terminateVM(): void;
		turnOffFaultToleranceForVM_Task(): VcTask;
		unmountToolsInstaller(): void;
		unregisterVM(): void;
		upgradeTools_Task(arg0?: String): VcTask;
		upgradeToolsFromImage_Task(arg0?: String, arg1?: VcVirtualDeviceBackingInfo, arg2?: VcGuestAuthentication): VcTask;
		upgradeVM_Task(arg0?: String): VcTask;
		wipeDisk_Task(): VcTask;
	}

	declare const VcVirtualMachine: VcVirtualMachine;

	declare class VcVirtualMachineAffinityInfo
	{
		affinitySet: Number[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(affinitySet?: Number[]);
	}

	interface VcVirtualMachineAppHeartbeatStatusType
	{
		readonly appStatusGray: VcVirtualMachineAppHeartbeatStatusType;
		readonly appStatusGreen: VcVirtualMachineAppHeartbeatStatusType;
		readonly appStatusRed: VcVirtualMachineAppHeartbeatStatusType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineAppHeartbeatStatusType): VcVirtualMachineAppHeartbeatStatusType;
	}

	declare const VcVirtualMachineAppHeartbeatStatusType: VcVirtualMachineAppHeartbeatStatusType;

	interface VcVirtualMachineBackupAgent
	{
		readonly availableField: VcCustomFieldDef[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		abortBackup(arg0?: String): void;
		backupProtocolEvent(arg0?: Number): VcVirtualMachineBackupEventInfo;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		notifySnapshotCompletion(): void;
		setCustomValue(arg0?: String, arg1?: String): void;
		startBackup(arg0?: boolean, arg1?: String[]): void;
	}

	declare const VcVirtualMachineBackupAgent: VcVirtualMachineBackupAgent;

	declare class VcVirtualMachineBackupEventInfo
	{
		code: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eventType: String;
		message: String;

		constructor();
		constructor(eventType?: String, code?: Number, message?: String);
	}

	interface VcVirtualMachineBackupEventInfoBackupEventType
	{
		readonly backupManifest: VcVirtualMachineBackupEventInfoBackupEventType;
		readonly id: String;
		readonly keepAlive: VcVirtualMachineBackupEventInfoBackupEventType;
		readonly name: String;
		readonly providerAbort: VcVirtualMachineBackupEventInfoBackupEventType;
		readonly requestorAbort: VcVirtualMachineBackupEventInfoBackupEventType;
		readonly requestorDone: VcVirtualMachineBackupEventInfoBackupEventType;
		readonly requestorError: VcVirtualMachineBackupEventInfoBackupEventType;
		readonly reset: VcVirtualMachineBackupEventInfoBackupEventType;
		readonly snapshotCommit: VcVirtualMachineBackupEventInfoBackupEventType;
		readonly snapshotPrepare: VcVirtualMachineBackupEventInfoBackupEventType;
		readonly value: String;
		readonly writerError: VcVirtualMachineBackupEventInfoBackupEventType;

		fromString(value?: VcVirtualMachineBackupEventInfoBackupEventType): VcVirtualMachineBackupEventInfoBackupEventType;
	}

	declare const VcVirtualMachineBackupEventInfoBackupEventType: VcVirtualMachineBackupEventInfoBackupEventType;

	declare class VcVirtualMachineBootOptions
	{
		bootDelay: Number;
		bootOrder: VcVirtualMachineBootOptionsBootableDevice[];
		bootRetryDelay: Number;
		bootRetryEnabled: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		efiSecureBootEnabled: boolean;
		enterBIOSSetup: boolean;
		networkBootProtocol: String;

		constructor();
		constructor(bootDelay?: Number, enterBIOSSetup?: boolean, efiSecureBootEnabled?: boolean, bootRetryEnabled?: boolean, bootRetryDelay?: Number, bootOrder?: VcVirtualMachineBootOptionsBootableDevice[], networkBootProtocol?: String);
		isBootRetryEnabled(): boolean;
		isEfiSecureBootEnabled(): boolean;
		isEnterBIOSSetup(): boolean;
	}

	declare class VcVirtualMachineBootOptionsBootableCdromDevice
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVirtualMachineBootOptionsBootableDevice
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVirtualMachineBootOptionsBootableDiskDevice
	{
		deviceKey: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(deviceKey?: Number);
	}

	declare class VcVirtualMachineBootOptionsBootableEthernetDevice
	{
		deviceKey: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(deviceKey?: Number);
	}

	declare class VcVirtualMachineBootOptionsBootableFloppyDevice
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcVirtualMachineBootOptionsNetworkBootProtocolType
	{
		readonly id: String;
		readonly ipv4: VcVirtualMachineBootOptionsNetworkBootProtocolType;
		readonly ipv6: VcVirtualMachineBootOptionsNetworkBootProtocolType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineBootOptionsNetworkBootProtocolType): VcVirtualMachineBootOptionsNetworkBootProtocolType;
	}

	declare const VcVirtualMachineBootOptionsNetworkBootProtocolType: VcVirtualMachineBootOptionsNetworkBootProtocolType;

	declare class VcVirtualMachineCapability
	{
		bootOptionsSupported: boolean;
		bootRetryOptionsSupported: boolean;
		canConnectUSBDevices: boolean;
		changeTrackingSupported: boolean;
		consolePreferencesSupported: boolean;
		cpuFeatureMaskSupported: boolean;
		disableSnapshotsSupported: boolean;
		diskSharesSupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		featureRequirementSupported: boolean;
		guestAutoLockSupported: boolean;
		hostBasedReplicationSupported: boolean;
		lockSnapshotsSupported: boolean;
		memoryReservationLockSupported: boolean;
		memorySnapshotsSupported: boolean;
		messageBusSupported: boolean;
		multipleCoresPerSocketSupported: boolean;
		multipleSnapshotsSupported: boolean;
		nestedHVSupported: boolean;
		npivWwnOnNonRdmVmSupported: boolean;
		perVmEvcSupported: boolean;
		poweredOffSnapshotsSupported: boolean;
		poweredOnMonitorTypeChangeSupported: boolean;
		quiescedSnapshotsSupported: boolean;
		recordReplaySupported: boolean;
		revertToSnapshotSupported: boolean;
		s1AcpiManagementSupported: boolean;
		secureBootSupported: boolean;
		seSparseDiskSupported: boolean;
		settingDisplayTopologyModesSupported: boolean;
		settingDisplayTopologySupported: boolean;
		settingScreenResolutionSupported: boolean;
		settingVideoRamSizeSupported: boolean;
		snapshotConfigSupported: boolean;
		snapshotOperationsSupported: boolean;
		swapPlacementSupported: boolean;
		toolsAutoUpdateSupported: boolean;
		toolsRebootPredictSupported: boolean;
		toolsSyncTimeSupported: boolean;
		virtualMmuUsageSupported: boolean;
		vmfsNativeSnapshotSupported: boolean;
		vmNpivWwnDisableSupported: boolean;
		vmNpivWwnSupported: boolean;
		vmNpivWwnUpdateSupported: boolean;
		vPMCSupported: boolean;

		constructor();
		constructor(snapshotOperationsSupported?: boolean, multipleSnapshotsSupported?: boolean, snapshotConfigSupported?: boolean, poweredOffSnapshotsSupported?: boolean, memorySnapshotsSupported?: boolean, revertToSnapshotSupported?: boolean, quiescedSnapshotsSupported?: boolean, disableSnapshotsSupported?: boolean, lockSnapshotsSupported?: boolean, consolePreferencesSupported?: boolean, cpuFeatureMaskSupported?: boolean, s1AcpiManagementSupported?: boolean, settingScreenResolutionSupported?: boolean, toolsAutoUpdateSupported?: boolean, vmNpivWwnSupported?: boolean, npivWwnOnNonRdmVmSupported?: boolean, vmNpivWwnDisableSupported?: boolean, vmNpivWwnUpdateSupported?: boolean, swapPlacementSupported?: boolean, toolsSyncTimeSupported?: boolean, virtualMmuUsageSupported?: boolean, diskSharesSupported?: boolean, bootOptionsSupported?: boolean, bootRetryOptionsSupported?: boolean, settingVideoRamSizeSupported?: boolean, settingDisplayTopologySupported?: boolean, settingDisplayTopologyModesSupported?: boolean, recordReplaySupported?: boolean, changeTrackingSupported?: boolean, multipleCoresPerSocketSupported?: boolean, hostBasedReplicationSupported?: boolean, guestAutoLockSupported?: boolean, memoryReservationLockSupported?: boolean, featureRequirementSupported?: boolean, poweredOnMonitorTypeChangeSupported?: boolean, vmfsNativeSnapshotSupported?: boolean, seSparseDiskSupported?: boolean, nestedHVSupported?: boolean, vPMCSupported?: boolean, toolsRebootPredictSupported?: boolean, messageBusSupported?: boolean, canConnectUSBDevices?: boolean, secureBootSupported?: boolean, perVmEvcSupported?: boolean);
		isBootRetryOptionsSupported(): boolean;
		isCanConnectUSBDevices(): boolean;
		isChangeTrackingSupported(): boolean;
		isFeatureRequirementSupported(): boolean;
		isGuestAutoLockSupported(): boolean;
		isHostBasedReplicationSupported(): boolean;
		isMemoryReservationLockSupported(): boolean;
		isMessageBusSupported(): boolean;
		isMultipleCoresPerSocketSupported(): boolean;
		isNestedHVSupported(): boolean;
		isPerVmEvcSupported(): boolean;
		isPoweredOnMonitorTypeChangeSupported(): boolean;
		isRecordReplaySupported(): boolean;
		isSecureBootSupported(): boolean;
		isSeSparseDiskSupported(): boolean;
		isSettingDisplayTopologyModesSupported(): boolean;
		isSettingDisplayTopologySupported(): boolean;
		isToolsRebootPredictSupported(): boolean;
		isVmfsNativeSnapshotSupported(): boolean;
		isVmNpivWwnDisableSupported(): boolean;
		isVmNpivWwnUpdateSupported(): boolean;
		isVPMCSupported(): boolean;
	}

	declare class VcVirtualMachineCdromInfo
	{
		configurationTag: String[];
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, configurationTag?: String[], description?: String);
	}

	declare class VcVirtualMachineCloneSpec
	{
		config: VcVirtualMachineConfigSpec;
		customization: VcCustomizationSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		location: VcVirtualMachineRelocateSpec;
		memory: boolean;
		powerOn: boolean;
		snapshot: VcVirtualMachineSnapshot;
		template: boolean;

		constructor();
		constructor(location?: VcVirtualMachineRelocateSpec, template?: boolean, config?: VcVirtualMachineConfigSpec, customization?: VcCustomizationSpec, powerOn?: boolean, snapshot?: VcVirtualMachineSnapshot, memory?: boolean);
		isMemory(): boolean;
	}

	interface VcVirtualMachineCompatibilityChecker
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkCompatibility_Task(arg0?: VcVirtualMachine, arg1?: VcHostSystem, arg2?: VcResourcePool, arg3?: String[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcVirtualMachineCompatibilityChecker: VcVirtualMachineCompatibilityChecker;

	declare class VcVirtualMachineConfigInfo
	{
		alternateGuestName: String;
		annotation: String;
		bootOptions: VcVirtualMachineBootOptions;
		changeTrackingEnabled: boolean;
		changeVersion: String;
		consolePreferences: VcVirtualMachineConsolePreferences;
		cpuAffinity: VcVirtualMachineAffinityInfo;
		cpuAllocation: VcResourceAllocationInfo;
		cpuFeatureMask: VcHostCpuIdInfo[];
		cpuHotAddEnabled: boolean;
		cpuHotRemoveEnabled: boolean;
		datastoreUrl: VcVirtualMachineConfigInfoDatastoreUrlPair[];
		defaultPowerOps: VcVirtualMachineDefaultPowerOpInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extraConfig: VcOptionValue[];
		files: VcVirtualMachineFileInfo;
		firmware: String;
		flags: VcVirtualMachineFlagInfo;
		forkConfigInfo: VcVirtualMachineForkConfigInfo;
		ftInfo: VcFaultToleranceConfigInfo;
		guestAutoLockEnabled: boolean;
		guestFullName: String;
		guestId: String;
		guestIntegrityInfo: VcVirtualMachineGuestIntegrityInfo;
		hardware: VcVirtualHardware;
		hotPlugMemoryIncrementSize: Number;
		hotPlugMemoryLimit: Number;
		initialOverhead: VcVirtualMachineConfigInfoOverheadInfo;
		instanceUuid: String;
		keyId: VcCryptoKeyId;
		latencySensitivity: VcLatencySensitivity;
		locationId: String;
		managedBy: VcManagedByInfo;
		maxMksConnections: Number;
		memoryAffinity: VcVirtualMachineAffinityInfo;
		memoryAllocation: VcResourceAllocationInfo;
		memoryHotAddEnabled: boolean;
		memoryReservationLockedToMax: boolean;
		messageBusTunnelEnabled: boolean;
		migrateEncryption: String;
		modified: Date;
		name: String;
		nestedHVEnabled: boolean;
		networkShaper: VcVirtualMachineNetworkShaperInfo;
		npivDesiredNodeWwns: Number;
		npivDesiredPortWwns: Number;
		npivNodeWorldWideName: Number[];
		npivOnNonRdmDisks: boolean;
		npivPortWorldWideName: Number[];
		npivTemporaryDisabled: boolean;
		npivWorldWideNameType: String;
		repConfig: VcReplicationConfigSpec;
		scheduledHardwareUpgradeInfo: VcScheduledHardwareUpgradeInfo;
		swapPlacement: String;
		swapStorageObjectId: String;
		template: boolean;
		tools: VcToolsConfigInfo;
		uuid: String;
		vAppConfig: VcVmConfigInfo;
		vAssertsEnabled: boolean;
		version: String;
		vFlashCacheReservation: Number;
		vmStorageObjectId: String;
		vPMCEnabled: boolean;

		constructor();
		isChangeTrackingEnabled(): boolean;
		isCpuHotAddEnabled(): boolean;
		isCpuHotRemoveEnabled(): boolean;
		isGuestAutoLockEnabled(): boolean;
		isMemoryHotAddEnabled(): boolean;
		isMemoryReservationLockedToMax(): boolean;
		isMessageBusTunnelEnabled(): boolean;
		isNestedHVEnabled(): boolean;
		isNpivOnNonRdmDisks(): boolean;
		isNpivTemporaryDisabled(): boolean;
		isVAssertsEnabled(): boolean;
		isVPMCEnabled(): boolean;
	}

	declare class VcVirtualMachineConfigInfoDatastoreUrlPair
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		url: String;

		constructor();
		constructor(name?: String, url?: String);
	}

	interface VcVirtualMachineConfigInfoNpivWwnType
	{
		readonly external: VcVirtualMachineConfigInfoNpivWwnType;
		readonly host: VcVirtualMachineConfigInfoNpivWwnType;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vc: VcVirtualMachineConfigInfoNpivWwnType;

		fromString(value?: VcVirtualMachineConfigInfoNpivWwnType): VcVirtualMachineConfigInfoNpivWwnType;
	}

	declare const VcVirtualMachineConfigInfoNpivWwnType: VcVirtualMachineConfigInfoNpivWwnType;

	declare class VcVirtualMachineConfigInfoOverheadInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		initialMemoryReservation: Number;
		initialSwapReservation: Number;

		constructor();
		constructor(initialMemoryReservation?: Number, initialSwapReservation?: Number);
	}

	interface VcVirtualMachineConfigInfoSwapPlacementType
	{
		readonly hostLocal: VcVirtualMachineConfigInfoSwapPlacementType;
		readonly id: String;
		readonly inherit: VcVirtualMachineConfigInfoSwapPlacementType;
		readonly name: String;
		readonly value: String;
		readonly vmDirectory: VcVirtualMachineConfigInfoSwapPlacementType;

		fromString(value?: VcVirtualMachineConfigInfoSwapPlacementType): VcVirtualMachineConfigInfoSwapPlacementType;
	}

	declare const VcVirtualMachineConfigInfoSwapPlacementType: VcVirtualMachineConfigInfoSwapPlacementType;

	declare class VcVirtualMachineConfigOption
	{
		capabilities: VcVirtualMachineCapability;
		datastore: VcDatastoreOption;
		defaultDevice: VcVirtualDevice[];
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		guestOSDefaultIndex: Number;
		guestOSDescriptor: VcGuestOsDescriptor[];
		hardwareOptions: VcVirtualHardwareOption;
		supportedMonitorType: String[];
		supportedOvfEnvironmentTransport: String[];
		supportedOvfInstallTransport: String[];
		version: String;

		constructor();
		constructor(version?: String, description?: String, guestOSDescriptor?: VcGuestOsDescriptor[], guestOSDefaultIndex?: Number, hardwareOptions?: VcVirtualHardwareOption, capabilities?: VcVirtualMachineCapability, datastore?: VcDatastoreOption, defaultDevice?: VcVirtualDevice[], supportedMonitorType?: String[], supportedOvfEnvironmentTransport?: String[], supportedOvfInstallTransport?: String[]);
	}

	declare class VcVirtualMachineConfigOptionDescriptor
	{
		createSupported: boolean;
		defaultConfigOption: boolean;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem[];
		key: String;
		runSupported: boolean;
		upgradeSupported: boolean;

		constructor();
		constructor(key?: String, description?: String, host?: VcHostSystem[], createSupported?: boolean, defaultConfigOption?: boolean, runSupported?: boolean, upgradeSupported?: boolean);
		isCreateSupported(): boolean;
		isDefaultConfigOption(): boolean;
		isRunSupported(): boolean;
		isUpgradeSupported(): boolean;
	}

	declare class VcVirtualMachineConfigSpec
	{
		alternateGuestName: String;
		annotation: String;
		bootOptions: VcVirtualMachineBootOptions;
		changeTrackingEnabled: boolean;
		changeVersion: String;
		consolePreferences: VcVirtualMachineConsolePreferences;
		cpuAffinity: VcVirtualMachineAffinityInfo;
		cpuAllocation: VcResourceAllocationInfo;
		cpuFeatureMask: VcVirtualMachineCpuIdInfoSpec[];
		cpuHotAddEnabled: boolean;
		cpuHotRemoveEnabled: boolean;
		crypto: VcCryptoSpec;
		deviceChange: VcVirtualDeviceConfigSpec[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extraConfig: VcOptionValue[];
		files: VcVirtualMachineFileInfo;
		firmware: String;
		flags: VcVirtualMachineFlagInfo;
		ftInfo: VcFaultToleranceConfigInfo;
		guestAutoLockEnabled: boolean;
		guestId: String;
		instanceUuid: String;
		latencySensitivity: VcLatencySensitivity;
		locationId: String;
		managedBy: VcManagedByInfo;
		maxMksConnections: Number;
		memoryAffinity: VcVirtualMachineAffinityInfo;
		memoryAllocation: VcResourceAllocationInfo;
		memoryHotAddEnabled: boolean;
		memoryMB: Number;
		memoryReservationLockedToMax: boolean;
		messageBusTunnelEnabled: boolean;
		migrateEncryption: String;
		name: String;
		nestedHVEnabled: boolean;
		networkShaper: VcVirtualMachineNetworkShaperInfo;
		npivDesiredNodeWwns: Number;
		npivDesiredPortWwns: Number;
		npivNodeWorldWideName: Number[];
		npivOnNonRdmDisks: boolean;
		npivPortWorldWideName: Number[];
		npivTemporaryDisabled: boolean;
		npivWorldWideNameOp: String;
		npivWorldWideNameType: String;
		numCoresPerSocket: Number;
		numCPUs: Number;
		powerOpInfo: VcVirtualMachineDefaultPowerOpInfo;
		repConfig: VcReplicationConfigSpec;
		scheduledHardwareUpgradeInfo: VcScheduledHardwareUpgradeInfo;
		swapPlacement: String;
		tools: VcToolsConfigInfo;
		uuid: String;
		vAppConfig: VcVmConfigSpec;
		vAppConfigRemoved: boolean;
		vAssertsEnabled: boolean;
		version: String;
		virtualICH7MPresent: boolean;
		virtualSMCPresent: boolean;
		vmProfile: VcVirtualMachineProfileSpec[];
		vPMCEnabled: boolean;

		constructor();
		constructor(changeVersion?: String, name?: String, version?: String, uuid?: String, instanceUuid?: String, npivNodeWorldWideName?: Number[], npivPortWorldWideName?: Number[], npivWorldWideNameType?: String, npivDesiredNodeWwns?: Number, npivDesiredPortWwns?: Number, npivTemporaryDisabled?: boolean, npivOnNonRdmDisks?: boolean, npivWorldWideNameOp?: String, locationId?: String, guestId?: String, alternateGuestName?: String, annotation?: String, files?: VcVirtualMachineFileInfo, tools?: VcToolsConfigInfo, flags?: VcVirtualMachineFlagInfo, consolePreferences?: VcVirtualMachineConsolePreferences, powerOpInfo?: VcVirtualMachineDefaultPowerOpInfo, numCPUs?: Number, numCoresPerSocket?: Number, memoryMB?: Number, memoryHotAddEnabled?: boolean, cpuHotAddEnabled?: boolean, cpuHotRemoveEnabled?: boolean, virtualICH7MPresent?: boolean, virtualSMCPresent?: boolean, deviceChange?: VcVirtualDeviceConfigSpec[], cpuAllocation?: VcResourceAllocationInfo, memoryAllocation?: VcResourceAllocationInfo, latencySensitivity?: VcLatencySensitivity, cpuAffinity?: VcVirtualMachineAffinityInfo, memoryAffinity?: VcVirtualMachineAffinityInfo, networkShaper?: VcVirtualMachineNetworkShaperInfo, cpuFeatureMask?: VcVirtualMachineCpuIdInfoSpec[], extraConfig?: VcOptionValue[], swapPlacement?: String, bootOptions?: VcVirtualMachineBootOptions, vAppConfig?: VcVmConfigSpec, ftInfo?: VcFaultToleranceConfigInfo, repConfig?: VcReplicationConfigSpec, vAppConfigRemoved?: boolean, vAssertsEnabled?: boolean, changeTrackingEnabled?: boolean, firmware?: String, maxMksConnections?: Number, guestAutoLockEnabled?: boolean, managedBy?: VcManagedByInfo, memoryReservationLockedToMax?: boolean, nestedHVEnabled?: boolean, vPMCEnabled?: boolean, scheduledHardwareUpgradeInfo?: VcScheduledHardwareUpgradeInfo, vmProfile?: VcVirtualMachineProfileSpec[], messageBusTunnelEnabled?: boolean, crypto?: VcCryptoSpec, migrateEncryption?: String);
		isChangeTrackingEnabled(): boolean;
		isCpuHotAddEnabled(): boolean;
		isCpuHotRemoveEnabled(): boolean;
		isGuestAutoLockEnabled(): boolean;
		isMemoryHotAddEnabled(): boolean;
		isMemoryReservationLockedToMax(): boolean;
		isMessageBusTunnelEnabled(): boolean;
		isNestedHVEnabled(): boolean;
		isNpivOnNonRdmDisks(): boolean;
		isNpivTemporaryDisabled(): boolean;
		isVAppConfigRemoved(): boolean;
		isVAssertsEnabled(): boolean;
		isVirtualICH7MPresent(): boolean;
		isVirtualSMCPresent(): boolean;
		isVPMCEnabled(): boolean;
	}

	interface VcVirtualMachineConfigSpecEncryptedVMotionModes
	{
		readonly disabled: VcVirtualMachineConfigSpecEncryptedVMotionModes;
		readonly id: String;
		readonly name: String;
		readonly opportunistic: VcVirtualMachineConfigSpecEncryptedVMotionModes;
		readonly required: VcVirtualMachineConfigSpecEncryptedVMotionModes;
		readonly value: String;

		fromString(value?: VcVirtualMachineConfigSpecEncryptedVMotionModes): VcVirtualMachineConfigSpecEncryptedVMotionModes;
	}

	declare const VcVirtualMachineConfigSpecEncryptedVMotionModes: VcVirtualMachineConfigSpecEncryptedVMotionModes;

	interface VcVirtualMachineConfigSpecNpivWwnOp
	{
		readonly extend: VcVirtualMachineConfigSpecNpivWwnOp;
		readonly generate: VcVirtualMachineConfigSpecNpivWwnOp;
		readonly id: String;
		readonly name: String;
		readonly remove: VcVirtualMachineConfigSpecNpivWwnOp;
		readonly set: VcVirtualMachineConfigSpecNpivWwnOp;
		readonly value: String;

		fromString(value?: VcVirtualMachineConfigSpecNpivWwnOp): VcVirtualMachineConfigSpecNpivWwnOp;
	}

	declare const VcVirtualMachineConfigSpecNpivWwnOp: VcVirtualMachineConfigSpecNpivWwnOp;

	declare class VcVirtualMachineConfigSummary
	{
		annotation: String;
		cpuReservation: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ftInfo: VcFaultToleranceConfigInfo;
		guestFullName: String;
		guestId: String;
		installBootRequired: boolean;
		instanceUuid: String;
		managedBy: VcManagedByInfo;
		memoryReservation: Number;
		memorySizeMB: Number;
		name: String;
		numCpu: Number;
		numEthernetCards: Number;
		numVirtualDisks: Number;
		product: VcVAppProductInfo;
		template: boolean;
		uuid: String;
		vmPathName: String;

		constructor();
		constructor(name?: String, template?: boolean, vmPathName?: String, memorySizeMB?: Number, cpuReservation?: Number, memoryReservation?: Number, numCpu?: Number, numEthernetCards?: Number, numVirtualDisks?: Number, uuid?: String, instanceUuid?: String, guestId?: String, guestFullName?: String, annotation?: String, product?: VcVAppProductInfo, installBootRequired?: boolean, ftInfo?: VcFaultToleranceConfigInfo, managedBy?: VcManagedByInfo);
		isInstallBootRequired(): boolean;
	}

	interface VcVirtualMachineConnectionState
	{
		readonly connected: VcVirtualMachineConnectionState;
		readonly disconnected: VcVirtualMachineConnectionState;
		readonly id: String;
		readonly inaccessible: VcVirtualMachineConnectionState;
		readonly invalid: VcVirtualMachineConnectionState;
		readonly name: String;
		readonly orphaned: VcVirtualMachineConnectionState;
		readonly value: String;

		fromString(value?: VcVirtualMachineConnectionState): VcVirtualMachineConnectionState;
	}

	declare const VcVirtualMachineConnectionState: VcVirtualMachineConnectionState;

	declare class VcVirtualMachineConsolePreferences
	{
		closeOnPowerOffOrSuspend: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enterFullScreenOnPowerOn: boolean;
		powerOnWhenOpened: boolean;

		constructor();
		constructor(powerOnWhenOpened?: boolean, enterFullScreenOnPowerOn?: boolean, closeOnPowerOffOrSuspend?: boolean);
		isCloseOnPowerOffOrSuspend(): boolean;
		isEnterFullScreenOnPowerOn(): boolean;
		isPowerOnWhenOpened(): boolean;
	}

	declare class VcVirtualMachineCpuIdInfoSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcHostCpuIdInfo;
		operation: VcArrayUpdateOperation;
		removeKey_AnyValue: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
		constructor(operation?: VcArrayUpdateOperation, removeKey?: Object, info?: VcHostCpuIdInfo);
	}

	declare class VcVirtualMachineDatastoreInfo
	{
		capability: VcDatastoreCapability;
		configurationTag: String[];
		datastore: VcDatastoreSummary;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		maxFileSize: Number;
		maxPhysicalRDMFileSize: Number;
		maxVirtualDiskCapacity: Number;
		maxVirtualRDMFileSize: Number;
		mode: String;
		name: String;
		vStorageSupport: String;

		constructor();
		constructor(name?: String, configurationTag?: String[], datastore?: VcDatastoreSummary, capability?: VcDatastoreCapability, maxFileSize?: Number, maxVirtualDiskCapacity?: Number, maxPhysicalRDMFileSize?: Number, maxVirtualRDMFileSize?: Number, mode?: String, vStorageSupport?: String);
	}

	declare class VcVirtualMachineDatastoreVolumeOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSystemType: String;
		majorVersion: Number;

		constructor();
		constructor(fileSystemType?: String, majorVersion?: Number);
	}

	declare class VcVirtualMachineDefaultPowerOpInfo
	{
		defaultPowerOffType: String;
		defaultResetType: String;
		defaultSuspendType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		powerOffType: String;
		resetType: String;
		standbyAction: String;
		suspendType: String;

		constructor();
		constructor(powerOffType?: String, suspendType?: String, resetType?: String, defaultPowerOffType?: String, defaultSuspendType?: String, defaultResetType?: String, standbyAction?: String);
	}

	declare class VcVirtualMachineDefaultProfileSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVirtualMachineDefinedProfileSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profileData: VcVirtualMachineProfileRawData;
		profileId: String;
		replicationSpec: VcReplicationSpec;

		constructor();
		constructor(profileId?: String, replicationSpec?: VcReplicationSpec, profileData?: VcVirtualMachineProfileRawData);
	}

	declare class VcVirtualMachineDeviceRuntimeInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		runtimeState: VcVirtualMachineDeviceRuntimeInfoDeviceRuntimeState;

		constructor();
		constructor(runtimeState?: VcVirtualMachineDeviceRuntimeInfoDeviceRuntimeState, key?: Number);
	}

	declare class VcVirtualMachineDeviceRuntimeInfoDeviceRuntimeState
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reservationStatus: String;
		vmDirectPathGen2Active: boolean;
		vmDirectPathGen2InactiveReasonExtended: String;
		vmDirectPathGen2InactiveReasonOther: String[];
		vmDirectPathGen2InactiveReasonVm: String[];

		constructor();
		constructor(vmDirectPathGen2Active?: boolean, vmDirectPathGen2InactiveReasonVm?: String[], vmDirectPathGen2InactiveReasonOther?: String[], vmDirectPathGen2InactiveReasonExtended?: String, reservationStatus?: String);
	}

	interface VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmNptIncompatibleHost: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;
		readonly vmNptIncompatibleNetwork: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;

		fromString(value?: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther): VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;
	}

	declare const VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;

	interface VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmNptConflictingIOChainConfigured: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptConflictingOperationInProgress: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptDisabledOrDisconnectedAdapter: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptFaultToleranceOrRecordReplayConfigured: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptIncompatibleAdapterFeatures: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptIncompatibleAdapterType: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptIncompatibleBackingType: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptIncompatibleGuest: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptIncompatibleGuestDriver: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptInsufficientMemoryReservation: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptMonitorBlocks: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptOutOfIntrVector: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptRuntimeError: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptVMCIActive: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;

		fromString(value?: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm): VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
	}

	declare const VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;

	declare class VcVirtualMachineDiskDeviceInfo
	{
		capacity: Number;
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		vm: VcVirtualMachine[];

		constructor();
		constructor(name?: String, configurationTag?: String[], capacity?: Number, vm?: VcVirtualMachine[]);
	}

	declare class VcVirtualMachineDisplayTopology
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		height: Number;
		width: Number;
		x: Number;
		y: Number;

		constructor();
		constructor(x?: Number, y?: Number, width?: Number, height?: Number);
	}

	declare class VcVirtualMachineEmptyProfileSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcVirtualMachineFaultToleranceState
	{
		readonly disabled: VcVirtualMachineFaultToleranceState;
		readonly enabled: VcVirtualMachineFaultToleranceState;
		readonly id: String;
		readonly name: String;
		readonly needSecondary: VcVirtualMachineFaultToleranceState;
		readonly notConfigured: VcVirtualMachineFaultToleranceState;
		readonly running: VcVirtualMachineFaultToleranceState;
		readonly starting: VcVirtualMachineFaultToleranceState;
		readonly value: String;

		fromString(value?: VcVirtualMachineFaultToleranceState): VcVirtualMachineFaultToleranceState;
	}

	declare const VcVirtualMachineFaultToleranceState: VcVirtualMachineFaultToleranceState;

	interface VcVirtualMachineFaultToleranceType
	{
		readonly checkpointing: VcVirtualMachineFaultToleranceType;
		readonly id: String;
		readonly name: String;
		readonly recordReplay: VcVirtualMachineFaultToleranceType;
		readonly unset: VcVirtualMachineFaultToleranceType;
		readonly value: String;

		fromString(value?: VcVirtualMachineFaultToleranceType): VcVirtualMachineFaultToleranceType;
	}

	declare const VcVirtualMachineFaultToleranceType: VcVirtualMachineFaultToleranceType;

	declare class VcVirtualMachineFeatureRequirement
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		featureName: String;
		key: String;
		value: String;

		constructor();
		constructor(key?: String, featureName?: String, value?: String);
	}

	declare class VcVirtualMachineFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ftMetadataDirectory: String;
		logDirectory: String;
		snapshotDirectory: String;
		suspendDirectory: String;
		vmPathName: String;

		constructor();
		constructor(vmPathName?: String, snapshotDirectory?: String, suspendDirectory?: String, logDirectory?: String, ftMetadataDirectory?: String);
	}

	declare class VcVirtualMachineFileLayout
	{
		configFile: String[];
		disk: VcVirtualMachineFileLayoutDiskLayout[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		logFile: String[];
		snapshot: VcVirtualMachineFileLayoutSnapshotLayout[];
		swapFile: String;

		constructor();
		constructor(configFile?: String[], logFile?: String[], disk?: VcVirtualMachineFileLayoutDiskLayout[], snapshot?: VcVirtualMachineFileLayoutSnapshotLayout[], swapFile?: String);
	}

	declare class VcVirtualMachineFileLayoutDiskLayout
	{
		diskFile: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;

		constructor();
		constructor(key?: Number, diskFile?: String[]);
	}

	declare class VcVirtualMachineFileLayoutEx
	{
		disk: VcVirtualMachineFileLayoutExDiskLayout[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		file: VcVirtualMachineFileLayoutExFileInfo[];
		snapshot: VcVirtualMachineFileLayoutExSnapshotLayout[];
		timestamp: Date;

		constructor();
		constructor(file?: VcVirtualMachineFileLayoutExFileInfo[], disk?: VcVirtualMachineFileLayoutExDiskLayout[], snapshot?: VcVirtualMachineFileLayoutExSnapshotLayout[], timestamp?: Date);
	}

	declare class VcVirtualMachineFileLayoutExDiskLayout
	{
		chain: VcVirtualMachineFileLayoutExDiskUnit[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;

		constructor();
		constructor(key?: Number, chain?: VcVirtualMachineFileLayoutExDiskUnit[]);
	}

	declare class VcVirtualMachineFileLayoutExDiskUnit
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileKey: Number[];

		constructor();
		constructor(fileKey?: Number[]);
	}

	declare class VcVirtualMachineFileLayoutExFileInfo
	{
		accessible: boolean;
		backingObjectId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		name: String;
		size: Number;
		type: String;
		uniqueSize: Number;

		constructor();
		constructor(key?: Number, name?: String, type?: String, size?: Number, uniqueSize?: Number, backingObjectId?: String, accessible?: boolean);
		isAccessible(): boolean;
	}

	interface VcVirtualMachineFileLayoutExFileType
	{
		readonly config: VcVirtualMachineFileLayoutExFileType;
		readonly core: VcVirtualMachineFileLayoutExFileType;
		readonly digestDescriptor: VcVirtualMachineFileLayoutExFileType;
		readonly digestExtent: VcVirtualMachineFileLayoutExFileType;
		readonly diskDescriptor: VcVirtualMachineFileLayoutExFileType;
		readonly diskExtent: VcVirtualMachineFileLayoutExFileType;
		readonly diskReplicationState: VcVirtualMachineFileLayoutExFileType;
		readonly extendedConfig: VcVirtualMachineFileLayoutExFileType;
		readonly ftMetadata: VcVirtualMachineFileLayoutExFileType;
		readonly guestCustomization: VcVirtualMachineFileLayoutExFileType;
		readonly id: String;
		readonly log: VcVirtualMachineFileLayoutExFileType;
		readonly name: String;
		readonly namespaceData: VcVirtualMachineFileLayoutExFileType;
		readonly nvram: VcVirtualMachineFileLayoutExFileType;
		readonly screenshot: VcVirtualMachineFileLayoutExFileType;
		readonly snapshotData: VcVirtualMachineFileLayoutExFileType;
		readonly snapshotList: VcVirtualMachineFileLayoutExFileType;
		readonly snapshotManifestList: VcVirtualMachineFileLayoutExFileType;
		readonly snapshotMemory: VcVirtualMachineFileLayoutExFileType;
		readonly stat: VcVirtualMachineFileLayoutExFileType;
		readonly suspend: VcVirtualMachineFileLayoutExFileType;
		readonly suspendMemory: VcVirtualMachineFileLayoutExFileType;
		readonly swap: VcVirtualMachineFileLayoutExFileType;
		readonly uwswap: VcVirtualMachineFileLayoutExFileType;
		readonly value: String;

		fromString(value?: VcVirtualMachineFileLayoutExFileType): VcVirtualMachineFileLayoutExFileType;
	}

	declare const VcVirtualMachineFileLayoutExFileType: VcVirtualMachineFileLayoutExFileType;

	declare class VcVirtualMachineFileLayoutExSnapshotLayout
	{
		dataKey: Number;
		disk: VcVirtualMachineFileLayoutExDiskLayout[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcVirtualMachineSnapshot;
		memoryKey: Number;

		constructor();
		constructor(key?: VcVirtualMachineSnapshot, dataKey?: Number, memoryKey?: Number, disk?: VcVirtualMachineFileLayoutExDiskLayout[]);
	}

	declare class VcVirtualMachineFileLayoutSnapshotLayout
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcVirtualMachineSnapshot;
		snapshotFile: String[];

		constructor();
		constructor(key?: VcVirtualMachineSnapshot, snapshotFile?: String[]);
	}

	declare class VcVirtualMachineFlagInfo
	{
		cbrcCacheEnabled: boolean;
		disableAcceleration: boolean;
		diskUuidEnabled: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enableLogging: boolean;
		faultToleranceType: String;
		htSharing: String;
		monitorType: String;
		recordReplayEnabled: boolean;
		runWithDebugInfo: boolean;
		snapshotDisabled: boolean;
		snapshotLocked: boolean;
		snapshotPowerOffBehavior: String;
		useToe: boolean;
		virtualExecUsage: String;
		virtualMmuUsage: String;

		constructor();
		constructor(disableAcceleration?: boolean, enableLogging?: boolean, useToe?: boolean, runWithDebugInfo?: boolean, monitorType?: String, htSharing?: String, snapshotDisabled?: boolean, snapshotLocked?: boolean, diskUuidEnabled?: boolean, virtualMmuUsage?: String, virtualExecUsage?: String, snapshotPowerOffBehavior?: String, recordReplayEnabled?: boolean, faultToleranceType?: String, cbrcCacheEnabled?: boolean);
		isCbrcCacheEnabled(): boolean;
		isDisableAcceleration(): boolean;
		isDiskUuidEnabled(): boolean;
		isEnableLogging(): boolean;
		isRecordReplayEnabled(): boolean;
		isRunWithDebugInfo(): boolean;
		isSnapshotDisabled(): boolean;
		isSnapshotLocked(): boolean;
		isUseToe(): boolean;
	}

	interface VcVirtualMachineFlagInfoMonitorType
	{
		readonly debug: VcVirtualMachineFlagInfoMonitorType;
		readonly id: String;
		readonly name: String;
		readonly release: VcVirtualMachineFlagInfoMonitorType;
		readonly stats: VcVirtualMachineFlagInfoMonitorType;
		readonly value: String;

		fromString(value?: VcVirtualMachineFlagInfoMonitorType): VcVirtualMachineFlagInfoMonitorType;
	}

	declare const VcVirtualMachineFlagInfoMonitorType: VcVirtualMachineFlagInfoMonitorType;

	interface VcVirtualMachineFlagInfoVirtualExecUsage
	{
		readonly hvAuto: VcVirtualMachineFlagInfoVirtualExecUsage;
		readonly hvOff: VcVirtualMachineFlagInfoVirtualExecUsage;
		readonly hvOn: VcVirtualMachineFlagInfoVirtualExecUsage;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineFlagInfoVirtualExecUsage): VcVirtualMachineFlagInfoVirtualExecUsage;
	}

	declare const VcVirtualMachineFlagInfoVirtualExecUsage: VcVirtualMachineFlagInfoVirtualExecUsage;

	interface VcVirtualMachineFlagInfoVirtualMmuUsage
	{
		readonly automatic: VcVirtualMachineFlagInfoVirtualMmuUsage;
		readonly id: String;
		readonly name: String;
		readonly off: VcVirtualMachineFlagInfoVirtualMmuUsage;
		readonly on: VcVirtualMachineFlagInfoVirtualMmuUsage;
		readonly value: String;

		fromString(value?: VcVirtualMachineFlagInfoVirtualMmuUsage): VcVirtualMachineFlagInfoVirtualMmuUsage;
	}

	declare const VcVirtualMachineFlagInfoVirtualMmuUsage: VcVirtualMachineFlagInfoVirtualMmuUsage;

	declare class VcVirtualMachineFloppyInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, configurationTag?: String[]);
	}

	declare class VcVirtualMachineForkConfigInfo
	{
		childForkGroupId: String;
		childType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parentEnabled: boolean;
		parentForkGroupId: String;

		constructor();
		constructor(parentEnabled?: boolean, childForkGroupId?: String, parentForkGroupId?: String, childType?: String);
		isParentEnabled(): boolean;
	}

	interface VcVirtualMachineForkConfigInfoChildType
	{
		readonly id: String;
		readonly name: String;
		readonly none: VcVirtualMachineForkConfigInfoChildType;
		readonly nonpersistent: VcVirtualMachineForkConfigInfoChildType;
		readonly persistent: VcVirtualMachineForkConfigInfoChildType;
		readonly value: String;

		fromString(value?: VcVirtualMachineForkConfigInfoChildType): VcVirtualMachineForkConfigInfoChildType;
	}

	declare const VcVirtualMachineForkConfigInfoChildType: VcVirtualMachineForkConfigInfoChildType;

	declare class VcVirtualMachineGuestIntegrityInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;

		constructor();
		constructor(enabled?: boolean);
		isEnabled(): boolean;
	}

	interface VcVirtualMachineGuestOsFamily
	{
		readonly darwinGuestFamily: VcVirtualMachineGuestOsFamily;
		readonly id: String;
		readonly linuxGuest: VcVirtualMachineGuestOsFamily;
		readonly name: String;
		readonly netwareGuest: VcVirtualMachineGuestOsFamily;
		readonly otherGuestFamily: VcVirtualMachineGuestOsFamily;
		readonly solarisGuest: VcVirtualMachineGuestOsFamily;
		readonly value: String;
		readonly windowsGuest: VcVirtualMachineGuestOsFamily;

		fromString(value?: VcVirtualMachineGuestOsFamily): VcVirtualMachineGuestOsFamily;
	}

	declare const VcVirtualMachineGuestOsFamily: VcVirtualMachineGuestOsFamily;

	interface VcVirtualMachineGuestOsIdentifier
	{
		readonly asianux3_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly asianux3Guest: VcVirtualMachineGuestOsIdentifier;
		readonly asianux4_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly asianux4Guest: VcVirtualMachineGuestOsIdentifier;
		readonly asianux5_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly asianux7_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly centos6_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly centos64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly centos6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly centos7_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly centos7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly centosGuest: VcVirtualMachineGuestOsIdentifier;
		readonly coreos64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin10_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin10Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin11_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin11Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin12_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin13_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin14_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin15_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin16_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin17_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwinGuest: VcVirtualMachineGuestOsIdentifier;
		readonly debian10_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian10Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian4_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian4Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian5_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian5Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian6_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian7_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian8_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian8Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian9_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian9Guest: VcVirtualMachineGuestOsIdentifier;
		readonly dosGuest: VcVirtualMachineGuestOsIdentifier;
		readonly eComStation2Guest: VcVirtualMachineGuestOsIdentifier;
		readonly eComStationGuest: VcVirtualMachineGuestOsIdentifier;
		readonly fedora64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly fedoraGuest: VcVirtualMachineGuestOsIdentifier;
		readonly freebsd64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly freebsdGuest: VcVirtualMachineGuestOsIdentifier;
		readonly genericLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly id: String;
		readonly mandrakeGuest: VcVirtualMachineGuestOsIdentifier;
		readonly mandriva64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly mandrivaGuest: VcVirtualMachineGuestOsIdentifier;
		readonly name: String;
		readonly netware4Guest: VcVirtualMachineGuestOsIdentifier;
		readonly netware5Guest: VcVirtualMachineGuestOsIdentifier;
		readonly netware6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly nld9Guest: VcVirtualMachineGuestOsIdentifier;
		readonly oesGuest: VcVirtualMachineGuestOsIdentifier;
		readonly openServer5Guest: VcVirtualMachineGuestOsIdentifier;
		readonly openServer6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly opensuse64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly opensuseGuest: VcVirtualMachineGuestOsIdentifier;
		readonly oracleLinux6_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly oracleLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly oracleLinux6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly oracleLinux7_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly oracleLinux7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly oracleLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly os2Guest: VcVirtualMachineGuestOsIdentifier;
		readonly other24xLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly other24xLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly other26xLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly other26xLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly other3xLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly other3xLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly otherGuest: VcVirtualMachineGuestOsIdentifier;
		readonly otherGuest64: VcVirtualMachineGuestOsIdentifier;
		readonly otherLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly otherLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly redhatGuest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel2Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel3_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel3Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel4_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel4Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel5_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel5Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel6_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel7_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sjdsGuest: VcVirtualMachineGuestOsIdentifier;
		readonly sles10_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles10Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles11_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles11Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles12_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles12Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly slesGuest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris10_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris10Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris11_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris8Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris9Guest: VcVirtualMachineGuestOsIdentifier;
		readonly suse64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly suseGuest: VcVirtualMachineGuestOsIdentifier;
		readonly turboLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly turboLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly ubuntu64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly ubuntuGuest: VcVirtualMachineGuestOsIdentifier;
		readonly unixWare7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly value: String;
		readonly vmkernel5Guest: VcVirtualMachineGuestOsIdentifier;
		readonly vmkernel65Guest: VcVirtualMachineGuestOsIdentifier;
		readonly vmkernel6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly vmkernelGuest: VcVirtualMachineGuestOsIdentifier;
		readonly vmwarePhoton64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly win2000AdvServGuest: VcVirtualMachineGuestOsIdentifier;
		readonly win2000ProGuest: VcVirtualMachineGuestOsIdentifier;
		readonly win2000ServGuest: VcVirtualMachineGuestOsIdentifier;
		readonly win31Guest: VcVirtualMachineGuestOsIdentifier;
		readonly win95Guest: VcVirtualMachineGuestOsIdentifier;
		readonly win98Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows7_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows7Server64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows8_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows8Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows8Server64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows9_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows9Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows9Server64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windowsHyperVGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winLonghorn64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winLonghornGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winMeGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetBusinessGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetDatacenter64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetDatacenterGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetEnterprise64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetEnterpriseGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetStandard64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetStandardGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetWebGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNTGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winVista64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winVistaGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winXPHomeGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winXPPro64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winXPProGuest: VcVirtualMachineGuestOsIdentifier;

		fromString(value?: VcVirtualMachineGuestOsIdentifier): VcVirtualMachineGuestOsIdentifier;
	}

	declare const VcVirtualMachineGuestOsIdentifier: VcVirtualMachineGuestOsIdentifier;

	declare class VcVirtualMachineGuestQuiesceSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		timeout: Number;

		constructor();
		constructor(timeout?: Number);
	}

	interface VcVirtualMachineGuestState
	{
		readonly id: String;
		readonly name: String;
		readonly notRunning: VcVirtualMachineGuestState;
		readonly resetting: VcVirtualMachineGuestState;
		readonly running: VcVirtualMachineGuestState;
		readonly shuttingDown: VcVirtualMachineGuestState;
		readonly standby: VcVirtualMachineGuestState;
		readonly unknown: VcVirtualMachineGuestState;
		readonly value: String;

		fromString(value?: VcVirtualMachineGuestState): VcVirtualMachineGuestState;
	}

	declare const VcVirtualMachineGuestState: VcVirtualMachineGuestState;

	declare class VcVirtualMachineGuestSummary
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		guestFullName: String;
		guestId: String;
		hostName: String;
		ipAddress: String;
		toolsRunningStatus: String;
		toolsStatus: VcVirtualMachineToolsStatus;
		toolsVersionStatus: String;
		toolsVersionStatus2: String;

		constructor();
		constructor(guestId?: String, guestFullName?: String, toolsStatus?: VcVirtualMachineToolsStatus, toolsVersionStatus?: String, toolsVersionStatus2?: String, toolsRunningStatus?: String, hostName?: String, ipAddress?: String);
	}

	interface VcVirtualMachineHtSharing
	{
		readonly any: VcVirtualMachineHtSharing;
		readonly id: String;
		readonly internal: VcVirtualMachineHtSharing;
		readonly name: String;
		readonly none: VcVirtualMachineHtSharing;
		readonly value: String;

		fromString(value?: VcVirtualMachineHtSharing): VcVirtualMachineHtSharing;
	}

	declare const VcVirtualMachineHtSharing: VcVirtualMachineHtSharing;

	declare class VcVirtualMachineIdeDiskDeviceInfo
	{
		capacity: Number;
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		partitionTable: VcVirtualMachineIdeDiskDevicePartitionInfo[];
		vm: VcVirtualMachine[];

		constructor();
		constructor(name?: String, configurationTag?: String[], capacity?: Number, vm?: VcVirtualMachine[], partitionTable?: VcVirtualMachineIdeDiskDevicePartitionInfo[]);
	}

	declare class VcVirtualMachineIdeDiskDevicePartitionInfo
	{
		capacity: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: Number;

		constructor();
		constructor(id?: Number, capacity?: Number);
	}

	declare class VcVirtualMachineImportSpec
	{
		configSpec: VcVirtualMachineConfigSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		entityConfig: VcVAppEntityConfigInfo;
		instantiationOst: VcOvfConsumerOstNode;
		resPoolEntity: VcResourcePool;

		constructor();
		constructor(entityConfig?: VcVAppEntityConfigInfo, instantiationOst?: VcOvfConsumerOstNode, configSpec?: VcVirtualMachineConfigSpec, resPoolEntity?: VcResourcePool);
	}

	declare class VcVirtualMachineInstantCloneSpec
	{
		config: VcVirtualMachineConfigSpec;
		customization: VcInstantCloneCustomizationSpec;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, config?: VcVirtualMachineConfigSpec, customization?: VcInstantCloneCustomizationSpec);
	}

	declare class VcVirtualMachineInternalConfigSpec
	{
		alternateGuestName: String;
		annotation: String;
		bootOptions: VcVirtualMachineBootOptions;
		changeTrackingEnabled: boolean;
		changeVersion: String;
		consolePreferences: VcVirtualMachineConsolePreferences;
		cpuAffinity: VcVirtualMachineAffinityInfo;
		cpuAllocation: VcResourceAllocationInfo;
		cpuFeatureMask: VcVirtualMachineCpuIdInfoSpec[];
		cpuHotAddEnabled: boolean;
		cpuHotRemoveEnabled: boolean;
		crypto: VcCryptoSpec;
		deviceChange: VcVirtualDeviceConfigSpec[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extraConfig: VcOptionValue[];
		files: VcVirtualMachineFileInfo;
		firmware: String;
		flags: VcVirtualMachineFlagInfo;
		ftInfo: VcFaultToleranceConfigInfo;
		guestAutoLockEnabled: boolean;
		guestId: String;
		instanceUuid: String;
		internalForkConfigInfo: VcVirtualMachineForkConfigInfo;
		internalGuestIntegrityInfo: VcVirtualMachineGuestIntegrityInfo;
		latencySensitivity: VcLatencySensitivity;
		locationId: String;
		managedBy: VcManagedByInfo;
		maxMksConnections: Number;
		memoryAffinity: VcVirtualMachineAffinityInfo;
		memoryAllocation: VcResourceAllocationInfo;
		memoryHotAddEnabled: boolean;
		memoryMB: Number;
		memoryReservationLockedToMax: boolean;
		messageBusTunnelEnabled: boolean;
		migrateEncryption: String;
		name: String;
		nestedHVEnabled: boolean;
		networkShaper: VcVirtualMachineNetworkShaperInfo;
		npivDesiredNodeWwns: Number;
		npivDesiredPortWwns: Number;
		npivNodeWorldWideName: Number[];
		npivOnNonRdmDisks: boolean;
		npivPortWorldWideName: Number[];
		npivTemporaryDisabled: boolean;
		npivWorldWideNameOp: String;
		npivWorldWideNameType: String;
		numCoresPerSocket: Number;
		numCPUs: Number;
		powerOpInfo: VcVirtualMachineDefaultPowerOpInfo;
		repConfig: VcReplicationConfigSpec;
		scheduledHardwareUpgradeInfo: VcScheduledHardwareUpgradeInfo;
		swapPlacement: String;
		tools: VcToolsConfigInfo;
		uuid: String;
		vAppConfig: VcVmConfigSpec;
		vAppConfigRemoved: boolean;
		vAssertsEnabled: boolean;
		version: String;
		virtualICH7MPresent: boolean;
		virtualSMCPresent: boolean;
		vmProfile: VcVirtualMachineProfileSpec[];
		vPMCEnabled: boolean;

		constructor();
		constructor(changeVersion?: String, name?: String, version?: String, uuid?: String, instanceUuid?: String, npivNodeWorldWideName?: Number[], npivPortWorldWideName?: Number[], npivWorldWideNameType?: String, npivDesiredNodeWwns?: Number, npivDesiredPortWwns?: Number, npivTemporaryDisabled?: boolean, npivOnNonRdmDisks?: boolean, npivWorldWideNameOp?: String, locationId?: String, guestId?: String, alternateGuestName?: String, annotation?: String, files?: VcVirtualMachineFileInfo, tools?: VcToolsConfigInfo, flags?: VcVirtualMachineFlagInfo, consolePreferences?: VcVirtualMachineConsolePreferences, powerOpInfo?: VcVirtualMachineDefaultPowerOpInfo, numCPUs?: Number, numCoresPerSocket?: Number, memoryMB?: Number, memoryHotAddEnabled?: boolean, cpuHotAddEnabled?: boolean, cpuHotRemoveEnabled?: boolean, virtualICH7MPresent?: boolean, virtualSMCPresent?: boolean, deviceChange?: VcVirtualDeviceConfigSpec[], cpuAllocation?: VcResourceAllocationInfo, memoryAllocation?: VcResourceAllocationInfo, latencySensitivity?: VcLatencySensitivity, cpuAffinity?: VcVirtualMachineAffinityInfo, memoryAffinity?: VcVirtualMachineAffinityInfo, networkShaper?: VcVirtualMachineNetworkShaperInfo, cpuFeatureMask?: VcVirtualMachineCpuIdInfoSpec[], extraConfig?: VcOptionValue[], swapPlacement?: String, bootOptions?: VcVirtualMachineBootOptions, vAppConfig?: VcVmConfigSpec, ftInfo?: VcFaultToleranceConfigInfo, repConfig?: VcReplicationConfigSpec, vAppConfigRemoved?: boolean, vAssertsEnabled?: boolean, changeTrackingEnabled?: boolean, firmware?: String, maxMksConnections?: Number, guestAutoLockEnabled?: boolean, managedBy?: VcManagedByInfo, memoryReservationLockedToMax?: boolean, nestedHVEnabled?: boolean, vPMCEnabled?: boolean, scheduledHardwareUpgradeInfo?: VcScheduledHardwareUpgradeInfo, vmProfile?: VcVirtualMachineProfileSpec[], messageBusTunnelEnabled?: boolean, crypto?: VcCryptoSpec, migrateEncryption?: String, internalForkConfigInfo?: VcVirtualMachineForkConfigInfo, internalGuestIntegrityInfo?: VcVirtualMachineGuestIntegrityInfo);
		isChangeTrackingEnabled(): boolean;
		isCpuHotAddEnabled(): boolean;
		isCpuHotRemoveEnabled(): boolean;
		isGuestAutoLockEnabled(): boolean;
		isMemoryHotAddEnabled(): boolean;
		isMemoryReservationLockedToMax(): boolean;
		isMessageBusTunnelEnabled(): boolean;
		isNestedHVEnabled(): boolean;
		isNpivOnNonRdmDisks(): boolean;
		isNpivTemporaryDisabled(): boolean;
		isVAppConfigRemoved(): boolean;
		isVAssertsEnabled(): boolean;
		isVirtualICH7MPresent(): boolean;
		isVirtualSMCPresent(): boolean;
		isVPMCEnabled(): boolean;
	}

	declare class VcVirtualMachineLegacyNetworkSwitchInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String);
	}

	interface VcVirtualMachineMemoryAllocationPolicy
	{
		readonly id: String;
		readonly name: String;
		readonly swapMost: VcVirtualMachineMemoryAllocationPolicy;
		readonly swapNone: VcVirtualMachineMemoryAllocationPolicy;
		readonly swapSome: VcVirtualMachineMemoryAllocationPolicy;
		readonly value: String;

		fromString(value?: VcVirtualMachineMemoryAllocationPolicy): VcVirtualMachineMemoryAllocationPolicy;
	}

	declare const VcVirtualMachineMemoryAllocationPolicy: VcVirtualMachineMemoryAllocationPolicy;

	declare class VcVirtualMachineMemoryReservationInfo
	{
		allocationPolicy: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		virtualMachineMax: Number;
		virtualMachineMin: Number;
		virtualMachineReserved: Number;

		constructor();
		constructor(virtualMachineMin?: Number, virtualMachineMax?: Number, virtualMachineReserved?: Number, allocationPolicy?: String);
	}

	declare class VcVirtualMachineMemoryReservationSpec
	{
		allocationPolicy: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		virtualMachineReserved: Number;

		constructor();
		constructor(virtualMachineReserved?: Number, allocationPolicy?: String);
	}

	declare class VcVirtualMachineMessage
	{
		argument: Object[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		text: String;

		constructor();
		constructor(id?: String, argument?: Object[], text?: String);
	}

	interface VcVirtualMachineMetadataManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		clearMetadata(arg0?: VcVirtualMachineMetadataManagerVmMetadataOwner, arg1?: VcDatastore): VcVirtualMachineMetadataManagerVmMetadataResult[];
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		retrieveAllMetadata(arg0?: VcVirtualMachineMetadataManagerVmMetadataOwner, arg1?: VcDatastore): VcVirtualMachineMetadataManagerVmMetadataResult[];
		retrieveMetadata(arg0?: VcVirtualMachineMetadataManagerVmMetadataOwner, arg1?: String[]): VcVirtualMachineMetadataManagerVmMetadataResult[];
		updateMetadata(arg0?: VcVirtualMachineMetadataManagerVmMetadataOwner, arg1?: VcVirtualMachineMetadataManagerVmMetadataInput[]): VcVirtualMachineMetadataManagerVmMetadataResult[];
	}

	declare const VcVirtualMachineMetadataManager: VcVirtualMachineMetadataManager;

	declare class VcVirtualMachineMetadataManagerVmMetadata
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		metadata: String;
		vmId: String;

		constructor();
		constructor(vmId?: String, metadata?: String);
	}

	declare class VcVirtualMachineMetadataManagerVmMetadataInput
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operation: String;
		vmMetadata: VcVirtualMachineMetadataManagerVmMetadata;

		constructor();
		constructor(operation?: String, vmMetadata?: VcVirtualMachineMetadataManagerVmMetadata);
	}

	interface VcVirtualMachineMetadataManagerVmMetadataOp
	{
		readonly id: String;
		readonly name: String;
		readonly Remove: VcVirtualMachineMetadataManagerVmMetadataOp;
		readonly Update: VcVirtualMachineMetadataManagerVmMetadataOp;
		readonly value: String;

		fromString(value?: VcVirtualMachineMetadataManagerVmMetadataOp): VcVirtualMachineMetadataManagerVmMetadataOp;
	}

	declare const VcVirtualMachineMetadataManagerVmMetadataOp: VcVirtualMachineMetadataManagerVmMetadataOp;

	declare class VcVirtualMachineMetadataManagerVmMetadataOwner
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String);
	}

	interface VcVirtualMachineMetadataManagerVmMetadataOwnerOwner
	{
		readonly ComVmwareVsphereHA: VcVirtualMachineMetadataManagerVmMetadataOwnerOwner;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineMetadataManagerVmMetadataOwnerOwner): VcVirtualMachineMetadataManagerVmMetadataOwnerOwner;
	}

	declare const VcVirtualMachineMetadataManagerVmMetadataOwnerOwner: VcVirtualMachineMetadataManagerVmMetadataOwnerOwner;

	declare class VcVirtualMachineMetadataManagerVmMetadataResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault;
		vmMetadata: VcVirtualMachineMetadataManagerVmMetadata;

		constructor();
		constructor(vmMetadata?: VcVirtualMachineMetadataManagerVmMetadata, error?: VcLocalizedMethodFault);
	}

	declare class VcVirtualMachineMksTicket
	{
		cfgFile: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: String;
		port: Number;
		sslThumbprint: String;
		ticket: String;

		constructor();
		constructor(ticket?: String, cfgFile?: String, host?: String, port?: Number, sslThumbprint?: String);
	}

	interface VcVirtualMachineMovePriority
	{
		readonly defaultPriority: VcVirtualMachineMovePriority;
		readonly highPriority: VcVirtualMachineMovePriority;
		readonly id: String;
		readonly lowPriority: VcVirtualMachineMovePriority;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineMovePriority): VcVirtualMachineMovePriority;
	}

	declare const VcVirtualMachineMovePriority: VcVirtualMachineMovePriority;

	interface VcVirtualMachineNamespaceManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createNamespace(arg0?: VcVirtualMachine, arg1?: VcVirtualMachineNamespaceManagerCreateSpec): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteAllNamespaces(arg0?: VcVirtualMachine): void;
		deleteNamespace(arg0?: VcVirtualMachine, arg1?: String): void;
		fetchEventsFromGuest(arg0?: VcVirtualMachine, arg1?: String): VcVirtualMachineNamespaceManagerEventList;
		listNamespaces(arg0?: VcVirtualMachine): String[];
		queryNamespace(arg0?: VcVirtualMachine, arg1?: String): VcVirtualMachineNamespaceManagerNamespaceInfo;
		retrieveData(arg0?: VcVirtualMachine, arg1?: String, arg2?: String[], arg3?: String): VcVirtualMachineNamespaceManagerQueryResult;
		sendEventToGuest(arg0?: VcVirtualMachine, arg1?: String, arg2?: String): boolean;
		updateData(arg0?: VcVirtualMachine, arg1?: String, arg2?: VcVirtualMachineNamespaceManagerDataSpec[]): void;
		updateNamespace(arg0?: VcVirtualMachine, arg1?: VcVirtualMachineNamespaceManagerCreateSpec): void;
	}

	declare const VcVirtualMachineNamespaceManager: VcVirtualMachineNamespaceManager;

	declare class VcVirtualMachineNamespaceManagerAccessMode
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		guestWriteable: boolean;
		vmodlWriteable: boolean;

		constructor();
		constructor(guestWriteable?: boolean, vmodlWriteable?: boolean);
	}

	declare class VcVirtualMachineNamespaceManagerCreateSpec
	{
		accessMode: VcVirtualMachineNamespaceManagerAccessMode;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		maxSizeData: Number;
		maxSizeEventsFromGuest: Number;
		maxSizeEventsToGuest: Number;
		namespace: String;

		constructor();
		constructor(namespace?: String, maxSizeEventsToGuest?: Number, maxSizeEventsFromGuest?: Number, maxSizeData?: Number, accessMode?: VcVirtualMachineNamespaceManagerAccessMode);
	}

	declare class VcVirtualMachineNamespaceManagerDataInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		value: String;

		constructor();
		constructor(key?: String, value?: String);
	}

	declare class VcVirtualMachineNamespaceManagerDataSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		oldValue: String;
		opCode: VcVirtualMachineNamespaceManagerDataSpecOpCode;
		value: String;

		constructor();
		constructor(opCode?: VcVirtualMachineNamespaceManagerDataSpecOpCode, key?: String, value?: String, oldValue?: String);
	}

	interface VcVirtualMachineNamespaceManagerDataSpecOpCode
	{
		readonly id: String;
		readonly name: String;
		readonly updateAlways: VcVirtualMachineNamespaceManagerDataSpecOpCode;
		readonly updateIfEqual: VcVirtualMachineNamespaceManagerDataSpecOpCode;
		readonly value: String;

		fromString(value?: VcVirtualMachineNamespaceManagerDataSpecOpCode): VcVirtualMachineNamespaceManagerDataSpecOpCode;
	}

	declare const VcVirtualMachineNamespaceManagerDataSpecOpCode: VcVirtualMachineNamespaceManagerDataSpecOpCode;

	declare class VcVirtualMachineNamespaceManagerEventList
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		events: String[];
		eventsDropped: boolean;

		constructor();
		constructor(events?: String[], eventsDropped?: boolean);
	}

	declare class VcVirtualMachineNamespaceManagerNamespaceInfo
	{
		accessMode: VcVirtualMachineNamespaceManagerAccessMode;
		data: VcVirtualMachineNamespaceManagerNamespaceInfoNamespaceAllocation;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eventsFromGuest: VcVirtualMachineNamespaceManagerNamespaceInfoNamespaceAllocation;
		eventsToGuest: VcVirtualMachineNamespaceManagerNamespaceInfoNamespaceAllocation;
		namespace: String;

		constructor();
		constructor(namespace?: String, eventsToGuest?: VcVirtualMachineNamespaceManagerNamespaceInfoNamespaceAllocation, eventsFromGuest?: VcVirtualMachineNamespaceManagerNamespaceInfoNamespaceAllocation, data?: VcVirtualMachineNamespaceManagerNamespaceInfoNamespaceAllocation, accessMode?: VcVirtualMachineNamespaceManagerAccessMode);
	}

	declare class VcVirtualMachineNamespaceManagerNamespaceInfoNamespaceAllocation
	{
		allocated: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		limit: Number;

		constructor();
		constructor(limit?: Number, allocated?: Number);
	}

	declare class VcVirtualMachineNamespaceManagerQueryResult
	{
		dataInfo: VcVirtualMachineNamespaceManagerDataInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nextQuery: String;

		constructor();
		constructor(dataInfo?: VcVirtualMachineNamespaceManagerDataInfo[], nextQuery?: String);
	}

	interface VcVirtualMachineNeedSecondaryReason
	{
		readonly checkpointError: VcVirtualMachineNeedSecondaryReason;
		readonly divergence: VcVirtualMachineNeedSecondaryReason;
		readonly id: String;
		readonly initializing: VcVirtualMachineNeedSecondaryReason;
		readonly lostConnection: VcVirtualMachineNeedSecondaryReason;
		readonly name: String;
		readonly other: VcVirtualMachineNeedSecondaryReason;
		readonly partialHardwareFailure: VcVirtualMachineNeedSecondaryReason;
		readonly userAction: VcVirtualMachineNeedSecondaryReason;
		readonly value: String;

		fromString(value?: VcVirtualMachineNeedSecondaryReason): VcVirtualMachineNeedSecondaryReason;
	}

	declare const VcVirtualMachineNeedSecondaryReason: VcVirtualMachineNeedSecondaryReason;

	declare class VcVirtualMachineNetworkInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		network: VcNetworkSummary;
		vswitch: String;

		constructor();
		constructor(name?: String, configurationTag?: String[], network?: VcNetworkSummary, vswitch?: String);
	}

	declare class VcVirtualMachineNetworkShaperInfo
	{
		averageBps: Number;
		burstSize: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		peakBps: Number;

		constructor();
		constructor(enabled?: boolean, peakBps?: Number, averageBps?: Number, burstSize?: Number);
		isEnabled(): boolean;
	}

	declare class VcVirtualMachineParallelInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, configurationTag?: String[]);
	}

	interface VcVirtualMachinePauseManager
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		pause(arg0?: VcVirtualMachine): void;
		powerOnPaused_Task(arg0?: VcVirtualMachine, arg1?: VcHostSystem): VcTask;
		unpause(arg0?: VcVirtualMachine): void;
	}

	declare const VcVirtualMachinePauseManager: VcVirtualMachinePauseManager;

	declare class VcVirtualMachinePciPassthroughInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		pciDevice: VcHostPciDevice;
		systemId: String;

		constructor();
		constructor(name?: String, configurationTag?: String[], pciDevice?: VcHostPciDevice, systemId?: String);
	}

	declare class VcVirtualMachinePciSharedGpuPassthroughInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		vgpu: String;

		constructor();
		constructor(name?: String, configurationTag?: String[], vgpu?: String);
	}

	interface VcVirtualMachinePowerOffBehavior
	{
		readonly id: String;
		readonly name: String;
		readonly powerOff: VcVirtualMachinePowerOffBehavior;
		readonly prompt: VcVirtualMachinePowerOffBehavior;
		readonly revert: VcVirtualMachinePowerOffBehavior;
		readonly take: VcVirtualMachinePowerOffBehavior;
		readonly value: String;

		fromString(value?: VcVirtualMachinePowerOffBehavior): VcVirtualMachinePowerOffBehavior;
	}

	declare const VcVirtualMachinePowerOffBehavior: VcVirtualMachinePowerOffBehavior;

	interface VcVirtualMachinePowerOpType
	{
		readonly hard: VcVirtualMachinePowerOpType;
		readonly id: String;
		readonly name: String;
		readonly preset: VcVirtualMachinePowerOpType;
		readonly soft: VcVirtualMachinePowerOpType;
		readonly value: String;

		fromString(value?: VcVirtualMachinePowerOpType): VcVirtualMachinePowerOpType;
	}

	declare const VcVirtualMachinePowerOpType: VcVirtualMachinePowerOpType;

	declare class VcVirtualMachinePowerPolicy
	{
		acProfile: VcVirtualMachinePowerPolicyProfile;
		batteryProfile: VcVirtualMachinePowerPolicyProfile;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		powerMode: String;

		constructor();
		constructor(powerMode?: String, acProfile?: VcVirtualMachinePowerPolicyProfile, batteryProfile?: VcVirtualMachinePowerPolicyProfile);
	}

	interface VcVirtualMachinePowerPolicyCpuMode
	{
		readonly adaptiveProcessorThrottling: VcVirtualMachinePowerPolicyCpuMode;
		readonly constantProcessorThrottling: VcVirtualMachinePowerPolicyCpuMode;
		readonly degradedProcessorThrottling: VcVirtualMachinePowerPolicyCpuMode;
		readonly id: String;
		readonly name: String;
		readonly noProcessorThrottling: VcVirtualMachinePowerPolicyCpuMode;
		readonly value: String;

		fromString(value?: VcVirtualMachinePowerPolicyCpuMode): VcVirtualMachinePowerPolicyCpuMode;
	}

	declare const VcVirtualMachinePowerPolicyCpuMode: VcVirtualMachinePowerPolicyCpuMode;

	interface VcVirtualMachinePowerPolicyPowerMode
	{
		readonly acPower: VcVirtualMachinePowerPolicyPowerMode;
		readonly batteryPower: VcVirtualMachinePowerPolicyPowerMode;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachinePowerPolicyPowerMode): VcVirtualMachinePowerPolicyPowerMode;
	}

	declare const VcVirtualMachinePowerPolicyPowerMode: VcVirtualMachinePowerPolicyPowerMode;

	declare class VcVirtualMachinePowerPolicyProfile
	{
		cpuMode: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		forcedThrottle: Number;
		hardDiskTimeout: Number;
		hibernateTimeout: Number;
		maxProcessorState: Number;
		minProcessorState: Number;
		monitorTimeout: Number;
		suspendTimeout: Number;

		constructor();
		constructor(cpuMode?: String, monitorTimeout?: Number, hardDiskTimeout?: Number, hibernateTimeout?: Number, suspendTimeout?: Number, forcedThrottle?: Number, minProcessorState?: Number, maxProcessorState?: Number);
	}

	interface VcVirtualMachinePowerState
	{
		readonly id: String;
		readonly name: String;
		readonly poweredOff: VcVirtualMachinePowerState;
		readonly poweredOn: VcVirtualMachinePowerState;
		readonly suspended: VcVirtualMachinePowerState;
		readonly value: String;

		fromString(value?: VcVirtualMachinePowerState): VcVirtualMachinePowerState;
	}

	declare const VcVirtualMachinePowerState: VcVirtualMachinePowerState;

	declare class VcVirtualMachineProfileRawData
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extensionKey: String;
		objectData: String;

		constructor();
		constructor(extensionKey?: String, objectData?: String);
	}

	declare class VcVirtualMachineProfileSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	interface VcVirtualMachineProvisioningChecker
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		checkClone_Task(arg0?: VcVirtualMachine, arg1?: VcFolder, arg2?: String, arg3?: VcVirtualMachineCloneSpec, arg4?: String[]): VcTask;
		checkMigrate_Task(arg0?: VcVirtualMachine, arg1?: VcHostSystem, arg2?: VcResourcePool, arg3?: VcVirtualMachinePowerState, arg4?: String[]): VcTask;
		checkRelocate_Task(arg0?: VcVirtualMachine, arg1?: VcVirtualMachineRelocateSpec, arg2?: String[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryVMotionCompatibilityEx_Task(arg0?: VcVirtualMachine[], arg1?: VcHostSystem[]): VcTask;
	}

	declare const VcVirtualMachineProvisioningChecker: VcVirtualMachineProvisioningChecker;

	declare class VcVirtualMachineProvisioningPolicy
	{
		configPolicy: VcVirtualMachineProvisioningPolicyConfigPolicy[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filePolicy: VcVirtualMachineProvisioningPolicyFilePolicy[];

		constructor();
		constructor(configPolicy?: VcVirtualMachineProvisioningPolicyConfigPolicy[], filePolicy?: VcVirtualMachineProvisioningPolicyFilePolicy[]);
	}

	interface VcVirtualMachineProvisioningPolicyAction
	{
		readonly id: String;
		readonly keep: VcVirtualMachineProvisioningPolicyAction;
		readonly name: String;
		readonly remove: VcVirtualMachineProvisioningPolicyAction;
		readonly value: String;

		fromString(value?: VcVirtualMachineProvisioningPolicyAction): VcVirtualMachineProvisioningPolicyAction;
	}

	declare const VcVirtualMachineProvisioningPolicyAction: VcVirtualMachineProvisioningPolicyAction;

	declare class VcVirtualMachineProvisioningPolicyConfigPolicy
	{
		capabilitySupportRequired: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policy: VcVirtualMachineProvisioningPolicyPolicy[];
		specPropPath: String;
		specPropPathRegex: String;

		constructor();
		constructor(specPropPath?: String, specPropPathRegex?: String, capabilitySupportRequired?: String[], policy?: VcVirtualMachineProvisioningPolicyPolicy[]);
	}

	declare class VcVirtualMachineProvisioningPolicyFilePolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileType: String;
		policy: VcVirtualMachineProvisioningPolicyPolicy[];

		constructor();
		constructor(fileType?: String, policy?: VcVirtualMachineProvisioningPolicyPolicy[]);
	}

	interface VcVirtualMachineProvisioningPolicyOpType
	{
		readonly clone: VcVirtualMachineProvisioningPolicyOpType;
		readonly createForkChild: VcVirtualMachineProvisioningPolicyOpType;
		readonly createSecondary: VcVirtualMachineProvisioningPolicyOpType;
		readonly id: String;
		readonly migrate: VcVirtualMachineProvisioningPolicyOpType;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineProvisioningPolicyOpType): VcVirtualMachineProvisioningPolicyOpType;
	}

	declare const VcVirtualMachineProvisioningPolicyOpType: VcVirtualMachineProvisioningPolicyOpType;

	declare class VcVirtualMachineProvisioningPolicyPolicy
	{
		action: String;
		changeDatacenter: boolean;
		changeHost: boolean;
		changeStorage: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failOnError: boolean;
		opType: String;
		powerState: String;

		constructor();
		constructor(opType?: String, powerState?: String, changeHost?: boolean, changeStorage?: boolean, changeDatacenter?: boolean, action?: String, failOnError?: boolean);
		isChangeDatacenter(): boolean;
		isChangeHost(): boolean;
		isChangeStorage(): boolean;
		isFailOnError(): boolean;
	}

	declare class VcVirtualMachineQuestionInfo
	{
		choice: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		message: VcVirtualMachineMessage[];
		text: String;

		constructor();
		constructor(id?: String, text?: String, choice?: VcChoiceOption, message?: VcVirtualMachineMessage[]);
	}

	declare class VcVirtualMachineQuickStats
	{
		balloonedMemory: Number;
		compressedMemory: Number;
		consumedOverheadMemory: Number;
		distributedCpuEntitlement: Number;
		distributedMemoryEntitlement: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ftLatencyStatus: VcManagedEntityStatus;
		ftLogBandwidth: Number;
		ftSecondaryLatency: Number;
		guestHeartbeatStatus: VcManagedEntityStatus;
		guestMemoryUsage: Number;
		hostMemoryUsage: Number;
		overallCpuDemand: Number;
		overallCpuUsage: Number;
		privateMemory: Number;
		sharedMemory: Number;
		ssdSwappedMemory: Number;
		staticCpuEntitlement: Number;
		staticMemoryEntitlement: Number;
		swappedMemory: Number;
		uptimeSeconds: Number;

		constructor();
		constructor(overallCpuUsage?: Number, overallCpuDemand?: Number, guestMemoryUsage?: Number, hostMemoryUsage?: Number, guestHeartbeatStatus?: VcManagedEntityStatus, distributedCpuEntitlement?: Number, distributedMemoryEntitlement?: Number, staticCpuEntitlement?: Number, staticMemoryEntitlement?: Number, privateMemory?: Number, sharedMemory?: Number, swappedMemory?: Number, balloonedMemory?: Number, consumedOverheadMemory?: Number, ftLogBandwidth?: Number, ftSecondaryLatency?: Number, ftLatencyStatus?: VcManagedEntityStatus, compressedMemory?: Number, uptimeSeconds?: Number, ssdSwappedMemory?: Number);
	}

	interface VcVirtualMachineRecordReplayState
	{
		readonly id: String;
		readonly inactive: VcVirtualMachineRecordReplayState;
		readonly name: String;
		readonly recording: VcVirtualMachineRecordReplayState;
		readonly replaying: VcVirtualMachineRecordReplayState;
		readonly value: String;

		fromString(value?: VcVirtualMachineRecordReplayState): VcVirtualMachineRecordReplayState;
	}

	declare const VcVirtualMachineRecordReplayState: VcVirtualMachineRecordReplayState;

	interface VcVirtualMachineRelocateDiskMoveOptions
	{
		readonly createNewChildDiskBacking: VcVirtualMachineRelocateDiskMoveOptions;
		readonly id: String;
		readonly moveAllDiskBackingsAndAllowSharing: VcVirtualMachineRelocateDiskMoveOptions;
		readonly moveAllDiskBackingsAndConsolidate: VcVirtualMachineRelocateDiskMoveOptions;
		readonly moveAllDiskBackingsAndDisallowSharing: VcVirtualMachineRelocateDiskMoveOptions;
		readonly moveChildMostDiskBacking: VcVirtualMachineRelocateDiskMoveOptions;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineRelocateDiskMoveOptions): VcVirtualMachineRelocateDiskMoveOptions;
	}

	declare const VcVirtualMachineRelocateDiskMoveOptions: VcVirtualMachineRelocateDiskMoveOptions;

	declare class VcVirtualMachineRelocateSpec
	{
		datastore: VcDatastore;
		deviceChange: VcVirtualDeviceConfigSpec[];
		disk: VcVirtualMachineRelocateSpecDiskLocator[];
		diskMoveType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		folder: VcFolder;
		host: VcHostSystem;
		pool: VcResourcePool;
		profile: VcVirtualMachineProfileSpec[];
		service: VcServiceLocator;
		transform: VcVirtualMachineRelocateTransformation;

		constructor();
		constructor(service?: VcServiceLocator, folder?: VcFolder, datastore?: VcDatastore, diskMoveType?: String, pool?: VcResourcePool, host?: VcHostSystem, disk?: VcVirtualMachineRelocateSpecDiskLocator[], transform?: VcVirtualMachineRelocateTransformation, deviceChange?: VcVirtualDeviceConfigSpec[], profile?: VcVirtualMachineProfileSpec[]);
	}

	declare class VcVirtualMachineRelocateSpecDiskLocator
	{
		datastore: VcDatastore;
		diskBackingInfo: VcVirtualDeviceBackingInfo;
		diskId: Number;
		diskMoveType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(diskId?: Number, datastore?: VcDatastore, diskMoveType?: String, diskBackingInfo?: VcVirtualDeviceBackingInfo, profile?: VcVirtualMachineProfileSpec[]);
	}

	interface VcVirtualMachineRelocateTransformation
	{
		readonly flat: VcVirtualMachineRelocateTransformation;
		readonly id: String;
		readonly name: String;
		readonly sparse: VcVirtualMachineRelocateTransformation;
		readonly value: String;

		fromString(value?: VcVirtualMachineRelocateTransformation): VcVirtualMachineRelocateTransformation;
	}

	declare const VcVirtualMachineRelocateTransformation: VcVirtualMachineRelocateTransformation;

	declare class VcVirtualMachineRuntimeInfo
	{
		bootTime: Date;
		cleanPowerOff: boolean;
		connectionState: VcVirtualMachineConnectionState;
		consolidationNeeded: boolean;
		dasVmProtection: VcVirtualMachineRuntimeInfoDasProtectionState;
		device: VcVirtualMachineDeviceRuntimeInfo[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		faultToleranceState: VcVirtualMachineFaultToleranceState;
		featureMask: VcHostFeatureMask[];
		featureRequirement: VcVirtualMachineFeatureRequirement[];
		host: VcHostSystem;
		maxCpuUsage: Number;
		maxMemoryUsage: Number;
		memoryOverhead: Number;
		minRequiredEVCModeKey: String;
		needSecondaryReason: String;
		numMksConnections: Number;
		offlineFeatureRequirement: VcVirtualMachineFeatureRequirement[];
		onlineStandby: boolean;
		paused: boolean;
		powerState: VcVirtualMachinePowerState;
		question: VcVirtualMachineQuestionInfo;
		quiescedForkParent: boolean;
		recordReplayState: VcVirtualMachineRecordReplayState;
		snapshotInBackground: boolean;
		suspendInterval: Number;
		suspendTime: Date;
		toolsInstallerMounted: boolean;
		vFlashCacheAllocation: Number;

		constructor();
		constructor(device?: VcVirtualMachineDeviceRuntimeInfo[], host?: VcHostSystem, connectionState?: VcVirtualMachineConnectionState, powerState?: VcVirtualMachinePowerState, faultToleranceState?: VcVirtualMachineFaultToleranceState, dasVmProtection?: VcVirtualMachineRuntimeInfoDasProtectionState, toolsInstallerMounted?: boolean, suspendTime?: Date, bootTime?: Date, suspendInterval?: Number, question?: VcVirtualMachineQuestionInfo, memoryOverhead?: Number, maxCpuUsage?: Number, maxMemoryUsage?: Number, numMksConnections?: Number, recordReplayState?: VcVirtualMachineRecordReplayState, cleanPowerOff?: boolean, needSecondaryReason?: String, onlineStandby?: boolean, minRequiredEVCModeKey?: String, consolidationNeeded?: boolean, offlineFeatureRequirement?: VcVirtualMachineFeatureRequirement[], featureRequirement?: VcVirtualMachineFeatureRequirement[], featureMask?: VcHostFeatureMask[], vFlashCacheAllocation?: Number, paused?: boolean, snapshotInBackground?: boolean, quiescedForkParent?: boolean);
		isCleanPowerOff(): boolean;
		isConsolidationNeeded(): boolean;
		isOnlineStandby(): boolean;
		isPaused(): boolean;
		isQuiescedForkParent(): boolean;
		isSnapshotInBackground(): boolean;
	}

	declare class VcVirtualMachineRuntimeInfoDasProtectionState
	{
		dasProtected: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(dasProtected?: boolean);
	}

	declare class VcVirtualMachineScsiDiskDeviceInfo
	{
		capacity: Number;
		configurationTag: String[];
		disk: VcHostScsiDisk;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lunNumber: Number;
		name: String;
		transportHint: String;
		vm: VcVirtualMachine[];

		constructor();
		constructor(name?: String, configurationTag?: String[], capacity?: Number, vm?: VcVirtualMachine[], disk?: VcHostScsiDisk, transportHint?: String, lunNumber?: Number);
	}

	declare class VcVirtualMachineScsiPassthroughInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		physicalUnitNumber: Number;
		scsiClass: String;
		vendor: String;

		constructor();
		constructor(name?: String, configurationTag?: String[], scsiClass?: String, vendor?: String, physicalUnitNumber?: Number);
	}

	interface VcVirtualMachineScsiPassthroughType
	{
		readonly cdrom: VcVirtualMachineScsiPassthroughType;
		readonly com: VcVirtualMachineScsiPassthroughType;
		readonly disk: VcVirtualMachineScsiPassthroughType;
		readonly id: String;
		readonly media: VcVirtualMachineScsiPassthroughType;
		readonly name: String;
		readonly optical: VcVirtualMachineScsiPassthroughType;
		readonly printer: VcVirtualMachineScsiPassthroughType;
		readonly processor: VcVirtualMachineScsiPassthroughType;
		readonly raid: VcVirtualMachineScsiPassthroughType;
		readonly scanner: VcVirtualMachineScsiPassthroughType;
		readonly tape: VcVirtualMachineScsiPassthroughType;
		readonly unknown: VcVirtualMachineScsiPassthroughType;
		readonly value: String;
		readonly worm: VcVirtualMachineScsiPassthroughType;

		fromString(value?: VcVirtualMachineScsiPassthroughType): VcVirtualMachineScsiPassthroughType;
	}

	declare const VcVirtualMachineScsiPassthroughType: VcVirtualMachineScsiPassthroughType;

	declare class VcVirtualMachineSerialInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, configurationTag?: String[]);
	}

	interface VcVirtualMachineSnapshot
	{
		readonly availableField: VcCustomFieldDef[];
		childSnapshot: VcVirtualMachineSnapshot[];
		config: VcVirtualMachineConfigInfo;
		description: String;
		id: String;
		moref: VcManagedObjectReference;
		name: String;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;
		virtualMachineName: String;
		vm: VcVirtualMachine;

		_getRef(): VcManagedObjectReference;
		createLinkedClone_Task(arg0?: String, arg1?: String, arg2?: boolean): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		exportSnapshot(): VcHttpNfcLease;
		removeSnapshot_Task(arg0?: boolean, arg1?: boolean): VcTask;
		renameSnapshot(arg0?: String, arg1?: String): void;
		revertToSnapshot_Task(arg0?: VcHostSystem, arg1?: boolean): VcTask;
		setCustomValue(arg0?: String, arg1?: String): void;
	}

	declare const VcVirtualMachineSnapshot: VcVirtualMachineSnapshot;

	declare class VcVirtualMachineSnapshotInfo
	{
		currentSnapshot: VcVirtualMachineSnapshot;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		rootSnapshotList: VcVirtualMachineSnapshotTree[];

		constructor();
		constructor(currentSnapshot?: VcVirtualMachineSnapshot, rootSnapshotList?: VcVirtualMachineSnapshotTree[]);
	}

	declare class VcVirtualMachineSnapshotTree
	{
		backupManifest: String;
		childSnapshotList: VcVirtualMachineSnapshotTree[];
		createTime: Date;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: Number;
		name: String;
		quiesced: boolean;
		replaySupported: boolean;
		snapshot: VcVirtualMachineSnapshot;
		state: VcVirtualMachinePowerState;
		vm: VcVirtualMachine;

		constructor();
		constructor(snapshot?: VcVirtualMachineSnapshot, vm?: VcVirtualMachine, name?: String, description?: String, id?: Number, createTime?: Date, state?: VcVirtualMachinePowerState, quiesced?: boolean, backupManifest?: String, childSnapshotList?: VcVirtualMachineSnapshotTree[], replaySupported?: boolean);
		isReplaySupported(): boolean;
	}

	declare class VcVirtualMachineSoundInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, configurationTag?: String[]);
	}

	declare class VcVirtualMachineSriovDevicePoolInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;

		constructor(key?: String);
		constructor();
	}

	declare class VcVirtualMachineSriovInfo
	{
		configurationTag: String[];
		devicePool: VcVirtualMachineSriovDevicePoolInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		pciDevice: VcHostPciDevice;
		pnic: String;
		systemId: String;
		virtualFunction: boolean;

		constructor();
		constructor(name?: String, configurationTag?: String[], pciDevice?: VcHostPciDevice, systemId?: String, virtualFunction?: boolean, pnic?: String, devicePool?: VcVirtualMachineSriovDevicePoolInfo);
	}

	declare class VcVirtualMachineSriovNetworkDevicePoolInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		switchKey: String;
		switchUuid: String;

		constructor();
		constructor(key?: String, switchKey?: String, switchUuid?: String);
	}

	interface VcVirtualMachineStandbyActionType
	{
		readonly checkpoint: VcVirtualMachineStandbyActionType;
		readonly id: String;
		readonly name: String;
		readonly powerOnSuspend: VcVirtualMachineStandbyActionType;
		readonly value: String;

		fromString(value?: VcVirtualMachineStandbyActionType): VcVirtualMachineStandbyActionType;
	}

	declare const VcVirtualMachineStandbyActionType: VcVirtualMachineStandbyActionType;

	declare class VcVirtualMachineStorageInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		perDatastoreUsage: VcVirtualMachineUsageOnDatastore[];
		timestamp: Date;

		constructor();
		constructor(perDatastoreUsage?: VcVirtualMachineUsageOnDatastore[], timestamp?: Date);
	}

	declare class VcVirtualMachineStorageSummary
	{
		committed: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		timestamp: Date;
		uncommitted: Number;
		unshared: Number;

		constructor();
		constructor(committed?: Number, uncommitted?: Number, unshared?: Number, timestamp?: Date);
	}

	declare class VcVirtualMachineSummary
	{
		config: VcVirtualMachineConfigSummary;
		customValue: VcCustomFieldValue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		guest: VcVirtualMachineGuestSummary;
		overallStatus: VcManagedEntityStatus;
		quickStats: VcVirtualMachineQuickStats;
		runtime: VcVirtualMachineRuntimeInfo;
		storage: VcVirtualMachineStorageSummary;
		vm: VcVirtualMachine;

		constructor();
		constructor(vm?: VcVirtualMachine, runtime?: VcVirtualMachineRuntimeInfo, guest?: VcVirtualMachineGuestSummary, config?: VcVirtualMachineConfigSummary, storage?: VcVirtualMachineStorageSummary, quickStats?: VcVirtualMachineQuickStats, overallStatus?: VcManagedEntityStatus, customValue?: VcCustomFieldValue[]);
	}

	declare class VcVirtualMachineTargetInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String, configurationTag?: String[]);
	}

	interface VcVirtualMachineTargetInfoConfigurationTag
	{
		readonly clusterWide: VcVirtualMachineTargetInfoConfigurationTag;
		readonly compliant: VcVirtualMachineTargetInfoConfigurationTag;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineTargetInfoConfigurationTag): VcVirtualMachineTargetInfoConfigurationTag;
	}

	declare const VcVirtualMachineTargetInfoConfigurationTag: VcVirtualMachineTargetInfoConfigurationTag;

	declare class VcVirtualMachineTicket
	{
		cfgFile: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: String;
		port: Number;
		sslThumbprint: String;
		ticket: String;
		url: String;

		constructor();
		constructor(ticket?: String, cfgFile?: String, host?: String, port?: Number, sslThumbprint?: String, url?: String);
	}

	interface VcVirtualMachineTicketType
	{
		readonly device: VcVirtualMachineTicketType;
		readonly dnd: VcVirtualMachineTicketType;
		readonly guestControl: VcVirtualMachineTicketType;
		readonly guestIntegrity: VcVirtualMachineTicketType;
		readonly id: String;
		readonly mks: VcVirtualMachineTicketType;
		readonly name: String;
		readonly value: String;
		readonly webmks: VcVirtualMachineTicketType;

		fromString(value?: VcVirtualMachineTicketType): VcVirtualMachineTicketType;
	}

	declare const VcVirtualMachineTicketType: VcVirtualMachineTicketType;

	interface VcVirtualMachineToolsInstallType
	{
		readonly guestToolsTypeMSI: VcVirtualMachineToolsInstallType;
		readonly guestToolsTypeOpenVMTools: VcVirtualMachineToolsInstallType;
		readonly guestToolsTypeOSP: VcVirtualMachineToolsInstallType;
		readonly guestToolsTypeTar: VcVirtualMachineToolsInstallType;
		readonly guestToolsTypeUnknown: VcVirtualMachineToolsInstallType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineToolsInstallType): VcVirtualMachineToolsInstallType;
	}

	declare const VcVirtualMachineToolsInstallType: VcVirtualMachineToolsInstallType;

	interface VcVirtualMachineToolsRunningStatus
	{
		readonly guestToolsExecutingScripts: VcVirtualMachineToolsRunningStatus;
		readonly guestToolsNotRunning: VcVirtualMachineToolsRunningStatus;
		readonly guestToolsRunning: VcVirtualMachineToolsRunningStatus;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineToolsRunningStatus): VcVirtualMachineToolsRunningStatus;
	}

	declare const VcVirtualMachineToolsRunningStatus: VcVirtualMachineToolsRunningStatus;

	interface VcVirtualMachineToolsStatus
	{
		readonly id: String;
		readonly name: String;
		readonly toolsNotInstalled: VcVirtualMachineToolsStatus;
		readonly toolsNotRunning: VcVirtualMachineToolsStatus;
		readonly toolsOk: VcVirtualMachineToolsStatus;
		readonly toolsOld: VcVirtualMachineToolsStatus;
		readonly value: String;

		fromString(value?: VcVirtualMachineToolsStatus): VcVirtualMachineToolsStatus;
	}

	declare const VcVirtualMachineToolsStatus: VcVirtualMachineToolsStatus;

	declare class VcVirtualMachineToolsUpdateStatus
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		updateRequireReboot: boolean;
		updateRequireRebootComponent: String[];

		constructor();
		constructor(updateRequireReboot?: boolean, updateRequireRebootComponent?: String[]);
		isUpdateRequireReboot(): boolean;
	}

	interface VcVirtualMachineToolsVersionStatus
	{
		readonly guestToolsBlacklisted: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsCurrent: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsNeedUpgrade: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsNotInstalled: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsSupportedNew: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsSupportedOld: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsTooNew: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsTooOld: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsUnmanaged: VcVirtualMachineToolsVersionStatus;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineToolsVersionStatus): VcVirtualMachineToolsVersionStatus;
	}

	declare const VcVirtualMachineToolsVersionStatus: VcVirtualMachineToolsVersionStatus;

	declare class VcVirtualMachineUsageOnDatastore
	{
		committed: Number;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		uncommitted: Number;
		unshared: Number;

		constructor();
		constructor(datastore?: VcDatastore, committed?: Number, uncommitted?: Number, unshared?: Number);
	}

	declare class VcVirtualMachineUsbInfo
	{
		configurationTag: String[];
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		family: String[];
		name: String;
		physicalPath: String;
		product: Number;
		speed: String[];
		summary: VcVirtualMachineSummary;
		vendor: Number;

		constructor();
		constructor(name?: String, configurationTag?: String[], description?: String, vendor?: Number, product?: Number, physicalPath?: String, family?: String[], speed?: String[], summary?: VcVirtualMachineSummary);
	}

	interface VcVirtualMachineUsbInfoFamily
	{
		readonly audio: VcVirtualMachineUsbInfoFamily;
		readonly bluetooth: VcVirtualMachineUsbInfoFamily;
		readonly communication: VcVirtualMachineUsbInfoFamily;
		readonly hid: VcVirtualMachineUsbInfoFamily;
		readonly hid_bootable: VcVirtualMachineUsbInfoFamily;
		readonly hub: VcVirtualMachineUsbInfoFamily;
		readonly id: String;
		readonly imaging: VcVirtualMachineUsbInfoFamily;
		readonly name: String;
		readonly other: VcVirtualMachineUsbInfoFamily;
		readonly pda: VcVirtualMachineUsbInfoFamily;
		readonly physical: VcVirtualMachineUsbInfoFamily;
		readonly printer: VcVirtualMachineUsbInfoFamily;
		readonly security: VcVirtualMachineUsbInfoFamily;
		readonly smart_card: VcVirtualMachineUsbInfoFamily;
		readonly storage: VcVirtualMachineUsbInfoFamily;
		readonly unknownFamily: VcVirtualMachineUsbInfoFamily;
		readonly value: String;
		readonly vendor_specific: VcVirtualMachineUsbInfoFamily;
		readonly video: VcVirtualMachineUsbInfoFamily;
		readonly wireless: VcVirtualMachineUsbInfoFamily;
		readonly wusb: VcVirtualMachineUsbInfoFamily;

		fromString(value?: VcVirtualMachineUsbInfoFamily): VcVirtualMachineUsbInfoFamily;
	}

	declare const VcVirtualMachineUsbInfoFamily: VcVirtualMachineUsbInfoFamily;

	interface VcVirtualMachineUsbInfoSpeed
	{
		readonly full: VcVirtualMachineUsbInfoSpeed;
		readonly high: VcVirtualMachineUsbInfoSpeed;
		readonly id: String;
		readonly low: VcVirtualMachineUsbInfoSpeed;
		readonly name: String;
		readonly superSpeed: VcVirtualMachineUsbInfoSpeed;
		readonly unknownSpeed: VcVirtualMachineUsbInfoSpeed;
		readonly value: String;

		fromString(value?: VcVirtualMachineUsbInfoSpeed): VcVirtualMachineUsbInfoSpeed;
	}

	declare const VcVirtualMachineUsbInfoSpeed: VcVirtualMachineUsbInfoSpeed;

	declare class VcVirtualMachineVFlashModuleInfo
	{
		configurationTag: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		vFlashModule: VcHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;

		constructor();
		constructor(name?: String, configurationTag?: String[], vFlashModule?: VcHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption);
	}

	declare class VcVirtualMachineVideoCard
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enable3DSupport: boolean;
		enableMPTSupport: boolean;
		graphicsMemorySizeInKB: Number;
		key: Number;
		numDisplays: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		use3dRenderer: String;
		useAutoDetect: boolean;
		videoRamSizeInKB: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, videoRamSizeInKB?: Number, numDisplays?: Number, useAutoDetect?: boolean, enable3DSupport?: boolean, enableMPTSupport?: boolean, use3dRenderer?: String, graphicsMemorySizeInKB?: Number);
		isEnable3DSupport(): boolean;
		isEnableMPTSupport(): boolean;
		isUseAutoDetect(): boolean;
	}

	interface VcVirtualMachineVideoCardUse3dRenderer
	{
		readonly automatic: VcVirtualMachineVideoCardUse3dRenderer;
		readonly hardware: VcVirtualMachineVideoCardUse3dRenderer;
		readonly id: String;
		readonly name: String;
		readonly software: VcVirtualMachineVideoCardUse3dRenderer;
		readonly value: String;

		fromString(value?: VcVirtualMachineVideoCardUse3dRenderer): VcVirtualMachineVideoCardUse3dRenderer;
	}

	declare const VcVirtualMachineVideoCardUse3dRenderer: VcVirtualMachineVideoCardUse3dRenderer;

	declare class VcVirtualMachineVMCIDevice
	{
		allowUnrestrictedCommunication: boolean;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filterEnable: boolean;
		filterInfo: VcVirtualMachineVMCIDeviceFilterInfo;
		id: Number;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, id?: Number, allowUnrestrictedCommunication?: boolean, filterEnable?: boolean, filterInfo?: VcVirtualMachineVMCIDeviceFilterInfo);
		isAllowUnrestrictedCommunication(): boolean;
		isFilterEnable(): boolean;
	}

	interface VcVirtualMachineVMCIDeviceAction
	{
		readonly allow: VcVirtualMachineVMCIDeviceAction;
		readonly deny: VcVirtualMachineVMCIDeviceAction;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineVMCIDeviceAction): VcVirtualMachineVMCIDeviceAction;
	}

	declare const VcVirtualMachineVMCIDeviceAction: VcVirtualMachineVMCIDeviceAction;

	interface VcVirtualMachineVMCIDeviceDirection
	{
		readonly anyDirection: VcVirtualMachineVMCIDeviceDirection;
		readonly guest: VcVirtualMachineVMCIDeviceDirection;
		readonly host: VcVirtualMachineVMCIDeviceDirection;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineVMCIDeviceDirection): VcVirtualMachineVMCIDeviceDirection;
	}

	declare const VcVirtualMachineVMCIDeviceDirection: VcVirtualMachineVMCIDeviceDirection;

	declare class VcVirtualMachineVMCIDeviceFilterInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filters: VcVirtualMachineVMCIDeviceFilterSpec[];

		constructor();
		constructor(filters?: VcVirtualMachineVMCIDeviceFilterSpec[]);
	}

	declare class VcVirtualMachineVMCIDeviceFilterSpec
	{
		action: String;
		direction: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lowerDstPortBoundary: Number;
		protocol: String;
		rank: Number;
		upperDstPortBoundary: Number;

		constructor();
		constructor(rank?: Number, action?: String, protocol?: String, direction?: String, lowerDstPortBoundary?: Number, upperDstPortBoundary?: Number);
	}

	declare class VcVirtualMachineVMCIDeviceOption
	{
		allowUnrestrictedCommunication: VcBoolOption;
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filterSpecOption: VcVirtualMachineVMCIDeviceOptionFilterSpecOption;
		filterSupported: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, allowUnrestrictedCommunication?: VcBoolOption, filterSpecOption?: VcVirtualMachineVMCIDeviceOptionFilterSpecOption, filterSupported?: VcBoolOption);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualMachineVMCIDeviceOptionFilterSpecOption
	{
		action: VcChoiceOption;
		direction: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lowerDstPortBoundary: VcLongOption;
		protocol: VcChoiceOption;
		upperDstPortBoundary: VcLongOption;

		constructor();
		constructor(action?: VcChoiceOption, protocol?: VcChoiceOption, direction?: VcChoiceOption, lowerDstPortBoundary?: VcLongOption, upperDstPortBoundary?: VcLongOption);
	}

	interface VcVirtualMachineVMCIDeviceProtocol
	{
		readonly anyProtocol: VcVirtualMachineVMCIDeviceProtocol;
		readonly datagram: VcVirtualMachineVMCIDeviceProtocol;
		readonly doorbell: VcVirtualMachineVMCIDeviceProtocol;
		readonly hypervisor: VcVirtualMachineVMCIDeviceProtocol;
		readonly id: String;
		readonly name: String;
		readonly queuepair: VcVirtualMachineVMCIDeviceProtocol;
		readonly stream: VcVirtualMachineVMCIDeviceProtocol;
		readonly value: String;

		fromString(value?: VcVirtualMachineVMCIDeviceProtocol): VcVirtualMachineVMCIDeviceProtocol;
	}

	declare const VcVirtualMachineVMCIDeviceProtocol: VcVirtualMachineVMCIDeviceProtocol;

	declare class VcVirtualMachineVMIROM
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualMachineWindowsQuiesceSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		timeout: Number;
		vssBackupContext: String;
		vssBackupType: Number;
		vssBootableSystemState: boolean;
		vssPartialFileSupport: boolean;

		constructor();
		constructor(timeout?: Number, vssBackupType?: Number, vssBootableSystemState?: boolean, vssPartialFileSupport?: boolean, vssBackupContext?: String);
		isVssBootableSystemState(): boolean;
		isVssPartialFileSupport(): boolean;
	}

	interface VcVirtualMachineWindowsQuiesceSpecVssBackupContext
	{
		readonly ctx_auto: VcVirtualMachineWindowsQuiesceSpecVssBackupContext;
		readonly ctx_backup: VcVirtualMachineWindowsQuiesceSpecVssBackupContext;
		readonly ctx_file_share_backup: VcVirtualMachineWindowsQuiesceSpecVssBackupContext;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVirtualMachineWindowsQuiesceSpecVssBackupContext): VcVirtualMachineWindowsQuiesceSpecVssBackupContext;
	}

	declare const VcVirtualMachineWindowsQuiesceSpecVssBackupContext: VcVirtualMachineWindowsQuiesceSpecVssBackupContext;

	declare class VcVirtualMachineWipeResult
	{
		diskId: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		shrinkableDiskSpace: Number;

		constructor();
		constructor(diskId?: Number, shrinkableDiskSpace?: Number);
	}

	declare class VcVirtualNicManagerNetConfig
	{
		candidateVnic: VcHostVirtualNic[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		multiSelectAllowed: boolean;
		nicType: String;
		selectedVnic: String[];

		constructor();
		constructor(nicType?: String, multiSelectAllowed?: boolean, candidateVnic?: VcHostVirtualNic[], selectedVnic?: String[]);
	}

	declare class VcVirtualNVDIMM
	{
		backing: VcVirtualDeviceBackingInfo;
		capacityInMB: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, capacityInMB?: Number);
	}

	declare class VcVirtualNVDIMMBackingInfo
	{
		backingObjectId: String;
		changeId: String;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;
		parent: VcVirtualNVDIMMBackingInfo;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String, parent?: VcVirtualNVDIMMBackingInfo, changeId?: String);
	}

	declare class VcVirtualNVDIMMController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[]);
	}

	declare class VcVirtualNVDIMMControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numNVDIMMControllers: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numNVDIMMControllers?: VcIntOption);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualNVDIMMOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		capacityInMB: VcLongOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		granularityInMB: Number;
		growable: boolean;
		hotGrowable: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, capacityInMB?: VcLongOption, growable?: boolean, hotGrowable?: boolean, granularityInMB?: Number);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualNVMEController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[]);
	}

	declare class VcVirtualNVMEControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numNVMEDisks: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numNVMEDisks?: VcIntOption);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualParallelPort
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualParallelPortDeviceBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualParallelPortDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualParallelPortFileBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String);
	}

	declare class VcVirtualParallelPortFileBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileNameExtensions: VcChoiceOption;
		type: String;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption);
	}

	declare class VcVirtualParallelPortOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualPCIController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[]);
	}

	declare class VcVirtualPCIControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numEthernetCards: VcIntOption;
		numNVMEControllers: VcIntOption;
		numParaVirtualSCSIControllers: VcIntOption;
		numPCIPassthroughDevices: VcIntOption;
		numSasSCSIControllers: VcIntOption;
		numSATAControllers: VcIntOption;
		numSCSIControllers: VcIntOption;
		numSoundCards: VcIntOption;
		numVideoCards: VcIntOption;
		numVmciDevices: VcIntOption;
		numVmiRoms: VcIntOption;
		numVmxnet3EthernetCards: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numSCSIControllers?: VcIntOption, numEthernetCards?: VcIntOption, numVideoCards?: VcIntOption, numSoundCards?: VcIntOption, numVmiRoms?: VcIntOption, numVmciDevices?: VcIntOption, numPCIPassthroughDevices?: VcIntOption, numSasSCSIControllers?: VcIntOption, numVmxnet3EthernetCards?: VcIntOption, numParaVirtualSCSIControllers?: VcIntOption, numSATAControllers?: VcIntOption, numNVMEControllers?: VcIntOption);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualPCIPassthrough
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualPCIPassthroughDeviceBackingInfo
	{
		deviceId: String;
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: String;
		systemId: String;
		useAutoDetect: boolean;
		vendorId: Number;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean, id?: String, deviceId?: String, systemId?: String, vendorId?: Number);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualPCIPassthroughDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualPCIPassthroughOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualPCIPassthroughPluginBackingInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVirtualPCIPassthroughPluginBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String);
	}

	declare class VcVirtualPCIPassthroughVmiopBackingInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vgpu: String;

		constructor();
		constructor(vgpu?: String);
	}

	declare class VcVirtualPCIPassthroughVmiopBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		maxInstances: Number;
		type: String;
		vgpu: VcStringOption;

		constructor();
		constructor(type?: String, vgpu?: VcStringOption, maxInstances?: Number);
	}

	declare class VcVirtualPCNet32
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, addressType?: String, macAddress?: String, wakeOnLanEnabled?: boolean, resourceAllocation?: VcVirtualEthernetCardResourceAllocation, externalId?: String, uptCompatibilityEnabled?: boolean);
		isUptCompatibilityEnabled(): boolean;
		isWakeOnLanEnabled(): boolean;
	}

	declare class VcVirtualPCNet32Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		supportsMorphing: boolean;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, supportedOUI?: VcChoiceOption, macType?: VcChoiceOption, wakeOnLanEnabled?: VcBoolOption, vmDirectPathGen2Supported?: boolean, uptCompatibilityEnabled?: VcBoolOption, supportsMorphing?: boolean);
		isHotRemoveSupported(): boolean;
		isVmDirectPathGen2Supported(): boolean;
	}

	declare class VcVirtualPointingDevice
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualPointingDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostPointingDevice: VcChoiceOption;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption, hostPointingDevice?: VcChoiceOption);
	}

	declare class VcVirtualPointingDeviceDeviceBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostPointingDevice: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean, hostPointingDevice?: String);
		isUseAutoDetect(): boolean;
	}

	interface VcVirtualPointingDeviceHostChoice
	{
		readonly autodetect: VcVirtualPointingDeviceHostChoice;
		readonly id: String;
		readonly intellimouseExplorer: VcVirtualPointingDeviceHostChoice;
		readonly intellimousePs2: VcVirtualPointingDeviceHostChoice;
		readonly logitechMouseman: VcVirtualPointingDeviceHostChoice;
		readonly microsoft_serial: VcVirtualPointingDeviceHostChoice;
		readonly mousemanSerial: VcVirtualPointingDeviceHostChoice;
		readonly mouseSystems: VcVirtualPointingDeviceHostChoice;
		readonly name: String;
		readonly ps2: VcVirtualPointingDeviceHostChoice;
		readonly value: String;

		fromString(value?: VcVirtualPointingDeviceHostChoice): VcVirtualPointingDeviceHostChoice;
	}

	declare const VcVirtualPointingDeviceHostChoice: VcVirtualPointingDeviceHostChoice;

	declare class VcVirtualPointingDeviceOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualPS2Controller
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[]);
	}

	declare class VcVirtualPS2ControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numKeyboards: VcIntOption;
		numPointingDevices: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numKeyboards?: VcIntOption, numPointingDevices?: VcIntOption);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualResourcePoolSpec
	{
		changeVersion: Number;
		cpuAllocation: VcVrpResourceAllocationInfo;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hubList: VcManagedEntity[];
		memoryAllocation: VcVrpResourceAllocationInfo;
		rootVRP: boolean;
		rpList: VcManagedEntity[];
		staticVRP: boolean;
		vrpId: String;
		vrpName: String;

		constructor();
		constructor(vrpId?: String, vrpName?: String, description?: String, cpuAllocation?: VcVrpResourceAllocationInfo, memoryAllocation?: VcVrpResourceAllocationInfo, rpList?: VcManagedEntity[], hubList?: VcManagedEntity[], rootVRP?: boolean, staticVRP?: boolean, changeVersion?: Number);
		isRootVRP(): boolean;
		isStaticVRP(): boolean;
	}

	declare class VcVirtualResourcePoolUsage
	{
		cpuReservationMhz: Number;
		cpuReservationUsedMhz: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memReservationMB: Number;
		memReservationUsedMB: Number;
		vrpId: String;

		constructor();
		constructor(vrpId?: String, cpuReservationMhz?: Number, memReservationMB?: Number, cpuReservationUsedMhz?: Number, memReservationUsedMB?: Number);
	}

	declare class VcVirtualSATAController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[]);
	}

	declare class VcVirtualSATAControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSATACdroms: VcIntOption;
		numSATADisks: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numSATADisks?: VcIntOption, numSATACdroms?: VcIntOption);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualSCSIController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotAddRemove: boolean;
		key: Number;
		scsiCtlrUnitNumber: Number;
		sharedBus: VcVirtualSCSISharing;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[], hotAddRemove?: boolean, sharedBus?: VcVirtualSCSISharing, scsiCtlrUnitNumber?: Number);
		isHotAddRemove(): boolean;
	}

	declare class VcVirtualSCSIControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		defaultSharedIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotAddRemove: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSCSICdroms: VcIntOption;
		numSCSIDisks: VcIntOption;
		numSCSIPassthrough: VcIntOption;
		plugAndPlay: boolean;
		scsiCtlrUnitNumber: Number;
		sharing: VcVirtualSCSISharing[];
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numSCSIDisks?: VcIntOption, numSCSICdroms?: VcIntOption, numSCSIPassthrough?: VcIntOption, sharing?: VcVirtualSCSISharing[], defaultSharedIndex?: Number, hotAddRemove?: VcBoolOption, scsiCtlrUnitNumber?: Number);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualSCSIPassthrough
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualSCSIPassthroughDeviceBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualSCSIPassthroughDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualSCSIPassthroughOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	interface VcVirtualSCSISharing
	{
		readonly id: String;
		readonly name: String;
		readonly noSharing: VcVirtualSCSISharing;
		readonly physicalSharing: VcVirtualSCSISharing;
		readonly value: String;
		readonly virtualSharing: VcVirtualSCSISharing;

		fromString(value?: VcVirtualSCSISharing): VcVirtualSCSISharing;
	}

	declare const VcVirtualSCSISharing: VcVirtualSCSISharing;

	declare class VcVirtualSerialPort
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		yieldOnPoll: boolean;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, yieldOnPoll?: boolean);
	}

	declare class VcVirtualSerialPortDeviceBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualSerialPortDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	interface VcVirtualSerialPortEndPoint
	{
		readonly client: VcVirtualSerialPortEndPoint;
		readonly id: String;
		readonly name: String;
		readonly server: VcVirtualSerialPortEndPoint;
		readonly value: String;

		fromString(value?: VcVirtualSerialPortEndPoint): VcVirtualSerialPortEndPoint;
	}

	declare const VcVirtualSerialPortEndPoint: VcVirtualSerialPortEndPoint;

	declare class VcVirtualSerialPortFileBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileName: String;

		constructor();
		constructor(fileName?: String, datastore?: VcDatastore, backingObjectId?: String);
	}

	declare class VcVirtualSerialPortFileBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileNameExtensions: VcChoiceOption;
		type: String;

		constructor();
		constructor(type?: String, fileNameExtensions?: VcChoiceOption);
	}

	declare class VcVirtualSerialPortOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;
		yieldOnPoll: VcBoolOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, yieldOnPoll?: VcBoolOption);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualSerialPortPipeBackingInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endpoint: String;
		noRxLoss: boolean;
		pipeName: String;

		constructor();
		constructor(pipeName?: String, endpoint?: String, noRxLoss?: boolean);
		isNoRxLoss(): boolean;
	}

	declare class VcVirtualSerialPortPipeBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		endpoint: VcChoiceOption;
		noRxLoss: VcBoolOption;
		type: String;

		constructor();
		constructor(type?: String, endpoint?: VcChoiceOption, noRxLoss?: VcBoolOption);
	}

	declare class VcVirtualSerialPortThinPrintBackingInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVirtualSerialPortThinPrintBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String);
	}

	declare class VcVirtualSerialPortURIBackingInfo
	{
		direction: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		proxyURI: String;
		serviceURI: String;

		constructor();
		constructor(serviceURI?: String, direction?: String, proxyURI?: String);
	}

	declare class VcVirtualSerialPortURIBackingOption
	{
		directions: VcChoiceOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, directions?: VcChoiceOption);
	}

	declare class VcVirtualSIOController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[]);
	}

	declare class VcVirtualSIOControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numFloppyDrives: VcIntOption;
		numParallelPorts: VcIntOption;
		numSerialPorts: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], numFloppyDrives?: VcIntOption, numSerialPorts?: VcIntOption, numParallelPorts?: VcIntOption);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualSoundBlaster16
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualSoundBlaster16Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualSoundCard
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number);
	}

	declare class VcVirtualSoundCardDeviceBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualSoundCardDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualSoundCardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualSriovEthernetCard
	{
		addressType: String;
		allowGuestOSMtuChange: boolean;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		sriovBacking: VcVirtualSriovEthernetCardSriovBackingInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, addressType?: String, macAddress?: String, wakeOnLanEnabled?: boolean, resourceAllocation?: VcVirtualEthernetCardResourceAllocation, externalId?: String, uptCompatibilityEnabled?: boolean, allowGuestOSMtuChange?: boolean, sriovBacking?: VcVirtualSriovEthernetCardSriovBackingInfo);
		isAllowGuestOSMtuChange(): boolean;
		isUptCompatibilityEnabled(): boolean;
		isWakeOnLanEnabled(): boolean;
	}

	declare class VcVirtualSriovEthernetCardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, supportedOUI?: VcChoiceOption, macType?: VcChoiceOption, wakeOnLanEnabled?: VcBoolOption, vmDirectPathGen2Supported?: boolean, uptCompatibilityEnabled?: VcBoolOption);
		isHotRemoveSupported(): boolean;
		isVmDirectPathGen2Supported(): boolean;
	}

	declare class VcVirtualSriovEthernetCardSriovBackingInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		physicalFunctionBacking: VcVirtualPCIPassthroughDeviceBackingInfo;
		virtualFunctionBacking: VcVirtualPCIPassthroughDeviceBackingInfo;
		virtualFunctionIndex: Number;

		constructor();
		constructor(physicalFunctionBacking?: VcVirtualPCIPassthroughDeviceBackingInfo, virtualFunctionBacking?: VcVirtualPCIPassthroughDeviceBackingInfo, virtualFunctionIndex?: Number);
	}

	declare class VcVirtualSriovEthernetCardSriovBackingOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String);
	}

	declare class VcVirtualSwitchProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		link: VcLinkProfile;
		name: String;
		networkPolicy: VcNetworkPolicyProfile;
		numPorts: VcNumPortsProfile;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String, name?: String, link?: VcLinkProfile, numPorts?: VcNumPortsProfile, networkPolicy?: VcNetworkPolicyProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcVirtualSwitchSelectionProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcVirtualUSB
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		connected: boolean;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		family: String[];
		key: Number;
		product: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		speed: String[];
		unitNumber: Number;
		vendor: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, connected?: boolean, vendor?: Number, product?: Number, family?: String[], speed?: String[]);
	}

	declare class VcVirtualUSBController
	{
		autoConnectDevices: boolean;
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ehciEnabled: boolean;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[], autoConnectDevices?: boolean, ehciEnabled?: boolean);
		isAutoConnectDevices(): boolean;
		isEhciEnabled(): boolean;
	}

	declare class VcVirtualUSBControllerOption
	{
		autoAssignController: VcBoolOption;
		autoConnectDevices: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ehciSupported: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		supportedDevice: String[];
		supportedSpeeds: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], autoConnectDevices?: VcBoolOption, ehciSupported?: VcBoolOption, supportedSpeeds?: String[]);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualUSBControllerPciBusSlotInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ehciPciSlotNumber: Number;
		pciSlotNumber: Number;

		constructor();
		constructor(pciSlotNumber?: Number, ehciPciSlotNumber?: Number);
	}

	declare class VcVirtualUSBOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualUSBRemoteClientBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostname: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean, hostname?: String);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualUSBRemoteClientBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualUSBRemoteHostBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostname: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean, hostname?: String);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualUSBRemoteHostBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualUSBUSBBackingInfo
	{
		deviceName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		useAutoDetect: boolean;

		constructor();
		constructor(deviceName?: String, useAutoDetect?: boolean);
		isUseAutoDetect(): boolean;
	}

	declare class VcVirtualUSBUSBBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		type: String;

		constructor();
		constructor(type?: String, autoDetectAvailable?: VcBoolOption);
	}

	declare class VcVirtualUSBXHCIController
	{
		autoConnectDevices: boolean;
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, busNumber?: Number, device?: Number[], autoConnectDevices?: boolean);
		isAutoConnectDevices(): boolean;
	}

	declare class VcVirtualUSBXHCIControllerOption
	{
		autoAssignController: VcBoolOption;
		autoConnectDevices: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		supportedDevice: String[];
		supportedSpeeds: String[];
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, devices?: VcIntOption, supportedDevice?: String[], autoConnectDevices?: VcBoolOption, supportedSpeeds?: String[]);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualVideoCardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		graphicsMemorySizeInKB: VcLongOption;
		graphicsMemorySizeSupported: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numDisplays: VcIntOption;
		plugAndPlay: boolean;
		support3D: VcBoolOption;
		supportMPT: VcBoolOption;
		type: String;
		use3dRendererSupported: VcBoolOption;
		useAutoDetect: VcBoolOption;
		videoRamSizeInKB: VcLongOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, videoRamSizeInKB?: VcLongOption, numDisplays?: VcIntOption, useAutoDetect?: VcBoolOption, support3D?: VcBoolOption, supportMPT?: VcBoolOption, use3dRendererSupported?: VcBoolOption, graphicsMemorySizeInKB?: VcLongOption, graphicsMemorySizeSupported?: VcBoolOption);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualVMIROMOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean);
		isHotRemoveSupported(): boolean;
	}

	declare class VcVirtualVmxnet
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, addressType?: String, macAddress?: String, wakeOnLanEnabled?: boolean, resourceAllocation?: VcVirtualEthernetCardResourceAllocation, externalId?: String, uptCompatibilityEnabled?: boolean);
		isUptCompatibilityEnabled(): boolean;
		isWakeOnLanEnabled(): boolean;
	}

	declare class VcVirtualVmxnet2
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, addressType?: String, macAddress?: String, wakeOnLanEnabled?: boolean, resourceAllocation?: VcVirtualEthernetCardResourceAllocation, externalId?: String, uptCompatibilityEnabled?: boolean);
		isUptCompatibilityEnabled(): boolean;
		isWakeOnLanEnabled(): boolean;
	}

	declare class VcVirtualVmxnet2Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, supportedOUI?: VcChoiceOption, macType?: VcChoiceOption, wakeOnLanEnabled?: VcBoolOption, vmDirectPathGen2Supported?: boolean, uptCompatibilityEnabled?: VcBoolOption);
		isHotRemoveSupported(): boolean;
		isVmDirectPathGen2Supported(): boolean;
	}

	declare class VcVirtualVmxnet3
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, addressType?: String, macAddress?: String, wakeOnLanEnabled?: boolean, resourceAllocation?: VcVirtualEthernetCardResourceAllocation, externalId?: String, uptCompatibilityEnabled?: boolean);
		isUptCompatibilityEnabled(): boolean;
		isWakeOnLanEnabled(): boolean;
	}

	declare class VcVirtualVmxnet3Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, supportedOUI?: VcChoiceOption, macType?: VcChoiceOption, wakeOnLanEnabled?: VcBoolOption, vmDirectPathGen2Supported?: boolean, uptCompatibilityEnabled?: VcBoolOption);
		isHotRemoveSupported(): boolean;
		isVmDirectPathGen2Supported(): boolean;
	}

	declare class VcVirtualVmxnet3Vrdma
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
		constructor(key?: Number, deviceInfo?: VcDescription, backing?: VcVirtualDeviceBackingInfo, connectable?: VcVirtualDeviceConnectInfo, slotInfo?: VcVirtualDeviceBusSlotInfo, controllerKey?: Number, unitNumber?: Number, addressType?: String, macAddress?: String, wakeOnLanEnabled?: boolean, resourceAllocation?: VcVirtualEthernetCardResourceAllocation, externalId?: String, uptCompatibilityEnabled?: boolean);
		isUptCompatibilityEnabled(): boolean;
		isWakeOnLanEnabled(): boolean;
	}

	declare class VcVirtualVmxnet3VrdmaOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, supportedOUI?: VcChoiceOption, macType?: VcChoiceOption, wakeOnLanEnabled?: VcBoolOption, vmDirectPathGen2Supported?: boolean, uptCompatibilityEnabled?: VcBoolOption);
		isHotRemoveSupported(): boolean;
		isVmDirectPathGen2Supported(): boolean;
	}

	declare class VcVirtualVmxnetOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
		constructor(type?: String, connectOption?: VcVirtualDeviceConnectOption, busSlotOption?: VcVirtualDeviceBusSlotOption, controllerType?: String, autoAssignController?: VcBoolOption, backingOption?: VcVirtualDeviceBackingOption[], defaultBackingOptionIndex?: Number, licensingLimit?: String[], deprecated?: boolean, plugAndPlay?: boolean, hotRemoveSupported?: boolean, supportedOUI?: VcChoiceOption, macType?: VcChoiceOption, wakeOnLanEnabled?: VcBoolOption, vmDirectPathGen2Supported?: boolean, uptCompatibilityEnabled?: VcBoolOption);
		isHotRemoveSupported(): boolean;
		isVmDirectPathGen2Supported(): boolean;
	}

	declare class VcVlanProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcVmAcquiredMksTicketEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmAcquiredTicketEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		ticketType: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, ticketType?: String);
	}

	declare class VcVmAlreadyExistsInDatacenter
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		hostname: String;
		readonly localizedMessage: String;
		message: String;
		target: VcManagedEntity;
		vm: VcVirtualMachine[];

		constructor();
		constructor(target?: VcManagedEntity, host?: VcHostSystem, hostname?: String, vm?: VcVirtualMachine[]);
		printStackTrace(): void;
	}

	declare class VcVmAutoRenameEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, oldName?: String, newName?: String);
	}

	declare class VcVmBeingClonedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destFolder: VcFolderEventArgument;
		destHost: VcHostEventArgument;
		destName: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, destFolder?: VcFolderEventArgument, destName?: String, destHost?: VcHostEventArgument);
	}

	declare class VcVmBeingClonedNoFolderEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destHost: VcHostEventArgument;
		destName: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, destName?: String, destHost?: VcHostEventArgument);
	}

	declare class VcVmBeingCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configSpec: VcVirtualMachineConfigSpec;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, configSpec?: VcVirtualMachineConfigSpec);
	}

	declare class VcVmBeingDeployedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		srcTemplate: VcVmEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, srcTemplate?: VcVmEventArgument);
	}

	declare class VcVmBeingHotMigratedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatacenter: VcDatacenterEventArgument;
		destDatastore: VcDatastoreEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, destHost?: VcHostEventArgument, destDatacenter?: VcDatacenterEventArgument, destDatastore?: VcDatastoreEventArgument);
	}

	declare class VcVmBeingMigratedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatacenter: VcDatacenterEventArgument;
		destDatastore: VcDatastoreEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, destHost?: VcHostEventArgument, destDatacenter?: VcDatacenterEventArgument, destDatastore?: VcDatastoreEventArgument);
	}

	declare class VcVmBeingRelocatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatacenter: VcDatacenterEventArgument;
		destDatastore: VcDatastoreEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, destHost?: VcHostEventArgument, destDatacenter?: VcDatacenterEventArgument, destDatastore?: VcDatastoreEventArgument);
	}

	declare class VcVmClonedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceVm: VcVmEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, sourceVm?: VcVmEventArgument);
	}

	declare class VcVmCloneEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmCloneFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destFolder: VcFolderEventArgument;
		destHost: VcHostEventArgument;
		destName: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, destFolder?: VcFolderEventArgument, destName?: String, destHost?: VcHostEventArgument, reason?: VcLocalizedMethodFault);
	}

	declare class VcVmConfigFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVmConfigFileEncryptionInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyId: VcCryptoKeyId;

		constructor();
		constructor(keyId?: VcCryptoKeyId);
	}

	declare class VcVmConfigFileInfo
	{
		configVersion: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encryption: VcVmConfigFileEncryptionInfo;
		fileSize: Number;
		friendlyName: String;
		modification: Date;
		owner: String;
		path: String;

		constructor();
		constructor(path?: String, friendlyName?: String, fileSize?: Number, modification?: Date, owner?: String, configVersion?: Number, encryption?: VcVmConfigFileEncryptionInfo);
	}

	declare class VcVmConfigFileQuery
	{
		details: VcVmConfigFileQueryFlags;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filter: VcVmConfigFileQueryFilter;

		constructor();
		constructor(filter?: VcVmConfigFileQueryFilter, details?: VcVmConfigFileQueryFlags);
	}

	declare class VcVmConfigFileQueryFilter
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encrypted: boolean;
		matchConfigVersion: Number[];

		constructor();
		constructor(matchConfigVersion?: Number[], encrypted?: boolean);
		isEncrypted(): boolean;
	}

	declare class VcVmConfigFileQueryFlags
	{
		configVersion: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encryption: boolean;

		constructor();
		constructor(configVersion?: boolean, encryption?: boolean);
		isEncryption(): boolean;
	}

	declare class VcVmConfigIncompatibleForFaultTolerance
	{
		fault: VcLocalizedMethodFault;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(fault?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcVmConfigIncompatibleForRecordReplay
	{
		fault: VcLocalizedMethodFault;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(fault?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcVmConfigInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eula: String[];
		installBootRequired: boolean;
		installBootStopDelay: Number;
		ipAssignment: VcVAppIPAssignmentInfo;
		ovfEnvironmentTransport: String[];
		ovfSection: VcVAppOvfSectionInfo[];
		product: VcVAppProductInfo[];
		property: VcVAppPropertyInfo[];

		constructor();
		constructor(product?: VcVAppProductInfo[], property?: VcVAppPropertyInfo[], ipAssignment?: VcVAppIPAssignmentInfo, eula?: String[], ovfSection?: VcVAppOvfSectionInfo[], ovfEnvironmentTransport?: String[], installBootRequired?: boolean, installBootStopDelay?: Number);
	}

	declare class VcVmConfigMissingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		eula: String[];
		installBootRequired: boolean;
		installBootStopDelay: Number;
		ipAssignment: VcVAppIPAssignmentInfo;
		ovfEnvironmentTransport: String[];
		ovfSection: VcVAppOvfSectionSpec[];
		product: VcVAppProductSpec[];
		property: VcVAppPropertySpec[];

		constructor();
		constructor(product?: VcVAppProductSpec[], property?: VcVAppPropertySpec[], ipAssignment?: VcVAppIPAssignmentInfo, eula?: String[], ovfSection?: VcVAppOvfSectionSpec[], ovfEnvironmentTransport?: String[], installBootRequired?: boolean, installBootStopDelay?: Number);
		isInstallBootRequired(): boolean;
	}

	declare class VcVmConnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmDasBeingResetEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: String);
		constructor();
	}

	interface VcVmDasBeingResetEventReasonCode
	{
		readonly appHeartbeatFailure: VcVmDasBeingResetEventReasonCode;
		readonly appImmediateResetRequest: VcVmDasBeingResetEventReasonCode;
		readonly guestOsCrashFailure: VcVmDasBeingResetEventReasonCode;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmcpResetApdCleared: VcVmDasBeingResetEventReasonCode;
		readonly vmtoolsHeartbeatFailure: VcVmDasBeingResetEventReasonCode;

		fromString(value?: VcVmDasBeingResetEventReasonCode): VcVmDasBeingResetEventReasonCode;
	}

	declare const VcVmDasBeingResetEventReasonCode: VcVmDasBeingResetEventReasonCode;

	declare class VcVmDasBeingResetWithScreenshotEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		screenshotFilePath: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: String, screenshotFilePath?: String);
	}

	declare class VcVmDasResetFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmDasUpdateErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmDasUpdateOkEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmDateRolledBackEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmDeployedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		srcTemplate: VcVmEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, srcTemplate?: VcVmEventArgument);
	}

	declare class VcVmDeployFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatastore: VcEntityEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, destDatastore?: VcEntityEventArgument, reason?: VcLocalizedMethodFault);
	}

	declare class VcVmDisconnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmDiscoveredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmDiskFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		disk: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, disk?: String, reason?: VcLocalizedMethodFault);
	}

	declare class VcVmDiskFileEncryptionInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		keyId: VcCryptoKeyId;

		constructor();
		constructor(keyId?: VcCryptoKeyId);
	}

	declare class VcVmDiskFileInfo
	{
		capacityKb: Number;
		controllerType: String;
		diskExtents: String[];
		diskType: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encryption: VcVmDiskFileEncryptionInfo;
		fileSize: Number;
		friendlyName: String;
		hardwareVersion: Number;
		modification: Date;
		owner: String;
		path: String;
		thin: boolean;

		constructor();
		constructor(path?: String, friendlyName?: String, fileSize?: Number, modification?: Date, owner?: String, diskType?: String, capacityKb?: Number, hardwareVersion?: Number, controllerType?: String, diskExtents?: String[], thin?: boolean, encryption?: VcVmDiskFileEncryptionInfo);
		isThin(): boolean;
	}

	declare class VcVmDiskFileQuery
	{
		details: VcVmDiskFileQueryFlags;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filter: VcVmDiskFileQueryFilter;

		constructor();
		constructor(filter?: VcVmDiskFileQueryFilter, details?: VcVmDiskFileQueryFlags);
	}

	declare class VcVmDiskFileQueryFilter
	{
		controllerType: String[];
		diskType: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encrypted: boolean;
		matchHardwareVersion: Number[];
		thin: boolean;

		constructor();
		constructor(diskType?: String[], matchHardwareVersion?: Number[], controllerType?: String[], thin?: boolean, encrypted?: boolean);
		isEncrypted(): boolean;
		isThin(): boolean;
	}

	declare class VcVmDiskFileQueryFlags
	{
		capacityKb: boolean;
		controllerType: boolean;
		diskExtents: boolean;
		diskType: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encryption: boolean;
		hardwareVersion: boolean;
		thin: boolean;

		constructor();
		constructor(diskType?: boolean, capacityKb?: boolean, hardwareVersion?: boolean, controllerType?: boolean, diskExtents?: boolean, thin?: boolean, encryption?: boolean);
		isControllerType(): boolean;
		isDiskExtents(): boolean;
		isEncryption(): boolean;
		isThin(): boolean;
	}

	declare class VcVmEmigratingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmEndRecordingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmEndReplayingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmEventArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		vm: VcVirtualMachine;

		constructor();
		constructor(name?: String, vm?: VcVirtualMachine);
	}

	declare class VcVmFailedMigrateEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatacenter: VcDatacenterEventArgument;
		destDatastore: VcDatastoreEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, destHost?: VcHostEventArgument, reason?: VcLocalizedMethodFault, destDatacenter?: VcDatacenterEventArgument, destDatastore?: VcDatastoreEventArgument);
	}

	declare class VcVmFailedRelayoutEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcVmFailedRelayoutOnVmfs2DatastoreEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmFailedStartingSecondaryEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: String);
		constructor();
	}

	interface VcVmFailedStartingSecondaryEventFailureReason
	{
		readonly id: String;
		readonly incompatibleHost: VcVmFailedStartingSecondaryEventFailureReason;
		readonly loginFailed: VcVmFailedStartingSecondaryEventFailureReason;
		readonly migrateFailed: VcVmFailedStartingSecondaryEventFailureReason;
		readonly name: String;
		readonly registerVmFailed: VcVmFailedStartingSecondaryEventFailureReason;
		readonly value: String;

		fromString(value?: VcVmFailedStartingSecondaryEventFailureReason): VcVmFailedStartingSecondaryEventFailureReason;
	}

	declare const VcVmFailedStartingSecondaryEventFailureReason: VcVmFailedStartingSecondaryEventFailureReason;

	declare class VcVmFailedToPowerOffEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcVmFailedToPowerOnEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcVmFailedToRebootGuestEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcVmFailedToResetEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcVmFailedToShutdownGuestEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcVmFailedToStandbyGuestEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcVmFailedToSuspendEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcVmFailedUpdatingSecondaryConfig
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmFailoverFailed
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcVmFaultToleranceConfigIssue
	{
		entity: VcManagedEntity;
		entityName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(reason?: String, entityName?: String, entity?: VcManagedEntity);
		printStackTrace(): void;
	}

	interface VcVmFaultToleranceConfigIssueReasonForIssue
	{
		readonly cpuHvDisabled: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly cpuHvUnsupported: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly cpuHwmmuUnsupported: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly esxAgentVm: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly ftSecondaryVm: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly ftUnsupportedHardware: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly ftUnsupportedProduct: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly haNotEnabled: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasEFIFirmware: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasLocalDisk: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasNestedHVConfiguration: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasSnapshots: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasUnsupportedDisk: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasVFlashConfiguration: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hostInactive: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly id: String;
		readonly insufficientBandwidth: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly missingFTLoggingNic: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly missingVMotionNic: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly moreThanOneSecondary: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly multipleVCPU: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly name: String;
		readonly noConfig: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly recordReplayNotSupported: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly replayNotSupported: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly templateVm: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly thinDisk: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly unsupportedProduct: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly value: String;
		readonly verifySSLCertificateFlagNotSet: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly video3dEnabled: VcVmFaultToleranceConfigIssueReasonForIssue;

		fromString(value?: VcVmFaultToleranceConfigIssueReasonForIssue): VcVmFaultToleranceConfigIssueReasonForIssue;
	}

	declare const VcVmFaultToleranceConfigIssueReasonForIssue: VcVmFaultToleranceConfigIssueReasonForIssue;

	declare class VcVmFaultToleranceConfigIssueWrapper
	{
		entity: VcManagedEntity;
		entityName: String;
		error: VcLocalizedMethodFault;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(entityName?: String, entity?: VcManagedEntity, error?: VcLocalizedMethodFault);
		printStackTrace(): void;
	}

	declare class VcVmFaultToleranceInvalidFileBacking
	{
		backingFilename: String;
		backingType: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(backingType?: String, backingFilename?: String);
		printStackTrace(): void;
	}

	interface VcVmFaultToleranceInvalidFileBackingDeviceType
	{
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly virtualCdrom: VcVmFaultToleranceInvalidFileBackingDeviceType;
		readonly virtualDisk: VcVmFaultToleranceInvalidFileBackingDeviceType;
		readonly virtualFloppy: VcVmFaultToleranceInvalidFileBackingDeviceType;
		readonly virtualParallelPort: VcVmFaultToleranceInvalidFileBackingDeviceType;
		readonly virtualSerialPort: VcVmFaultToleranceInvalidFileBackingDeviceType;

		fromString(value?: VcVmFaultToleranceInvalidFileBackingDeviceType): VcVmFaultToleranceInvalidFileBackingDeviceType;
	}

	declare const VcVmFaultToleranceInvalidFileBackingDeviceType: VcVmFaultToleranceInvalidFileBackingDeviceType;

	declare class VcVmFaultToleranceIssue
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVmFaultToleranceOpIssuesList
	{
		errors: VcLocalizedMethodFault[];
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		warnings: VcLocalizedMethodFault[];

		constructor();
		constructor(errors?: VcLocalizedMethodFault[], warnings?: VcLocalizedMethodFault[]);
		printStackTrace(): void;
	}

	declare class VcVmFaultToleranceStateChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newState: VcVirtualMachineFaultToleranceState;
		oldState: VcVirtualMachineFaultToleranceState;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, oldState?: VcVirtualMachineFaultToleranceState, newState?: VcVirtualMachineFaultToleranceState);
	}

	declare class VcVmFaultToleranceTooManyFtVcpusOnHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		maxNumFtVcpus: Number;
		message: String;

		constructor();
		constructor(hostName?: String, maxNumFtVcpus?: Number);
		printStackTrace(): void;
	}

	declare class VcVmFaultToleranceTooManyVMsOnHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		maxNumFtVms: Number;
		message: String;

		constructor();
		constructor(hostName?: String, maxNumFtVms?: Number);
		printStackTrace(): void;
	}

	declare class VcVmFaultToleranceTurnedOffEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmFaultToleranceVmTerminatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: String);
		constructor();
	}

	interface VcVmFolder
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		childEntity: VcManagedEntity[];
		childType: String[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		folder: Object[];
		folderTypes: Object[];
		id: String;
		name: String;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		resourcePool_VirtualApp: Object[];
		sdkConnection: VcSdkConnection;
		sdkId: String;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vm: Object[];
		wrappedFolder: VcFolder;

		_getRef(): VcManagedObjectReference;
		addStandaloneHost_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		addStandaloneHostWithAdminDisabled_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		addTag(tag?: VcTag[]): void;
		createCluster(name?: String, spec?: VcClusterConfigSpec): VcClusterComputeResource;
		createClusterEx(name?: String, spec?: VcClusterConfigSpecEx): VcClusterComputeResource;
		createDatacenter(name?: String): VcDatacenter;
		createDVS_Task(spec?: VcDVSCreateSpec): VcTask;
		createFolder(name?: String): VcFolder;
		createStoragePod(name?: String): VcStoragePod;
		createVM_Task(config?: VcVirtualMachineConfigSpec, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		destroy_Task(): VcTask;
		isFolder(type?: String): boolean;
		moveIntoFolder_Task(list?: VcManagedEntity[]): VcTask;
		registerVM_Task(path?: String, name?: String, asTemplate?: boolean, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		reload(): void;
		removeTag(tag?: VcTag[]): void;
		rename_Task(newName?: String): VcTask;
		retrieveCustomValues(keys?: Number[]): VcCustomFieldValue[];
		setCustomValue(key?: String, value?: String): void;
		unregisterAndDestroy_Task(): VcTask;
	}

	interface VcVmFolderConstructor {
		new(value?:any): VcVmFolder;
		readonly prototype: VcVmFolder;
	}

	declare const VcVmFolder: VcVmFolderConstructor;

	declare class VcVmfsAlreadyMounted
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		uuid: String;

		constructor();
		constructor(uuid?: String);
		printStackTrace(): void;
	}

	declare class VcVmfsAmbiguousMount
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		uuid: String;

		constructor();
		constructor(uuid?: String);
		printStackTrace(): void;
	}

	declare class VcVmfsConfigOption
	{
		blockSizeOption: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		unmapGranularityOption: Number[];

		constructor();
		constructor(blockSizeOption?: Number, unmapGranularityOption?: Number[]);
	}

	declare class VcVmfsDatastoreAllExtentOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		layout: VcHostDiskPartitionLayout;
		partitionFormatChange: boolean;
		vmfsExtent: VcHostDiskPartitionBlockRange;

		constructor();
		constructor(layout?: VcHostDiskPartitionLayout, partitionFormatChange?: boolean, vmfsExtent?: VcHostDiskPartitionBlockRange);
		isPartitionFormatChange(): boolean;
	}

	declare class VcVmfsDatastoreBaseOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		layout: VcHostDiskPartitionLayout;
		partitionFormatChange: boolean;

		constructor();
		constructor(layout?: VcHostDiskPartitionLayout, partitionFormatChange?: boolean);
		isPartitionFormatChange(): boolean;
	}

	declare class VcVMFSDatastoreCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		datastoreUrl: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument, datastoreUrl?: String);
	}

	declare class VcVmfsDatastoreCreateSpec
	{
		diskUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extent: VcHostScsiDiskPartition[];
		partition: VcHostDiskPartitionSpec;
		vmfs: VcHostVmfsSpec;

		constructor();
		constructor(diskUuid?: String, partition?: VcHostDiskPartitionSpec, vmfs?: VcHostVmfsSpec, extent?: VcHostScsiDiskPartition[]);
	}

	declare class VcVMFSDatastoreExpandedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument);
	}

	declare class VcVmfsDatastoreExpandSpec
	{
		diskUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extent: VcHostScsiDiskPartition;
		partition: VcHostDiskPartitionSpec;

		constructor();
		constructor(diskUuid?: String, partition?: VcHostDiskPartitionSpec, extent?: VcHostScsiDiskPartition);
	}

	declare class VcVMFSDatastoreExtendedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, datastore?: VcDatastoreEventArgument);
	}

	declare class VcVmfsDatastoreExtendSpec
	{
		diskUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extent: VcHostScsiDiskPartition[];
		partition: VcHostDiskPartitionSpec;

		constructor();
		constructor(diskUuid?: String, partition?: VcHostDiskPartitionSpec, extent?: VcHostScsiDiskPartition[]);
	}

	declare class VcVmfsDatastoreInfo
	{
		containerId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpace: Number;
		lun: VcVmfsDatastoreInfoScsiLunInfo[];
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxPhysicalRDMFileSize: Number;
		maxVirtualDiskCapacity: Number;
		maxVirtualRDMFileSize: Number;
		name: String;
		timestamp: Date;
		url: String;
		vmfs: VcHostVmfsVolume;

		constructor();
		constructor(name?: String, url?: String, freeSpace?: Number, maxFileSize?: Number, maxVirtualDiskCapacity?: Number, maxMemoryFileSize?: Number, timestamp?: Date, containerId?: String, maxPhysicalRDMFileSize?: Number, maxVirtualRDMFileSize?: Number, vmfs?: VcHostVmfsVolume, lun?: VcVmfsDatastoreInfoScsiLunInfo[]);
	}

	declare class VcVmfsDatastoreInfoScsiLunInfo
	{
		canonicalName: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: String;
		uuid: String;

		constructor();
		constructor(key?: String, canonicalName?: String, uuid?: String);
	}

	declare class VcVmfsDatastoreMultipleExtentOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		layout: VcHostDiskPartitionLayout;
		partitionFormatChange: boolean;
		vmfsExtent: VcHostDiskPartitionBlockRange[];

		constructor();
		constructor(layout?: VcHostDiskPartitionLayout, partitionFormatChange?: boolean, vmfsExtent?: VcHostDiskPartitionBlockRange[]);
		isPartitionFormatChange(): boolean;
	}

	declare class VcVmfsDatastoreOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		info: VcVmfsDatastoreBaseOption;
		spec: VcVmfsDatastoreSpec;

		constructor();
		constructor(info?: VcVmfsDatastoreBaseOption, spec?: VcVmfsDatastoreSpec);
	}

	declare class VcVmfsDatastoreSingleExtentOption
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		layout: VcHostDiskPartitionLayout;
		partitionFormatChange: boolean;
		vmfsExtent: VcHostDiskPartitionBlockRange;

		constructor();
		constructor(layout?: VcHostDiskPartitionLayout, partitionFormatChange?: boolean, vmfsExtent?: VcHostDiskPartitionBlockRange);
		isPartitionFormatChange(): boolean;
	}

	declare class VcVmfsDatastoreSpec
	{
		diskUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(diskUuid?: String);
	}

	declare class VcVmfsMountFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		uuid: String;

		constructor();
		constructor(uuid?: String);
		printStackTrace(): void;
	}

	declare class VcVmGuestOSCrashedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmGuestRebootEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmGuestShutdownEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmGuestStandbyEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmHealthMonitoringStateChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		prevState: String;
		state: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, state?: String, prevState?: String);
	}

	declare class VcVmHostAffinityRuleViolation
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		message: String;
		vmName: String;

		constructor();
		constructor(vmName?: String, hostName?: String);
		printStackTrace(): void;
	}

	declare class VcVMINotSupported
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		reason: String;

		constructor();
		constructor(device?: String, reason?: String);
		printStackTrace(): void;
	}

	declare class VcVmInstanceUuidAssignedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		instanceUuid: String;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, instanceUuid?: String);
	}

	declare class VcVmInstanceUuidChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newInstanceUuid: String;
		oldInstanceUuid: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, oldInstanceUuid?: String, newInstanceUuid?: String);
	}

	declare class VcVmInstanceUuidConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedVm: VcVmEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		instanceUuid: String;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, conflictedVm?: VcVmEventArgument, instanceUuid?: String);
	}

	declare class VcVmLimitLicense
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		limit: Number;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(limit?: Number);
		printStackTrace(): void;
	}

	declare class VcVmLogFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSize: Number;
		friendlyName: String;
		modification: Date;
		owner: String;
		path: String;

		constructor();
		constructor(path?: String, friendlyName?: String, fileSize?: Number, modification?: Date, owner?: String);
	}

	declare class VcVmLogFileQuery
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVmMacAssignedEvent
	{
		adapter: String;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		mac: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, adapter?: String, mac?: String);
	}

	declare class VcVmMacChangedEvent
	{
		adapter: String;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newMac: String;
		oldMac: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, adapter?: String, oldMac?: String, newMac?: String);
	}

	declare class VcVmMacConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedVm: VcVmEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		mac: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, conflictedVm?: VcVmEventArgument, mac?: String);
	}

	declare class VcVmMaxFTRestartCountReached
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmMaxRestartCountReached
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmMessageErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		messageInfo: VcVirtualMachineMessage[];
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, message?: String, messageInfo?: VcVirtualMachineMessage[]);
	}

	declare class VcVmMessageEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		messageInfo: VcVirtualMachineMessage[];
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, message?: String, messageInfo?: VcVirtualMachineMessage[]);
	}

	declare class VcVmMessageWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		messageInfo: VcVirtualMachineMessage[];
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, message?: String, messageInfo?: VcVirtualMachineMessage[]);
	}

	declare class VcVmMetadataInaccessibleFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVmMetadataInvalidOwner
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		name: String;

		constructor();
		constructor(name?: String);
		printStackTrace(): void;
	}

	declare class VcVmMetadataManagerFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVmMetadataOpFailedRetry
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		retryTime: Number;

		constructor();
		constructor(retryTime?: Number);
		printStackTrace(): void;
	}

	declare class VcVmMigratedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDatacenter: VcDatacenterEventArgument;
		sourceDatastore: VcDatastoreEventArgument;
		sourceHost: VcHostEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, sourceHost?: VcHostEventArgument, sourceDatacenter?: VcDatacenterEventArgument, sourceDatastore?: VcDatastoreEventArgument);
	}

	declare class VcVmMonitorIncompatibleForFaultTolerance
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVmNoCompatibleHostForSecondaryEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmNoNetworkAccessEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, destHost?: VcHostEventArgument);
	}

	declare class VcVmNvramFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSize: Number;
		friendlyName: String;
		modification: Date;
		owner: String;
		path: String;

		constructor();
		constructor(path?: String, friendlyName?: String, fileSize?: Number, modification?: Date, owner?: String);
	}

	declare class VcVmNvramFileQuery
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVMOnConflictDVPort
	{
		backing: String;
		connected: boolean;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		network: VcNetwork;

		constructor();
		constructor(device?: String, backing?: String, connected?: boolean, network?: VcNetwork);
		printStackTrace(): void;
	}

	declare class VcVMOnVirtualIntranet
	{
		backing: String;
		connected: boolean;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		network: VcNetwork;

		constructor();
		constructor(device?: String, backing?: String, connected?: boolean, network?: VcNetwork);
		printStackTrace(): void;
	}

	declare class VcVmOrphanedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVMotionAcrossNetworkNotSupported
	{
		atSourceHost: boolean;
		failedHost: VcHostSystem;
		failedHostName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHostName?: String, failedHost?: VcHostSystem);
		printStackTrace(): void;
	}

	interface VcVMotionCompatibilityType
	{
		readonly cpu: VcVMotionCompatibilityType;
		readonly id: String;
		readonly name: String;
		readonly software: VcVMotionCompatibilityType;
		readonly value: String;

		fromString(value?: VcVMotionCompatibilityType): VcVMotionCompatibilityType;
	}

	declare const VcVMotionCompatibilityType: VcVMotionCompatibilityType;

	declare class VcVMotionInterfaceIssue
	{
		atSourceHost: boolean;
		failedHost: String;
		failedHostEntity: VcHostSystem;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHost?: String, failedHostEntity?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcVmotionInterfaceNotEnabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVMotionLicenseExpiredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String);
	}

	declare class VcVMotionLinkCapacityLow
	{
		atSourceHost: boolean;
		failedHost: String;
		failedHostEntity: VcHostSystem;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		network: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHost?: String, failedHostEntity?: VcHostSystem, network?: String);
		printStackTrace(): void;
	}

	declare class VcVMotionLinkDown
	{
		atSourceHost: boolean;
		failedHost: String;
		failedHostEntity: VcHostSystem;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		network: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHost?: String, failedHostEntity?: VcHostSystem, network?: String);
		printStackTrace(): void;
	}

	declare class VcVMotionNotConfigured
	{
		atSourceHost: boolean;
		failedHost: String;
		failedHostEntity: VcHostSystem;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHost?: String, failedHostEntity?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcVMotionNotLicensed
	{
		atSourceHost: boolean;
		failedHost: String;
		failedHostEntity: VcHostSystem;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHost?: String, failedHostEntity?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcVMotionNotSupported
	{
		atSourceHost: boolean;
		failedHost: String;
		failedHostEntity: VcHostSystem;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(atSourceHost?: boolean, failedHost?: String, failedHostEntity?: VcHostSystem);
		printStackTrace(): void;
	}

	declare class VcVMotionProtocolIncompatible
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVmPodConfigForPlacement
	{
		disk: VcPodDiskLocator[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		interVmRule: VcClusterRuleInfo[];
		storagePod: VcStoragePod;
		vmConfig: VcStorageDrsVmConfigInfo;

		constructor();
		constructor(storagePod?: VcStoragePod, disk?: VcPodDiskLocator[], vmConfig?: VcStorageDrsVmConfigInfo, interVmRule?: VcClusterRuleInfo[]);
	}

	declare class VcVmPortGroupProfile
	{
		copyEnableStatus: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		favorite: boolean;
		key: String;
		name: String;
		networkPolicy: VcNetworkPolicyProfile;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		toBeDeleted: boolean;
		toBeMerged: boolean;
		toReplaceWith: boolean;
		vlan: VcVlanProfile;
		vswitch: VcVirtualSwitchSelectionProfile;

		constructor();
		constructor(enabled?: boolean, policy?: VcProfilePolicy[], profileTypeName?: String, profileVersion?: String, property?: VcProfileApplyProfileProperty[], favorite?: boolean, toBeMerged?: boolean, toReplaceWith?: boolean, toBeDeleted?: boolean, copyEnableStatus?: boolean, key?: String, name?: String, vlan?: VcVlanProfile, vswitch?: VcVirtualSwitchSelectionProfile, networkPolicy?: VcNetworkPolicyProfile);
		isCopyEnableStatus(): boolean;
		isFavorite(): boolean;
		isToBeDeleted(): boolean;
		isToBeMerged(): boolean;
		isToReplaceWith(): boolean;
	}

	declare class VcVmPoweredOffEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmPoweredOnEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmPoweringOnWithCustomizedDVPortEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;
		vnic: VcVnicPortArgument[];

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, vnic?: VcVnicPortArgument[]);
	}

	declare class VcVmPowerOffOnIsolationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		isolatedHost: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, isolatedHost?: VcHostEventArgument);
	}

	declare class VcVmPowerOnDisabled
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVmPrimaryFailoverEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: String);
		constructor();
	}

	declare class VcVmReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configChanges: VcChangesInfoEventArgument;
		configSpec: VcVirtualMachineConfigSpec;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, configSpec?: VcVirtualMachineConfigSpec, configChanges?: VcChangesInfoEventArgument);
	}

	declare class VcVmRegisteredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmRelayoutSuccessfulEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmRelayoutUpToDateEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmReloadFromPathEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configPath: String;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, configPath?: String);
	}

	declare class VcVmReloadFromPathFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configPath: String;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, configPath?: String);
	}

	declare class VcVmRelocatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDatacenter: VcDatacenterEventArgument;
		sourceDatastore: VcDatastoreEventArgument;
		sourceHost: VcHostEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, sourceHost?: VcHostEventArgument, sourceDatacenter?: VcDatacenterEventArgument, sourceDatastore?: VcDatastoreEventArgument);
	}

	declare class VcVmRelocateFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatacenter: VcDatacenterEventArgument;
		destDatastore: VcDatastoreEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, destHost?: VcHostEventArgument, reason?: VcLocalizedMethodFault, destDatacenter?: VcDatacenterEventArgument, destDatastore?: VcDatastoreEventArgument);
	}

	declare class VcVmRelocateSpecEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmRemoteConsoleConnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmRemoteConsoleDisconnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, oldName?: String, newName?: String);
	}

	declare class VcVmRequirementsExceedCurrentEVCModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmResettingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmResourcePoolMovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newParent: VcResourcePoolEventArgument;
		oldParent: VcResourcePoolEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, oldParent?: VcResourcePoolEventArgument, newParent?: VcResourcePoolEventArgument);
	}

	declare class VcVmResourceReallocatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configChanges: VcChangesInfoEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, configChanges?: VcChangesInfoEventArgument);
	}

	declare class VcVmRestartedOnAlternateHostEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceHost: VcHostEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, sourceHost?: VcHostEventArgument);
	}

	declare class VcVmResumingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmSecondaryAddedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmSecondaryDisabledBySystemEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, reason?: VcLocalizedMethodFault);
		constructor();
	}

	declare class VcVmSecondaryDisabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmSecondaryEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmSecondaryStartedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmShutdownOnIsolationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		isolatedHost: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		shutdownResult: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, isolatedHost?: VcHostEventArgument, shutdownResult?: String);
	}

	interface VcVmShutdownOnIsolationEventOperation
	{
		readonly id: String;
		readonly name: String;
		readonly poweredOff: VcVmShutdownOnIsolationEventOperation;
		readonly shutdown: VcVmShutdownOnIsolationEventOperation;
		readonly value: String;

		fromString(value?: VcVmShutdownOnIsolationEventOperation): VcVmShutdownOnIsolationEventOperation;
	}

	declare const VcVmShutdownOnIsolationEventOperation: VcVmShutdownOnIsolationEventOperation;

	declare class VcVmSmpFaultToleranceTooManyVMsOnHost
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostName: String;
		readonly localizedMessage: String;
		maxNumSmpFtVms: Number;
		message: String;

		constructor();
		constructor(hostName?: String, maxNumSmpFtVms?: Number);
		printStackTrace(): void;
	}

	declare class VcVmSnapshotFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fileSize: Number;
		friendlyName: String;
		modification: Date;
		owner: String;
		path: String;

		constructor();
		constructor(path?: String, friendlyName?: String, fileSize?: Number, modification?: Date, owner?: String);
	}

	declare class VcVmSnapshotFileQuery
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
	}

	declare class VcVmStartingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmStartingSecondaryEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmStartRecordingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmStartReplayingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmStaticMacConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedVm: VcVmEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		mac: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, conflictedVm?: VcVmEventArgument, mac?: String);
	}

	declare class VcVmStoppingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmSuspendedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmSuspendingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmTimedoutStartingSecondaryEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		timeout: Number;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, timeout?: Number);
	}

	declare class VcVmToolsUpgradeFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVmUnsupportedStartingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		guestId: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, guestId?: String);
	}

	declare class VcVmUpgradeCompleteEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		version: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, version?: String);
	}

	declare class VcVmUpgradeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean);
	}

	declare class VcVmUpgradingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		version: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, version?: String);
	}

	declare class VcVmUuidAssignedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		uuid: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, uuid?: String);
	}

	declare class VcVmUuidChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newUuid: String;
		oldUuid: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, oldUuid?: String, newUuid?: String);
	}

	declare class VcVmUuidConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedVm: VcVmEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		uuid: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, conflictedVm?: VcVmEventArgument, uuid?: String);
	}

	declare class VcVmValidateMaxDevice
	{
		count: Number;
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		max: Number;
		message: String;

		constructor();
		constructor(device?: String, max?: Number, count?: Number);
		printStackTrace(): void;
	}

	declare class VcVmVnicPoolReservationViolationClearEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;
		vmVnicResourcePoolKey: String;
		vmVnicResourcePoolName: String;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, vmVnicResourcePoolKey?: String, vmVnicResourcePoolName?: String);
	}

	declare class VcVmVnicPoolReservationViolationRaiseEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;
		vmVnicResourcePoolKey: String;
		vmVnicResourcePoolName: String;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, vmVnicResourcePoolKey?: String, vmVnicResourcePoolName?: String);
	}

	interface VcVmwareDistributedVirtualSwitch
	{
		readonly alarmActionsEnabled: boolean;
		readonly availableField: VcCustomFieldDef[];
		readonly capability: VcDVSCapability;
		readonly config: VcDVSConfigInfo;
		readonly configIssue: VcEvent[];
		readonly configStatus: VcManagedEntityStatus;
		readonly customValue: VcCustomFieldValue[];
		readonly declaredAlarmState: VcAlarmState[];
		description: String;
		readonly disabledMethod: String[];
		readonly effectiveRole: Number[];
		id: String;
		moref: VcManagedObjectReference;
		readonly name: String;
		readonly networkResourcePool: VcDVSNetworkResourcePool[];
		readonly overallStatus: VcManagedEntityStatus;
		readonly parent: VcManagedEntity;
		readonly permission: VcPermission[];
		readonly portgroup: VcDistributedVirtualPortgroup[];
		readonly recentTask: VcTask[];
		readonly runtime: VcDVSRuntimeInfo;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		readonly summary: VcDVSSummary;
		readonly tag: VcTag[];
		readonly triggeredAlarmState: VcAlarmState[];
		type: String;
		readonly uuid: String;
		readonly value: VcCustomFieldValue[];
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		addDVPortgroup_Task(arg0?: VcDVPortgroupConfigSpec[]): VcTask;
		addNetworkResourcePool(arg0?: VcDVSNetworkResourcePoolConfigSpec[]): void;
		addTag(arg0?: VcTag[]): void;
		createDVPortgroup_Task(arg0?: VcDVPortgroupConfigSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		dvsReconfigureVmVnicNetworkResourcePool_Task(arg0?: VcDvsVmVnicResourcePoolConfigSpec[]): VcTask;
		dVSRollback_Task(arg0?: VcEntityBackupConfig): VcTask;
		enableNetworkResourceManagement(arg0?: boolean): void;
		fetchDVPortKeys(arg0?: VcDistributedVirtualSwitchPortCriteria): String[];
		fetchDVPorts(arg0?: VcDistributedVirtualSwitchPortCriteria): VcDistributedVirtualPort[];
		lookupDvPortGroup(arg0?: String): VcDistributedVirtualPortgroup;
		mergeDvs_Task(arg0?: VcDistributedVirtualSwitch): VcTask;
		moveDVPort_Task(arg0?: String[], arg1?: String): VcTask;
		performDvsProductSpecOperation_Task(arg0?: String, arg1?: VcDistributedVirtualSwitchProductSpec): VcTask;
		queryUsedVlanIdInDvs(): Number[];
		reconfigureDVPort_Task(arg0?: VcDVPortConfigSpec[]): VcTask;
		reconfigureDvs_Task(arg0?: VcDVSConfigSpec): VcTask;
		rectifyDvsHost_Task(arg0?: VcHostSystem[]): VcTask;
		refreshDVPortState(arg0?: String[]): void;
		reload(): void;
		removeNetworkResourcePool(arg0?: String[]): void;
		removeTag(arg0?: VcTag[]): void;
		rename_Task(arg0?: String): VcTask;
		retrieveCustomValues(arg0?: Number[]): VcCustomFieldValue[];
		setCustomValue(arg0?: String, arg1?: String): void;
		updateDvsCapability(arg0?: VcDVSCapability): void;
		updateDVSHealthCheckConfig_Task(arg0?: VcDVSHealthCheckConfig[]): VcTask;
		updateDVSLacpGroupConfig_Task(arg0?: VcVMwareDvsLacpGroupSpec[]): VcTask;
		updateNetworkResourcePool(arg0?: VcDVSNetworkResourcePoolConfigSpec[]): void;
	}

	declare const VcVmwareDistributedVirtualSwitch: VcVmwareDistributedVirtualSwitch;

	interface VcVmwareDistributedVirtualSwitchPvlanPortType
	{
		readonly community: VcVmwareDistributedVirtualSwitchPvlanPortType;
		readonly id: String;
		readonly isolated: VcVmwareDistributedVirtualSwitchPvlanPortType;
		readonly name: String;
		readonly promiscuous: VcVmwareDistributedVirtualSwitchPvlanPortType;
		readonly value: String;

		fromString(value?: VcVmwareDistributedVirtualSwitchPvlanPortType): VcVmwareDistributedVirtualSwitchPvlanPortType;
	}

	declare const VcVmwareDistributedVirtualSwitchPvlanPortType: VcVmwareDistributedVirtualSwitchPvlanPortType;

	declare class VcVmwareDistributedVirtualSwitchPvlanSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		pvlanId: Number;

		constructor();
		constructor(inherited?: boolean, pvlanId?: Number);
	}

	declare class VcVmwareDistributedVirtualSwitchTrunkVlanSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		vlanId: VcNumericRange[];

		constructor();
		constructor(inherited?: boolean, vlanId?: VcNumericRange[]);
	}

	declare class VcVmwareDistributedVirtualSwitchVlanIdSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		vlanId: Number;

		constructor();
		constructor(inherited?: boolean, vlanId?: Number);
	}

	declare class VcVmwareDistributedVirtualSwitchVlanSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;

		constructor();
		constructor(inherited?: boolean);
	}

	declare class VcVMwareDVSConfigInfo
	{
		configVersion: String;
		contact: VcDVSContactInfo;
		createTime: Date;
		defaultPortConfig: VcDVPortSetting;
		defaultProxySwitchMaxNumPorts: Number;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extensionKey: String;
		healthCheckConfig: VcDVSHealthCheckConfig[];
		host: VcDistributedVirtualSwitchHostMember[];
		infrastructureTrafficResourceConfig: VcDvsHostInfrastructureTrafficResource[];
		ipfixConfig: VcVMwareIpfixConfig;
		lacpApiVersion: String;
		lacpGroupConfig: VcVMwareDvsLacpGroupConfig[];
		linkDiscoveryProtocolConfig: VcLinkDiscoveryProtocolConfig;
		maxMtu: Number;
		maxPorts: Number;
		multicastFilteringMode: String;
		name: String;
		networkResourceControlVersion: String;
		networkResourceManagementEnabled: boolean;
		numPorts: Number;
		numStandalonePorts: Number;
		pnicCapacityRatioForReservation: Number;
		policy: VcDVSPolicy;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		pvlanConfig: VcVMwareDVSPvlanMapEntry[];
		switchIpAddress: String;
		targetInfo: VcDistributedVirtualSwitchProductSpec;
		uplinkPortgroup: VcDistributedVirtualPortgroup[];
		uplinkPortPolicy: VcDVSUplinkPortPolicy;
		uuid: String;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vmVnicNetworkResourcePool: VcDVSVmVnicNetworkResourcePool[];
		vspanSession: VcVMwareVspanSession[];

		constructor();
		constructor(uuid?: String, name?: String, numStandalonePorts?: Number, numPorts?: Number, maxPorts?: Number, uplinkPortPolicy?: VcDVSUplinkPortPolicy, uplinkPortgroup?: VcDistributedVirtualPortgroup[], defaultPortConfig?: VcDVPortSetting, host?: VcDistributedVirtualSwitchHostMember[], productInfo?: VcDistributedVirtualSwitchProductSpec, targetInfo?: VcDistributedVirtualSwitchProductSpec, extensionKey?: String, vendorSpecificConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], policy?: VcDVSPolicy, description?: String, configVersion?: String, contact?: VcDVSContactInfo, switchIpAddress?: String, createTime?: Date, networkResourceManagementEnabled?: boolean, defaultProxySwitchMaxNumPorts?: Number, healthCheckConfig?: VcDVSHealthCheckConfig[], infrastructureTrafficResourceConfig?: VcDvsHostInfrastructureTrafficResource[], networkResourceControlVersion?: String, vmVnicNetworkResourcePool?: VcDVSVmVnicNetworkResourcePool[], pnicCapacityRatioForReservation?: Number, vspanSession?: VcVMwareVspanSession[], pvlanConfig?: VcVMwareDVSPvlanMapEntry[], maxMtu?: Number, linkDiscoveryProtocolConfig?: VcLinkDiscoveryProtocolConfig, ipfixConfig?: VcVMwareIpfixConfig, lacpGroupConfig?: VcVMwareDvsLacpGroupConfig[], lacpApiVersion?: String, multicastFilteringMode?: String);
		isNetworkResourceManagementEnabled(): boolean;
	}

	declare class VcVMwareDVSConfigSpec
	{
		configVersion: String;
		contact: VcDVSContactInfo;
		defaultPortConfig: VcDVPortSetting;
		defaultProxySwitchMaxNumPorts: Number;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		extensionKey: String;
		host: VcDistributedVirtualSwitchHostMemberConfigSpec[];
		infrastructureTrafficResourceConfig: VcDvsHostInfrastructureTrafficResource[];
		ipfixConfig: VcVMwareIpfixConfig;
		lacpApiVersion: String;
		linkDiscoveryProtocolConfig: VcLinkDiscoveryProtocolConfig;
		maxMtu: Number;
		maxPorts: Number;
		multicastFilteringMode: String;
		name: String;
		networkResourceControlVersion: String;
		numStandalonePorts: Number;
		policy: VcDVSPolicy;
		pvlanConfigSpec: VcVMwareDVSPvlanConfigSpec[];
		switchIpAddress: String;
		uplinkPortgroup: VcDistributedVirtualPortgroup[];
		uplinkPortPolicy: VcDVSUplinkPortPolicy;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vspanConfigSpec: VcVMwareDVSVspanConfigSpec[];

		constructor();
		constructor(configVersion?: String, name?: String, numStandalonePorts?: Number, maxPorts?: Number, uplinkPortPolicy?: VcDVSUplinkPortPolicy, uplinkPortgroup?: VcDistributedVirtualPortgroup[], defaultPortConfig?: VcDVPortSetting, host?: VcDistributedVirtualSwitchHostMemberConfigSpec[], extensionKey?: String, description?: String, policy?: VcDVSPolicy, vendorSpecificConfig?: VcDistributedVirtualSwitchKeyedOpaqueBlob[], contact?: VcDVSContactInfo, switchIpAddress?: String, defaultProxySwitchMaxNumPorts?: Number, infrastructureTrafficResourceConfig?: VcDvsHostInfrastructureTrafficResource[], networkResourceControlVersion?: String, pvlanConfigSpec?: VcVMwareDVSPvlanConfigSpec[], vspanConfigSpec?: VcVMwareDVSVspanConfigSpec[], maxMtu?: Number, linkDiscoveryProtocolConfig?: VcLinkDiscoveryProtocolConfig, ipfixConfig?: VcVMwareIpfixConfig, lacpApiVersion?: String, multicastFilteringMode?: String);
	}

	declare class VcVMwareDVSFeatureCapability
	{
		backupRestoreCapability: VcDVSBackupRestoreCapability;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		healthCheckCapability: VcDVSHealthCheckCapability;
		ipfixCapability: VcVMwareDvsIpfixCapability;
		ipfixSupported: boolean;
		lacpCapability: VcVMwareDvsLacpCapability;
		lldpSupported: boolean;
		multicastSnoopingSupported: boolean;
		networkFilterSupported: boolean;
		networkResourceManagementCapability: VcDVSNetworkResourceManagementCapability;
		networkResourceManagementSupported: boolean;
		networkResourcePoolHighShareValue: Number;
		nicTeamingPolicy: String[];
		rollbackCapability: VcDVSRollbackCapability;
		vmDirectPathGen2Supported: boolean;
		vspanCapability: VcVMwareDVSVspanCapability;
		vspanSupported: boolean;

		constructor();
		constructor(networkResourceManagementSupported?: boolean, vmDirectPathGen2Supported?: boolean, nicTeamingPolicy?: String[], networkResourcePoolHighShareValue?: Number, networkResourceManagementCapability?: VcDVSNetworkResourceManagementCapability, healthCheckCapability?: VcDVSHealthCheckCapability, rollbackCapability?: VcDVSRollbackCapability, backupRestoreCapability?: VcDVSBackupRestoreCapability, networkFilterSupported?: boolean, vspanSupported?: boolean, lldpSupported?: boolean, ipfixSupported?: boolean, ipfixCapability?: VcVMwareDvsIpfixCapability, multicastSnoopingSupported?: boolean, vspanCapability?: VcVMwareDVSVspanCapability, lacpCapability?: VcVMwareDvsLacpCapability);
		isIpfixSupported(): boolean;
		isLldpSupported(): boolean;
		isMulticastSnoopingSupported(): boolean;
		isNetworkFilterSupported(): boolean;
		isVspanSupported(): boolean;
	}

	declare class VcVMwareDVSHealthCheckCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		teamingSupported: boolean;
		vlanMtuSupported: boolean;

		constructor();
		constructor(vlanMtuSupported?: boolean, teamingSupported?: boolean);
	}

	declare class VcVMwareDVSHealthCheckConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enable: boolean;
		interval: Number;

		constructor();
		constructor(enable?: boolean, interval?: Number);
		isEnable(): boolean;
	}

	declare class VcVMwareDvsIpfixCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipfixSupported: boolean;
		ipv6ForIpfixSupported: boolean;
		observationDomainIdSupported: boolean;

		constructor();
		constructor(ipfixSupported?: boolean, ipv6ForIpfixSupported?: boolean, observationDomainIdSupported?: boolean);
		isIpfixSupported(): boolean;
		isIpv6ForIpfixSupported(): boolean;
		isObservationDomainIdSupported(): boolean;
	}

	interface VcVMwareDvsLacpApiVersion
	{
		readonly id: String;
		readonly multipleLag: VcVMwareDvsLacpApiVersion;
		readonly name: String;
		readonly singleLag: VcVMwareDvsLacpApiVersion;
		readonly value: String;

		fromString(value?: VcVMwareDvsLacpApiVersion): VcVMwareDvsLacpApiVersion;
	}

	declare const VcVMwareDvsLacpApiVersion: VcVMwareDvsLacpApiVersion;

	declare class VcVMwareDvsLacpCapability
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lacpSupported: boolean;
		multiLacpGroupSupported: boolean;

		constructor();
		constructor(lacpSupported?: boolean, multiLacpGroupSupported?: boolean);
		isLacpSupported(): boolean;
		isMultiLacpGroupSupported(): boolean;
	}

	declare class VcVMwareDvsLacpGroupConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipfix: VcVMwareDvsLagIpfixConfig;
		key: String;
		loadbalanceAlgorithm: String;
		mode: String;
		name: String;
		uplinkName: String[];
		uplinkNum: Number;
		uplinkPortKey: String[];
		vlan: VcVMwareDvsLagVlanConfig;

		constructor();
		constructor(key?: String, name?: String, mode?: String, uplinkNum?: Number, loadbalanceAlgorithm?: String, vlan?: VcVMwareDvsLagVlanConfig, ipfix?: VcVMwareDvsLagIpfixConfig, uplinkName?: String[], uplinkPortKey?: String[]);
	}

	declare class VcVMwareDvsLacpGroupSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lacpGroupConfig: VcVMwareDvsLacpGroupConfig;
		operation: String;

		constructor();
		constructor(lacpGroupConfig?: VcVMwareDvsLacpGroupConfig, operation?: String);
	}

	interface VcVMwareDvsLacpLoadBalanceAlgorithm
	{
		readonly destIp: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly destIpTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly destIpTcpUdpPortVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly destIpVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly destMac: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly destTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly id: String;
		readonly name: String;
		readonly srcDestIp: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcDestIpTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcDestIpTcpUdpPortVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcDestIpVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcDestMac: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcDestTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcIp: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcIpTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcIpTcpUdpPortVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcIpVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcMac: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcPortId: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly value: String;
		readonly vlan: VcVMwareDvsLacpLoadBalanceAlgorithm;

		fromString(value?: VcVMwareDvsLacpLoadBalanceAlgorithm): VcVMwareDvsLacpLoadBalanceAlgorithm;
	}

	declare const VcVMwareDvsLacpLoadBalanceAlgorithm: VcVMwareDvsLacpLoadBalanceAlgorithm;

	declare class VcVMwareDvsLagIpfixConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipfixEnabled: boolean;

		constructor();
		constructor(ipfixEnabled?: boolean);
		isIpfixEnabled(): boolean;
	}

	declare class VcVMwareDvsLagVlanConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vlanId: VcNumericRange[];

		constructor();
		constructor(vlanId?: VcNumericRange[]);
	}

	declare class VcVMwareDVSMtuHealthCheckResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mtuMismatch: boolean;
		summary: String;
		uplinkPortKey: String;
		vlanNotSupportSwitchMtu: VcNumericRange[];
		vlanSupportSwitchMtu: VcNumericRange[];

		constructor();
		constructor(summary?: String, uplinkPortKey?: String, mtuMismatch?: boolean, vlanSupportSwitchMtu?: VcNumericRange[], vlanNotSupportSwitchMtu?: VcNumericRange[]);
	}

	interface VcVMwareDvsMulticastFilteringMode
	{
		readonly id: String;
		readonly legacyFiltering: VcVMwareDvsMulticastFilteringMode;
		readonly name: String;
		readonly snooping: VcVMwareDvsMulticastFilteringMode;
		readonly value: String;

		fromString(value?: VcVMwareDvsMulticastFilteringMode): VcVMwareDvsMulticastFilteringMode;
	}

	declare const VcVMwareDvsMulticastFilteringMode: VcVMwareDvsMulticastFilteringMode;

	declare class VcVMwareDVSPortgroupPolicy
	{
		blockOverrideAllowed: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipfixOverrideAllowed: boolean;
		livePortMovingAllowed: boolean;
		networkResourcePoolOverrideAllowed: boolean;
		portConfigResetAtDisconnect: boolean;
		securityPolicyOverrideAllowed: boolean;
		shapingOverrideAllowed: boolean;
		trafficFilterOverrideAllowed: boolean;
		uplinkTeamingOverrideAllowed: boolean;
		vendorConfigOverrideAllowed: boolean;
		vlanOverrideAllowed: boolean;

		constructor();
		constructor(blockOverrideAllowed?: boolean, shapingOverrideAllowed?: boolean, vendorConfigOverrideAllowed?: boolean, livePortMovingAllowed?: boolean, portConfigResetAtDisconnect?: boolean, networkResourcePoolOverrideAllowed?: boolean, trafficFilterOverrideAllowed?: boolean, vlanOverrideAllowed?: boolean, uplinkTeamingOverrideAllowed?: boolean, securityPolicyOverrideAllowed?: boolean, ipfixOverrideAllowed?: boolean);
		isIpfixOverrideAllowed(): boolean;
		isNetworkResourcePoolOverrideAllowed(): boolean;
		isTrafficFilterOverrideAllowed(): boolean;
	}

	declare class VcVMwareDVSPortSetting
	{
		blocked: VcBoolPolicy;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		filterPolicy: VcDvsFilterPolicy;
		inShapingPolicy: VcDVSTrafficShapingPolicy;
		ipfixEnabled: VcBoolPolicy;
		lacpPolicy: VcVMwareUplinkLacpPolicy;
		networkResourcePoolKey: VcStringPolicy;
		outShapingPolicy: VcDVSTrafficShapingPolicy;
		qosTag: VcIntPolicy;
		securityPolicy: VcDVSSecurityPolicy;
		txUplink: VcBoolPolicy;
		uplinkTeamingPolicy: VcVmwareUplinkPortTeamingPolicy;
		vendorSpecificConfig: VcDVSVendorSpecificConfig;
		vlan: VcVmwareDistributedVirtualSwitchVlanSpec;
		vmDirectPathGen2Allowed: VcBoolPolicy;

		constructor();
		constructor(blocked?: VcBoolPolicy, vmDirectPathGen2Allowed?: VcBoolPolicy, inShapingPolicy?: VcDVSTrafficShapingPolicy, outShapingPolicy?: VcDVSTrafficShapingPolicy, vendorSpecificConfig?: VcDVSVendorSpecificConfig, networkResourcePoolKey?: VcStringPolicy, filterPolicy?: VcDvsFilterPolicy, vlan?: VcVmwareDistributedVirtualSwitchVlanSpec, qosTag?: VcIntPolicy, uplinkTeamingPolicy?: VcVmwareUplinkPortTeamingPolicy, securityPolicy?: VcDVSSecurityPolicy, ipfixEnabled?: VcBoolPolicy, txUplink?: VcBoolPolicy, lacpPolicy?: VcVMwareUplinkLacpPolicy);
	}

	declare class VcVMwareDVSPvlanConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operation: String;
		pvlanEntry: VcVMwareDVSPvlanMapEntry;

		constructor();
		constructor(pvlanEntry?: VcVMwareDVSPvlanMapEntry, operation?: String);
	}

	declare class VcVMwareDVSPvlanMapEntry
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		primaryVlanId: Number;
		pvlanType: String;
		secondaryVlanId: Number;

		constructor();
		constructor(primaryVlanId?: Number, secondaryVlanId?: Number, pvlanType?: String);
	}

	declare class VcVMwareDVSTeamingHealthCheckConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enable: boolean;
		interval: Number;

		constructor();
		constructor(enable?: boolean, interval?: Number);
		isEnable(): boolean;
	}

	declare class VcVMwareDVSTeamingHealthCheckResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		summary: String;
		teamingStatus: String;

		constructor();
		constructor(summary?: String, teamingStatus?: String);
	}

	interface VcVMwareDVSTeamingMatchStatus
	{
		readonly id: String;
		readonly iphashMatch: VcVMwareDVSTeamingMatchStatus;
		readonly iphashMismatch: VcVMwareDVSTeamingMatchStatus;
		readonly name: String;
		readonly nonIphashMatch: VcVMwareDVSTeamingMatchStatus;
		readonly nonIphashMismatch: VcVMwareDVSTeamingMatchStatus;
		readonly value: String;

		fromString(value?: VcVMwareDVSTeamingMatchStatus): VcVMwareDVSTeamingMatchStatus;
	}

	declare const VcVMwareDVSTeamingMatchStatus: VcVMwareDVSTeamingMatchStatus;

	declare class VcVMwareDVSVlanHealthCheckResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		summary: String;
		trunkedVlan: VcNumericRange[];
		untrunkedVlan: VcNumericRange[];
		uplinkPortKey: String;

		constructor();
		constructor(summary?: String, uplinkPortKey?: String, trunkedVlan?: VcNumericRange[], untrunkedVlan?: VcNumericRange[]);
	}

	declare class VcVMwareDVSVlanMtuHealthCheckConfig
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enable: boolean;
		interval: Number;

		constructor();
		constructor(enable?: boolean, interval?: Number);
		isEnable(): boolean;
	}

	declare class VcVMwareDVSVspanCapability
	{
		dvportSupported: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		encapRemoteSourceSupported: boolean;
		erspanProtocolSupported: boolean;
		mixedDestSupported: boolean;
		remoteDestSupported: boolean;
		remoteSourceSupported: boolean;

		constructor();
		constructor(mixedDestSupported?: boolean, dvportSupported?: boolean, remoteSourceSupported?: boolean, remoteDestSupported?: boolean, encapRemoteSourceSupported?: boolean, erspanProtocolSupported?: boolean);
		isErspanProtocolSupported(): boolean;
	}

	declare class VcVMwareDVSVspanConfigSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		operation: String;
		vspanSession: VcVMwareVspanSession;

		constructor();
		constructor(vspanSession?: VcVMwareVspanSession, operation?: String);
	}

	interface VcVMwareDVSVspanSessionEncapType
	{
		readonly erspan2: VcVMwareDVSVspanSessionEncapType;
		readonly erspan3: VcVMwareDVSVspanSessionEncapType;
		readonly gre: VcVMwareDVSVspanSessionEncapType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVMwareDVSVspanSessionEncapType): VcVMwareDVSVspanSessionEncapType;
	}

	declare const VcVMwareDVSVspanSessionEncapType: VcVMwareDVSVspanSessionEncapType;

	interface VcVMwareDVSVspanSessionType
	{
		readonly dvPortMirror: VcVMwareDVSVspanSessionType;
		readonly encapsulatedRemoteMirrorSource: VcVMwareDVSVspanSessionType;
		readonly id: String;
		readonly mixedDestMirror: VcVMwareDVSVspanSessionType;
		readonly name: String;
		readonly remoteMirrorDest: VcVMwareDVSVspanSessionType;
		readonly remoteMirrorSource: VcVMwareDVSVspanSessionType;
		readonly value: String;

		fromString(value?: VcVMwareDVSVspanSessionType): VcVMwareDVSVspanSessionType;
	}

	declare const VcVMwareDVSVspanSessionType: VcVMwareDVSVspanSessionType;

	declare class VcVMwareIpfixConfig
	{
		activeFlowTimeout: Number;
		collectorIpAddress: String;
		collectorPort: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		idleFlowTimeout: Number;
		internalFlowsOnly: boolean;
		observationDomainId: Number;
		samplingRate: Number;

		constructor();
		constructor(collectorIpAddress?: String, collectorPort?: Number, observationDomainId?: Number, activeFlowTimeout?: Number, idleFlowTimeout?: Number, samplingRate?: Number, internalFlowsOnly?: boolean);
	}

	interface VcVMwareUplinkLacpMode
	{
		readonly active: VcVMwareUplinkLacpMode;
		readonly id: String;
		readonly name: String;
		readonly passive: VcVMwareUplinkLacpMode;
		readonly value: String;

		fromString(value?: VcVMwareUplinkLacpMode): VcVMwareUplinkLacpMode;
	}

	declare const VcVMwareUplinkLacpMode: VcVMwareUplinkLacpMode;

	declare class VcVMwareUplinkLacpPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enable: VcBoolPolicy;
		inherited: boolean;
		mode: VcStringPolicy;

		constructor();
		constructor(inherited?: boolean, enable?: VcBoolPolicy, mode?: VcStringPolicy);
	}

	declare class VcVMwareUplinkPortOrderPolicy
	{
		activeUplinkPort: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		inherited: boolean;
		standbyUplinkPort: String[];

		constructor();
		constructor(inherited?: boolean, activeUplinkPort?: String[], standbyUplinkPort?: String[]);
	}

	declare class VcVmwareUplinkPortTeamingPolicy
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failureCriteria: VcDVSFailureCriteria;
		inherited: boolean;
		notifySwitches: VcBoolPolicy;
		policy: VcStringPolicy;
		reversePolicy: VcBoolPolicy;
		rollingOrder: VcBoolPolicy;
		uplinkPortOrder: VcVMwareUplinkPortOrderPolicy;

		constructor();
		constructor(inherited?: boolean, policy?: VcStringPolicy, reversePolicy?: VcBoolPolicy, notifySwitches?: VcBoolPolicy, rollingOrder?: VcBoolPolicy, failureCriteria?: VcDVSFailureCriteria, uplinkPortOrder?: VcVMwareUplinkPortOrderPolicy);
	}

	declare class VcVMwareVspanPort
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipAddress: String[];
		portKey: String[];
		uplinkPortName: String[];
		vlans: Number[];
		wildcardPortConnecteeType: String[];

		constructor();
		constructor(portKey?: String[], uplinkPortName?: String[], wildcardPortConnecteeType?: String[], vlans?: Number[], ipAddress?: String[]);
	}

	declare class VcVMwareVspanSession
	{
		description: String;
		destinationPort: VcVMwareVspanPort;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		encapsulationVlanId: Number;
		encapType: String;
		erspanCOS: Number;
		erspanGraNanosec: boolean;
		erspanId: Number;
		key: String;
		mirroredPacketLength: Number;
		name: String;
		normalTrafficAllowed: boolean;
		samplingRate: Number;
		sessionType: String;
		sourcePortReceived: VcVMwareVspanPort;
		sourcePortTransmitted: VcVMwareVspanPort;
		stripOriginalVlan: boolean;

		constructor();
		constructor(key?: String, name?: String, description?: String, enabled?: boolean, sourcePortTransmitted?: VcVMwareVspanPort, sourcePortReceived?: VcVMwareVspanPort, destinationPort?: VcVMwareVspanPort, encapsulationVlanId?: Number, stripOriginalVlan?: boolean, mirroredPacketLength?: Number, normalTrafficAllowed?: boolean, sessionType?: String, samplingRate?: Number, encapType?: String, erspanId?: Number, erspanCOS?: Number, erspanGraNanosec?: boolean);
		isErspanGraNanosec(): boolean;
	}

	declare class VcVmWwnAssignedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		nodeWwns: Number[];
		portWwns: Number[];
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, nodeWwns?: Number[], portWwns?: Number[]);
	}

	declare class VcVmWwnChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newNodeWwns: Number[];
		newPortWwns: Number[];
		oldNodeWwns: Number[];
		oldPortWwns: Number[];
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, oldNodeWwns?: Number[], oldPortWwns?: Number[], newNodeWwns?: Number[], newPortWwns?: Number[]);
	}

	declare class VcVmWwnConflict
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		host: VcHostSystem;
		readonly localizedMessage: String;
		message: String;
		name: String;
		property: String;
		vm: VcVirtualMachine;
		wwn: Number;

		constructor();
		constructor(property?: String, vm?: VcVirtualMachine, host?: VcHostSystem, name?: String, wwn?: Number);
		printStackTrace(): void;
	}

	declare class VcVmWwnConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedHosts: VcHostEventArgument[];
		conflictedVms: VcVmEventArgument[];
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;
		wwn: Number;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, template?: boolean, conflictedVms?: VcVmEventArgument[], conflictedHosts?: VcHostEventArgument[], wwn?: Number);
	}

	declare class VcVnicPortArgument
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		port: VcDistributedVirtualSwitchPortConnection;
		vnic: String;

		constructor();
		constructor(vnic?: String, port?: VcDistributedVirtualSwitchPortConnection);
	}

	declare class VcVolumeEditorError
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVramLimitLicense
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		limit: Number;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(limit?: Number);
		printStackTrace(): void;
	}

	declare class VcVRPEditSpec
	{
		addedHubs: VcManagedEntity[];
		changeVersion: Number;
		cpuAllocation: VcVrpResourceAllocationInfo;
		description: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		memoryAllocation: VcVrpResourceAllocationInfo;
		removedHubs: VcManagedEntity[];
		vrpId: String;

		constructor();
		constructor(vrpId?: String, description?: String, cpuAllocation?: VcVrpResourceAllocationInfo, memoryAllocation?: VcVrpResourceAllocationInfo, addedHubs?: VcManagedEntity[], removedHubs?: VcManagedEntity[], changeVersion?: Number);
	}

	declare class VcVrpResourceAllocationInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expandableReservation: boolean;
		limit: Number;
		overheadLimit: Number;
		reservation: Number;
		reservationLimit: Number;
		shares: VcSharesInfo;

		constructor();
		constructor(reservation?: Number, expandableReservation?: boolean, limit?: Number, shares?: VcSharesInfo, overheadLimit?: Number, reservationLimit?: Number);
		isExpandableReservation(): boolean;
	}

	interface VcVRPResourceManager
	{
		allVRPIds: String[];
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVRP(arg0?: VcVirtualResourcePoolSpec): String;
		deleteVRP(arg0?: String): void;
		deployVM(arg0?: String, arg1?: VcVirtualMachine, arg2?: VcManagedEntity): void;
		getChildRPforHub(arg0?: String, arg1?: VcManagedEntity): VcResourcePool;
		getRPSettings(arg0?: VcResourcePool): VcResourceConfigSpec;
		getVRPofVM(arg0?: VcVirtualMachine): String;
		getVRPSettings(arg0?: String): VcVirtualResourcePoolSpec;
		getVRPUsage(arg0?: String): VcVirtualResourcePoolUsage;
		setManagedByVDC(arg0?: VcManagedEntity, arg1?: boolean): void;
		undeployVM(arg0?: String, arg1?: VcVirtualMachine, arg2?: VcManagedEntity): void;
		updateVRP(arg0?: VcVRPEditSpec): void;
	}

	declare const VcVRPResourceManager: VcVRPResourceManager;

	declare class VcVsanClusterConfigInfo
	{
		defaultConfig: VcVsanClusterConfigInfoHostDefaultInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;

		constructor();
		constructor(enabled?: boolean, defaultConfig?: VcVsanClusterConfigInfoHostDefaultInfo);
		isEnabled(): boolean;
	}

	declare class VcVsanClusterConfigInfoHostDefaultInfo
	{
		autoClaimStorage: boolean;
		checksumEnabled: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		uuid: String;

		constructor();
		constructor(uuid?: String, autoClaimStorage?: boolean, checksumEnabled?: boolean);
		isAutoClaimStorage(): boolean;
		isChecksumEnabled(): boolean;
	}

	declare class VcVsanClusterUuidMismatch
	{
		destinationClusterUuid: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		hostClusterUuid: String;
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(hostClusterUuid?: String, destinationClusterUuid?: String);
		printStackTrace(): void;
	}

	declare class VcVsanDecommissioningBatch
	{
		dp: VcVsanDecomParam[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mode: VcVsanHostDecommissionMode;

		constructor();
		constructor(mode?: VcVsanHostDecommissionMode, dp?: VcVsanDecomParam[]);
	}

	declare class VcVsanDecommissioningCost
	{
		copyDataSize: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		flashReadCacheSize: Number;
		usedDataSize: Number;

		constructor();
		constructor(copyDataSize?: Number, usedDataSize?: Number, flashReadCacheSize?: Number);
	}

	declare class VcVsanDecommissioningSatisfiability
	{
		canDecommission: boolean;
		cost: VcVsanDecommissioningCost;
		dp: VcVsanDecomParam;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		reason: VcLocalizableMessage;

		constructor();
		constructor(canDecommission?: boolean, reason?: VcLocalizableMessage, cost?: VcVsanDecommissioningCost, dp?: VcVsanDecomParam);
	}

	declare class VcVsanDecomParam
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nodeUUID: String;
		scsiDisk: VcHostScsiDisk;

		constructor();
		constructor(nodeUUID?: String, scsiDisk?: VcHostScsiDisk);
	}

	declare class VcVsanDiskFault
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	interface VcVsanDiskIssueType
	{
		readonly id: String;
		readonly name: String;
		readonly nonExist: VcVsanDiskIssueType;
		readonly stampMismatch: VcVsanDiskIssueType;
		readonly unknown: VcVsanDiskIssueType;
		readonly value: String;

		fromString(value?: VcVsanDiskIssueType): VcVsanDiskIssueType;
	}

	declare const VcVsanDiskIssueType: VcVsanDiskIssueType;

	declare class VcVsanFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcVsanHostClusterStatus
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		health: String;
		memberUuid: String[];
		nodeState: VcVsanHostClusterStatusState;
		nodeUuid: String;
		uuid: String;

		constructor();
		constructor(uuid?: String, nodeUuid?: String, health?: String, nodeState?: VcVsanHostClusterStatusState, memberUuid?: String[]);
	}

	declare class VcVsanHostClusterStatusState
	{
		completion: VcVsanHostClusterStatusStateCompletionEstimate;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		state: String;

		constructor();
		constructor(state?: String, completion?: VcVsanHostClusterStatusStateCompletionEstimate);
	}

	declare class VcVsanHostClusterStatusStateCompletionEstimate
	{
		completeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		percentComplete: Number;

		constructor();
		constructor(completeTime?: Date, percentComplete?: Number);
	}

	declare class VcVsanHostConfigInfo
	{
		clusterInfo: VcVsanHostConfigInfoClusterInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		enabled: boolean;
		faultDomainInfo: VcVsanHostFaultDomainInfo;
		hostSystem: VcHostSystem;
		networkInfo: VcVsanHostConfigInfoNetworkInfo;
		storageInfo: VcVsanHostConfigInfoStorageInfo;

		constructor();
		constructor(enabled?: boolean, hostSystem?: VcHostSystem, clusterInfo?: VcVsanHostConfigInfoClusterInfo, storageInfo?: VcVsanHostConfigInfoStorageInfo, networkInfo?: VcVsanHostConfigInfoNetworkInfo, faultDomainInfo?: VcVsanHostFaultDomainInfo);
		isEnabled(): boolean;
	}

	declare class VcVsanHostConfigInfoClusterInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nodeUuid: String;
		uuid: String;

		constructor();
		constructor(uuid?: String, nodeUuid?: String);
	}

	declare class VcVsanHostConfigInfoNetworkInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		port: VcVsanHostConfigInfoNetworkInfoPortConfig[];

		constructor();
		constructor(port?: VcVsanHostConfigInfoNetworkInfoPortConfig[]);
	}

	declare class VcVsanHostConfigInfoNetworkInfoPortConfig
	{
		device: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipConfig: VcVsanHostIpConfig;

		constructor();
		constructor(ipConfig?: VcVsanHostIpConfig, device?: String);
	}

	declare class VcVsanHostConfigInfoStorageInfo
	{
		autoClaimStorage: boolean;
		checksumEnabled: boolean;
		diskMapInfo: VcVsanHostDiskMapInfo[];
		diskMapping: VcVsanHostDiskMapping[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(autoClaimStorage?: boolean, diskMapping?: VcVsanHostDiskMapping[], diskMapInfo?: VcVsanHostDiskMapInfo[], checksumEnabled?: boolean);
		isAutoClaimStorage(): boolean;
		isChecksumEnabled(): boolean;
	}

	declare class VcVsanHostDecommissionMode
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		objectAction: String;

		constructor();
		constructor(objectAction?: String);
	}

	interface VcVsanHostDecommissionModeObjectAction
	{
		readonly ensureObjectAccessibility: VcVsanHostDecommissionModeObjectAction;
		readonly evacuateAllData: VcVsanHostDecommissionModeObjectAction;
		readonly id: String;
		readonly name: String;
		readonly noAction: VcVsanHostDecommissionModeObjectAction;
		readonly value: String;

		fromString(value?: VcVsanHostDecommissionModeObjectAction): VcVsanHostDecommissionModeObjectAction;
	}

	declare const VcVsanHostDecommissionModeObjectAction: VcVsanHostDecommissionModeObjectAction;

	declare class VcVsanHostDiskMapInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mapping: VcVsanHostDiskMapping;
		mounted: boolean;

		constructor();
		constructor(mapping?: VcVsanHostDiskMapping, mounted?: boolean);
	}

	declare class VcVsanHostDiskMapping
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		nonSsd: VcHostScsiDisk[];
		ssd: VcHostScsiDisk;

		constructor();
		constructor(ssd?: VcHostScsiDisk, nonSsd?: VcHostScsiDisk[]);
	}

	declare class VcVsanHostDiskMapResult
	{
		diskResult: VcVsanHostDiskResult[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault;
		mapping: VcVsanHostDiskMapping;

		constructor();
		constructor(mapping?: VcVsanHostDiskMapping, diskResult?: VcVsanHostDiskResult[], error?: VcLocalizedMethodFault);
	}

	declare class VcVsanHostDiskResult
	{
		degraded: boolean;
		disk: VcHostScsiDisk;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		error: VcLocalizedMethodFault;
		state: String;
		vsanUuid: String;

		constructor();
		constructor(disk?: VcHostScsiDisk, state?: String, vsanUuid?: String, error?: VcLocalizedMethodFault, degraded?: boolean);
		isDegraded(): boolean;
	}

	interface VcVsanHostDiskResultState
	{
		readonly eligible: VcVsanHostDiskResultState;
		readonly id: String;
		readonly ineligible: VcVsanHostDiskResultState;
		readonly inUse: VcVsanHostDiskResultState;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVsanHostDiskResultState): VcVsanHostDiskResultState;
	}

	declare const VcVsanHostDiskResultState: VcVsanHostDiskResultState;

	declare class VcVsanHostFaultDomainInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;

		constructor();
		constructor(name?: String);
	}

	interface VcVsanHostHealthState
	{
		readonly healthy: VcVsanHostHealthState;
		readonly id: String;
		readonly name: String;
		readonly unhealthy: VcVsanHostHealthState;
		readonly unknown: VcVsanHostHealthState;
		readonly value: String;

		fromString(value?: VcVsanHostHealthState): VcVsanHostHealthState;
	}

	declare const VcVsanHostHealthState: VcVsanHostHealthState;

	declare class VcVsanHostIpConfig
	{
		downstreamIpAddress: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		upstreamIpAddress: String;

		constructor();
		constructor(upstreamIpAddress?: String, downstreamIpAddress?: String);
	}

	declare class VcVsanHostMembershipInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hostname: String;
		nodeUuid: String;

		constructor();
		constructor(nodeUuid?: String, hostname?: String);
	}

	interface VcVsanHostNodeState
	{
		readonly agent: VcVsanHostNodeState;
		readonly backup: VcVsanHostNodeState;
		readonly decommissioning: VcVsanHostNodeState;
		readonly disabled: VcVsanHostNodeState;
		readonly enteringMaintenanceMode: VcVsanHostNodeState;
		readonly error: VcVsanHostNodeState;
		readonly exitingMaintenanceMode: VcVsanHostNodeState;
		readonly id: String;
		readonly master: VcVsanHostNodeState;
		readonly name: String;
		readonly starting: VcVsanHostNodeState;
		readonly stopping: VcVsanHostNodeState;
		readonly value: String;

		fromString(value?: VcVsanHostNodeState): VcVsanHostNodeState;
	}

	declare const VcVsanHostNodeState: VcVsanHostNodeState;

	declare class VcVsanHostRuntimeInfo
	{
		accessGenNo: Number;
		diskIssues: VcVsanHostRuntimeInfoDiskIssue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		membershipList: VcVsanHostMembershipInfo[];

		constructor();
		constructor(membershipList?: VcVsanHostMembershipInfo[], diskIssues?: VcVsanHostRuntimeInfoDiskIssue[], accessGenNo?: Number);
	}

	declare class VcVsanHostRuntimeInfoDiskIssue
	{
		diskId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		issue: String;

		constructor();
		constructor(diskId?: String, issue?: String);
	}

	declare class VcVsanHostVsanDiskInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		formatVersion: Number;
		vsanUuid: String;

		constructor();
		constructor(vsanUuid?: String, formatVersion?: Number);
	}

	declare class VcVsanIncompatibleDiskMapping
	{
		device: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		constructor(device?: String);
		printStackTrace(): void;
	}

	declare class VcVsanNewPolicyBatch
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policy: String;
		size: Number[];

		constructor();
		constructor(size?: Number[], policy?: String);
	}

	declare class VcVsanPolicyChangeBatch
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		policy: String;
		uuid: String[];

		constructor();
		constructor(uuid?: String[], policy?: String);
	}

	declare class VcVsanPolicyCost
	{
		changeDataSize: Number;
		changeFlashReadCacheSize: Number;
		copyDataSize: Number;
		currentDataSize: Number;
		currentDiskSpaceToAddressSpaceRatio: Number;
		currentFlashReadCacheSize: Number;
		diskSpaceToAddressSpaceRatio: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		tempDataSize: Number;

		constructor();
		constructor(changeDataSize?: Number, currentDataSize?: Number, tempDataSize?: Number, copyDataSize?: Number, changeFlashReadCacheSize?: Number, currentFlashReadCacheSize?: Number, currentDiskSpaceToAddressSpaceRatio?: Number, diskSpaceToAddressSpaceRatio?: Number);
	}

	declare class VcVsanPolicySatisfiability
	{
		cost: VcVsanPolicyCost;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		isSatisfiable: boolean;
		reason: VcLocalizableMessage;
		uuid: String;

		constructor();
		constructor(uuid?: String, isSatisfiable?: boolean, reason?: VcLocalizableMessage, cost?: VcVsanPolicyCost);
	}

	interface VcVsanUpgradeSystem
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		performVsanUpgrade_Task(arg0?: VcClusterComputeResource, arg1?: boolean, arg2?: boolean, arg3?: boolean, arg4?: VcHostSystem[]): VcTask;
		performVsanUpgradePreflightCheck(arg0?: VcClusterComputeResource, arg1?: boolean): VcVsanUpgradeSystemPreflightCheckResult;
		queryVsanUpgradeStatus(arg0?: VcClusterComputeResource): VcVsanUpgradeSystemUpgradeStatus;
	}

	declare const VcVsanUpgradeSystem: VcVsanUpgradeSystem;

	declare class VcVsanUpgradeSystemAPIBrokenIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hosts: VcHostSystem[];
		msg: String;

		constructor();
		constructor(msg?: String, hosts?: VcHostSystem[]);
	}

	declare class VcVsanUpgradeSystemAutoClaimEnabledOnHostsIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hosts: VcHostSystem[];
		msg: String;

		constructor();
		constructor(msg?: String, hosts?: VcHostSystem[]);
	}

	declare class VcVsanUpgradeSystemHostsDisconnectedIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hosts: VcHostSystem[];
		msg: String;

		constructor();
		constructor(msg?: String, hosts?: VcHostSystem[]);
	}

	declare class VcVsanUpgradeSystemMissingHostsInClusterIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hosts: VcHostSystem[];
		msg: String;

		constructor();
		constructor(msg?: String, hosts?: VcHostSystem[]);
	}

	declare class VcVsanUpgradeSystemNetworkPartitionInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hosts: VcHostSystem[];

		constructor();
		constructor(hosts?: VcHostSystem[]);
	}

	declare class VcVsanUpgradeSystemNetworkPartitionIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		msg: String;
		partitions: VcVsanUpgradeSystemNetworkPartitionInfo[];

		constructor();
		constructor(msg?: String, partitions?: VcVsanUpgradeSystemNetworkPartitionInfo[]);
	}

	declare class VcVsanUpgradeSystemNotEnoughFreeCapacityIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		msg: String;
		reducedRedundancyUpgradePossible: boolean;

		constructor();
		constructor(msg?: String, reducedRedundancyUpgradePossible?: boolean);
	}

	declare class VcVsanUpgradeSystemPreflightCheckIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		msg: String;

		constructor();
		constructor(msg?: String);
	}

	declare class VcVsanUpgradeSystemPreflightCheckResult
	{
		diskMappingToRestore: VcVsanHostDiskMapping;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		issues: VcVsanUpgradeSystemPreflightCheckIssue[];

		constructor();
		constructor(issues?: VcVsanUpgradeSystemPreflightCheckIssue[], diskMappingToRestore?: VcVsanHostDiskMapping);
	}

	declare class VcVsanUpgradeSystemRogueHostsInClusterIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		msg: String;
		uuids: String[];

		constructor();
		constructor(msg?: String, uuids?: String[]);
	}

	declare class VcVsanUpgradeSystemUpgradeHistoryDiskGroupOp
	{
		diskMapping: VcVsanHostDiskMapping;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		message: String;
		operation: String;
		task: VcTask;
		timestamp: Date;

		constructor();
		constructor(timestamp?: Date, host?: VcHostSystem, message?: String, task?: VcTask, operation?: String, diskMapping?: VcVsanHostDiskMapping);
	}

	interface VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType
	{
		readonly add: VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
		readonly id: String;
		readonly name: String;
		readonly remove: VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
		readonly value: String;

		fromString(value?: VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType): VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
	}

	declare const VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType: VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType;

	declare class VcVsanUpgradeSystemUpgradeHistoryItem
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		message: String;
		task: VcTask;
		timestamp: Date;

		constructor();
		constructor(timestamp?: Date, host?: VcHostSystem, message?: String, task?: VcTask);
	}

	declare class VcVsanUpgradeSystemUpgradeHistoryPreflightFail
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		host: VcHostSystem;
		message: String;
		preflightResult: VcVsanUpgradeSystemPreflightCheckResult;
		task: VcTask;
		timestamp: Date;

		constructor();
		constructor(timestamp?: Date, host?: VcHostSystem, message?: String, task?: VcTask, preflightResult?: VcVsanUpgradeSystemPreflightCheckResult);
	}

	declare class VcVsanUpgradeSystemUpgradeStatus
	{
		aborted: boolean;
		completed: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		history: VcVsanUpgradeSystemUpgradeHistoryItem[];
		inProgress: boolean;
		progress: Number;

		constructor();
		constructor(inProgress?: boolean, history?: VcVsanUpgradeSystemUpgradeHistoryItem[], aborted?: boolean, completed?: boolean, progress?: Number);
		isAborted(): boolean;
		isCompleted(): boolean;
	}

	declare class VcVsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		msg: String;
		uuids: String[];

		constructor();
		constructor(msg?: String, uuids?: String[]);
	}

	declare class VcVsanUpgradeSystemWrongEsxVersionIssue
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		hosts: VcHostSystem[];
		msg: String;

		constructor();
		constructor(msg?: String, hosts?: VcHostSystem[]);
	}

	declare class VcVslmCloneSpec
	{
		backingSpec: VcVslmCreateSpecBackingSpec;
		consolidate: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(backingSpec?: VcVslmCreateSpecBackingSpec, profile?: VcVirtualMachineProfileSpec[], consolidate?: boolean, name?: String);
		isConsolidate(): boolean;
	}

	declare class VcVslmCreateSpec
	{
		backingSpec: VcVslmCreateSpecBackingSpec;
		capacityInMB: Number;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		name: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(name?: String, backingSpec?: VcVslmCreateSpecBackingSpec, capacityInMB?: Number, profile?: VcVirtualMachineProfileSpec[]);
	}

	declare class VcVslmCreateSpecBackingSpec
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor();
		constructor(datastore?: VcDatastore);
	}

	declare class VcVslmCreateSpecDiskFileBackingSpec
	{
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		provisioningType: String;

		constructor();
		constructor(datastore?: VcDatastore, provisioningType?: String);
	}

	declare class VcVslmCreateSpecRawDiskMappingBackingSpec
	{
		compatibilityMode: String;
		datastore: VcDatastore;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		lunUuid: String;

		constructor();
		constructor(datastore?: VcDatastore, lunUuid?: String, compatibilityMode?: String);
	}

	declare class VcVslmMigrateSpec
	{
		backingSpec: VcVslmCreateSpecBackingSpec;
		consolidate: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(backingSpec?: VcVslmCreateSpecBackingSpec, profile?: VcVirtualMachineProfileSpec[], consolidate?: boolean);
		isConsolidate(): boolean;
	}

	declare class VcVslmRelocateSpec
	{
		backingSpec: VcVslmCreateSpecBackingSpec;
		consolidate: boolean;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
		constructor(backingSpec?: VcVslmCreateSpecBackingSpec, profile?: VcVirtualMachineProfileSpec[], consolidate?: boolean);
		isConsolidate(): boolean;
	}

	declare class VcVslmTagEntry
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		parentCategoryName: String;
		tagName: String;

		constructor();
		constructor(tagName?: String, parentCategoryName?: String);
	}

	declare class VcVspanDestPortConflict
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		portKey: String;
		vspanSessionKey1: String;
		vspanSessionKey2: String;

		constructor();
		constructor(vspanSessionKey1?: String, vspanSessionKey2?: String, portKey?: String);
		printStackTrace(): void;
	}

	declare class VcVspanPortConflict
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		portKey: String;
		vspanSessionKey1: String;
		vspanSessionKey2: String;

		constructor();
		constructor(vspanSessionKey1?: String, vspanSessionKey2?: String, portKey?: String);
		printStackTrace(): void;
	}

	declare class VcVspanPortgroupPromiscChangeFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		portgroupName: String;

		constructor();
		constructor(portgroupName?: String);
		printStackTrace(): void;
	}

	declare class VcVspanPortgroupTypeChangeFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		portgroupName: String;

		constructor();
		constructor(portgroupName?: String);
		printStackTrace(): void;
	}

	declare class VcVspanPortMoveFault
	{
		destPortgroupName: String;
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		portKey: String;
		srcPortgroupName: String;

		constructor();
		constructor(srcPortgroupName?: String, destPortgroupName?: String, portKey?: String);
		printStackTrace(): void;
	}

	declare class VcVspanPortPromiscChangeFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		portKey: String;

		constructor();
		constructor(portKey?: String);
		printStackTrace(): void;
	}

	declare class VcVspanPromiscuousPortNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		portKey: String;
		vspanSessionKey: String;

		constructor();
		constructor(vspanSessionKey?: String, portKey?: String);
		printStackTrace(): void;
	}

	declare class VcVspanSameSessionPortConflict
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		portKey: String;
		vspanSessionKey: String;

		constructor();
		constructor(vspanSessionKey?: String, portKey?: String);
		printStackTrace(): void;
	}

	declare class VcVStorageObject
	{
		config: VcVStorageObjectConfigInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor(config?: VcVStorageObjectConfigInfo);
		constructor();
	}

	declare class VcVStorageObjectAssociations
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcID;
		vmDiskAssociations: VcVStorageObjectAssociationsVmDiskAssociations[];

		constructor();
		constructor(id?: VcID, vmDiskAssociations?: VcVStorageObjectAssociationsVmDiskAssociations[]);
	}

	declare class VcVStorageObjectAssociationsVmDiskAssociations
	{
		diskKeys: String[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vmId: String;

		constructor();
		constructor(vmId?: String, diskKeys?: String[]);
	}

	declare class VcVStorageObjectConfigInfo
	{
		backing: VcBaseConfigInfoBackingInfo;
		capacityInMB: Number;
		consumerId: VcID[];
		consumptionType: String[];
		createTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcID;
		iofilter: String[];
		name: String;

		constructor();
		constructor(id?: VcID, name?: String, createTime?: Date, backing?: VcBaseConfigInfoBackingInfo, iofilter?: String[], capacityInMB?: Number, consumptionType?: String[], consumerId?: VcID[]);
	}

	interface VcVStorageObjectConsumptionType
	{
		readonly disk: VcVStorageObjectConsumptionType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: VcVStorageObjectConsumptionType): VcVStorageObjectConsumptionType;
	}

	declare const VcVStorageObjectConsumptionType: VcVStorageObjectConsumptionType;

	interface VcVStorageObjectManagerBase
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcVStorageObjectManagerBase: VcVStorageObjectManagerBase;

	declare class VcVStorageObjectSnapshot
	{
		config: VcVStorageObjectSnapshotSnapshotConfigInfo;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;

		constructor(config?: VcVStorageObjectSnapshotSnapshotConfigInfo);
		constructor();
	}

	declare class VcVStorageObjectSnapshotSnapshotConfigInfo
	{
		backing: VcBaseConfigInfoBackingInfo;
		createTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		id: VcID;
		iofilter: String[];
		name: String;
		vStorageObjectInfo: VcObjectInfo[];

		constructor();
		constructor(id?: VcID, name?: String, createTime?: Date, backing?: VcBaseConfigInfoBackingInfo, iofilter?: String[], vStorageObjectInfo?: VcObjectInfo[]);
	}

	declare class VcVStorageObjectStateInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		tentative: boolean;

		constructor();
		constructor(tentative?: boolean);
		isTentative(): boolean;
	}

	declare class VcVvolDatastoreInfo
	{
		containerId: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		freeSpace: Number;
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxVirtualDiskCapacity: Number;
		name: String;
		timestamp: Date;
		url: String;
		vvolDS: VcHostVvolVolume;

		constructor();
		constructor(name?: String, url?: String, freeSpace?: Number, maxFileSize?: Number, maxVirtualDiskCapacity?: Number, maxMemoryFileSize?: Number, timestamp?: Date, containerId?: String, vvolDS?: VcHostVvolVolume);
	}

	declare class VcVvolDatastoreSpec
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		vvol: VcHostVvolVolumeSpecification;

		constructor();
		constructor(vvol?: VcHostVvolVolumeSpecification);
	}

	declare class VcVVolHostPE
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		key: VcHostSystem;
		protocolEndpoint: VcHostProtocolEndpoint[];

		constructor();
		constructor(key?: VcHostSystem, protocolEndpoint?: VcHostProtocolEndpoint[]);
	}

	declare class VcVVolVmConfigFileUpdateResult
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		failedVmConfigFile: VcVVolVmConfigFileUpdateResultFailedVmConfigFileInfo[];
		succeededVmConfigFile: VcKeyValue[];

		constructor();
		constructor(succeededVmConfigFile?: VcKeyValue[], failedVmConfigFile?: VcVVolVmConfigFileUpdateResultFailedVmConfigFileInfo[]);
	}

	declare class VcVVolVmConfigFileUpdateResultFailedVmConfigFileInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		targetConfigVVolId: String;

		constructor();
		constructor(targetConfigVVolId?: String, fault?: VcLocalizedMethodFault);
	}

	declare class VcVwirePort
	{
		connectee: VcDistributedVirtualSwitchPortConnectee;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		port: VcDistributedVirtualSwitchPortConnection;

		constructor();
		constructor(port?: VcDistributedVirtualSwitchPortConnection, connectee?: VcDistributedVirtualSwitchPortConnectee);
	}

	declare class VcWaitOptions
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		maxObjectUpdates: Number;
		maxWaitSeconds: Number;

		constructor();
		constructor(maxWaitSeconds?: Number, maxObjectUpdates?: Number);
	}

	declare class VcWakeOnLanNotSupported
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcWakeOnLanNotSupportedByVmotionNIC
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcWarningUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
		constructor(key?: Number, chainId?: Number, createdTime?: Date, userName?: String, datacenter?: VcDatacenterEventArgument, computeResource?: VcComputeResourceEventArgument, host?: VcHostEventArgument, vm?: VcVmEventArgument, ds?: VcDatastoreEventArgument, net?: VcNetworkEventArgument, dvs?: VcDvsEventArgument, fullFormattedMessage?: String, changeTag?: String, message?: String);
	}

	declare class VcWeeklyTaskScheduler
	{
		activeTime: Date;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		expireTime: Date;
		friday: boolean;
		hour: Number;
		interval: Number;
		minute: Number;
		monday: boolean;
		saturday: boolean;
		sunday: boolean;
		thursday: boolean;
		tuesday: boolean;
		wednesday: boolean;

		constructor();
		constructor(activeTime?: Date, expireTime?: Date, interval?: Number, minute?: Number, hour?: Number, sunday?: boolean, monday?: boolean, tuesday?: boolean, wednesday?: boolean, thursday?: boolean, friday?: boolean, saturday?: boolean);
	}

	interface VcWeekOfMonth
	{
		readonly first: VcWeekOfMonth;
		readonly fourth: VcWeekOfMonth;
		readonly id: String;
		readonly last: VcWeekOfMonth;
		readonly name: String;
		readonly second: VcWeekOfMonth;
		readonly third: VcWeekOfMonth;
		readonly value: String;

		fromString(value?: VcWeekOfMonth): VcWeekOfMonth;
	}

	declare const VcWeekOfMonth: VcWeekOfMonth;

	declare class VcWillLoseHAProtection
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;
		resolution: String;

		constructor();
		constructor(resolution?: String);
		printStackTrace(): void;
	}

	interface VcWillLoseHAProtectionResolution
	{
		readonly id: String;
		readonly name: String;
		readonly relocate: VcWillLoseHAProtectionResolution;
		readonly svmotion: VcWillLoseHAProtectionResolution;
		readonly value: String;

		fromString(value?: VcWillLoseHAProtectionResolution): VcWillLoseHAProtectionResolution;
	}

	declare const VcWillLoseHAProtectionResolution: VcWillLoseHAProtectionResolution;

	declare class VcWillModifyConfigCpuRequirements
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcWillResetSnapshotDirectory
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcWinNetBIOSConfigInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		mode: String;
		primaryWINS: String;
		secondaryWINS: String;

		constructor();
		constructor(mode?: String, primaryWINS?: String, secondaryWINS?: String);
	}

	declare class VcWipeDiskFault
	{
		faultCause: VcLocalizedMethodFault;
		faultMessage: VcLocalizableMessage[];
		readonly localizedMessage: String;
		message: String;

		constructor();
		printStackTrace(): void;
	}

	declare class VcWitnessNodeInfo
	{
		biosUuid: String;
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		ipSettings: VcCustomizationIPSettings;

		constructor();
		constructor(ipSettings?: VcCustomizationIPSettings, biosUuid?: String);
	}

	interface VcWorkflowStepHandler
	{
		id: String;
		moref: VcManagedObjectReference;
		sdkConnection: VcSdkConnection;
		sdkId: String;
		type: String;
		vimHost: VcSdkConnection;
		vimId: String;
		vimType: String;

		_getRef(): VcManagedObjectReference;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		executeStep(arg0?: VcContext): VcWorkflowStepHandlerResult;
		finalizeStep(arg0?: VcContext, arg1?: VcLocalizedMethodFault): void;
		undoStep(arg0?: VcContext, arg1?: VcLocalizedMethodFault): void;
	}

	declare const VcWorkflowStepHandler: VcWorkflowStepHandler;

	declare class VcWorkflowStepHandlerInfo
	{
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		handler: VcWorkflowStepHandler;
		serviceKey: String;

		constructor();
		constructor(serviceKey?: String, handler?: VcWorkflowStepHandler);
	}

	declare class VcWorkflowStepHandlerResult
	{
		data: VcKeyAnyValue[];
		dynamicProperty: VcDynamicProperty[];
		dynamicType: String;
		fault: VcLocalizedMethodFault;
		tasksInProgress: VcTask[];

		constructor();
		constructor(data?: VcKeyAnyValue[], fault?: VcLocalizedMethodFault, tasksInProgress?: VcTask[]);
	}

    
    // Finder objects.
declare namespace VC {
	interface _ROOT
	{

		getSdkConnections(): SdkConnection;
	}

	interface _ROOTConstructor {
		new(value?:any): _ROOT;
		readonly prototype: _ROOT;
	}

	const _ROOT: _ROOTConstructor;

	interface ActionParameter extends VcActionParameter
	{
		name: any;

	}

	interface ActionParameterConstructor {
		new(value?:any): ActionParameter;
		readonly prototype: ActionParameter;
	}

	const ActionParameter: ActionParameterConstructor;

	interface ActionType extends VcActionType
	{
		name: any;

	}

	interface ActionTypeConstructor {
		new(value?:any): ActionType;
		readonly prototype: ActionType;
	}

	const ActionType: ActionTypeConstructor;

	interface AffinityType extends VcAffinityType
	{
		name: any;

	}

	interface AffinityTypeConstructor {
		new(value?:any): AffinityType;
		readonly prototype: AffinityType;
	}

	const AffinityType: AffinityTypeConstructor;

	interface AgentInstallFailedReason extends VcAgentInstallFailedReason
	{
		name: any;

	}

	interface AgentInstallFailedReasonConstructor {
		new(value?:any): AgentInstallFailedReason;
		readonly prototype: AgentInstallFailedReason;
	}

	const AgentInstallFailedReason: AgentInstallFailedReasonConstructor;

	interface AgentManager extends VcAgentManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface AgentManagerConstructor {
		new(value?:any): AgentManager;
		readonly prototype: AgentManager;
	}

	const AgentManager: AgentManagerConstructor;

	interface Alarm extends VcAlarm
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface AlarmConstructor {
		new(value?:any): Alarm;
		readonly prototype: Alarm;
	}

	const Alarm: AlarmConstructor;

	interface AlarmFilterSpecAlarmTypeByEntity extends VcAlarmFilterSpecAlarmTypeByEntity
	{
		name: any;

	}

	interface AlarmFilterSpecAlarmTypeByEntityConstructor {
		new(value?:any): AlarmFilterSpecAlarmTypeByEntity;
		readonly prototype: AlarmFilterSpecAlarmTypeByEntity;
	}

	const AlarmFilterSpecAlarmTypeByEntity: AlarmFilterSpecAlarmTypeByEntityConstructor;

	interface AlarmFilterSpecAlarmTypeByTrigger extends VcAlarmFilterSpecAlarmTypeByTrigger
	{
		name: any;

	}

	interface AlarmFilterSpecAlarmTypeByTriggerConstructor {
		new(value?:any): AlarmFilterSpecAlarmTypeByTrigger;
		readonly prototype: AlarmFilterSpecAlarmTypeByTrigger;
	}

	const AlarmFilterSpecAlarmTypeByTrigger: AlarmFilterSpecAlarmTypeByTriggerConstructor;

	interface AlarmManager extends VcAlarmManager
	{
		id: any;
		lastTriggerId: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface AlarmManagerConstructor {
		new(value?:any): AlarmManager;
		readonly prototype: AlarmManager;
	}

	const AlarmManager: AlarmManagerConstructor;

	interface AlarmTriggerType extends VcAlarmTriggerType
	{
		name: any;

	}

	interface AlarmTriggerTypeConstructor {
		new(value?:any): AlarmTriggerType;
		readonly prototype: AlarmTriggerType;
	}

	const AlarmTriggerType: AlarmTriggerTypeConstructor;

	interface AnswerFileValidationResultStatus extends VcAnswerFileValidationResultStatus
	{
		name: any;

	}

	interface AnswerFileValidationResultStatusConstructor {
		new(value?:any): AnswerFileValidationResultStatus;
		readonly prototype: AnswerFileValidationResultStatus;
	}

	const AnswerFileValidationResultStatus: AnswerFileValidationResultStatusConstructor;

	interface AntiAffinityGroup extends VcAntiAffinityGroup
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface AntiAffinityGroupConstructor {
		new(value?:any): AntiAffinityGroup;
		readonly prototype: AntiAffinityGroup;
	}

	const AntiAffinityGroup: AntiAffinityGroupConstructor;

	interface ApplyHostProfileConfigurationResultStatus extends VcApplyHostProfileConfigurationResultStatus
	{
		name: any;

	}

	interface ApplyHostProfileConfigurationResultStatusConstructor {
		new(value?:any): ApplyHostProfileConfigurationResultStatus;
		readonly prototype: ApplyHostProfileConfigurationResultStatus;
	}

	const ApplyHostProfileConfigurationResultStatus: ApplyHostProfileConfigurationResultStatusConstructor;

	interface ArrayUpdateOperation extends VcArrayUpdateOperation
	{
		name: any;

	}

	interface ArrayUpdateOperationConstructor {
		new(value?:any): ArrayUpdateOperation;
		readonly prototype: ArrayUpdateOperation;
	}

	const ArrayUpdateOperation: ArrayUpdateOperationConstructor;

	interface AuthorizationManager extends VcAuthorizationManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface AuthorizationManagerConstructor {
		new(value?:any): AuthorizationManager;
		readonly prototype: AuthorizationManager;
	}

	const AuthorizationManager: AuthorizationManagerConstructor;

	interface AutoStartAction extends VcAutoStartAction
	{
		name: any;

	}

	interface AutoStartActionConstructor {
		new(value?:any): AutoStartAction;
		readonly prototype: AutoStartAction;
	}

	const AutoStartAction: AutoStartActionConstructor;

	interface AutoStartWaitHeartbeatSetting extends VcAutoStartWaitHeartbeatSetting
	{
		name: any;

	}

	interface AutoStartWaitHeartbeatSettingConstructor {
		new(value?:any): AutoStartWaitHeartbeatSetting;
		readonly prototype: AutoStartWaitHeartbeatSetting;
	}

	const AutoStartWaitHeartbeatSetting: AutoStartWaitHeartbeatSettingConstructor;

	interface BaseConfigInfoDiskFileBackingInfoProvisioningType extends VcBaseConfigInfoDiskFileBackingInfoProvisioningType
	{
		name: any;

	}

	interface BaseConfigInfoDiskFileBackingInfoProvisioningTypeConstructor {
		new(value?:any): BaseConfigInfoDiskFileBackingInfoProvisioningType;
		readonly prototype: BaseConfigInfoDiskFileBackingInfoProvisioningType;
	}

	const BaseConfigInfoDiskFileBackingInfoProvisioningType: BaseConfigInfoDiskFileBackingInfoProvisioningTypeConstructor;

	interface BatchResultResult extends VcBatchResultResult
	{
		name: any;

	}

	interface BatchResultResultConstructor {
		new(value?:any): BatchResultResult;
		readonly prototype: BatchResultResult;
	}

	const BatchResultResult: BatchResultResultConstructor;

	interface CannotEnableVmcpForClusterReason extends VcCannotEnableVmcpForClusterReason
	{
		name: any;

	}

	interface CannotEnableVmcpForClusterReasonConstructor {
		new(value?:any): CannotEnableVmcpForClusterReason;
		readonly prototype: CannotEnableVmcpForClusterReason;
	}

	const CannotEnableVmcpForClusterReason: CannotEnableVmcpForClusterReasonConstructor;

	interface CannotMoveFaultToleranceVmMoveType extends VcCannotMoveFaultToleranceVmMoveType
	{
		name: any;

	}

	interface CannotMoveFaultToleranceVmMoveTypeConstructor {
		new(value?:any): CannotMoveFaultToleranceVmMoveType;
		readonly prototype: CannotMoveFaultToleranceVmMoveType;
	}

	const CannotMoveFaultToleranceVmMoveType: CannotMoveFaultToleranceVmMoveTypeConstructor;

	interface CannotPowerOffVmInClusterOperation extends VcCannotPowerOffVmInClusterOperation
	{
		name: any;

	}

	interface CannotPowerOffVmInClusterOperationConstructor {
		new(value?:any): CannotPowerOffVmInClusterOperation;
		readonly prototype: CannotPowerOffVmInClusterOperation;
	}

	const CannotPowerOffVmInClusterOperation: CannotPowerOffVmInClusterOperationConstructor;

	interface CannotUseNetworkReason extends VcCannotUseNetworkReason
	{
		name: any;

	}

	interface CannotUseNetworkReasonConstructor {
		new(value?:any): CannotUseNetworkReason;
		readonly prototype: CannotUseNetworkReason;
	}

	const CannotUseNetworkReason: CannotUseNetworkReasonConstructor;

	interface CbrcManager extends VcCbrcManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface CbrcManagerConstructor {
		new(value?:any): CbrcManager;
		readonly prototype: CbrcManager;
	}

	const CbrcManager: CbrcManagerConstructor;

	interface CDCAlarmChangeKind extends VcCDCAlarmChangeKind
	{
		name: any;

	}

	interface CDCAlarmChangeKindConstructor {
		new(value?:any): CDCAlarmChangeKind;
		readonly prototype: CDCAlarmChangeKind;
	}

	const CDCAlarmChangeKind: CDCAlarmChangeKindConstructor;

	interface CDCChangeLogCollector extends VcCDCChangeLogCollector
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface CDCChangeLogCollectorConstructor {
		new(value?:any): CDCChangeLogCollector;
		readonly prototype: CDCChangeLogCollector;
	}

	const CDCChangeLogCollector: CDCChangeLogCollectorConstructor;

	interface CDCChangeLogCollectorChangeLog extends VcCDCChangeLogCollectorChangeLog
	{
		name: any;

	}

	interface CDCChangeLogCollectorChangeLogConstructor {
		new(value?:any): CDCChangeLogCollectorChangeLog;
		readonly prototype: CDCChangeLogCollectorChangeLog;
	}

	const CDCChangeLogCollectorChangeLog: CDCChangeLogCollectorChangeLogConstructor;

	interface CDCInventoryChangeKind extends VcCDCInventoryChangeKind
	{
		name: any;

	}

	interface CDCInventoryChangeKindConstructor {
		new(value?:any): CDCInventoryChangeKind;
		readonly prototype: CDCInventoryChangeKind;
	}

	const CDCInventoryChangeKind: CDCInventoryChangeKindConstructor;

	interface CertificateManager extends VcCertificateManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface CertificateManagerConstructor {
		new(value?:any): CertificateManager;
		readonly prototype: CertificateManager;
	}

	const CertificateManager: CertificateManagerConstructor;

	interface CheckTestType extends VcCheckTestType
	{
		name: any;

	}

	interface CheckTestTypeConstructor {
		new(value?:any): CheckTestType;
		readonly prototype: CheckTestType;
	}

	const CheckTestType: CheckTestTypeConstructor;

	interface ClusterComputeResource extends VcClusterComputeResource
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

		datastores(): Datastore;
		dvp(): DistributedVirtualPortgroup;
		hosts(): HostSystem;
		networks(): Network;
		resourcePools(): ResourcePool;
		vapps(): VirtualApp;
	}

	interface ClusterComputeResourceConstructor {
		new(value?:any): ClusterComputeResource;
		readonly prototype: ClusterComputeResource;
	}

	const ClusterComputeResource: ClusterComputeResourceConstructor;

	interface ClusterDasAamNodeStateDasState extends VcClusterDasAamNodeStateDasState
	{
		name: any;

	}

	interface ClusterDasAamNodeStateDasStateConstructor {
		new(value?:any): ClusterDasAamNodeStateDasState;
		readonly prototype: ClusterDasAamNodeStateDasState;
	}

	const ClusterDasAamNodeStateDasState: ClusterDasAamNodeStateDasStateConstructor;

	interface ClusterDasConfigInfoHBDatastoreCandidate extends VcClusterDasConfigInfoHBDatastoreCandidate
	{
		name: any;

	}

	interface ClusterDasConfigInfoHBDatastoreCandidateConstructor {
		new(value?:any): ClusterDasConfigInfoHBDatastoreCandidate;
		readonly prototype: ClusterDasConfigInfoHBDatastoreCandidate;
	}

	const ClusterDasConfigInfoHBDatastoreCandidate: ClusterDasConfigInfoHBDatastoreCandidateConstructor;

	interface ClusterDasConfigInfoServiceState extends VcClusterDasConfigInfoServiceState
	{
		name: any;

	}

	interface ClusterDasConfigInfoServiceStateConstructor {
		new(value?:any): ClusterDasConfigInfoServiceState;
		readonly prototype: ClusterDasConfigInfoServiceState;
	}

	const ClusterDasConfigInfoServiceState: ClusterDasConfigInfoServiceStateConstructor;

	interface ClusterDasConfigInfoVmMonitoringState extends VcClusterDasConfigInfoVmMonitoringState
	{
		name: any;

	}

	interface ClusterDasConfigInfoVmMonitoringStateConstructor {
		new(value?:any): ClusterDasConfigInfoVmMonitoringState;
		readonly prototype: ClusterDasConfigInfoVmMonitoringState;
	}

	const ClusterDasConfigInfoVmMonitoringState: ClusterDasConfigInfoVmMonitoringStateConstructor;

	interface ClusterDasFdmAvailabilityState extends VcClusterDasFdmAvailabilityState
	{
		name: any;

	}

	interface ClusterDasFdmAvailabilityStateConstructor {
		new(value?:any): ClusterDasFdmAvailabilityState;
		readonly prototype: ClusterDasFdmAvailabilityState;
	}

	const ClusterDasFdmAvailabilityState: ClusterDasFdmAvailabilityStateConstructor;

	interface ClusterDasVmSettingsIsolationResponse extends VcClusterDasVmSettingsIsolationResponse
	{
		name: any;

	}

	interface ClusterDasVmSettingsIsolationResponseConstructor {
		new(value?:any): ClusterDasVmSettingsIsolationResponse;
		readonly prototype: ClusterDasVmSettingsIsolationResponse;
	}

	const ClusterDasVmSettingsIsolationResponse: ClusterDasVmSettingsIsolationResponseConstructor;

	interface ClusterDasVmSettingsRestartPriority extends VcClusterDasVmSettingsRestartPriority
	{
		name: any;

	}

	interface ClusterDasVmSettingsRestartPriorityConstructor {
		new(value?:any): ClusterDasVmSettingsRestartPriority;
		readonly prototype: ClusterDasVmSettingsRestartPriority;
	}

	const ClusterDasVmSettingsRestartPriority: ClusterDasVmSettingsRestartPriorityConstructor;

	interface ClusterEVCManager extends VcClusterEVCManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ClusterEVCManagerConstructor {
		new(value?:any): ClusterEVCManager;
		readonly prototype: ClusterEVCManager;
	}

	const ClusterEVCManager: ClusterEVCManagerConstructor;

	interface ClusterHostInfraUpdateHaModeActionOperationType extends VcClusterHostInfraUpdateHaModeActionOperationType
	{
		name: any;

	}

	interface ClusterHostInfraUpdateHaModeActionOperationTypeConstructor {
		new(value?:any): ClusterHostInfraUpdateHaModeActionOperationType;
		readonly prototype: ClusterHostInfraUpdateHaModeActionOperationType;
	}

	const ClusterHostInfraUpdateHaModeActionOperationType: ClusterHostInfraUpdateHaModeActionOperationTypeConstructor;

	interface ClusterInfraUpdateHaConfigInfoBehaviorType extends VcClusterInfraUpdateHaConfigInfoBehaviorType
	{
		name: any;

	}

	interface ClusterInfraUpdateHaConfigInfoBehaviorTypeConstructor {
		new(value?:any): ClusterInfraUpdateHaConfigInfoBehaviorType;
		readonly prototype: ClusterInfraUpdateHaConfigInfoBehaviorType;
	}

	const ClusterInfraUpdateHaConfigInfoBehaviorType: ClusterInfraUpdateHaConfigInfoBehaviorTypeConstructor;

	interface ClusterInfraUpdateHaConfigInfoRemediationType extends VcClusterInfraUpdateHaConfigInfoRemediationType
	{
		name: any;

	}

	interface ClusterInfraUpdateHaConfigInfoRemediationTypeConstructor {
		new(value?:any): ClusterInfraUpdateHaConfigInfoRemediationType;
		readonly prototype: ClusterInfraUpdateHaConfigInfoRemediationType;
	}

	const ClusterInfraUpdateHaConfigInfoRemediationType: ClusterInfraUpdateHaConfigInfoRemediationTypeConstructor;

	interface ClusterPowerOnVmOption extends VcClusterPowerOnVmOption
	{
		name: any;

	}

	interface ClusterPowerOnVmOptionConstructor {
		new(value?:any): ClusterPowerOnVmOption;
		readonly prototype: ClusterPowerOnVmOption;
	}

	const ClusterPowerOnVmOption: ClusterPowerOnVmOptionConstructor;

	interface ClusterProfile extends VcClusterProfile
	{
		complianceStatus: any;
		createdTime: any;
		id: any;
		modifiedTime: any;
		name: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ClusterProfileConstructor {
		new(value?:any): ClusterProfile;
		readonly prototype: ClusterProfile;
	}

	const ClusterProfile: ClusterProfileConstructor;

	interface ClusterProfileManager extends VcClusterProfileManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ClusterProfileManagerConstructor {
		new(value?:any): ClusterProfileManager;
		readonly prototype: ClusterProfileManager;
	}

	const ClusterProfileManager: ClusterProfileManagerConstructor;

	interface ClusterProfileServiceType extends VcClusterProfileServiceType
	{
		name: any;

	}

	interface ClusterProfileServiceTypeConstructor {
		new(value?:any): ClusterProfileServiceType;
		readonly prototype: ClusterProfileServiceType;
	}

	const ClusterProfileServiceType: ClusterProfileServiceTypeConstructor;

	interface ClusterTransitionalEVCManager extends VcClusterTransitionalEVCManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ClusterTransitionalEVCManagerConstructor {
		new(value?:any): ClusterTransitionalEVCManager;
		readonly prototype: ClusterTransitionalEVCManager;
	}

	const ClusterTransitionalEVCManager: ClusterTransitionalEVCManagerConstructor;

	interface ClusterVmComponentProtectionSettingsStorageVmReaction extends VcClusterVmComponentProtectionSettingsStorageVmReaction
	{
		name: any;

	}

	interface ClusterVmComponentProtectionSettingsStorageVmReactionConstructor {
		new(value?:any): ClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly prototype: ClusterVmComponentProtectionSettingsStorageVmReaction;
	}

	const ClusterVmComponentProtectionSettingsStorageVmReaction: ClusterVmComponentProtectionSettingsStorageVmReactionConstructor;

	interface ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared extends VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared
	{
		name: any;

	}

	interface ClusterVmComponentProtectionSettingsVmReactionOnAPDClearedConstructor {
		new(value?:any): ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
		readonly prototype: ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
	}

	const ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared: ClusterVmComponentProtectionSettingsVmReactionOnAPDClearedConstructor;

	interface ClusterVmReadinessReadyCondition extends VcClusterVmReadinessReadyCondition
	{
		name: any;

	}

	interface ClusterVmReadinessReadyConditionConstructor {
		new(value?:any): ClusterVmReadinessReadyCondition;
		readonly prototype: ClusterVmReadinessReadyCondition;
	}

	const ClusterVmReadinessReadyCondition: ClusterVmReadinessReadyConditionConstructor;

	interface ComplianceResultStatus extends VcComplianceResultStatus
	{
		name: any;

	}

	interface ComplianceResultStatusConstructor {
		new(value?:any): ComplianceResultStatus;
		readonly prototype: ComplianceResultStatus;
	}

	const ComplianceResultStatus: ComplianceResultStatusConstructor;

	interface ComputeResource extends VcComputeResource
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

		datastores(): Datastore;
		dvp(): DistributedVirtualPortgroup;
		hosts(): HostSystem;
		networks(): Network;
		resourcePools(): ResourcePool;
		vapps(): VirtualApp;
	}

	interface ComputeResourceConstructor {
		new(value?:any): ComputeResource;
		readonly prototype: ComputeResource;
	}

	const ComputeResource: ComputeResourceConstructor;

	interface ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState extends VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState
	{
		name: any;

	}

	interface ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseStateConstructor {
		new(value?:any): ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
		readonly prototype: ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
	}

	const ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState: ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseStateConstructor;

	interface ConfigSpecOperation extends VcConfigSpecOperation
	{
		name: any;

	}

	interface ConfigSpecOperationConstructor {
		new(value?:any): ConfigSpecOperation;
		readonly prototype: ConfigSpecOperation;
	}

	const ConfigSpecOperation: ConfigSpecOperationConstructor;

	interface ContainerView extends VcContainerView
	{
		id: any;
		recursive: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ContainerViewConstructor {
		new(value?:any): ContainerView;
		readonly prototype: ContainerView;
	}

	const ContainerView: ContainerViewConstructor;

	interface ContentLibrary extends VcContentLibrary
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ContentLibraryConstructor {
		new(value?:any): ContentLibrary;
		readonly prototype: ContentLibrary;
	}

	const ContentLibrary: ContentLibraryConstructor;

	interface ContentLibraryItem extends VcContentLibraryItem
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ContentLibraryItemConstructor {
		new(value?:any): ContentLibraryItem;
		readonly prototype: ContentLibraryItem;
	}

	const ContentLibraryItem: ContentLibraryItemConstructor;

	interface CryptoManager extends VcCryptoManager
	{
		enabled: any;
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface CryptoManagerConstructor {
		new(value?:any): CryptoManager;
		readonly prototype: CryptoManager;
	}

	const CryptoManager: CryptoManagerConstructor;

	interface CryptoManagerKmip extends VcCryptoManagerKmip
	{
		enabled: any;
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface CryptoManagerKmipConstructor {
		new(value?:any): CryptoManagerKmip;
		readonly prototype: CryptoManagerKmip;
	}

	const CryptoManagerKmip: CryptoManagerKmipConstructor;

	interface CustomFieldsManager extends VcCustomFieldsManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface CustomFieldsManagerConstructor {
		new(value?:any): CustomFieldsManager;
		readonly prototype: CustomFieldsManager;
	}

	const CustomFieldsManager: CustomFieldsManagerConstructor;

	interface CustomizationLicenseDataMode extends VcCustomizationLicenseDataMode
	{
		name: any;

	}

	interface CustomizationLicenseDataModeConstructor {
		new(value?:any): CustomizationLicenseDataMode;
		readonly prototype: CustomizationLicenseDataMode;
	}

	const CustomizationLicenseDataMode: CustomizationLicenseDataModeConstructor;

	interface CustomizationNetBIOSMode extends VcCustomizationNetBIOSMode
	{
		name: any;

	}

	interface CustomizationNetBIOSModeConstructor {
		new(value?:any): CustomizationNetBIOSMode;
		readonly prototype: CustomizationNetBIOSMode;
	}

	const CustomizationNetBIOSMode: CustomizationNetBIOSModeConstructor;

	interface CustomizationSpecManager extends VcCustomizationSpecManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface CustomizationSpecManagerConstructor {
		new(value?:any): CustomizationSpecManager;
		readonly prototype: CustomizationSpecManager;
	}

	const CustomizationSpecManager: CustomizationSpecManagerConstructor;

	interface CustomizationSysprepRebootOption extends VcCustomizationSysprepRebootOption
	{
		name: any;

	}

	interface CustomizationSysprepRebootOptionConstructor {
		new(value?:any): CustomizationSysprepRebootOption;
		readonly prototype: CustomizationSysprepRebootOption;
	}

	const CustomizationSysprepRebootOption: CustomizationSysprepRebootOptionConstructor;

	interface DasConfigFaultDasConfigFaultReason extends VcDasConfigFaultDasConfigFaultReason
	{
		name: any;

	}

	interface DasConfigFaultDasConfigFaultReasonConstructor {
		new(value?:any): DasConfigFaultDasConfigFaultReason;
		readonly prototype: DasConfigFaultDasConfigFaultReason;
	}

	const DasConfigFaultDasConfigFaultReason: DasConfigFaultDasConfigFaultReasonConstructor;

	interface DasVmPriority extends VcDasVmPriority
	{
		name: any;

	}

	interface DasVmPriorityConstructor {
		new(value?:any): DasVmPriority;
		readonly prototype: DasVmPriority;
	}

	const DasVmPriority: DasVmPriorityConstructor;

	interface Datacenter extends VcDatacenter
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

		datastoreFolder(): DatastoreFolder;
		getHostFolder(): HostFolder;
		networks(): NetworkFolder;
		vm(): VmFolder;
	}

	interface DatacenterConstructor {
		new(value?:any): Datacenter;
		readonly prototype: Datacenter;
	}

	const Datacenter: DatacenterConstructor;

	interface DatacenterFolder extends VcDatacenterFolder
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;

		datacenters(): Datacenter;
		folders(): DatacenterFolder;
	}

	interface DatacenterFolderConstructor {
		new(value?:any): DatacenterFolder;
		readonly prototype: DatacenterFolder;
	}

	const DatacenterFolder: DatacenterFolderConstructor;

	interface Datastore extends VcDatastore
	{
		accessible: any;
		alarmActionsEnabled: any;
		capacity: any;
		configStatus: any;
		freeSpace: any;
		id: any;
		name: any;
		overallStatus: any;
		provisionedSpace: any;
		sdkId: any;
		type: any;
		url: any;
		vimId: any;
		vimType: any;

	}

	interface DatastoreConstructor {
		new(value?:any): Datastore;
		readonly prototype: Datastore;
	}

	const Datastore: DatastoreConstructor;

	interface DatastoreAccessible extends VcDatastoreAccessible
	{
		name: any;

	}

	interface DatastoreAccessibleConstructor {
		new(value?:any): DatastoreAccessible;
		readonly prototype: DatastoreAccessible;
	}

	const DatastoreAccessible: DatastoreAccessibleConstructor;

	interface DatastoreFolder extends VcDatastoreFolder
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;

		datastoreFolder(): DatastoreFolder;
		datastores(): Datastore;
		pods(): StoragePod;
	}

	interface DatastoreFolderConstructor {
		new(value?:any): DatastoreFolder;
		readonly prototype: DatastoreFolder;
	}

	const DatastoreFolder: DatastoreFolderConstructor;

	interface DatastoreNamespaceManager extends VcDatastoreNamespaceManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface DatastoreNamespaceManagerConstructor {
		new(value?:any): DatastoreNamespaceManager;
		readonly prototype: DatastoreNamespaceManager;
	}

	const DatastoreNamespaceManager: DatastoreNamespaceManagerConstructor;

	interface DatastoreSummaryMaintenanceModeState extends VcDatastoreSummaryMaintenanceModeState
	{
		name: any;

	}

	interface DatastoreSummaryMaintenanceModeStateConstructor {
		new(value?:any): DatastoreSummaryMaintenanceModeState;
		readonly prototype: DatastoreSummaryMaintenanceModeState;
	}

	const DatastoreSummaryMaintenanceModeState: DatastoreSummaryMaintenanceModeStateConstructor;

	interface DayOfWeek extends VcDayOfWeek
	{
		name: any;

	}

	interface DayOfWeekConstructor {
		new(value?:any): DayOfWeek;
		readonly prototype: DayOfWeek;
	}

	const DayOfWeek: DayOfWeekConstructor;

	interface DeploymentInfo extends VcDeploymentInfo
	{
		hostName: any;
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface DeploymentInfoConstructor {
		new(value?:any): DeploymentInfo;
		readonly prototype: DeploymentInfo;
	}

	const DeploymentInfo: DeploymentInfoConstructor;

	interface DeviceNotSupportedReason extends VcDeviceNotSupportedReason
	{
		name: any;

	}

	interface DeviceNotSupportedReasonConstructor {
		new(value?:any): DeviceNotSupportedReason;
		readonly prototype: DeviceNotSupportedReason;
	}

	const DeviceNotSupportedReason: DeviceNotSupportedReasonConstructor;

	interface DiagnosticManager extends VcDiagnosticManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface DiagnosticManagerConstructor {
		new(value?:any): DiagnosticManager;
		readonly prototype: DiagnosticManager;
	}

	const DiagnosticManager: DiagnosticManagerConstructor;

	interface DiagnosticManagerFileHashSpecHashAlgorithm extends VcDiagnosticManagerFileHashSpecHashAlgorithm
	{
		name: any;

	}

	interface DiagnosticManagerFileHashSpecHashAlgorithmConstructor {
		new(value?:any): DiagnosticManagerFileHashSpecHashAlgorithm;
		readonly prototype: DiagnosticManagerFileHashSpecHashAlgorithm;
	}

	const DiagnosticManagerFileHashSpecHashAlgorithm: DiagnosticManagerFileHashSpecHashAlgorithmConstructor;

	interface DiagnosticManagerLogCreator extends VcDiagnosticManagerLogCreator
	{
		name: any;

	}

	interface DiagnosticManagerLogCreatorConstructor {
		new(value?:any): DiagnosticManagerLogCreator;
		readonly prototype: DiagnosticManagerLogCreator;
	}

	const DiagnosticManagerLogCreator: DiagnosticManagerLogCreatorConstructor;

	interface DiagnosticManagerLogFormat extends VcDiagnosticManagerLogFormat
	{
		name: any;

	}

	interface DiagnosticManagerLogFormatConstructor {
		new(value?:any): DiagnosticManagerLogFormat;
		readonly prototype: DiagnosticManagerLogFormat;
	}

	const DiagnosticManagerLogFormat: DiagnosticManagerLogFormatConstructor;

	interface DiagnosticPartitionStorageType extends VcDiagnosticPartitionStorageType
	{
		name: any;

	}

	interface DiagnosticPartitionStorageTypeConstructor {
		new(value?:any): DiagnosticPartitionStorageType;
		readonly prototype: DiagnosticPartitionStorageType;
	}

	const DiagnosticPartitionStorageType: DiagnosticPartitionStorageTypeConstructor;

	interface DiagnosticPartitionType extends VcDiagnosticPartitionType
	{
		name: any;

	}

	interface DiagnosticPartitionTypeConstructor {
		new(value?:any): DiagnosticPartitionType;
		readonly prototype: DiagnosticPartitionType;
	}

	const DiagnosticPartitionType: DiagnosticPartitionTypeConstructor;

	interface DisallowedChangeByServiceDisallowedChange extends VcDisallowedChangeByServiceDisallowedChange
	{
		name: any;

	}

	interface DisallowedChangeByServiceDisallowedChangeConstructor {
		new(value?:any): DisallowedChangeByServiceDisallowedChange;
		readonly prototype: DisallowedChangeByServiceDisallowedChange;
	}

	const DisallowedChangeByServiceDisallowedChange: DisallowedChangeByServiceDisallowedChangeConstructor;

	interface DistributedVirtualPortgroup extends VcDistributedVirtualPortgroup
	{
		accessible: any;
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		key: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface DistributedVirtualPortgroupConstructor {
		new(value?:any): DistributedVirtualPortgroup;
		readonly prototype: DistributedVirtualPortgroup;
	}

	const DistributedVirtualPortgroup: DistributedVirtualPortgroupConstructor;

	interface DistributedVirtualPortgroupMetaTagName extends VcDistributedVirtualPortgroupMetaTagName
	{
		name: any;

	}

	interface DistributedVirtualPortgroupMetaTagNameConstructor {
		new(value?:any): DistributedVirtualPortgroupMetaTagName;
		readonly prototype: DistributedVirtualPortgroupMetaTagName;
	}

	const DistributedVirtualPortgroupMetaTagName: DistributedVirtualPortgroupMetaTagNameConstructor;

	interface DistributedVirtualPortgroupPortgroupType extends VcDistributedVirtualPortgroupPortgroupType
	{
		name: any;

	}

	interface DistributedVirtualPortgroupPortgroupTypeConstructor {
		new(value?:any): DistributedVirtualPortgroupPortgroupType;
		readonly prototype: DistributedVirtualPortgroupPortgroupType;
	}

	const DistributedVirtualPortgroupPortgroupType: DistributedVirtualPortgroupPortgroupTypeConstructor;

	interface DistributedVirtualSwitch extends VcDistributedVirtualSwitch
	{
		alarmActionsEnabled: any;
		configStatus: any;
		description: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		uuid: any;
		vimId: any;
		vimType: any;

	}

	interface DistributedVirtualSwitchConstructor {
		new(value?:any): DistributedVirtualSwitch;
		readonly prototype: DistributedVirtualSwitch;
	}

	const DistributedVirtualSwitch: DistributedVirtualSwitchConstructor;

	interface DistributedVirtualSwitchHostInfrastructureTrafficClass extends VcDistributedVirtualSwitchHostInfrastructureTrafficClass
	{
		name: any;

	}

	interface DistributedVirtualSwitchHostInfrastructureTrafficClassConstructor {
		new(value?:any): DistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly prototype: DistributedVirtualSwitchHostInfrastructureTrafficClass;
	}

	const DistributedVirtualSwitchHostInfrastructureTrafficClass: DistributedVirtualSwitchHostInfrastructureTrafficClassConstructor;

	interface DistributedVirtualSwitchHostMemberHostComponentState extends VcDistributedVirtualSwitchHostMemberHostComponentState
	{
		name: any;

	}

	interface DistributedVirtualSwitchHostMemberHostComponentStateConstructor {
		new(value?:any): DistributedVirtualSwitchHostMemberHostComponentState;
		readonly prototype: DistributedVirtualSwitchHostMemberHostComponentState;
	}

	const DistributedVirtualSwitchHostMemberHostComponentState: DistributedVirtualSwitchHostMemberHostComponentStateConstructor;

	interface DistributedVirtualSwitchManager extends VcDistributedVirtualSwitchManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface DistributedVirtualSwitchManagerConstructor {
		new(value?:any): DistributedVirtualSwitchManager;
		readonly prototype: DistributedVirtualSwitchManager;
	}

	const DistributedVirtualSwitchManager: DistributedVirtualSwitchManagerConstructor;

	interface DistributedVirtualSwitchNetworkResourceControlVersion extends VcDistributedVirtualSwitchNetworkResourceControlVersion
	{
		name: any;

	}

	interface DistributedVirtualSwitchNetworkResourceControlVersionConstructor {
		new(value?:any): DistributedVirtualSwitchNetworkResourceControlVersion;
		readonly prototype: DistributedVirtualSwitchNetworkResourceControlVersion;
	}

	const DistributedVirtualSwitchNetworkResourceControlVersion: DistributedVirtualSwitchNetworkResourceControlVersionConstructor;

	interface DistributedVirtualSwitchNicTeamingPolicyMode extends VcDistributedVirtualSwitchNicTeamingPolicyMode
	{
		name: any;

	}

	interface DistributedVirtualSwitchNicTeamingPolicyModeConstructor {
		new(value?:any): DistributedVirtualSwitchNicTeamingPolicyMode;
		readonly prototype: DistributedVirtualSwitchNicTeamingPolicyMode;
	}

	const DistributedVirtualSwitchNicTeamingPolicyMode: DistributedVirtualSwitchNicTeamingPolicyModeConstructor;

	interface DistributedVirtualSwitchPortConnecteeConnecteeType extends VcDistributedVirtualSwitchPortConnecteeConnecteeType
	{
		name: any;

	}

	interface DistributedVirtualSwitchPortConnecteeConnecteeTypeConstructor {
		new(value?:any): DistributedVirtualSwitchPortConnecteeConnecteeType;
		readonly prototype: DistributedVirtualSwitchPortConnecteeConnecteeType;
	}

	const DistributedVirtualSwitchPortConnecteeConnecteeType: DistributedVirtualSwitchPortConnecteeConnecteeTypeConstructor;

	interface DistributedVirtualSwitchProductSpecOperationType extends VcDistributedVirtualSwitchProductSpecOperationType
	{
		name: any;

	}

	interface DistributedVirtualSwitchProductSpecOperationTypeConstructor {
		new(value?:any): DistributedVirtualSwitchProductSpecOperationType;
		readonly prototype: DistributedVirtualSwitchProductSpecOperationType;
	}

	const DistributedVirtualSwitchProductSpecOperationType: DistributedVirtualSwitchProductSpecOperationTypeConstructor;

	interface DpmBehavior extends VcDpmBehavior
	{
		name: any;

	}

	interface DpmBehaviorConstructor {
		new(value?:any): DpmBehavior;
		readonly prototype: DpmBehavior;
	}

	const DpmBehavior: DpmBehaviorConstructor;

	interface DrsBehavior extends VcDrsBehavior
	{
		name: any;

	}

	interface DrsBehaviorConstructor {
		new(value?:any): DrsBehavior;
		readonly prototype: DrsBehavior;
	}

	const DrsBehavior: DrsBehaviorConstructor;

	interface DrsInjectorWorkloadCorrelationState extends VcDrsInjectorWorkloadCorrelationState
	{
		name: any;

	}

	interface DrsInjectorWorkloadCorrelationStateConstructor {
		new(value?:any): DrsInjectorWorkloadCorrelationState;
		readonly prototype: DrsInjectorWorkloadCorrelationState;
	}

	const DrsInjectorWorkloadCorrelationState: DrsInjectorWorkloadCorrelationStateConstructor;

	interface DrsRecommendationReasonCode extends VcDrsRecommendationReasonCode
	{
		name: any;

	}

	interface DrsRecommendationReasonCodeConstructor {
		new(value?:any): DrsRecommendationReasonCode;
		readonly prototype: DrsRecommendationReasonCode;
	}

	const DrsRecommendationReasonCode: DrsRecommendationReasonCodeConstructor;

	interface DrsStatsManager extends VcDrsStatsManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface DrsStatsManagerConstructor {
		new(value?:any): DrsStatsManager;
		readonly prototype: DrsStatsManager;
	}

	const DrsStatsManager: DrsStatsManagerConstructor;

	interface DVPortStatusVmDirectPathGen2InactiveReasonNetwork extends VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork
	{
		name: any;

	}

	interface DVPortStatusVmDirectPathGen2InactiveReasonNetworkConstructor {
		new(value?:any): DVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly prototype: DVPortStatusVmDirectPathGen2InactiveReasonNetwork;
	}

	const DVPortStatusVmDirectPathGen2InactiveReasonNetwork: DVPortStatusVmDirectPathGen2InactiveReasonNetworkConstructor;

	interface DVPortStatusVmDirectPathGen2InactiveReasonOther extends VcDVPortStatusVmDirectPathGen2InactiveReasonOther
	{
		name: any;

	}

	interface DVPortStatusVmDirectPathGen2InactiveReasonOtherConstructor {
		new(value?:any): DVPortStatusVmDirectPathGen2InactiveReasonOther;
		readonly prototype: DVPortStatusVmDirectPathGen2InactiveReasonOther;
	}

	const DVPortStatusVmDirectPathGen2InactiveReasonOther: DVPortStatusVmDirectPathGen2InactiveReasonOtherConstructor;

	interface DvsEventPortBlockState extends VcDvsEventPortBlockState
	{
		name: any;

	}

	interface DvsEventPortBlockStateConstructor {
		new(value?:any): DvsEventPortBlockState;
		readonly prototype: DvsEventPortBlockState;
	}

	const DvsEventPortBlockState: DvsEventPortBlockStateConstructor;

	interface DvsFilterOnFailure extends VcDvsFilterOnFailure
	{
		name: any;

	}

	interface DvsFilterOnFailureConstructor {
		new(value?:any): DvsFilterOnFailure;
		readonly prototype: DvsFilterOnFailure;
	}

	const DvsFilterOnFailure: DvsFilterOnFailureConstructor;

	interface DvsNetworkRuleDirectionType extends VcDvsNetworkRuleDirectionType
	{
		name: any;

	}

	interface DvsNetworkRuleDirectionTypeConstructor {
		new(value?:any): DvsNetworkRuleDirectionType;
		readonly prototype: DvsNetworkRuleDirectionType;
	}

	const DvsNetworkRuleDirectionType: DvsNetworkRuleDirectionTypeConstructor;

	interface DynamicTypeMgrMethodTypeInfoAnnotationType extends VcDynamicTypeMgrMethodTypeInfoAnnotationType
	{
		name: any;

	}

	interface DynamicTypeMgrMethodTypeInfoAnnotationTypeConstructor {
		new(value?:any): DynamicTypeMgrMethodTypeInfoAnnotationType;
		readonly prototype: DynamicTypeMgrMethodTypeInfoAnnotationType;
	}

	const DynamicTypeMgrMethodTypeInfoAnnotationType: DynamicTypeMgrMethodTypeInfoAnnotationTypeConstructor;

	interface DynamicTypeMgrParamTypeInfoAnnotationType extends VcDynamicTypeMgrParamTypeInfoAnnotationType
	{
		name: any;

	}

	interface DynamicTypeMgrParamTypeInfoAnnotationTypeConstructor {
		new(value?:any): DynamicTypeMgrParamTypeInfoAnnotationType;
		readonly prototype: DynamicTypeMgrParamTypeInfoAnnotationType;
	}

	const DynamicTypeMgrParamTypeInfoAnnotationType: DynamicTypeMgrParamTypeInfoAnnotationTypeConstructor;

	interface DynamicTypeMgrPropertyTypeInfoAnnotationType extends VcDynamicTypeMgrPropertyTypeInfoAnnotationType
	{
		name: any;

	}

	interface DynamicTypeMgrPropertyTypeInfoAnnotationTypeConstructor {
		new(value?:any): DynamicTypeMgrPropertyTypeInfoAnnotationType;
		readonly prototype: DynamicTypeMgrPropertyTypeInfoAnnotationType;
	}

	const DynamicTypeMgrPropertyTypeInfoAnnotationType: DynamicTypeMgrPropertyTypeInfoAnnotationTypeConstructor;

	interface EntityImportType extends VcEntityImportType
	{
		name: any;

	}

	interface EntityImportTypeConstructor {
		new(value?:any): EntityImportType;
		readonly prototype: EntityImportType;
	}

	const EntityImportType: EntityImportTypeConstructor;

	interface EntityType extends VcEntityType
	{
		name: any;

	}

	interface EntityTypeConstructor {
		new(value?:any): EntityType;
		readonly prototype: EntityType;
	}

	const EntityType: EntityTypeConstructor;

	interface EnvironmentBrowser extends VcEnvironmentBrowser
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface EnvironmentBrowserConstructor {
		new(value?:any): EnvironmentBrowser;
		readonly prototype: EnvironmentBrowser;
	}

	const EnvironmentBrowser: EnvironmentBrowserConstructor;

	interface EsxAgentConfigManager extends VcEsxAgentConfigManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface EsxAgentConfigManagerConstructor {
		new(value?:any): EsxAgentConfigManager;
		readonly prototype: EsxAgentConfigManager;
	}

	const EsxAgentConfigManager: EsxAgentConfigManagerConstructor;

	interface EsxAgentConfigManagerAgentVmState extends VcEsxAgentConfigManagerAgentVmState
	{
		name: any;

	}

	interface EsxAgentConfigManagerAgentVmStateConstructor {
		new(value?:any): EsxAgentConfigManagerAgentVmState;
		readonly prototype: EsxAgentConfigManagerAgentVmState;
	}

	const EsxAgentConfigManagerAgentVmState: EsxAgentConfigManagerAgentVmStateConstructor;

	interface EventAlarmExpressionComparisonOperator extends VcEventAlarmExpressionComparisonOperator
	{
		name: any;

	}

	interface EventAlarmExpressionComparisonOperatorConstructor {
		new(value?:any): EventAlarmExpressionComparisonOperator;
		readonly prototype: EventAlarmExpressionComparisonOperator;
	}

	const EventAlarmExpressionComparisonOperator: EventAlarmExpressionComparisonOperatorConstructor;

	interface EventCategory extends VcEventCategory
	{
		name: any;

	}

	interface EventCategoryConstructor {
		new(value?:any): EventCategory;
		readonly prototype: EventCategory;
	}

	const EventCategory: EventCategoryConstructor;

	interface EventEventSeverity extends VcEventEventSeverity
	{
		name: any;

	}

	interface EventEventSeverityConstructor {
		new(value?:any): EventEventSeverity;
		readonly prototype: EventEventSeverity;
	}

	const EventEventSeverity: EventEventSeverityConstructor;

	interface EventFilterSpecOrderBy extends VcEventFilterSpecOrderBy
	{
		name: any;

	}

	interface EventFilterSpecOrderByConstructor {
		new(value?:any): EventFilterSpecOrderBy;
		readonly prototype: EventFilterSpecOrderBy;
	}

	const EventFilterSpecOrderBy: EventFilterSpecOrderByConstructor;

	interface EventFilterSpecRecursionOption extends VcEventFilterSpecRecursionOption
	{
		name: any;

	}

	interface EventFilterSpecRecursionOptionConstructor {
		new(value?:any): EventFilterSpecRecursionOption;
		readonly prototype: EventFilterSpecRecursionOption;
	}

	const EventFilterSpecRecursionOption: EventFilterSpecRecursionOptionConstructor;

	interface EventHistoryCollector extends VcEventHistoryCollector
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface EventHistoryCollectorConstructor {
		new(value?:any): EventHistoryCollector;
		readonly prototype: EventHistoryCollector;
	}

	const EventHistoryCollector: EventHistoryCollectorConstructor;

	interface EventManager extends VcEventManager
	{
		id: any;
		maxCollector: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface EventManagerConstructor {
		new(value?:any): EventManager;
		readonly prototype: EventManager;
	}

	const EventManager: EventManagerConstructor;

	interface ExtensibleManagedObject extends VcExtensibleManagedObject
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ExtensibleManagedObjectConstructor {
		new(value?:any): ExtensibleManagedObject;
		readonly prototype: ExtensibleManagedObject;
	}

	const ExtensibleManagedObject: ExtensibleManagedObjectConstructor;

	interface ExtensionManager extends VcExtensionManager
	{
		id: any;
		publicKey: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ExtensionManagerConstructor {
		new(value?:any): ExtensionManager;
		readonly prototype: ExtensionManager;
	}

	const ExtensionManager: ExtensionManagerConstructor;

	interface ExternalStatsManager extends VcExternalStatsManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ExternalStatsManagerConstructor {
		new(value?:any): ExternalStatsManager;
		readonly prototype: ExternalStatsManager;
	}

	const ExternalStatsManager: ExternalStatsManagerConstructor;

	interface ExternalStatsManagerMetricType extends VcExternalStatsManagerMetricType
	{
		name: any;

	}

	interface ExternalStatsManagerMetricTypeConstructor {
		new(value?:any): ExternalStatsManagerMetricType;
		readonly prototype: ExternalStatsManagerMetricType;
	}

	const ExternalStatsManagerMetricType: ExternalStatsManagerMetricTypeConstructor;

	interface FailoverClusterConfigurator extends VcFailoverClusterConfigurator
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface FailoverClusterConfiguratorConstructor {
		new(value?:any): FailoverClusterConfigurator;
		readonly prototype: FailoverClusterConfigurator;
	}

	const FailoverClusterConfigurator: FailoverClusterConfiguratorConstructor;

	interface FailoverClusterManager extends VcFailoverClusterManager
	{
		clusterMode: any;
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface FailoverClusterManagerConstructor {
		new(value?:any): FailoverClusterManager;
		readonly prototype: FailoverClusterManager;
	}

	const FailoverClusterManager: FailoverClusterManagerConstructor;

	interface FibreChannelPortType extends VcFibreChannelPortType
	{
		name: any;

	}

	interface FibreChannelPortTypeConstructor {
		new(value?:any): FibreChannelPortType;
		readonly prototype: FibreChannelPortType;
	}

	const FibreChannelPortType: FibreChannelPortTypeConstructor;

	interface FileManager extends VcFileManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface FileManagerConstructor {
		new(value?:any): FileManager;
		readonly prototype: FileManager;
	}

	const FileManager: FileManagerConstructor;

	interface FileManagerFileType extends VcFileManagerFileType
	{
		name: any;

	}

	interface FileManagerFileTypeConstructor {
		new(value?:any): FileManagerFileType;
		readonly prototype: FileManagerFileType;
	}

	const FileManagerFileType: FileManagerFileTypeConstructor;

	interface FileSystemMountInfoVStorageSupportStatus extends VcFileSystemMountInfoVStorageSupportStatus
	{
		name: any;

	}

	interface FileSystemMountInfoVStorageSupportStatusConstructor {
		new(value?:any): FileSystemMountInfoVStorageSupportStatus;
		readonly prototype: FileSystemMountInfoVStorageSupportStatus;
	}

	const FileSystemMountInfoVStorageSupportStatus: FileSystemMountInfoVStorageSupportStatusConstructor;

	interface Folder extends VcFolder
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface FolderConstructor {
		new(value?:any): Folder;
		readonly prototype: Folder;
	}

	const Folder: FolderConstructor;

	interface FtIssuesOnHostHostSelectionType extends VcFtIssuesOnHostHostSelectionType
	{
		name: any;

	}

	interface FtIssuesOnHostHostSelectionTypeConstructor {
		new(value?:any): FtIssuesOnHostHostSelectionType;
		readonly prototype: FtIssuesOnHostHostSelectionType;
	}

	const FtIssuesOnHostHostSelectionType: FtIssuesOnHostHostSelectionTypeConstructor;

	interface GuestAliasManager extends VcGuestAliasManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface GuestAliasManagerConstructor {
		new(value?:any): GuestAliasManager;
		readonly prototype: GuestAliasManager;
	}

	const GuestAliasManager: GuestAliasManagerConstructor;

	interface GuestAuthManager extends VcGuestAuthManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface GuestAuthManagerConstructor {
		new(value?:any): GuestAuthManager;
		readonly prototype: GuestAuthManager;
	}

	const GuestAuthManager: GuestAuthManagerConstructor;

	interface GuestFileManager extends VcGuestFileManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface GuestFileManagerConstructor {
		new(value?:any): GuestFileManager;
		readonly prototype: GuestFileManager;
	}

	const GuestFileManager: GuestFileManagerConstructor;

	interface GuestFileType extends VcGuestFileType
	{
		name: any;

	}

	interface GuestFileTypeConstructor {
		new(value?:any): GuestFileType;
		readonly prototype: GuestFileType;
	}

	const GuestFileType: GuestFileTypeConstructor;

	interface GuestInfoAppStateType extends VcGuestInfoAppStateType
	{
		name: any;

	}

	interface GuestInfoAppStateTypeConstructor {
		new(value?:any): GuestInfoAppStateType;
		readonly prototype: GuestInfoAppStateType;
	}

	const GuestInfoAppStateType: GuestInfoAppStateTypeConstructor;

	interface GuestOperationsManager extends VcGuestOperationsManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface GuestOperationsManagerConstructor {
		new(value?:any): GuestOperationsManager;
		readonly prototype: GuestOperationsManager;
	}

	const GuestOperationsManager: GuestOperationsManagerConstructor;

	interface GuestOsDescriptorFirmwareType extends VcGuestOsDescriptorFirmwareType
	{
		name: any;

	}

	interface GuestOsDescriptorFirmwareTypeConstructor {
		new(value?:any): GuestOsDescriptorFirmwareType;
		readonly prototype: GuestOsDescriptorFirmwareType;
	}

	const GuestOsDescriptorFirmwareType: GuestOsDescriptorFirmwareTypeConstructor;

	interface GuestOsDescriptorSupportLevel extends VcGuestOsDescriptorSupportLevel
	{
		name: any;

	}

	interface GuestOsDescriptorSupportLevelConstructor {
		new(value?:any): GuestOsDescriptorSupportLevel;
		readonly prototype: GuestOsDescriptorSupportLevel;
	}

	const GuestOsDescriptorSupportLevel: GuestOsDescriptorSupportLevelConstructor;

	interface GuestProcessManager extends VcGuestProcessManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface GuestProcessManagerConstructor {
		new(value?:any): GuestProcessManager;
		readonly prototype: GuestProcessManager;
	}

	const GuestProcessManager: GuestProcessManagerConstructor;

	interface GuestRegKeyWowSpec extends VcGuestRegKeyWowSpec
	{
		name: any;

	}

	interface GuestRegKeyWowSpecConstructor {
		new(value?:any): GuestRegKeyWowSpec;
		readonly prototype: GuestRegKeyWowSpec;
	}

	const GuestRegKeyWowSpec: GuestRegKeyWowSpecConstructor;

	interface GuestWindowsRegistryManager extends VcGuestWindowsRegistryManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface GuestWindowsRegistryManagerConstructor {
		new(value?:any): GuestWindowsRegistryManager;
		readonly prototype: GuestWindowsRegistryManager;
	}

	const GuestWindowsRegistryManager: GuestWindowsRegistryManagerConstructor;

	interface HbrManager extends VcHbrManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HbrManagerConstructor {
		new(value?:any): HbrManager;
		readonly prototype: HbrManager;
	}

	const HbrManager: HbrManagerConstructor;

	interface HealthUpdateInfoComponentType extends VcHealthUpdateInfoComponentType
	{
		name: any;

	}

	interface HealthUpdateInfoComponentTypeConstructor {
		new(value?:any): HealthUpdateInfoComponentType;
		readonly prototype: HealthUpdateInfoComponentType;
	}

	const HealthUpdateInfoComponentType: HealthUpdateInfoComponentTypeConstructor;

	interface HealthUpdateManager extends VcHealthUpdateManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HealthUpdateManagerConstructor {
		new(value?:any): HealthUpdateManager;
		readonly prototype: HealthUpdateManager;
	}

	const HealthUpdateManager: HealthUpdateManagerConstructor;

	interface HistoryCollector extends VcHistoryCollector
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HistoryCollectorConstructor {
		new(value?:any): HistoryCollector;
		readonly prototype: HistoryCollector;
	}

	const HistoryCollector: HistoryCollectorConstructor;

	interface HostAccessManager extends VcHostAccessManager
	{
		id: any;
		lockdownMode: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostAccessManagerConstructor {
		new(value?:any): HostAccessManager;
		readonly prototype: HostAccessManager;
	}

	const HostAccessManager: HostAccessManagerConstructor;

	interface HostAccessMode extends VcHostAccessMode
	{
		name: any;

	}

	interface HostAccessModeConstructor {
		new(value?:any): HostAccessMode;
		readonly prototype: HostAccessMode;
	}

	const HostAccessMode: HostAccessModeConstructor;

	interface HostActiveDirectoryAuthentication extends VcHostActiveDirectoryAuthentication
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostActiveDirectoryAuthenticationConstructor {
		new(value?:any): HostActiveDirectoryAuthentication;
		readonly prototype: HostActiveDirectoryAuthentication;
	}

	const HostActiveDirectoryAuthentication: HostActiveDirectoryAuthenticationConstructor;

	interface HostActiveDirectoryAuthenticationCertificateDigest extends VcHostActiveDirectoryAuthenticationCertificateDigest
	{
		name: any;

	}

	interface HostActiveDirectoryAuthenticationCertificateDigestConstructor {
		new(value?:any): HostActiveDirectoryAuthenticationCertificateDigest;
		readonly prototype: HostActiveDirectoryAuthenticationCertificateDigest;
	}

	const HostActiveDirectoryAuthenticationCertificateDigest: HostActiveDirectoryAuthenticationCertificateDigestConstructor;

	interface HostActiveDirectoryInfoDomainMembershipStatus extends VcHostActiveDirectoryInfoDomainMembershipStatus
	{
		name: any;

	}

	interface HostActiveDirectoryInfoDomainMembershipStatusConstructor {
		new(value?:any): HostActiveDirectoryInfoDomainMembershipStatus;
		readonly prototype: HostActiveDirectoryInfoDomainMembershipStatus;
	}

	const HostActiveDirectoryInfoDomainMembershipStatus: HostActiveDirectoryInfoDomainMembershipStatusConstructor;

	interface HostAuthenticationManager extends VcHostAuthenticationManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostAuthenticationManagerConstructor {
		new(value?:any): HostAuthenticationManager;
		readonly prototype: HostAuthenticationManager;
	}

	const HostAuthenticationManager: HostAuthenticationManagerConstructor;

	interface HostAuthenticationStore extends VcHostAuthenticationStore
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostAuthenticationStoreConstructor {
		new(value?:any): HostAuthenticationStore;
		readonly prototype: HostAuthenticationStore;
	}

	const HostAuthenticationStore: HostAuthenticationStoreConstructor;

	interface HostAutoStartManager extends VcHostAutoStartManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostAutoStartManagerConstructor {
		new(value?:any): HostAutoStartManager;
		readonly prototype: HostAutoStartManager;
	}

	const HostAutoStartManager: HostAutoStartManagerConstructor;

	interface HostBootDeviceSystem extends VcHostBootDeviceSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostBootDeviceSystemConstructor {
		new(value?:any): HostBootDeviceSystem;
		readonly prototype: HostBootDeviceSystem;
	}

	const HostBootDeviceSystem: HostBootDeviceSystemConstructor;

	interface HostCacheConfigurationManager extends VcHostCacheConfigurationManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostCacheConfigurationManagerConstructor {
		new(value?:any): HostCacheConfigurationManager;
		readonly prototype: HostCacheConfigurationManager;
	}

	const HostCacheConfigurationManager: HostCacheConfigurationManagerConstructor;

	interface HostCapabilityFtUnsupportedReason extends VcHostCapabilityFtUnsupportedReason
	{
		name: any;

	}

	interface HostCapabilityFtUnsupportedReasonConstructor {
		new(value?:any): HostCapabilityFtUnsupportedReason;
		readonly prototype: HostCapabilityFtUnsupportedReason;
	}

	const HostCapabilityFtUnsupportedReason: HostCapabilityFtUnsupportedReasonConstructor;

	interface HostCapabilityVmDirectPathGen2UnsupportedReason extends VcHostCapabilityVmDirectPathGen2UnsupportedReason
	{
		name: any;

	}

	interface HostCapabilityVmDirectPathGen2UnsupportedReasonConstructor {
		new(value?:any): HostCapabilityVmDirectPathGen2UnsupportedReason;
		readonly prototype: HostCapabilityVmDirectPathGen2UnsupportedReason;
	}

	const HostCapabilityVmDirectPathGen2UnsupportedReason: HostCapabilityVmDirectPathGen2UnsupportedReasonConstructor;

	interface HostCertificateManager extends VcHostCertificateManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostCertificateManagerConstructor {
		new(value?:any): HostCertificateManager;
		readonly prototype: HostCertificateManager;
	}

	const HostCertificateManager: HostCertificateManagerConstructor;

	interface HostCertificateManagerCertificateInfoCertificateStatus extends VcHostCertificateManagerCertificateInfoCertificateStatus
	{
		name: any;

	}

	interface HostCertificateManagerCertificateInfoCertificateStatusConstructor {
		new(value?:any): HostCertificateManagerCertificateInfoCertificateStatus;
		readonly prototype: HostCertificateManagerCertificateInfoCertificateStatus;
	}

	const HostCertificateManagerCertificateInfoCertificateStatus: HostCertificateManagerCertificateInfoCertificateStatusConstructor;

	interface HostConfigChangeMode extends VcHostConfigChangeMode
	{
		name: any;

	}

	interface HostConfigChangeModeConstructor {
		new(value?:any): HostConfigChangeMode;
		readonly prototype: HostConfigChangeMode;
	}

	const HostConfigChangeMode: HostConfigChangeModeConstructor;

	interface HostConfigChangeOperation extends VcHostConfigChangeOperation
	{
		name: any;

	}

	interface HostConfigChangeOperationConstructor {
		new(value?:any): HostConfigChangeOperation;
		readonly prototype: HostConfigChangeOperation;
	}

	const HostConfigChangeOperation: HostConfigChangeOperationConstructor;

	interface HostCpuPackageVendor extends VcHostCpuPackageVendor
	{
		name: any;

	}

	interface HostCpuPackageVendorConstructor {
		new(value?:any): HostCpuPackageVendor;
		readonly prototype: HostCpuPackageVendor;
	}

	const HostCpuPackageVendor: HostCpuPackageVendorConstructor;

	interface HostCpuPowerManagementInfoPolicyType extends VcHostCpuPowerManagementInfoPolicyType
	{
		name: any;

	}

	interface HostCpuPowerManagementInfoPolicyTypeConstructor {
		new(value?:any): HostCpuPowerManagementInfoPolicyType;
		readonly prototype: HostCpuPowerManagementInfoPolicyType;
	}

	const HostCpuPowerManagementInfoPolicyType: HostCpuPowerManagementInfoPolicyTypeConstructor;

	interface HostCpuSchedulerSystem extends VcHostCpuSchedulerSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostCpuSchedulerSystemConstructor {
		new(value?:any): HostCpuSchedulerSystem;
		readonly prototype: HostCpuSchedulerSystem;
	}

	const HostCpuSchedulerSystem: HostCpuSchedulerSystemConstructor;

	interface HostCryptoState extends VcHostCryptoState
	{
		name: any;

	}

	interface HostCryptoStateConstructor {
		new(value?:any): HostCryptoState;
		readonly prototype: HostCryptoState;
	}

	const HostCryptoState: HostCryptoStateConstructor;

	interface HostDasErrorEventHostDasErrorReason extends VcHostDasErrorEventHostDasErrorReason
	{
		name: any;

	}

	interface HostDasErrorEventHostDasErrorReasonConstructor {
		new(value?:any): HostDasErrorEventHostDasErrorReason;
		readonly prototype: HostDasErrorEventHostDasErrorReason;
	}

	const HostDasErrorEventHostDasErrorReason: HostDasErrorEventHostDasErrorReasonConstructor;

	interface HostDatastoreBrowser extends VcHostDatastoreBrowser
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostDatastoreBrowserConstructor {
		new(value?:any): HostDatastoreBrowser;
		readonly prototype: HostDatastoreBrowser;
	}

	const HostDatastoreBrowser: HostDatastoreBrowserConstructor;

	interface HostDatastoreSystem extends VcHostDatastoreSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostDatastoreSystemConstructor {
		new(value?:any): HostDatastoreSystem;
		readonly prototype: HostDatastoreSystem;
	}

	const HostDatastoreSystem: HostDatastoreSystemConstructor;

	interface HostDatastoreSystemDatastoreEventType extends VcHostDatastoreSystemDatastoreEventType
	{
		name: any;

	}

	interface HostDatastoreSystemDatastoreEventTypeConstructor {
		new(value?:any): HostDatastoreSystemDatastoreEventType;
		readonly prototype: HostDatastoreSystemDatastoreEventType;
	}

	const HostDatastoreSystemDatastoreEventType: HostDatastoreSystemDatastoreEventTypeConstructor;

	interface HostDatastoreSystemVmfsEventType extends VcHostDatastoreSystemVmfsEventType
	{
		name: any;

	}

	interface HostDatastoreSystemVmfsEventTypeConstructor {
		new(value?:any): HostDatastoreSystemVmfsEventType;
		readonly prototype: HostDatastoreSystemVmfsEventType;
	}

	const HostDatastoreSystemVmfsEventType: HostDatastoreSystemVmfsEventTypeConstructor;

	interface HostDateTimeSystem extends VcHostDateTimeSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostDateTimeSystemConstructor {
		new(value?:any): HostDateTimeSystem;
		readonly prototype: HostDateTimeSystem;
	}

	const HostDateTimeSystem: HostDateTimeSystemConstructor;

	interface HostDiagnosticSystem extends VcHostDiagnosticSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostDiagnosticSystemConstructor {
		new(value?:any): HostDiagnosticSystem;
		readonly prototype: HostDiagnosticSystem;
	}

	const HostDiagnosticSystem: HostDiagnosticSystemConstructor;

	interface HostDigestInfoDigestMethodType extends VcHostDigestInfoDigestMethodType
	{
		name: any;

	}

	interface HostDigestInfoDigestMethodTypeConstructor {
		new(value?:any): HostDigestInfoDigestMethodType;
		readonly prototype: HostDigestInfoDigestMethodType;
	}

	const HostDigestInfoDigestMethodType: HostDigestInfoDigestMethodTypeConstructor;

	interface HostDirectoryStore extends VcHostDirectoryStore
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostDirectoryStoreConstructor {
		new(value?:any): HostDirectoryStore;
		readonly prototype: HostDirectoryStore;
	}

	const HostDirectoryStore: HostDirectoryStoreConstructor;

	interface HostDisconnectedEventReasonCode extends VcHostDisconnectedEventReasonCode
	{
		name: any;

	}

	interface HostDisconnectedEventReasonCodeConstructor {
		new(value?:any): HostDisconnectedEventReasonCode;
		readonly prototype: HostDisconnectedEventReasonCode;
	}

	const HostDisconnectedEventReasonCode: HostDisconnectedEventReasonCodeConstructor;

	interface HostDiskManager extends VcHostDiskManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostDiskManagerConstructor {
		new(value?:any): HostDiskManager;
		readonly prototype: HostDiskManager;
	}

	const HostDiskManager: HostDiskManagerConstructor;

	interface HostDiskManagerLease extends VcHostDiskManagerLease
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostDiskManagerLeaseConstructor {
		new(value?:any): HostDiskManagerLease;
		readonly prototype: HostDiskManagerLease;
	}

	const HostDiskManagerLease: HostDiskManagerLeaseConstructor;

	interface HostDiskPartitionInfoPartitionFormat extends VcHostDiskPartitionInfoPartitionFormat
	{
		name: any;

	}

	interface HostDiskPartitionInfoPartitionFormatConstructor {
		new(value?:any): HostDiskPartitionInfoPartitionFormat;
		readonly prototype: HostDiskPartitionInfoPartitionFormat;
	}

	const HostDiskPartitionInfoPartitionFormat: HostDiskPartitionInfoPartitionFormatConstructor;

	interface HostDiskPartitionInfoType extends VcHostDiskPartitionInfoType
	{
		name: any;

	}

	interface HostDiskPartitionInfoTypeConstructor {
		new(value?:any): HostDiskPartitionInfoType;
		readonly prototype: HostDiskPartitionInfoType;
	}

	const HostDiskPartitionInfoType: HostDiskPartitionInfoTypeConstructor;

	interface HostDistributedVirtualSwitchManager extends VcHostDistributedVirtualSwitchManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostDistributedVirtualSwitchManagerConstructor {
		new(value?:any): HostDistributedVirtualSwitchManager;
		readonly prototype: HostDistributedVirtualSwitchManager;
	}

	const HostDistributedVirtualSwitchManager: HostDistributedVirtualSwitchManagerConstructor;

	interface HostDistributedVirtualSwitchManagerFetchPortOption extends VcHostDistributedVirtualSwitchManagerFetchPortOption
	{
		name: any;

	}

	interface HostDistributedVirtualSwitchManagerFetchPortOptionConstructor {
		new(value?:any): HostDistributedVirtualSwitchManagerFetchPortOption;
		readonly prototype: HostDistributedVirtualSwitchManagerFetchPortOption;
	}

	const HostDistributedVirtualSwitchManagerFetchPortOption: HostDistributedVirtualSwitchManagerFetchPortOptionConstructor;

	interface HostDistributedVirtualSwitchManagerNetworkResourcePoolKey extends VcHostDistributedVirtualSwitchManagerNetworkResourcePoolKey
	{
		name: any;

	}

	interface HostDistributedVirtualSwitchManagerNetworkResourcePoolKeyConstructor {
		new(value?:any): HostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
		readonly prototype: HostDistributedVirtualSwitchManagerNetworkResourcePoolKey;
	}

	const HostDistributedVirtualSwitchManagerNetworkResourcePoolKey: HostDistributedVirtualSwitchManagerNetworkResourcePoolKeyConstructor;

	interface HostEsxAgentHostManager extends VcHostEsxAgentHostManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostEsxAgentHostManagerConstructor {
		new(value?:any): HostEsxAgentHostManager;
		readonly prototype: HostEsxAgentHostManager;
	}

	const HostEsxAgentHostManager: HostEsxAgentHostManagerConstructor;

	interface HostFaultToleranceManager extends VcHostFaultToleranceManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostFaultToleranceManagerConstructor {
		new(value?:any): HostFaultToleranceManager;
		readonly prototype: HostFaultToleranceManager;
	}

	const HostFaultToleranceManager: HostFaultToleranceManagerConstructor;

	interface HostFaultToleranceManagerFaultToleranceType extends VcHostFaultToleranceManagerFaultToleranceType
	{
		name: any;

	}

	interface HostFaultToleranceManagerFaultToleranceTypeConstructor {
		new(value?:any): HostFaultToleranceManagerFaultToleranceType;
		readonly prototype: HostFaultToleranceManagerFaultToleranceType;
	}

	const HostFaultToleranceManagerFaultToleranceType: HostFaultToleranceManagerFaultToleranceTypeConstructor;

	interface HostFeatureVersionKey extends VcHostFeatureVersionKey
	{
		name: any;

	}

	interface HostFeatureVersionKeyConstructor {
		new(value?:any): HostFeatureVersionKey;
		readonly prototype: HostFeatureVersionKey;
	}

	const HostFeatureVersionKey: HostFeatureVersionKeyConstructor;

	interface HostFileSystemVolumeFileSystemType extends VcHostFileSystemVolumeFileSystemType
	{
		name: any;

	}

	interface HostFileSystemVolumeFileSystemTypeConstructor {
		new(value?:any): HostFileSystemVolumeFileSystemType;
		readonly prototype: HostFileSystemVolumeFileSystemType;
	}

	const HostFileSystemVolumeFileSystemType: HostFileSystemVolumeFileSystemTypeConstructor;

	interface HostFirewallRuleDirection extends VcHostFirewallRuleDirection
	{
		name: any;

	}

	interface HostFirewallRuleDirectionConstructor {
		new(value?:any): HostFirewallRuleDirection;
		readonly prototype: HostFirewallRuleDirection;
	}

	const HostFirewallRuleDirection: HostFirewallRuleDirectionConstructor;

	interface HostFirewallRulePortType extends VcHostFirewallRulePortType
	{
		name: any;

	}

	interface HostFirewallRulePortTypeConstructor {
		new(value?:any): HostFirewallRulePortType;
		readonly prototype: HostFirewallRulePortType;
	}

	const HostFirewallRulePortType: HostFirewallRulePortTypeConstructor;

	interface HostFirewallRuleProtocol extends VcHostFirewallRuleProtocol
	{
		name: any;

	}

	interface HostFirewallRuleProtocolConstructor {
		new(value?:any): HostFirewallRuleProtocol;
		readonly prototype: HostFirewallRuleProtocol;
	}

	const HostFirewallRuleProtocol: HostFirewallRuleProtocolConstructor;

	interface HostFirewallSystem extends VcHostFirewallSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostFirewallSystemConstructor {
		new(value?:any): HostFirewallSystem;
		readonly prototype: HostFirewallSystem;
	}

	const HostFirewallSystem: HostFirewallSystemConstructor;

	interface HostFirmwareSystem extends VcHostFirmwareSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostFirmwareSystemConstructor {
		new(value?:any): HostFirmwareSystem;
		readonly prototype: HostFirmwareSystem;
	}

	const HostFirmwareSystem: HostFirmwareSystemConstructor;

	interface HostFolder extends VcHostFolder
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;

		getComputeResource_ClusterComputeResource(): ClusterComputeResource;
		getComputeResource_ComputeResource(): ComputeResource;
		getHostFolder(): HostFolder;
	}

	interface HostFolderConstructor {
		new(value?:any): HostFolder;
		readonly prototype: HostFolder;
	}

	const HostFolder: HostFolderConstructor;

	interface HostGraphicsConfigGraphicsType extends VcHostGraphicsConfigGraphicsType
	{
		name: any;

	}

	interface HostGraphicsConfigGraphicsTypeConstructor {
		new(value?:any): HostGraphicsConfigGraphicsType;
		readonly prototype: HostGraphicsConfigGraphicsType;
	}

	const HostGraphicsConfigGraphicsType: HostGraphicsConfigGraphicsTypeConstructor;

	interface HostGraphicsConfigSharedPassthruAssignmentPolicy extends VcHostGraphicsConfigSharedPassthruAssignmentPolicy
	{
		name: any;

	}

	interface HostGraphicsConfigSharedPassthruAssignmentPolicyConstructor {
		new(value?:any): HostGraphicsConfigSharedPassthruAssignmentPolicy;
		readonly prototype: HostGraphicsConfigSharedPassthruAssignmentPolicy;
	}

	const HostGraphicsConfigSharedPassthruAssignmentPolicy: HostGraphicsConfigSharedPassthruAssignmentPolicyConstructor;

	interface HostGraphicsInfoGraphicsType extends VcHostGraphicsInfoGraphicsType
	{
		name: any;

	}

	interface HostGraphicsInfoGraphicsTypeConstructor {
		new(value?:any): HostGraphicsInfoGraphicsType;
		readonly prototype: HostGraphicsInfoGraphicsType;
	}

	const HostGraphicsInfoGraphicsType: HostGraphicsInfoGraphicsTypeConstructor;

	interface HostGraphicsManager extends VcHostGraphicsManager
	{
		id: any;
		sdkId: any;
		sharedGraphicsActive: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostGraphicsManagerConstructor {
		new(value?:any): HostGraphicsManager;
		readonly prototype: HostGraphicsManager;
	}

	const HostGraphicsManager: HostGraphicsManagerConstructor;

	interface HostHardwareElementStatus extends VcHostHardwareElementStatus
	{
		name: any;

	}

	interface HostHardwareElementStatusConstructor {
		new(value?:any): HostHardwareElementStatus;
		readonly prototype: HostHardwareElementStatus;
	}

	const HostHardwareElementStatus: HostHardwareElementStatusConstructor;

	interface HostHasComponentFailureHostComponentType extends VcHostHasComponentFailureHostComponentType
	{
		name: any;

	}

	interface HostHasComponentFailureHostComponentTypeConstructor {
		new(value?:any): HostHasComponentFailureHostComponentType;
		readonly prototype: HostHasComponentFailureHostComponentType;
	}

	const HostHasComponentFailureHostComponentType: HostHasComponentFailureHostComponentTypeConstructor;

	interface HostHealthStatusSystem extends VcHostHealthStatusSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostHealthStatusSystemConstructor {
		new(value?:any): HostHealthStatusSystem;
		readonly prototype: HostHealthStatusSystem;
	}

	const HostHealthStatusSystem: HostHealthStatusSystemConstructor;

	interface HostHostUpdateProxyManager extends VcHostHostUpdateProxyManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostHostUpdateProxyManagerConstructor {
		new(value?:any): HostHostUpdateProxyManager;
		readonly prototype: HostHostUpdateProxyManager;
	}

	const HostHostUpdateProxyManager: HostHostUpdateProxyManagerConstructor;

	interface HostImageAcceptanceLevel extends VcHostImageAcceptanceLevel
	{
		name: any;

	}

	interface HostImageAcceptanceLevelConstructor {
		new(value?:any): HostImageAcceptanceLevel;
		readonly prototype: HostImageAcceptanceLevel;
	}

	const HostImageAcceptanceLevel: HostImageAcceptanceLevelConstructor;

	interface HostImageConfigManager extends VcHostImageConfigManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostImageConfigManagerConstructor {
		new(value?:any): HostImageConfigManager;
		readonly prototype: HostImageConfigManager;
	}

	const HostImageConfigManager: HostImageConfigManagerConstructor;

	interface HostIncompatibleForFaultToleranceReason extends VcHostIncompatibleForFaultToleranceReason
	{
		name: any;

	}

	interface HostIncompatibleForFaultToleranceReasonConstructor {
		new(value?:any): HostIncompatibleForFaultToleranceReason;
		readonly prototype: HostIncompatibleForFaultToleranceReason;
	}

	const HostIncompatibleForFaultToleranceReason: HostIncompatibleForFaultToleranceReasonConstructor;

	interface HostIncompatibleForRecordReplayReason extends VcHostIncompatibleForRecordReplayReason
	{
		name: any;

	}

	interface HostIncompatibleForRecordReplayReasonConstructor {
		new(value?:any): HostIncompatibleForRecordReplayReason;
		readonly prototype: HostIncompatibleForRecordReplayReason;
	}

	const HostIncompatibleForRecordReplayReason: HostIncompatibleForRecordReplayReasonConstructor;

	interface HostInternetScsiHbaChapAuthenticationType extends VcHostInternetScsiHbaChapAuthenticationType
	{
		name: any;

	}

	interface HostInternetScsiHbaChapAuthenticationTypeConstructor {
		new(value?:any): HostInternetScsiHbaChapAuthenticationType;
		readonly prototype: HostInternetScsiHbaChapAuthenticationType;
	}

	const HostInternetScsiHbaChapAuthenticationType: HostInternetScsiHbaChapAuthenticationTypeConstructor;

	interface HostInternetScsiHbaDigestType extends VcHostInternetScsiHbaDigestType
	{
		name: any;

	}

	interface HostInternetScsiHbaDigestTypeConstructor {
		new(value?:any): HostInternetScsiHbaDigestType;
		readonly prototype: HostInternetScsiHbaDigestType;
	}

	const HostInternetScsiHbaDigestType: HostInternetScsiHbaDigestTypeConstructor;

	interface HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType extends VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType
	{
		name: any;

	}

	interface HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationTypeConstructor {
		new(value?:any): HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly prototype: HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
	}

	const HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType: HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationTypeConstructor;

	interface HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation extends VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation
	{
		name: any;

	}

	interface HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperationConstructor {
		new(value?:any): HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
		readonly prototype: HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
	}

	const HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation: HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperationConstructor;

	interface HostInternetScsiHbaNetworkBindingSupportType extends VcHostInternetScsiHbaNetworkBindingSupportType
	{
		name: any;

	}

	interface HostInternetScsiHbaNetworkBindingSupportTypeConstructor {
		new(value?:any): HostInternetScsiHbaNetworkBindingSupportType;
		readonly prototype: HostInternetScsiHbaNetworkBindingSupportType;
	}

	const HostInternetScsiHbaNetworkBindingSupportType: HostInternetScsiHbaNetworkBindingSupportTypeConstructor;

	interface HostInternetScsiHbaStaticTargetTargetDiscoveryMethod extends VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod
	{
		name: any;

	}

	interface HostInternetScsiHbaStaticTargetTargetDiscoveryMethodConstructor {
		new(value?:any): HostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly prototype: HostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
	}

	const HostInternetScsiHbaStaticTargetTargetDiscoveryMethod: HostInternetScsiHbaStaticTargetTargetDiscoveryMethodConstructor;

	interface HostIpConfigIpV6AddressConfigType extends VcHostIpConfigIpV6AddressConfigType
	{
		name: any;

	}

	interface HostIpConfigIpV6AddressConfigTypeConstructor {
		new(value?:any): HostIpConfigIpV6AddressConfigType;
		readonly prototype: HostIpConfigIpV6AddressConfigType;
	}

	const HostIpConfigIpV6AddressConfigType: HostIpConfigIpV6AddressConfigTypeConstructor;

	interface HostIpConfigIpV6AddressStatus extends VcHostIpConfigIpV6AddressStatus
	{
		name: any;

	}

	interface HostIpConfigIpV6AddressStatusConstructor {
		new(value?:any): HostIpConfigIpV6AddressStatus;
		readonly prototype: HostIpConfigIpV6AddressStatus;
	}

	const HostIpConfigIpV6AddressStatus: HostIpConfigIpV6AddressStatusConstructor;

	interface HostKernelModuleSystem extends VcHostKernelModuleSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostKernelModuleSystemConstructor {
		new(value?:any): HostKernelModuleSystem;
		readonly prototype: HostKernelModuleSystem;
	}

	const HostKernelModuleSystem: HostKernelModuleSystemConstructor;

	interface HostLicensableResourceKey extends VcHostLicensableResourceKey
	{
		name: any;

	}

	interface HostLicensableResourceKeyConstructor {
		new(value?:any): HostLicensableResourceKey;
		readonly prototype: HostLicensableResourceKey;
	}

	const HostLicensableResourceKey: HostLicensableResourceKeyConstructor;

	interface HostLocalAccountManager extends VcHostLocalAccountManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostLocalAccountManagerConstructor {
		new(value?:any): HostLocalAccountManager;
		readonly prototype: HostLocalAccountManager;
	}

	const HostLocalAccountManager: HostLocalAccountManagerConstructor;

	interface HostLocalAuthentication extends VcHostLocalAuthentication
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostLocalAuthenticationConstructor {
		new(value?:any): HostLocalAuthentication;
		readonly prototype: HostLocalAuthentication;
	}

	const HostLocalAuthentication: HostLocalAuthenticationConstructor;

	interface HostLockdownMode extends VcHostLockdownMode
	{
		name: any;

	}

	interface HostLockdownModeConstructor {
		new(value?:any): HostLockdownMode;
		readonly prototype: HostLockdownMode;
	}

	const HostLockdownMode: HostLockdownModeConstructor;

	interface HostLowLevelProvisioningManager extends VcHostLowLevelProvisioningManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostLowLevelProvisioningManagerConstructor {
		new(value?:any): HostLowLevelProvisioningManager;
		readonly prototype: HostLowLevelProvisioningManager;
	}

	const HostLowLevelProvisioningManager: HostLowLevelProvisioningManagerConstructor;

	interface HostLowLevelProvisioningManagerFileType extends VcHostLowLevelProvisioningManagerFileType
	{
		name: any;

	}

	interface HostLowLevelProvisioningManagerFileTypeConstructor {
		new(value?:any): HostLowLevelProvisioningManagerFileType;
		readonly prototype: HostLowLevelProvisioningManagerFileType;
	}

	const HostLowLevelProvisioningManagerFileType: HostLowLevelProvisioningManagerFileTypeConstructor;

	interface HostLowLevelProvisioningManagerReloadTarget extends VcHostLowLevelProvisioningManagerReloadTarget
	{
		name: any;

	}

	interface HostLowLevelProvisioningManagerReloadTargetConstructor {
		new(value?:any): HostLowLevelProvisioningManagerReloadTarget;
		readonly prototype: HostLowLevelProvisioningManagerReloadTarget;
	}

	const HostLowLevelProvisioningManagerReloadTarget: HostLowLevelProvisioningManagerReloadTargetConstructor;

	interface HostMemorySystem extends VcHostMemorySystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostMemorySystemConstructor {
		new(value?:any): HostMemorySystem;
		readonly prototype: HostMemorySystem;
	}

	const HostMemorySystem: HostMemorySystemConstructor;

	interface HostMountInfoInaccessibleReason extends VcHostMountInfoInaccessibleReason
	{
		name: any;

	}

	interface HostMountInfoInaccessibleReasonConstructor {
		new(value?:any): HostMountInfoInaccessibleReason;
		readonly prototype: HostMountInfoInaccessibleReason;
	}

	const HostMountInfoInaccessibleReason: HostMountInfoInaccessibleReasonConstructor;

	interface HostMountMode extends VcHostMountMode
	{
		name: any;

	}

	interface HostMountModeConstructor {
		new(value?:any): HostMountMode;
		readonly prototype: HostMountMode;
	}

	const HostMountMode: HostMountModeConstructor;

	interface HostNasVolumeSecurityType extends VcHostNasVolumeSecurityType
	{
		name: any;

	}

	interface HostNasVolumeSecurityTypeConstructor {
		new(value?:any): HostNasVolumeSecurityType;
		readonly prototype: HostNasVolumeSecurityType;
	}

	const HostNasVolumeSecurityType: HostNasVolumeSecurityTypeConstructor;

	interface HostNetStackInstanceCongestionControlAlgorithmType extends VcHostNetStackInstanceCongestionControlAlgorithmType
	{
		name: any;

	}

	interface HostNetStackInstanceCongestionControlAlgorithmTypeConstructor {
		new(value?:any): HostNetStackInstanceCongestionControlAlgorithmType;
		readonly prototype: HostNetStackInstanceCongestionControlAlgorithmType;
	}

	const HostNetStackInstanceCongestionControlAlgorithmType: HostNetStackInstanceCongestionControlAlgorithmTypeConstructor;

	interface HostNetStackInstanceSystemStackKey extends VcHostNetStackInstanceSystemStackKey
	{
		name: any;

	}

	interface HostNetStackInstanceSystemStackKeyConstructor {
		new(value?:any): HostNetStackInstanceSystemStackKey;
		readonly prototype: HostNetStackInstanceSystemStackKey;
	}

	const HostNetStackInstanceSystemStackKey: HostNetStackInstanceSystemStackKeyConstructor;

	interface HostNetworkSystem extends VcHostNetworkSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostNetworkSystemConstructor {
		new(value?:any): HostNetworkSystem;
		readonly prototype: HostNetworkSystem;
	}

	const HostNetworkSystem: HostNetworkSystemConstructor;

	interface HostNumericSensorHealthState extends VcHostNumericSensorHealthState
	{
		name: any;

	}

	interface HostNumericSensorHealthStateConstructor {
		new(value?:any): HostNumericSensorHealthState;
		readonly prototype: HostNumericSensorHealthState;
	}

	const HostNumericSensorHealthState: HostNumericSensorHealthStateConstructor;

	interface HostNumericSensorType extends VcHostNumericSensorType
	{
		name: any;

	}

	interface HostNumericSensorTypeConstructor {
		new(value?:any): HostNumericSensorType;
		readonly prototype: HostNumericSensorType;
	}

	const HostNumericSensorType: HostNumericSensorTypeConstructor;

	interface HostNvdimmSystem extends VcHostNvdimmSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostNvdimmSystemConstructor {
		new(value?:any): HostNvdimmSystem;
		readonly prototype: HostNvdimmSystem;
	}

	const HostNvdimmSystem: HostNvdimmSystemConstructor;

	interface HostOpaqueSwitchOpaqueSwitchState extends VcHostOpaqueSwitchOpaqueSwitchState
	{
		name: any;

	}

	interface HostOpaqueSwitchOpaqueSwitchStateConstructor {
		new(value?:any): HostOpaqueSwitchOpaqueSwitchState;
		readonly prototype: HostOpaqueSwitchOpaqueSwitchState;
	}

	const HostOpaqueSwitchOpaqueSwitchState: HostOpaqueSwitchOpaqueSwitchStateConstructor;

	interface HostOperationCleanupManager extends VcHostOperationCleanupManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostOperationCleanupManagerConstructor {
		new(value?:any): HostOperationCleanupManager;
		readonly prototype: HostOperationCleanupManager;
	}

	const HostOperationCleanupManager: HostOperationCleanupManagerConstructor;

	interface HostOperationCleanupManagerCleanupItemType extends VcHostOperationCleanupManagerCleanupItemType
	{
		name: any;

	}

	interface HostOperationCleanupManagerCleanupItemTypeConstructor {
		new(value?:any): HostOperationCleanupManagerCleanupItemType;
		readonly prototype: HostOperationCleanupManagerCleanupItemType;
	}

	const HostOperationCleanupManagerCleanupItemType: HostOperationCleanupManagerCleanupItemTypeConstructor;

	interface HostOperationCleanupManagerOperationActivity extends VcHostOperationCleanupManagerOperationActivity
	{
		name: any;

	}

	interface HostOperationCleanupManagerOperationActivityConstructor {
		new(value?:any): HostOperationCleanupManagerOperationActivity;
		readonly prototype: HostOperationCleanupManagerOperationActivity;
	}

	const HostOperationCleanupManagerOperationActivity: HostOperationCleanupManagerOperationActivityConstructor;

	interface HostOperationCleanupManagerOperationState extends VcHostOperationCleanupManagerOperationState
	{
		name: any;

	}

	interface HostOperationCleanupManagerOperationStateConstructor {
		new(value?:any): HostOperationCleanupManagerOperationState;
		readonly prototype: HostOperationCleanupManagerOperationState;
	}

	const HostOperationCleanupManagerOperationState: HostOperationCleanupManagerOperationStateConstructor;

	interface HostPatchManager extends VcHostPatchManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostPatchManagerConstructor {
		new(value?:any): HostPatchManager;
		readonly prototype: HostPatchManager;
	}

	const HostPatchManager: HostPatchManagerConstructor;

	interface HostPatchManagerInstallState extends VcHostPatchManagerInstallState
	{
		name: any;

	}

	interface HostPatchManagerInstallStateConstructor {
		new(value?:any): HostPatchManagerInstallState;
		readonly prototype: HostPatchManagerInstallState;
	}

	const HostPatchManagerInstallState: HostPatchManagerInstallStateConstructor;

	interface HostPatchManagerIntegrityStatus extends VcHostPatchManagerIntegrityStatus
	{
		name: any;

	}

	interface HostPatchManagerIntegrityStatusConstructor {
		new(value?:any): HostPatchManagerIntegrityStatus;
		readonly prototype: HostPatchManagerIntegrityStatus;
	}

	const HostPatchManagerIntegrityStatus: HostPatchManagerIntegrityStatusConstructor;

	interface HostPatchManagerReason extends VcHostPatchManagerReason
	{
		name: any;

	}

	interface HostPatchManagerReasonConstructor {
		new(value?:any): HostPatchManagerReason;
		readonly prototype: HostPatchManagerReason;
	}

	const HostPatchManagerReason: HostPatchManagerReasonConstructor;

	interface HostPciPassthruSystem extends VcHostPciPassthruSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostPciPassthruSystemConstructor {
		new(value?:any): HostPciPassthruSystem;
		readonly prototype: HostPciPassthruSystem;
	}

	const HostPciPassthruSystem: HostPciPassthruSystemConstructor;

	interface HostPowerOperationType extends VcHostPowerOperationType
	{
		name: any;

	}

	interface HostPowerOperationTypeConstructor {
		new(value?:any): HostPowerOperationType;
		readonly prototype: HostPowerOperationType;
	}

	const HostPowerOperationType: HostPowerOperationTypeConstructor;

	interface HostPowerSystem extends VcHostPowerSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostPowerSystemConstructor {
		new(value?:any): HostPowerSystem;
		readonly prototype: HostPowerSystem;
	}

	const HostPowerSystem: HostPowerSystemConstructor;

	interface HostProfile extends VcHostProfile
	{
		complianceStatus: any;
		createdTime: any;
		id: any;
		modifiedTime: any;
		name: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostProfileConstructor {
		new(value?:any): HostProfile;
		readonly prototype: HostProfile;
	}

	const HostProfile: HostProfileConstructor;

	interface HostProfileManager extends VcHostProfileManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostProfileManagerConstructor {
		new(value?:any): HostProfileManager;
		readonly prototype: HostProfileManager;
	}

	const HostProfileManager: HostProfileManagerConstructor;

	interface HostProfileManagerAnswerFileStatus extends VcHostProfileManagerAnswerFileStatus
	{
		name: any;

	}

	interface HostProfileManagerAnswerFileStatusConstructor {
		new(value?:any): HostProfileManagerAnswerFileStatus;
		readonly prototype: HostProfileManagerAnswerFileStatus;
	}

	const HostProfileManagerAnswerFileStatus: HostProfileManagerAnswerFileStatusConstructor;

	interface HostProfileManagerCompositionResultResultElementStatus extends VcHostProfileManagerCompositionResultResultElementStatus
	{
		name: any;

	}

	interface HostProfileManagerCompositionResultResultElementStatusConstructor {
		new(value?:any): HostProfileManagerCompositionResultResultElementStatus;
		readonly prototype: HostProfileManagerCompositionResultResultElementStatus;
	}

	const HostProfileManagerCompositionResultResultElementStatus: HostProfileManagerCompositionResultResultElementStatusConstructor;

	interface HostProfileManagerCompositionValidationResultResultElementStatus extends VcHostProfileManagerCompositionValidationResultResultElementStatus
	{
		name: any;

	}

	interface HostProfileManagerCompositionValidationResultResultElementStatusConstructor {
		new(value?:any): HostProfileManagerCompositionValidationResultResultElementStatus;
		readonly prototype: HostProfileManagerCompositionValidationResultResultElementStatus;
	}

	const HostProfileManagerCompositionValidationResultResultElementStatus: HostProfileManagerCompositionValidationResultResultElementStatusConstructor;

	interface HostProfileManagerMetadataTypes extends VcHostProfileManagerMetadataTypes
	{
		name: any;

	}

	interface HostProfileManagerMetadataTypesConstructor {
		new(value?:any): HostProfileManagerMetadataTypes;
		readonly prototype: HostProfileManagerMetadataTypes;
	}

	const HostProfileManagerMetadataTypes: HostProfileManagerMetadataTypesConstructor;

	interface HostProfileManagerTaskListRequirement extends VcHostProfileManagerTaskListRequirement
	{
		name: any;

	}

	interface HostProfileManagerTaskListRequirementConstructor {
		new(value?:any): HostProfileManagerTaskListRequirement;
		readonly prototype: HostProfileManagerTaskListRequirement;
	}

	const HostProfileManagerTaskListRequirement: HostProfileManagerTaskListRequirementConstructor;

	interface HostProtocolEndpointPEType extends VcHostProtocolEndpointPEType
	{
		name: any;

	}

	interface HostProtocolEndpointPETypeConstructor {
		new(value?:any): HostProtocolEndpointPEType;
		readonly prototype: HostProtocolEndpointPEType;
	}

	const HostProtocolEndpointPEType: HostProtocolEndpointPETypeConstructor;

	interface HostProtocolEndpointProtocolEndpointType extends VcHostProtocolEndpointProtocolEndpointType
	{
		name: any;

	}

	interface HostProtocolEndpointProtocolEndpointTypeConstructor {
		new(value?:any): HostProtocolEndpointProtocolEndpointType;
		readonly prototype: HostProtocolEndpointProtocolEndpointType;
	}

	const HostProtocolEndpointProtocolEndpointType: HostProtocolEndpointProtocolEndpointTypeConstructor;

	interface HostReplayUnsupportedReason extends VcHostReplayUnsupportedReason
	{
		name: any;

	}

	interface HostReplayUnsupportedReasonConstructor {
		new(value?:any): HostReplayUnsupportedReason;
		readonly prototype: HostReplayUnsupportedReason;
	}

	const HostReplayUnsupportedReason: HostReplayUnsupportedReasonConstructor;

	interface HostRuntimeInfoNetStackInstanceRuntimeInfoState extends VcHostRuntimeInfoNetStackInstanceRuntimeInfoState
	{
		name: any;

	}

	interface HostRuntimeInfoNetStackInstanceRuntimeInfoStateConstructor {
		new(value?:any): HostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly prototype: HostRuntimeInfoNetStackInstanceRuntimeInfoState;
	}

	const HostRuntimeInfoNetStackInstanceRuntimeInfoState: HostRuntimeInfoNetStackInstanceRuntimeInfoStateConstructor;

	interface HostServicePolicy extends VcHostServicePolicy
	{
		name: any;

	}

	interface HostServicePolicyConstructor {
		new(value?:any): HostServicePolicy;
		readonly prototype: HostServicePolicy;
	}

	const HostServicePolicy: HostServicePolicyConstructor;

	interface HostServiceSystem extends VcHostServiceSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostServiceSystemConstructor {
		new(value?:any): HostServiceSystem;
		readonly prototype: HostServiceSystem;
	}

	const HostServiceSystem: HostServiceSystemConstructor;

	interface HostSignatureInfoSigningMethodType extends VcHostSignatureInfoSigningMethodType
	{
		name: any;

	}

	interface HostSignatureInfoSigningMethodTypeConstructor {
		new(value?:any): HostSignatureInfoSigningMethodType;
		readonly prototype: HostSignatureInfoSigningMethodType;
	}

	const HostSignatureInfoSigningMethodType: HostSignatureInfoSigningMethodTypeConstructor;

	interface HostSnmpAgentCapability extends VcHostSnmpAgentCapability
	{
		name: any;

	}

	interface HostSnmpAgentCapabilityConstructor {
		new(value?:any): HostSnmpAgentCapability;
		readonly prototype: HostSnmpAgentCapability;
	}

	const HostSnmpAgentCapability: HostSnmpAgentCapabilityConstructor;

	interface HostSnmpSystem extends VcHostSnmpSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostSnmpSystemConstructor {
		new(value?:any): HostSnmpSystem;
		readonly prototype: HostSnmpSystem;
	}

	const HostSnmpSystem: HostSnmpSystemConstructor;

	interface HostSpecificationAgent extends VcHostSpecificationAgent
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostSpecificationAgentConstructor {
		new(value?:any): HostSpecificationAgent;
		readonly prototype: HostSpecificationAgent;
	}

	const HostSpecificationAgent: HostSpecificationAgentConstructor;

	interface HostSpecificationManager extends VcHostSpecificationManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostSpecificationManagerConstructor {
		new(value?:any): HostSpecificationManager;
		readonly prototype: HostSpecificationManager;
	}

	const HostSpecificationManager: HostSpecificationManagerConstructor;

	interface HostStandbyMode extends VcHostStandbyMode
	{
		name: any;

	}

	interface HostStandbyModeConstructor {
		new(value?:any): HostStandbyMode;
		readonly prototype: HostStandbyMode;
	}

	const HostStandbyMode: HostStandbyModeConstructor;

	interface HostStorageSystem extends VcHostStorageSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostStorageSystemConstructor {
		new(value?:any): HostStorageSystem;
		readonly prototype: HostStorageSystem;
	}

	const HostStorageSystem: HostStorageSystemConstructor;

	interface HostSystem extends VcHostSystem
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		state: any;
		type: any;
		uuid: any;
		version: any;
		vimId: any;
		vimType: any;

		ds(): Datastore;
		dvp(): DistributedVirtualPortgroup;
		network(): Network;
		vms(): VirtualMachine;
	}

	interface HostSystemConstructor {
		new(value?:any): HostSystem;
		readonly prototype: HostSystem;
	}

	const HostSystem: HostSystemConstructor;

	interface HostSystemConnectionState extends VcHostSystemConnectionState
	{
		name: any;

	}

	interface HostSystemConnectionStateConstructor {
		new(value?:any): HostSystemConnectionState;
		readonly prototype: HostSystemConnectionState;
	}

	const HostSystemConnectionState: HostSystemConnectionStateConstructor;

	interface HostSystemDebugManager extends VcHostSystemDebugManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostSystemDebugManagerConstructor {
		new(value?:any): HostSystemDebugManager;
		readonly prototype: HostSystemDebugManager;
	}

	const HostSystemDebugManager: HostSystemDebugManagerConstructor;

	interface HostSystemDebugManagerProcessKey extends VcHostSystemDebugManagerProcessKey
	{
		name: any;

	}

	interface HostSystemDebugManagerProcessKeyConstructor {
		new(value?:any): HostSystemDebugManagerProcessKey;
		readonly prototype: HostSystemDebugManagerProcessKey;
	}

	const HostSystemDebugManagerProcessKey: HostSystemDebugManagerProcessKeyConstructor;

	interface HostSystemIdentificationInfoIdentifier extends VcHostSystemIdentificationInfoIdentifier
	{
		name: any;

	}

	interface HostSystemIdentificationInfoIdentifierConstructor {
		new(value?:any): HostSystemIdentificationInfoIdentifier;
		readonly prototype: HostSystemIdentificationInfoIdentifier;
	}

	const HostSystemIdentificationInfoIdentifier: HostSystemIdentificationInfoIdentifierConstructor;

	interface HostSystemPowerState extends VcHostSystemPowerState
	{
		name: any;

	}

	interface HostSystemPowerStateConstructor {
		new(value?:any): HostSystemPowerState;
		readonly prototype: HostSystemPowerState;
	}

	const HostSystemPowerState: HostSystemPowerStateConstructor;

	interface HostTpmManager extends VcHostTpmManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostTpmManagerConstructor {
		new(value?:any): HostTpmManager;
		readonly prototype: HostTpmManager;
	}

	const HostTpmManager: HostTpmManagerConstructor;

	interface HostUnresolvedVmfsExtentUnresolvedReason extends VcHostUnresolvedVmfsExtentUnresolvedReason
	{
		name: any;

	}

	interface HostUnresolvedVmfsExtentUnresolvedReasonConstructor {
		new(value?:any): HostUnresolvedVmfsExtentUnresolvedReason;
		readonly prototype: HostUnresolvedVmfsExtentUnresolvedReason;
	}

	const HostUnresolvedVmfsExtentUnresolvedReason: HostUnresolvedVmfsExtentUnresolvedReasonConstructor;

	interface HostUnresolvedVmfsResolutionSpecVmfsUuidResolution extends VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution
	{
		name: any;

	}

	interface HostUnresolvedVmfsResolutionSpecVmfsUuidResolutionConstructor {
		new(value?:any): HostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
		readonly prototype: HostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
	}

	const HostUnresolvedVmfsResolutionSpecVmfsUuidResolution: HostUnresolvedVmfsResolutionSpecVmfsUuidResolutionConstructor;

	interface HostVFlashManager extends VcHostVFlashManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostVFlashManagerConstructor {
		new(value?:any): HostVFlashManager;
		readonly prototype: HostVFlashManager;
	}

	const HostVFlashManager: HostVFlashManagerConstructor;

	interface HostVirtualNicManager extends VcHostVirtualNicManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostVirtualNicManagerConstructor {
		new(value?:any): HostVirtualNicManager;
		readonly prototype: HostVirtualNicManager;
	}

	const HostVirtualNicManager: HostVirtualNicManagerConstructor;

	interface HostVirtualNicManagerNicType extends VcHostVirtualNicManagerNicType
	{
		name: any;

	}

	interface HostVirtualNicManagerNicTypeConstructor {
		new(value?:any): HostVirtualNicManagerNicType;
		readonly prototype: HostVirtualNicManagerNicType;
	}

	const HostVirtualNicManagerNicType: HostVirtualNicManagerNicTypeConstructor;

	interface HostVmciAccessManager extends VcHostVmciAccessManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostVmciAccessManagerConstructor {
		new(value?:any): HostVmciAccessManager;
		readonly prototype: HostVmciAccessManager;
	}

	const HostVmciAccessManager: HostVmciAccessManagerConstructor;

	interface HostVmciAccessManagerMode extends VcHostVmciAccessManagerMode
	{
		name: any;

	}

	interface HostVmciAccessManagerModeConstructor {
		new(value?:any): HostVmciAccessManagerMode;
		readonly prototype: HostVmciAccessManagerMode;
	}

	const HostVmciAccessManagerMode: HostVmciAccessManagerModeConstructor;

	interface HostVmfsVolumeUnmapPriority extends VcHostVmfsVolumeUnmapPriority
	{
		name: any;

	}

	interface HostVmfsVolumeUnmapPriorityConstructor {
		new(value?:any): HostVmfsVolumeUnmapPriority;
		readonly prototype: HostVmfsVolumeUnmapPriority;
	}

	const HostVmfsVolumeUnmapPriority: HostVmfsVolumeUnmapPriorityConstructor;

	interface HostVMotionManager extends VcHostVMotionManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostVMotionManagerConstructor {
		new(value?:any): HostVMotionManager;
		readonly prototype: HostVMotionManager;
	}

	const HostVMotionManager: HostVMotionManagerConstructor;

	interface HostVMotionManagerVMotionType extends VcHostVMotionManagerVMotionType
	{
		name: any;

	}

	interface HostVMotionManagerVMotionTypeConstructor {
		new(value?:any): HostVMotionManagerVMotionType;
		readonly prototype: HostVMotionManagerVMotionType;
	}

	const HostVMotionManagerVMotionType: HostVMotionManagerVMotionTypeConstructor;

	interface HostVMotionSystem extends VcHostVMotionSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostVMotionSystemConstructor {
		new(value?:any): HostVMotionSystem;
		readonly prototype: HostVMotionSystem;
	}

	const HostVMotionSystem: HostVMotionSystemConstructor;

	interface HostVsanInternalSystem extends VcHostVsanInternalSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostVsanInternalSystemConstructor {
		new(value?:any): HostVsanInternalSystem;
		readonly prototype: HostVsanInternalSystem;
	}

	const HostVsanInternalSystem: HostVsanInternalSystemConstructor;

	interface HostVsanSystem extends VcHostVsanSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostVsanSystemConstructor {
		new(value?:any): HostVsanSystem;
		readonly prototype: HostVsanSystem;
	}

	const HostVsanSystem: HostVsanSystemConstructor;

	interface HostVStorageObjectManager extends VcHostVStorageObjectManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HostVStorageObjectManagerConstructor {
		new(value?:any): HostVStorageObjectManager;
		readonly prototype: HostVStorageObjectManager;
	}

	const HostVStorageObjectManager: HostVStorageObjectManagerConstructor;

	interface HttpNfcLease extends VcHttpNfcLease
	{
		id: any;
		initializeProgress: any;
		mode: any;
		sdkId: any;
		state: any;
		transferProgress: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface HttpNfcLeaseConstructor {
		new(value?:any): HttpNfcLease;
		readonly prototype: HttpNfcLease;
	}

	const HttpNfcLease: HttpNfcLeaseConstructor;

	interface HttpNfcLeaseManifestEntryChecksumType extends VcHttpNfcLeaseManifestEntryChecksumType
	{
		name: any;

	}

	interface HttpNfcLeaseManifestEntryChecksumTypeConstructor {
		new(value?:any): HttpNfcLeaseManifestEntryChecksumType;
		readonly prototype: HttpNfcLeaseManifestEntryChecksumType;
	}

	const HttpNfcLeaseManifestEntryChecksumType: HttpNfcLeaseManifestEntryChecksumTypeConstructor;

	interface HttpNfcLeaseMode extends VcHttpNfcLeaseMode
	{
		name: any;

	}

	interface HttpNfcLeaseModeConstructor {
		new(value?:any): HttpNfcLeaseMode;
		readonly prototype: HttpNfcLeaseMode;
	}

	const HttpNfcLeaseMode: HttpNfcLeaseModeConstructor;

	interface HttpNfcLeaseState extends VcHttpNfcLeaseState
	{
		name: any;

	}

	interface HttpNfcLeaseStateConstructor {
		new(value?:any): HttpNfcLeaseState;
		readonly prototype: HttpNfcLeaseState;
	}

	const HttpNfcLeaseState: HttpNfcLeaseStateConstructor;

	interface ImageLibraryManager extends VcImageLibraryManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ImageLibraryManagerConstructor {
		new(value?:any): ImageLibraryManager;
		readonly prototype: ImageLibraryManager;
	}

	const ImageLibraryManager: ImageLibraryManagerConstructor;

	interface ImageLibraryManagerMediaType extends VcImageLibraryManagerMediaType
	{
		name: any;

	}

	interface ImageLibraryManagerMediaTypeConstructor {
		new(value?:any): ImageLibraryManagerMediaType;
		readonly prototype: ImageLibraryManagerMediaType;
	}

	const ImageLibraryManagerMediaType: ImageLibraryManagerMediaTypeConstructor;

	interface IncompatibleHostForVmReplicationIncompatibleReason extends VcIncompatibleHostForVmReplicationIncompatibleReason
	{
		name: any;

	}

	interface IncompatibleHostForVmReplicationIncompatibleReasonConstructor {
		new(value?:any): IncompatibleHostForVmReplicationIncompatibleReason;
		readonly prototype: IncompatibleHostForVmReplicationIncompatibleReason;
	}

	const IncompatibleHostForVmReplicationIncompatibleReason: IncompatibleHostForVmReplicationIncompatibleReasonConstructor;

	interface InternalDynamicTypeManager extends VcInternalDynamicTypeManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface InternalDynamicTypeManagerConstructor {
		new(value?:any): InternalDynamicTypeManager;
		readonly prototype: InternalDynamicTypeManager;
	}

	const InternalDynamicTypeManager: InternalDynamicTypeManagerConstructor;

	interface InternalMockupSystem extends VcInternalMockupSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface InternalMockupSystemConstructor {
		new(value?:any): InternalMockupSystem;
		readonly prototype: InternalMockupSystem;
	}

	const InternalMockupSystem: InternalMockupSystemConstructor;

	interface InternalPropertyProviderManager extends VcInternalPropertyProviderManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface InternalPropertyProviderManagerConstructor {
		new(value?:any): InternalPropertyProviderManager;
		readonly prototype: InternalPropertyProviderManager;
	}

	const InternalPropertyProviderManager: InternalPropertyProviderManagerConstructor;

	interface InternalPropertyStore extends VcInternalPropertyStore
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface InternalPropertyStoreConstructor {
		new(value?:any): InternalPropertyStore;
		readonly prototype: InternalPropertyStore;
	}

	const InternalPropertyStore: InternalPropertyStoreConstructor;

	interface InternalStatsCollector extends VcInternalStatsCollector
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface InternalStatsCollectorConstructor {
		new(value?:any): InternalStatsCollector;
		readonly prototype: InternalStatsCollector;
	}

	const InternalStatsCollector: InternalStatsCollectorConstructor;

	interface InternalStatsSet extends VcInternalStatsSet
	{
		name: any;

	}

	interface InternalStatsSetConstructor {
		new(value?:any): InternalStatsSet;
		readonly prototype: InternalStatsSet;
	}

	const InternalStatsSet: InternalStatsSetConstructor;

	interface InternetScsiSnsDiscoveryMethod extends VcInternetScsiSnsDiscoveryMethod
	{
		name: any;

	}

	interface InternetScsiSnsDiscoveryMethodConstructor {
		new(value?:any): InternetScsiSnsDiscoveryMethod;
		readonly prototype: InternetScsiSnsDiscoveryMethod;
	}

	const InternetScsiSnsDiscoveryMethod: InternetScsiSnsDiscoveryMethodConstructor;

	interface InvalidDasConfigArgumentEntryForInvalidArgument extends VcInvalidDasConfigArgumentEntryForInvalidArgument
	{
		name: any;

	}

	interface InvalidDasConfigArgumentEntryForInvalidArgumentConstructor {
		new(value?:any): InvalidDasConfigArgumentEntryForInvalidArgument;
		readonly prototype: InvalidDasConfigArgumentEntryForInvalidArgument;
	}

	const InvalidDasConfigArgumentEntryForInvalidArgument: InvalidDasConfigArgumentEntryForInvalidArgumentConstructor;

	interface InvalidProfileReferenceHostReason extends VcInvalidProfileReferenceHostReason
	{
		name: any;

	}

	interface InvalidProfileReferenceHostReasonConstructor {
		new(value?:any): InvalidProfileReferenceHostReason;
		readonly prototype: InvalidProfileReferenceHostReason;
	}

	const InvalidProfileReferenceHostReason: InvalidProfileReferenceHostReasonConstructor;

	interface InventoryView extends VcInventoryView
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface InventoryViewConstructor {
		new(value?:any): InventoryView;
		readonly prototype: InventoryView;
	}

	const InventoryView: InventoryViewConstructor;

	interface IoFilterManager extends VcIoFilterManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface IoFilterManagerConstructor {
		new(value?:any): IoFilterManager;
		readonly prototype: IoFilterManager;
	}

	const IoFilterManager: IoFilterManagerConstructor;

	interface IoFilterOperation extends VcIoFilterOperation
	{
		name: any;

	}

	interface IoFilterOperationConstructor {
		new(value?:any): IoFilterOperation;
		readonly prototype: IoFilterOperation;
	}

	const IoFilterOperation: IoFilterOperationConstructor;

	interface IoFilterType extends VcIoFilterType
	{
		name: any;

	}

	interface IoFilterTypeConstructor {
		new(value?:any): IoFilterType;
		readonly prototype: IoFilterType;
	}

	const IoFilterType: IoFilterTypeConstructor;

	interface IpPoolManager extends VcIpPoolManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface IpPoolManagerConstructor {
		new(value?:any): IpPoolManager;
		readonly prototype: IpPoolManager;
	}

	const IpPoolManager: IpPoolManagerConstructor;

	interface IscsiManager extends VcIscsiManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface IscsiManagerConstructor {
		new(value?:any): IscsiManager;
		readonly prototype: IscsiManager;
	}

	const IscsiManager: IscsiManagerConstructor;

	interface IscsiPortInfoPathStatus extends VcIscsiPortInfoPathStatus
	{
		name: any;

	}

	interface IscsiPortInfoPathStatusConstructor {
		new(value?:any): IscsiPortInfoPathStatus;
		readonly prototype: IscsiPortInfoPathStatus;
	}

	const IscsiPortInfoPathStatus: IscsiPortInfoPathStatusConstructor;

	interface LatencySensitivitySensitivityLevel extends VcLatencySensitivitySensitivityLevel
	{
		name: any;

	}

	interface LatencySensitivitySensitivityLevelConstructor {
		new(value?:any): LatencySensitivitySensitivityLevel;
		readonly prototype: LatencySensitivitySensitivityLevel;
	}

	const LatencySensitivitySensitivityLevel: LatencySensitivitySensitivityLevelConstructor;

	interface LegacyTemplateManager extends VcLegacyTemplateManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface LegacyTemplateManagerConstructor {
		new(value?:any): LegacyTemplateManager;
		readonly prototype: LegacyTemplateManager;
	}

	const LegacyTemplateManager: LegacyTemplateManagerConstructor;

	interface LicenseAssignmentFailedReason extends VcLicenseAssignmentFailedReason
	{
		name: any;

	}

	interface LicenseAssignmentFailedReasonConstructor {
		new(value?:any): LicenseAssignmentFailedReason;
		readonly prototype: LicenseAssignmentFailedReason;
	}

	const LicenseAssignmentFailedReason: LicenseAssignmentFailedReasonConstructor;

	interface LicenseAssignmentManager extends VcLicenseAssignmentManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface LicenseAssignmentManagerConstructor {
		new(value?:any): LicenseAssignmentManager;
		readonly prototype: LicenseAssignmentManager;
	}

	const LicenseAssignmentManager: LicenseAssignmentManagerConstructor;

	interface LicenseDataManager extends VcLicenseDataManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface LicenseDataManagerConstructor {
		new(value?:any): LicenseDataManager;
		readonly prototype: LicenseDataManager;
	}

	const LicenseDataManager: LicenseDataManagerConstructor;

	interface LicenseFeatureInfoSourceRestriction extends VcLicenseFeatureInfoSourceRestriction
	{
		name: any;

	}

	interface LicenseFeatureInfoSourceRestrictionConstructor {
		new(value?:any): LicenseFeatureInfoSourceRestriction;
		readonly prototype: LicenseFeatureInfoSourceRestriction;
	}

	const LicenseFeatureInfoSourceRestriction: LicenseFeatureInfoSourceRestrictionConstructor;

	interface LicenseFeatureInfoState extends VcLicenseFeatureInfoState
	{
		name: any;

	}

	interface LicenseFeatureInfoStateConstructor {
		new(value?:any): LicenseFeatureInfoState;
		readonly prototype: LicenseFeatureInfoState;
	}

	const LicenseFeatureInfoState: LicenseFeatureInfoStateConstructor;

	interface LicenseFeatureInfoUnit extends VcLicenseFeatureInfoUnit
	{
		name: any;

	}

	interface LicenseFeatureInfoUnitConstructor {
		new(value?:any): LicenseFeatureInfoUnit;
		readonly prototype: LicenseFeatureInfoUnit;
	}

	const LicenseFeatureInfoUnit: LicenseFeatureInfoUnitConstructor;

	interface LicenseManager extends VcLicenseManager
	{
		id: any;
		licensedEdition: any;
		sdkId: any;
		sourceAvailable: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface LicenseManagerConstructor {
		new(value?:any): LicenseManager;
		readonly prototype: LicenseManager;
	}

	const LicenseManager: LicenseManagerConstructor;

	interface LicenseManagerLicenseKey extends VcLicenseManagerLicenseKey
	{
		name: any;

	}

	interface LicenseManagerLicenseKeyConstructor {
		new(value?:any): LicenseManagerLicenseKey;
		readonly prototype: LicenseManagerLicenseKey;
	}

	const LicenseManagerLicenseKey: LicenseManagerLicenseKeyConstructor;

	interface LicenseManagerState extends VcLicenseManagerState
	{
		name: any;

	}

	interface LicenseManagerStateConstructor {
		new(value?:any): LicenseManagerState;
		readonly prototype: LicenseManagerState;
	}

	const LicenseManagerState: LicenseManagerStateConstructor;

	interface LicenseReservationInfoState extends VcLicenseReservationInfoState
	{
		name: any;

	}

	interface LicenseReservationInfoStateConstructor {
		new(value?:any): LicenseReservationInfoState;
		readonly prototype: LicenseReservationInfoState;
	}

	const LicenseReservationInfoState: LicenseReservationInfoStateConstructor;

	interface LinkDiscoveryProtocolConfigOperationType extends VcLinkDiscoveryProtocolConfigOperationType
	{
		name: any;

	}

	interface LinkDiscoveryProtocolConfigOperationTypeConstructor {
		new(value?:any): LinkDiscoveryProtocolConfigOperationType;
		readonly prototype: LinkDiscoveryProtocolConfigOperationType;
	}

	const LinkDiscoveryProtocolConfigOperationType: LinkDiscoveryProtocolConfigOperationTypeConstructor;

	interface LinkDiscoveryProtocolConfigProtocolType extends VcLinkDiscoveryProtocolConfigProtocolType
	{
		name: any;

	}

	interface LinkDiscoveryProtocolConfigProtocolTypeConstructor {
		new(value?:any): LinkDiscoveryProtocolConfigProtocolType;
		readonly prototype: LinkDiscoveryProtocolConfigProtocolType;
	}

	const LinkDiscoveryProtocolConfigProtocolType: LinkDiscoveryProtocolConfigProtocolTypeConstructor;

	interface ListView extends VcListView
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ListViewConstructor {
		new(value?:any): ListView;
		readonly prototype: ListView;
	}

	const ListView: ListViewConstructor;

	interface LocalizationManager extends VcLocalizationManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface LocalizationManagerConstructor {
		new(value?:any): LocalizationManager;
		readonly prototype: LocalizationManager;
	}

	const LocalizationManager: LocalizationManagerConstructor;

	interface ManagedEntity extends VcManagedEntity
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ManagedEntityConstructor {
		new(value?:any): ManagedEntity;
		readonly prototype: ManagedEntity;
	}

	const ManagedEntity: ManagedEntityConstructor;

	interface ManagedEntityStatus extends VcManagedEntityStatus
	{
		name: any;

	}

	interface ManagedEntityStatusConstructor {
		new(value?:any): ManagedEntityStatus;
		readonly prototype: ManagedEntityStatus;
	}

	const ManagedEntityStatus: ManagedEntityStatusConstructor;

	interface ManagedObject extends VcManagedObject
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ManagedObjectConstructor {
		new(value?:any): ManagedObject;
		readonly prototype: ManagedObject;
	}

	const ManagedObject: ManagedObjectConstructor;

	interface ManagedObjectView extends VcManagedObjectView
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ManagedObjectViewConstructor {
		new(value?:any): ManagedObjectView;
		readonly prototype: ManagedObjectView;
	}

	const ManagedObjectView: ManagedObjectViewConstructor;

	interface MessageBusProxy extends VcMessageBusProxy
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface MessageBusProxyConstructor {
		new(value?:any): MessageBusProxy;
		readonly prototype: MessageBusProxy;
	}

	const MessageBusProxy: MessageBusProxyConstructor;

	interface MetricAlarmOperator extends VcMetricAlarmOperator
	{
		name: any;

	}

	interface MetricAlarmOperatorConstructor {
		new(value?:any): MetricAlarmOperator;
		readonly prototype: MetricAlarmOperator;
	}

	const MetricAlarmOperator: MetricAlarmOperatorConstructor;

	interface MultipathState extends VcMultipathState
	{
		name: any;

	}

	interface MultipathStateConstructor {
		new(value?:any): MultipathState;
		readonly prototype: MultipathState;
	}

	const MultipathState: MultipathStateConstructor;

	interface NetBIOSConfigInfoMode extends VcNetBIOSConfigInfoMode
	{
		name: any;

	}

	interface NetBIOSConfigInfoModeConstructor {
		new(value?:any): NetBIOSConfigInfoMode;
		readonly prototype: NetBIOSConfigInfoMode;
	}

	const NetBIOSConfigInfoMode: NetBIOSConfigInfoModeConstructor;

	interface NetIpConfigInfoIpAddressOrigin extends VcNetIpConfigInfoIpAddressOrigin
	{
		name: any;

	}

	interface NetIpConfigInfoIpAddressOriginConstructor {
		new(value?:any): NetIpConfigInfoIpAddressOrigin;
		readonly prototype: NetIpConfigInfoIpAddressOrigin;
	}

	const NetIpConfigInfoIpAddressOrigin: NetIpConfigInfoIpAddressOriginConstructor;

	interface NetIpConfigInfoIpAddressStatus extends VcNetIpConfigInfoIpAddressStatus
	{
		name: any;

	}

	interface NetIpConfigInfoIpAddressStatusConstructor {
		new(value?:any): NetIpConfigInfoIpAddressStatus;
		readonly prototype: NetIpConfigInfoIpAddressStatus;
	}

	const NetIpConfigInfoIpAddressStatus: NetIpConfigInfoIpAddressStatusConstructor;

	interface NetIpStackInfoEntryType extends VcNetIpStackInfoEntryType
	{
		name: any;

	}

	interface NetIpStackInfoEntryTypeConstructor {
		new(value?:any): NetIpStackInfoEntryType;
		readonly prototype: NetIpStackInfoEntryType;
	}

	const NetIpStackInfoEntryType: NetIpStackInfoEntryTypeConstructor;

	interface NetIpStackInfoPreference extends VcNetIpStackInfoPreference
	{
		name: any;

	}

	interface NetIpStackInfoPreferenceConstructor {
		new(value?:any): NetIpStackInfoPreference;
		readonly prototype: NetIpStackInfoPreference;
	}

	const NetIpStackInfoPreference: NetIpStackInfoPreferenceConstructor;

	interface Network extends VcNetwork
	{
		accessible: any;
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface NetworkConstructor {
		new(value?:any): Network;
		readonly prototype: Network;
	}

	const Network: NetworkConstructor;

	interface NetworkFolder extends VcNetworkFolder
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;

		dvp(): DistributedVirtualPortgroup;
		dvs(): DistributedVirtualSwitch;
		networkFolders(): NetworkFolder;
		networks(): Network;
		vdvs(): VmwareDistributedVirtualSwitch;
	}

	interface NetworkFolderConstructor {
		new(value?:any): NetworkFolder;
		readonly prototype: NetworkFolder;
	}

	const NetworkFolder: NetworkFolderConstructor;

	interface NetworkManager extends VcNetworkManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface NetworkManagerConstructor {
		new(value?:any): NetworkManager;
		readonly prototype: NetworkManager;
	}

	const NetworkManager: NetworkManagerConstructor;

	interface NfcService extends VcNfcService
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface NfcServiceConstructor {
		new(value?:any): NfcService;
		readonly prototype: NfcService;
	}

	const NfcService: NfcServiceConstructor;

	interface NotSupportedDeviceForFTDeviceType extends VcNotSupportedDeviceForFTDeviceType
	{
		name: any;

	}

	interface NotSupportedDeviceForFTDeviceTypeConstructor {
		new(value?:any): NotSupportedDeviceForFTDeviceType;
		readonly prototype: NotSupportedDeviceForFTDeviceType;
	}

	const NotSupportedDeviceForFTDeviceType: NotSupportedDeviceForFTDeviceTypeConstructor;

	interface NumVirtualCpusIncompatibleReason extends VcNumVirtualCpusIncompatibleReason
	{
		name: any;

	}

	interface NumVirtualCpusIncompatibleReasonConstructor {
		new(value?:any): NumVirtualCpusIncompatibleReason;
		readonly prototype: NumVirtualCpusIncompatibleReason;
	}

	const NumVirtualCpusIncompatibleReason: NumVirtualCpusIncompatibleReasonConstructor;

	interface NvdimmHealthStatus extends VcNvdimmHealthStatus
	{
		name: any;

	}

	interface NvdimmHealthStatusConstructor {
		new(value?:any): NvdimmHealthStatus;
		readonly prototype: NvdimmHealthStatus;
	}

	const NvdimmHealthStatus: NvdimmHealthStatusConstructor;

	interface NvdimmNamespaceHealthStatus extends VcNvdimmNamespaceHealthStatus
	{
		name: any;

	}

	interface NvdimmNamespaceHealthStatusConstructor {
		new(value?:any): NvdimmNamespaceHealthStatus;
		readonly prototype: NvdimmNamespaceHealthStatus;
	}

	const NvdimmNamespaceHealthStatus: NvdimmNamespaceHealthStatusConstructor;

	interface NvdimmNamespaceType extends VcNvdimmNamespaceType
	{
		name: any;

	}

	interface NvdimmNamespaceTypeConstructor {
		new(value?:any): NvdimmNamespaceType;
		readonly prototype: NvdimmNamespaceType;
	}

	const NvdimmNamespaceType: NvdimmNamespaceTypeConstructor;

	interface NvdimmNvdimmHealthInfoState extends VcNvdimmNvdimmHealthInfoState
	{
		name: any;

	}

	interface NvdimmNvdimmHealthInfoStateConstructor {
		new(value?:any): NvdimmNvdimmHealthInfoState;
		readonly prototype: NvdimmNvdimmHealthInfoState;
	}

	const NvdimmNvdimmHealthInfoState: NvdimmNvdimmHealthInfoStateConstructor;

	interface NvdimmRangeType extends VcNvdimmRangeType
	{
		name: any;

	}

	interface NvdimmRangeTypeConstructor {
		new(value?:any): NvdimmRangeType;
		readonly prototype: NvdimmRangeType;
	}

	const NvdimmRangeType: NvdimmRangeTypeConstructor;

	interface NvdimmState extends VcNvdimmState
	{
		name: any;

	}

	interface NvdimmStateConstructor {
		new(value?:any): NvdimmState;
		readonly prototype: NvdimmState;
	}

	const NvdimmState: NvdimmStateConstructor;

	interface ObjectUpdateKind extends VcObjectUpdateKind
	{
		name: any;

	}

	interface ObjectUpdateKindConstructor {
		new(value?:any): ObjectUpdateKind;
		readonly prototype: ObjectUpdateKind;
	}

	const ObjectUpdateKind: ObjectUpdateKindConstructor;

	interface OpaqueNetwork extends VcOpaqueNetwork
	{
		accessible: any;
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface OpaqueNetworkConstructor {
		new(value?:any): OpaqueNetwork;
		readonly prototype: OpaqueNetwork;
	}

	const OpaqueNetwork: OpaqueNetworkConstructor;

	interface OptionManager extends VcOptionManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface OptionManagerConstructor {
		new(value?:any): OptionManager;
		readonly prototype: OptionManager;
	}

	const OptionManager: OptionManagerConstructor;

	interface OverheadMemoryManager extends VcOverheadMemoryManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface OverheadMemoryManagerConstructor {
		new(value?:any): OverheadMemoryManager;
		readonly prototype: OverheadMemoryManager;
	}

	const OverheadMemoryManager: OverheadMemoryManagerConstructor;

	interface OverheadService extends VcOverheadService
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface OverheadServiceConstructor {
		new(value?:any): OverheadService;
		readonly prototype: OverheadService;
	}

	const OverheadService: OverheadServiceConstructor;

	interface OvfConsumer extends VcOvfConsumer
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface OvfConsumerConstructor {
		new(value?:any): OvfConsumer;
		readonly prototype: OvfConsumer;
	}

	const OvfConsumer: OvfConsumerConstructor;

	interface OvfConsumerOstNodeType extends VcOvfConsumerOstNodeType
	{
		name: any;

	}

	interface OvfConsumerOstNodeTypeConstructor {
		new(value?:any): OvfConsumerOstNodeType;
		readonly prototype: OvfConsumerOstNodeType;
	}

	const OvfConsumerOstNodeType: OvfConsumerOstNodeTypeConstructor;

	interface OvfCreateImportSpecParamsDiskProvisioningType extends VcOvfCreateImportSpecParamsDiskProvisioningType
	{
		name: any;

	}

	interface OvfCreateImportSpecParamsDiskProvisioningTypeConstructor {
		new(value?:any): OvfCreateImportSpecParamsDiskProvisioningType;
		readonly prototype: OvfCreateImportSpecParamsDiskProvisioningType;
	}

	const OvfCreateImportSpecParamsDiskProvisioningType: OvfCreateImportSpecParamsDiskProvisioningTypeConstructor;

	interface OvfManager extends VcOvfManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface OvfManagerConstructor {
		new(value?:any): OvfManager;
		readonly prototype: OvfManager;
	}

	const OvfManager: OvfManagerConstructor;

	interface PerfFormat extends VcPerfFormat
	{
		name: any;

	}

	interface PerfFormatConstructor {
		new(value?:any): PerfFormat;
		readonly prototype: PerfFormat;
	}

	const PerfFormat: PerfFormatConstructor;

	interface PerformanceManager extends VcPerformanceManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface PerformanceManagerConstructor {
		new(value?:any): PerformanceManager;
		readonly prototype: PerformanceManager;
	}

	const PerformanceManager: PerformanceManagerConstructor;

	interface PerformanceManagerUnit extends VcPerformanceManagerUnit
	{
		name: any;

	}

	interface PerformanceManagerUnitConstructor {
		new(value?:any): PerformanceManagerUnit;
		readonly prototype: PerformanceManagerUnit;
	}

	const PerformanceManagerUnit: PerformanceManagerUnitConstructor;

	interface PerfStatsType extends VcPerfStatsType
	{
		name: any;

	}

	interface PerfStatsTypeConstructor {
		new(value?:any): PerfStatsType;
		readonly prototype: PerfStatsType;
	}

	const PerfStatsType: PerfStatsTypeConstructor;

	interface PerfSummaryType extends VcPerfSummaryType
	{
		name: any;

	}

	interface PerfSummaryTypeConstructor {
		new(value?:any): PerfSummaryType;
		readonly prototype: PerfSummaryType;
	}

	const PerfSummaryType: PerfSummaryTypeConstructor;

	interface PhysicalNicResourcePoolSchedulerDisallowedReason extends VcPhysicalNicResourcePoolSchedulerDisallowedReason
	{
		name: any;

	}

	interface PhysicalNicResourcePoolSchedulerDisallowedReasonConstructor {
		new(value?:any): PhysicalNicResourcePoolSchedulerDisallowedReason;
		readonly prototype: PhysicalNicResourcePoolSchedulerDisallowedReason;
	}

	const PhysicalNicResourcePoolSchedulerDisallowedReason: PhysicalNicResourcePoolSchedulerDisallowedReasonConstructor;

	interface PhysicalNicVmDirectPathGen2SupportedMode extends VcPhysicalNicVmDirectPathGen2SupportedMode
	{
		name: any;

	}

	interface PhysicalNicVmDirectPathGen2SupportedModeConstructor {
		new(value?:any): PhysicalNicVmDirectPathGen2SupportedMode;
		readonly prototype: PhysicalNicVmDirectPathGen2SupportedMode;
	}

	const PhysicalNicVmDirectPathGen2SupportedMode: PhysicalNicVmDirectPathGen2SupportedModeConstructor;

	interface PlacementAffinityRuleRuleScope extends VcPlacementAffinityRuleRuleScope
	{
		name: any;

	}

	interface PlacementAffinityRuleRuleScopeConstructor {
		new(value?:any): PlacementAffinityRuleRuleScope;
		readonly prototype: PlacementAffinityRuleRuleScope;
	}

	const PlacementAffinityRuleRuleScope: PlacementAffinityRuleRuleScopeConstructor;

	interface PlacementAffinityRuleRuleType extends VcPlacementAffinityRuleRuleType
	{
		name: any;

	}

	interface PlacementAffinityRuleRuleTypeConstructor {
		new(value?:any): PlacementAffinityRuleRuleType;
		readonly prototype: PlacementAffinityRuleRuleType;
	}

	const PlacementAffinityRuleRuleType: PlacementAffinityRuleRuleTypeConstructor;

	interface PlacementSpecPlacementType extends VcPlacementSpecPlacementType
	{
		name: any;

	}

	interface PlacementSpecPlacementTypeConstructor {
		new(value?:any): PlacementSpecPlacementType;
		readonly prototype: PlacementSpecPlacementType;
	}

	const PlacementSpecPlacementType: PlacementSpecPlacementTypeConstructor;

	interface PortGroupConnecteeType extends VcPortGroupConnecteeType
	{
		name: any;

	}

	interface PortGroupConnecteeTypeConstructor {
		new(value?:any): PortGroupConnecteeType;
		readonly prototype: PortGroupConnecteeType;
	}

	const PortGroupConnecteeType: PortGroupConnecteeTypeConstructor;

	interface PreCallbackResultResult extends VcPreCallbackResultResult
	{
		name: any;

	}

	interface PreCallbackResultResultConstructor {
		new(value?:any): PreCallbackResultResult;
		readonly prototype: PreCallbackResultResult;
	}

	const PreCallbackResultResult: PreCallbackResultResultConstructor;

	interface Profile extends VcProfile
	{
		complianceStatus: any;
		createdTime: any;
		id: any;
		modifiedTime: any;
		name: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ProfileConstructor {
		new(value?:any): Profile;
		readonly prototype: Profile;
	}

	const Profile: ProfileConstructor;

	interface ProfileComplianceManager extends VcProfileComplianceManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ProfileComplianceManagerConstructor {
		new(value?:any): ProfileComplianceManager;
		readonly prototype: ProfileComplianceManager;
	}

	const ProfileComplianceManager: ProfileComplianceManagerConstructor;

	interface ProfileExecuteResultStatus extends VcProfileExecuteResultStatus
	{
		name: any;

	}

	interface ProfileExecuteResultStatusConstructor {
		new(value?:any): ProfileExecuteResultStatus;
		readonly prototype: ProfileExecuteResultStatus;
	}

	const ProfileExecuteResultStatus: ProfileExecuteResultStatusConstructor;

	interface ProfileHostProfileEngineComplianceManager extends VcProfileHostProfileEngineComplianceManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ProfileHostProfileEngineComplianceManagerConstructor {
		new(value?:any): ProfileHostProfileEngineComplianceManager;
		readonly prototype: ProfileHostProfileEngineComplianceManager;
	}

	const ProfileHostProfileEngineComplianceManager: ProfileHostProfileEngineComplianceManagerConstructor;

	interface ProfileHostProfileEngineHostProfileManager extends VcProfileHostProfileEngineHostProfileManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ProfileHostProfileEngineHostProfileManagerConstructor {
		new(value?:any): ProfileHostProfileEngineHostProfileManager;
		readonly prototype: ProfileHostProfileEngineHostProfileManager;
	}

	const ProfileHostProfileEngineHostProfileManager: ProfileHostProfileEngineHostProfileManagerConstructor;

	interface ProfileManager extends VcProfileManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ProfileManagerConstructor {
		new(value?:any): ProfileManager;
		readonly prototype: ProfileManager;
	}

	const ProfileManager: ProfileManagerConstructor;

	interface ProfileNumericComparator extends VcProfileNumericComparator
	{
		name: any;

	}

	interface ProfileNumericComparatorConstructor {
		new(value?:any): ProfileNumericComparator;
		readonly prototype: ProfileNumericComparator;
	}

	const ProfileNumericComparator: ProfileNumericComparatorConstructor;

	interface PropertyChangeOp extends VcPropertyChangeOp
	{
		name: any;

	}

	interface PropertyChangeOpConstructor {
		new(value?:any): PropertyChangeOp;
		readonly prototype: PropertyChangeOp;
	}

	const PropertyChangeOp: PropertyChangeOpConstructor;

	interface PropertyCollector extends VcPropertyCollector
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface PropertyCollectorConstructor {
		new(value?:any): PropertyCollector;
		readonly prototype: PropertyCollector;
	}

	const PropertyCollector: PropertyCollectorConstructor;

	interface PropertyFilter extends VcPropertyFilter
	{
		id: any;
		partialUpdates: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface PropertyFilterConstructor {
		new(value?:any): PropertyFilter;
		readonly prototype: PropertyFilter;
	}

	const PropertyFilter: PropertyFilterConstructor;

	interface ProxyService extends VcProxyService
	{
		httpPort: any;
		httpsPort: any;
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ProxyServiceConstructor {
		new(value?:any): ProxyService;
		readonly prototype: ProxyService;
	}

	const ProxyService: ProxyServiceConstructor;

	interface ProxyServiceAccessMode extends VcProxyServiceAccessMode
	{
		name: any;

	}

	interface ProxyServiceAccessModeConstructor {
		new(value?:any): ProxyServiceAccessMode;
		readonly prototype: ProxyServiceAccessMode;
	}

	const ProxyServiceAccessMode: ProxyServiceAccessModeConstructor;

	interface ProxyServiceRedirectSpecRedirectType extends VcProxyServiceRedirectSpecRedirectType
	{
		name: any;

	}

	interface ProxyServiceRedirectSpecRedirectTypeConstructor {
		new(value?:any): ProxyServiceRedirectSpecRedirectType;
		readonly prototype: ProxyServiceRedirectSpecRedirectType;
	}

	const ProxyServiceRedirectSpecRedirectType: ProxyServiceRedirectSpecRedirectTypeConstructor;

	interface QuarantineModeFaultFaultType extends VcQuarantineModeFaultFaultType
	{
		name: any;

	}

	interface QuarantineModeFaultFaultTypeConstructor {
		new(value?:any): QuarantineModeFaultFaultType;
		readonly prototype: QuarantineModeFaultFaultType;
	}

	const QuarantineModeFaultFaultType: QuarantineModeFaultFaultTypeConstructor;

	interface QuiesceMode extends VcQuiesceMode
	{
		name: any;

	}

	interface QuiesceModeConstructor {
		new(value?:any): QuiesceMode;
		readonly prototype: QuiesceMode;
	}

	const QuiesceMode: QuiesceModeConstructor;

	interface RecommendationReasonCode extends VcRecommendationReasonCode
	{
		name: any;

	}

	interface RecommendationReasonCodeConstructor {
		new(value?:any): RecommendationReasonCode;
		readonly prototype: RecommendationReasonCode;
	}

	const RecommendationReasonCode: RecommendationReasonCodeConstructor;

	interface RecommendationType extends VcRecommendationType
	{
		name: any;

	}

	interface RecommendationTypeConstructor {
		new(value?:any): RecommendationType;
		readonly prototype: RecommendationType;
	}

	const RecommendationType: RecommendationTypeConstructor;

	interface ReflectManagedMethodExecuter extends VcReflectManagedMethodExecuter
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ReflectManagedMethodExecuterConstructor {
		new(value?:any): ReflectManagedMethodExecuter;
		readonly prototype: ReflectManagedMethodExecuter;
	}

	const ReflectManagedMethodExecuter: ReflectManagedMethodExecuterConstructor;

	interface ReplicationDiskConfigFaultReasonForFault extends VcReplicationDiskConfigFaultReasonForFault
	{
		name: any;

	}

	interface ReplicationDiskConfigFaultReasonForFaultConstructor {
		new(value?:any): ReplicationDiskConfigFaultReasonForFault;
		readonly prototype: ReplicationDiskConfigFaultReasonForFault;
	}

	const ReplicationDiskConfigFaultReasonForFault: ReplicationDiskConfigFaultReasonForFaultConstructor;

	interface ReplicationVmConfigFaultReasonForFault extends VcReplicationVmConfigFaultReasonForFault
	{
		name: any;

	}

	interface ReplicationVmConfigFaultReasonForFaultConstructor {
		new(value?:any): ReplicationVmConfigFaultReasonForFault;
		readonly prototype: ReplicationVmConfigFaultReasonForFault;
	}

	const ReplicationVmConfigFaultReasonForFault: ReplicationVmConfigFaultReasonForFaultConstructor;

	interface ReplicationVmFaultReasonForFault extends VcReplicationVmFaultReasonForFault
	{
		name: any;

	}

	interface ReplicationVmFaultReasonForFaultConstructor {
		new(value?:any): ReplicationVmFaultReasonForFault;
		readonly prototype: ReplicationVmFaultReasonForFault;
	}

	const ReplicationVmFaultReasonForFault: ReplicationVmFaultReasonForFaultConstructor;

	interface ReplicationVmInProgressFaultActivity extends VcReplicationVmInProgressFaultActivity
	{
		name: any;

	}

	interface ReplicationVmInProgressFaultActivityConstructor {
		new(value?:any): ReplicationVmInProgressFaultActivity;
		readonly prototype: ReplicationVmInProgressFaultActivity;
	}

	const ReplicationVmInProgressFaultActivity: ReplicationVmInProgressFaultActivityConstructor;

	interface ReplicationVmState extends VcReplicationVmState
	{
		name: any;

	}

	interface ReplicationVmStateConstructor {
		new(value?:any): ReplicationVmState;
		readonly prototype: ReplicationVmState;
	}

	const ReplicationVmState: ReplicationVmStateConstructor;

	interface ResourcePlanningManager extends VcResourcePlanningManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ResourcePlanningManagerConstructor {
		new(value?:any): ResourcePlanningManager;
		readonly prototype: ResourcePlanningManager;
	}

	const ResourcePlanningManager: ResourcePlanningManagerConstructor;

	interface ResourcePool extends VcResourcePool
	{
		alarmActionsEnabled: any;
		configStatus: any;
		cpuReservation: any;
		id: any;
		memoryReservation: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

		childResourcePools(): ResourcePool;
		vapps(): VirtualApp;
		vm(): VirtualMachine;
	}

	interface ResourcePoolConstructor {
		new(value?:any): ResourcePool;
		readonly prototype: ResourcePool;
	}

	const ResourcePool: ResourcePoolConstructor;

	interface ResourceType extends VcResourceType
	{
		name: any;

	}

	interface ResourceTypeConstructor {
		new(value?:any): ResourceType;
		readonly prototype: ResourceType;
	}

	const ResourceType: ResourceTypeConstructor;

	interface ScheduledHardwareUpgradeInfoHardwareUpgradePolicy extends VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy
	{
		name: any;

	}

	interface ScheduledHardwareUpgradeInfoHardwareUpgradePolicyConstructor {
		new(value?:any): ScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
		readonly prototype: ScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
	}

	const ScheduledHardwareUpgradeInfoHardwareUpgradePolicy: ScheduledHardwareUpgradeInfoHardwareUpgradePolicyConstructor;

	interface ScheduledHardwareUpgradeInfoHardwareUpgradeStatus extends VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus
	{
		name: any;

	}

	interface ScheduledHardwareUpgradeInfoHardwareUpgradeStatusConstructor {
		new(value?:any): ScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly prototype: ScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
	}

	const ScheduledHardwareUpgradeInfoHardwareUpgradeStatus: ScheduledHardwareUpgradeInfoHardwareUpgradeStatusConstructor;

	interface ScheduledTask extends VcScheduledTask
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ScheduledTaskConstructor {
		new(value?:any): ScheduledTask;
		readonly prototype: ScheduledTask;
	}

	const ScheduledTask: ScheduledTaskConstructor;

	interface ScheduledTaskManager extends VcScheduledTaskManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ScheduledTaskManagerConstructor {
		new(value?:any): ScheduledTaskManager;
		readonly prototype: ScheduledTaskManager;
	}

	const ScheduledTaskManager: ScheduledTaskManagerConstructor;

	interface ScsiDiskType extends VcScsiDiskType
	{
		name: any;

	}

	interface ScsiDiskTypeConstructor {
		new(value?:any): ScsiDiskType;
		readonly prototype: ScsiDiskType;
	}

	const ScsiDiskType: ScsiDiskTypeConstructor;

	interface ScsiLunDescriptorQuality extends VcScsiLunDescriptorQuality
	{
		name: any;

	}

	interface ScsiLunDescriptorQualityConstructor {
		new(value?:any): ScsiLunDescriptorQuality;
		readonly prototype: ScsiLunDescriptorQuality;
	}

	const ScsiLunDescriptorQuality: ScsiLunDescriptorQualityConstructor;

	interface ScsiLunState extends VcScsiLunState
	{
		name: any;

	}

	interface ScsiLunStateConstructor {
		new(value?:any): ScsiLunState;
		readonly prototype: ScsiLunState;
	}

	const ScsiLunState: ScsiLunStateConstructor;

	interface ScsiLunType extends VcScsiLunType
	{
		name: any;

	}

	interface ScsiLunTypeConstructor {
		new(value?:any): ScsiLunType;
		readonly prototype: ScsiLunType;
	}

	const ScsiLunType: ScsiLunTypeConstructor;

	interface ScsiLunVStorageSupportStatus extends VcScsiLunVStorageSupportStatus
	{
		name: any;

	}

	interface ScsiLunVStorageSupportStatusConstructor {
		new(value?:any): ScsiLunVStorageSupportStatus;
		readonly prototype: ScsiLunVStorageSupportStatus;
	}

	const ScsiLunVStorageSupportStatus: ScsiLunVStorageSupportStatusConstructor;

	interface SdkConnection extends VcSdkConnection
	{
		displayName: any;
		id: any;
		instanceUuid: any;
		name: any;
		sdkId: any;
		version: any;

		folders(): DatacenterFolder;
	}

	interface SdkConnectionConstructor {
		new(value?:any): SdkConnection;
		readonly prototype: SdkConnection;
	}

	const SdkConnection: SdkConnectionConstructor;

	interface SearchIndex extends VcSearchIndex
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface SearchIndexConstructor {
		new(value?:any): SearchIndex;
		readonly prototype: SearchIndex;
	}

	const SearchIndex: SearchIndexConstructor;

	interface ServiceDirectory extends VcServiceDirectory
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ServiceDirectoryConstructor {
		new(value?:any): ServiceDirectory;
		readonly prototype: ServiceDirectory;
	}

	const ServiceDirectory: ServiceDirectoryConstructor;

	interface ServiceInstance extends VcServiceInstance
	{
		id: any;
		sdkId: any;
		serverClock: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ServiceInstanceConstructor {
		new(value?:any): ServiceInstance;
		readonly prototype: ServiceInstance;
	}

	const ServiceInstance: ServiceInstanceConstructor;

	interface ServiceManager extends VcServiceManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ServiceManagerConstructor {
		new(value?:any): ServiceManager;
		readonly prototype: ServiceManager;
	}

	const ServiceManager: ServiceManagerConstructor;

	interface ServiceProtocol extends VcServiceProtocol
	{
		name: any;

	}

	interface ServiceProtocolConstructor {
		new(value?:any): ServiceProtocol;
		readonly prototype: ServiceProtocol;
	}

	const ServiceProtocol: ServiceProtocolConstructor;

	interface SessionManager extends VcSessionManager
	{
		defaultLocale: any;
		id: any;
		message: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface SessionManagerConstructor {
		new(value?:any): SessionManager;
		readonly prototype: SessionManager;
	}

	const SessionManager: SessionManagerConstructor;

	interface SessionManagerHttpServiceRequestSpecMethod extends VcSessionManagerHttpServiceRequestSpecMethod
	{
		name: any;

	}

	interface SessionManagerHttpServiceRequestSpecMethodConstructor {
		new(value?:any): SessionManagerHttpServiceRequestSpecMethod;
		readonly prototype: SessionManagerHttpServiceRequestSpecMethod;
	}

	const SessionManagerHttpServiceRequestSpecMethod: SessionManagerHttpServiceRequestSpecMethodConstructor;

	interface SharesLevel extends VcSharesLevel
	{
		name: any;

	}

	interface SharesLevelConstructor {
		new(value?:any): SharesLevel;
		readonly prototype: SharesLevel;
	}

	const SharesLevel: SharesLevelConstructor;

	interface SimpleCommand extends VcSimpleCommand
	{
		encodingType: any;
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface SimpleCommandConstructor {
		new(value?:any): SimpleCommand;
		readonly prototype: SimpleCommand;
	}

	const SimpleCommand: SimpleCommandConstructor;

	interface SimpleCommandEncoding extends VcSimpleCommandEncoding
	{
		name: any;

	}

	interface SimpleCommandEncodingConstructor {
		new(value?:any): SimpleCommandEncoding;
		readonly prototype: SimpleCommandEncoding;
	}

	const SimpleCommandEncoding: SimpleCommandEncodingConstructor;

	interface SlpDiscoveryMethod extends VcSlpDiscoveryMethod
	{
		name: any;

	}

	interface SlpDiscoveryMethodConstructor {
		new(value?:any): SlpDiscoveryMethod;
		readonly prototype: SlpDiscoveryMethod;
	}

	const SlpDiscoveryMethod: SlpDiscoveryMethodConstructor;

	interface SoftwarePackageConstraint extends VcSoftwarePackageConstraint
	{
		name: any;

	}

	interface SoftwarePackageConstraintConstructor {
		new(value?:any): SoftwarePackageConstraint;
		readonly prototype: SoftwarePackageConstraint;
	}

	const SoftwarePackageConstraint: SoftwarePackageConstraintConstructor;

	interface SoftwarePackageVibType extends VcSoftwarePackageVibType
	{
		name: any;

	}

	interface SoftwarePackageVibTypeConstructor {
		new(value?:any): SoftwarePackageVibType;
		readonly prototype: SoftwarePackageVibType;
	}

	const SoftwarePackageVibType: SoftwarePackageVibTypeConstructor;

	interface StateAlarmOperator extends VcStateAlarmOperator
	{
		name: any;

	}

	interface StateAlarmOperatorConstructor {
		new(value?:any): StateAlarmOperator;
		readonly prototype: StateAlarmOperator;
	}

	const StateAlarmOperator: StateAlarmOperatorConstructor;

	interface StorageDrsPodConfigInfoBehavior extends VcStorageDrsPodConfigInfoBehavior
	{
		name: any;

	}

	interface StorageDrsPodConfigInfoBehaviorConstructor {
		new(value?:any): StorageDrsPodConfigInfoBehavior;
		readonly prototype: StorageDrsPodConfigInfoBehavior;
	}

	const StorageDrsPodConfigInfoBehavior: StorageDrsPodConfigInfoBehaviorConstructor;

	interface StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode extends VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode
	{
		name: any;

	}

	interface StorageDrsSpaceLoadBalanceConfigSpaceThresholdModeConstructor {
		new(value?:any): StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
		readonly prototype: StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
	}

	const StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode: StorageDrsSpaceLoadBalanceConfigSpaceThresholdModeConstructor;

	interface StorageIORMThresholdMode extends VcStorageIORMThresholdMode
	{
		name: any;

	}

	interface StorageIORMThresholdModeConstructor {
		new(value?:any): StorageIORMThresholdMode;
		readonly prototype: StorageIORMThresholdMode;
	}

	const StorageIORMThresholdMode: StorageIORMThresholdModeConstructor;

	interface StoragePlacementSpecPlacementType extends VcStoragePlacementSpecPlacementType
	{
		name: any;

	}

	interface StoragePlacementSpecPlacementTypeConstructor {
		new(value?:any): StoragePlacementSpecPlacementType;
		readonly prototype: StoragePlacementSpecPlacementType;
	}

	const StoragePlacementSpecPlacementType: StoragePlacementSpecPlacementTypeConstructor;

	interface StoragePod extends VcStoragePod
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface StoragePodConstructor {
		new(value?:any): StoragePod;
		readonly prototype: StoragePod;
	}

	const StoragePod: StoragePodConstructor;

	interface StorageResourceManager extends VcStorageResourceManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface StorageResourceManagerConstructor {
		new(value?:any): StorageResourceManager;
		readonly prototype: StorageResourceManager;
	}

	const StorageResourceManager: StorageResourceManagerConstructor;

	interface TagPolicy extends VcTagPolicy
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface TagPolicyConstructor {
		new(value?:any): TagPolicy;
		readonly prototype: TagPolicy;
	}

	const TagPolicy: TagPolicyConstructor;

	interface TagPolicyOption extends VcTagPolicyOption
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface TagPolicyOptionConstructor {
		new(value?:any): TagPolicyOption;
		readonly prototype: TagPolicyOption;
	}

	const TagPolicyOption: TagPolicyOptionConstructor;

	interface Task extends VcTask
	{
		id: any;
		name: any;
		sdkId: any;
		state: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface TaskConstructor {
		new(value?:any): Task;
		readonly prototype: Task;
	}

	const Task: TaskConstructor;

	interface TaskFilterSpecRecursionOption extends VcTaskFilterSpecRecursionOption
	{
		name: any;

	}

	interface TaskFilterSpecRecursionOptionConstructor {
		new(value?:any): TaskFilterSpecRecursionOption;
		readonly prototype: TaskFilterSpecRecursionOption;
	}

	const TaskFilterSpecRecursionOption: TaskFilterSpecRecursionOptionConstructor;

	interface TaskFilterSpecTimeOption extends VcTaskFilterSpecTimeOption
	{
		name: any;

	}

	interface TaskFilterSpecTimeOptionConstructor {
		new(value?:any): TaskFilterSpecTimeOption;
		readonly prototype: TaskFilterSpecTimeOption;
	}

	const TaskFilterSpecTimeOption: TaskFilterSpecTimeOptionConstructor;

	interface TaskHistoryCollector extends VcTaskHistoryCollector
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface TaskHistoryCollectorConstructor {
		new(value?:any): TaskHistoryCollector;
		readonly prototype: TaskHistoryCollector;
	}

	const TaskHistoryCollector: TaskHistoryCollectorConstructor;

	interface TaskInfoState extends VcTaskInfoState
	{
		name: any;

	}

	interface TaskInfoStateConstructor {
		new(value?:any): TaskInfoState;
		readonly prototype: TaskInfoState;
	}

	const TaskInfoState: TaskInfoStateConstructor;

	interface TaskManager extends VcTaskManager
	{
		id: any;
		maxCollector: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface TaskManagerConstructor {
		new(value?:any): TaskManager;
		readonly prototype: TaskManager;
	}

	const TaskManager: TaskManagerConstructor;

	interface ThirdPartyLicenseAssignmentFailedReason extends VcThirdPartyLicenseAssignmentFailedReason
	{
		name: any;

	}

	interface ThirdPartyLicenseAssignmentFailedReasonConstructor {
		new(value?:any): ThirdPartyLicenseAssignmentFailedReason;
		readonly prototype: ThirdPartyLicenseAssignmentFailedReason;
	}

	const ThirdPartyLicenseAssignmentFailedReason: ThirdPartyLicenseAssignmentFailedReasonConstructor;

	interface UpgradePolicy extends VcUpgradePolicy
	{
		name: any;

	}

	interface UpgradePolicyConstructor {
		new(value?:any): UpgradePolicy;
		readonly prototype: UpgradePolicy;
	}

	const UpgradePolicy: UpgradePolicyConstructor;

	interface UserDirectory extends VcUserDirectory
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface UserDirectoryConstructor {
		new(value?:any): UserDirectory;
		readonly prototype: UserDirectory;
	}

	const UserDirectory: UserDirectoryConstructor;

	interface ValidateMigrationTestType extends VcValidateMigrationTestType
	{
		name: any;

	}

	interface ValidateMigrationTestTypeConstructor {
		new(value?:any): ValidateMigrationTestType;
		readonly prototype: ValidateMigrationTestType;
	}

	const ValidateMigrationTestType: ValidateMigrationTestTypeConstructor;

	interface VAppAutoStartAction extends VcVAppAutoStartAction
	{
		name: any;

	}

	interface VAppAutoStartActionConstructor {
		new(value?:any): VAppAutoStartAction;
		readonly prototype: VAppAutoStartAction;
	}

	const VAppAutoStartAction: VAppAutoStartActionConstructor;

	interface VAppCloneSpecProvisioningType extends VcVAppCloneSpecProvisioningType
	{
		name: any;

	}

	interface VAppCloneSpecProvisioningTypeConstructor {
		new(value?:any): VAppCloneSpecProvisioningType;
		readonly prototype: VAppCloneSpecProvisioningType;
	}

	const VAppCloneSpecProvisioningType: VAppCloneSpecProvisioningTypeConstructor;

	interface VAppIPAssignmentInfoAllocationSchemes extends VcVAppIPAssignmentInfoAllocationSchemes
	{
		name: any;

	}

	interface VAppIPAssignmentInfoAllocationSchemesConstructor {
		new(value?:any): VAppIPAssignmentInfoAllocationSchemes;
		readonly prototype: VAppIPAssignmentInfoAllocationSchemes;
	}

	const VAppIPAssignmentInfoAllocationSchemes: VAppIPAssignmentInfoAllocationSchemesConstructor;

	interface VAppIPAssignmentInfoIpAllocationPolicy extends VcVAppIPAssignmentInfoIpAllocationPolicy
	{
		name: any;

	}

	interface VAppIPAssignmentInfoIpAllocationPolicyConstructor {
		new(value?:any): VAppIPAssignmentInfoIpAllocationPolicy;
		readonly prototype: VAppIPAssignmentInfoIpAllocationPolicy;
	}

	const VAppIPAssignmentInfoIpAllocationPolicy: VAppIPAssignmentInfoIpAllocationPolicyConstructor;

	interface VAppIPAssignmentInfoProtocols extends VcVAppIPAssignmentInfoProtocols
	{
		name: any;

	}

	interface VAppIPAssignmentInfoProtocolsConstructor {
		new(value?:any): VAppIPAssignmentInfoProtocols;
		readonly prototype: VAppIPAssignmentInfoProtocols;
	}

	const VAppIPAssignmentInfoProtocols: VAppIPAssignmentInfoProtocolsConstructor;

	interface VasaVvolManager extends VcVasaVvolManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VasaVvolManagerConstructor {
		new(value?:any): VasaVvolManager;
		readonly prototype: VasaVvolManager;
	}

	const VasaVvolManager: VasaVvolManagerConstructor;

	interface VcenterVStorageObjectManager extends VcVcenterVStorageObjectManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VcenterVStorageObjectManagerConstructor {
		new(value?:any): VcenterVStorageObjectManager;
		readonly prototype: VcenterVStorageObjectManager;
	}

	const VcenterVStorageObjectManager: VcenterVStorageObjectManagerConstructor;

	interface VchaClusterMode extends VcVchaClusterMode
	{
		name: any;

	}

	interface VchaClusterModeConstructor {
		new(value?:any): VchaClusterMode;
		readonly prototype: VchaClusterMode;
	}

	const VchaClusterMode: VchaClusterModeConstructor;

	interface VchaClusterState extends VcVchaClusterState
	{
		name: any;

	}

	interface VchaClusterStateConstructor {
		new(value?:any): VchaClusterState;
		readonly prototype: VchaClusterState;
	}

	const VchaClusterState: VchaClusterStateConstructor;

	interface VchaNodeRole extends VcVchaNodeRole
	{
		name: any;

	}

	interface VchaNodeRoleConstructor {
		new(value?:any): VchaNodeRole;
		readonly prototype: VchaNodeRole;
	}

	const VchaNodeRole: VchaNodeRoleConstructor;

	interface VchaNodeState extends VcVchaNodeState
	{
		name: any;

	}

	interface VchaNodeStateConstructor {
		new(value?:any): VchaNodeState;
		readonly prototype: VchaNodeState;
	}

	const VchaNodeState: VchaNodeStateConstructor;

	interface VchaState extends VcVchaState
	{
		name: any;

	}

	interface VchaStateConstructor {
		new(value?:any): VchaState;
		readonly prototype: VchaState;
	}

	const VchaState: VchaStateConstructor;

	interface VdcsIpAddressingMode extends VcVdcsIpAddressingMode
	{
		name: any;

	}

	interface VdcsIpAddressingModeConstructor {
		new(value?:any): VdcsIpAddressingMode;
		readonly prototype: VdcsIpAddressingMode;
	}

	const VdcsIpAddressingMode: VdcsIpAddressingModeConstructor;

	interface VdcsIpAddressType extends VcVdcsIpAddressType
	{
		name: any;

	}

	interface VdcsIpAddressTypeConstructor {
		new(value?:any): VdcsIpAddressType;
		readonly prototype: VdcsIpAddressType;
	}

	const VdcsIpAddressType: VdcsIpAddressTypeConstructor;

	interface VdcsIpManager extends VcVdcsIpManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VdcsIpManagerConstructor {
		new(value?:any): VdcsIpManager;
		readonly prototype: VdcsIpManager;
	}

	const VdcsIpManager: VdcsIpManagerConstructor;

	interface VdcsNicManager extends VcVdcsNicManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VdcsNicManagerConstructor {
		new(value?:any): VdcsNicManager;
		readonly prototype: VdcsNicManager;
	}

	const VdcsNicManager: VdcsNicManagerConstructor;

	interface VFlashModuleNotSupportedReason extends VcVFlashModuleNotSupportedReason
	{
		name: any;

	}

	interface VFlashModuleNotSupportedReasonConstructor {
		new(value?:any): VFlashModuleNotSupportedReason;
		readonly prototype: VFlashModuleNotSupportedReason;
	}

	const VFlashModuleNotSupportedReason: VFlashModuleNotSupportedReasonConstructor;

	interface View extends VcView
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ViewConstructor {
		new(value?:any): View;
		readonly prototype: View;
	}

	const View: ViewConstructor;

	interface ViewManager extends VcViewManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface ViewManagerConstructor {
		new(value?:any): ViewManager;
		readonly prototype: ViewManager;
	}

	const ViewManager: ViewManagerConstructor;

	interface VirtualApp extends VcVirtualApp
	{
		alarmActionsEnabled: any;
		configStatus: any;
		cpuReservation: any;
		id: any;
		memoryReservation: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

		appVms(): VirtualMachine;
		vapps(): VirtualApp;
	}

	interface VirtualAppConstructor {
		new(value?:any): VirtualApp;
		readonly prototype: VirtualApp;
	}

	const VirtualApp: VirtualAppConstructor;

	interface VirtualAppVAppState extends VcVirtualAppVAppState
	{
		name: any;

	}

	interface VirtualAppVAppStateConstructor {
		new(value?:any): VirtualAppVAppState;
		readonly prototype: VirtualAppVAppState;
	}

	const VirtualAppVAppState: VirtualAppVAppStateConstructor;

	interface VirtualDatacenter extends VcVirtualDatacenter
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VirtualDatacenterConstructor {
		new(value?:any): VirtualDatacenter;
		readonly prototype: VirtualDatacenter;
	}

	const VirtualDatacenter: VirtualDatacenterConstructor;

	interface VirtualDeviceConfigSpecFileOperation extends VcVirtualDeviceConfigSpecFileOperation
	{
		name: any;

	}

	interface VirtualDeviceConfigSpecFileOperationConstructor {
		new(value?:any): VirtualDeviceConfigSpecFileOperation;
		readonly prototype: VirtualDeviceConfigSpecFileOperation;
	}

	const VirtualDeviceConfigSpecFileOperation: VirtualDeviceConfigSpecFileOperationConstructor;

	interface VirtualDeviceConfigSpecOperation extends VcVirtualDeviceConfigSpecOperation
	{
		name: any;

	}

	interface VirtualDeviceConfigSpecOperationConstructor {
		new(value?:any): VirtualDeviceConfigSpecOperation;
		readonly prototype: VirtualDeviceConfigSpecOperation;
	}

	const VirtualDeviceConfigSpecOperation: VirtualDeviceConfigSpecOperationConstructor;

	interface VirtualDeviceConnectInfoStatus extends VcVirtualDeviceConnectInfoStatus
	{
		name: any;

	}

	interface VirtualDeviceConnectInfoStatusConstructor {
		new(value?:any): VirtualDeviceConnectInfoStatus;
		readonly prototype: VirtualDeviceConnectInfoStatus;
	}

	const VirtualDeviceConnectInfoStatus: VirtualDeviceConnectInfoStatusConstructor;

	interface VirtualDeviceFileExtension extends VcVirtualDeviceFileExtension
	{
		name: any;

	}

	interface VirtualDeviceFileExtensionConstructor {
		new(value?:any): VirtualDeviceFileExtension;
		readonly prototype: VirtualDeviceFileExtension;
	}

	const VirtualDeviceFileExtension: VirtualDeviceFileExtensionConstructor;

	interface VirtualDeviceURIBackingOptionDirection extends VcVirtualDeviceURIBackingOptionDirection
	{
		name: any;

	}

	interface VirtualDeviceURIBackingOptionDirectionConstructor {
		new(value?:any): VirtualDeviceURIBackingOptionDirection;
		readonly prototype: VirtualDeviceURIBackingOptionDirection;
	}

	const VirtualDeviceURIBackingOptionDirection: VirtualDeviceURIBackingOptionDirectionConstructor;

	interface VirtualDiskAdapterType extends VcVirtualDiskAdapterType
	{
		name: any;

	}

	interface VirtualDiskAdapterTypeConstructor {
		new(value?:any): VirtualDiskAdapterType;
		readonly prototype: VirtualDiskAdapterType;
	}

	const VirtualDiskAdapterType: VirtualDiskAdapterTypeConstructor;

	interface VirtualDiskCompatibilityMode extends VcVirtualDiskCompatibilityMode
	{
		name: any;

	}

	interface VirtualDiskCompatibilityModeConstructor {
		new(value?:any): VirtualDiskCompatibilityMode;
		readonly prototype: VirtualDiskCompatibilityMode;
	}

	const VirtualDiskCompatibilityMode: VirtualDiskCompatibilityModeConstructor;

	interface VirtualDiskDeltaDiskFormat extends VcVirtualDiskDeltaDiskFormat
	{
		name: any;

	}

	interface VirtualDiskDeltaDiskFormatConstructor {
		new(value?:any): VirtualDiskDeltaDiskFormat;
		readonly prototype: VirtualDiskDeltaDiskFormat;
	}

	const VirtualDiskDeltaDiskFormat: VirtualDiskDeltaDiskFormatConstructor;

	interface VirtualDiskDeltaDiskFormatVariant extends VcVirtualDiskDeltaDiskFormatVariant
	{
		name: any;

	}

	interface VirtualDiskDeltaDiskFormatVariantConstructor {
		new(value?:any): VirtualDiskDeltaDiskFormatVariant;
		readonly prototype: VirtualDiskDeltaDiskFormatVariant;
	}

	const VirtualDiskDeltaDiskFormatVariant: VirtualDiskDeltaDiskFormatVariantConstructor;

	interface VirtualDiskManager extends VcVirtualDiskManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VirtualDiskManagerConstructor {
		new(value?:any): VirtualDiskManager;
		readonly prototype: VirtualDiskManager;
	}

	const VirtualDiskManager: VirtualDiskManagerConstructor;

	interface VirtualDiskMode extends VcVirtualDiskMode
	{
		name: any;

	}

	interface VirtualDiskModeConstructor {
		new(value?:any): VirtualDiskMode;
		readonly prototype: VirtualDiskMode;
	}

	const VirtualDiskMode: VirtualDiskModeConstructor;

	interface VirtualDiskSharing extends VcVirtualDiskSharing
	{
		name: any;

	}

	interface VirtualDiskSharingConstructor {
		new(value?:any): VirtualDiskSharing;
		readonly prototype: VirtualDiskSharing;
	}

	const VirtualDiskSharing: VirtualDiskSharingConstructor;

	interface VirtualDiskType extends VcVirtualDiskType
	{
		name: any;

	}

	interface VirtualDiskTypeConstructor {
		new(value?:any): VirtualDiskType;
		readonly prototype: VirtualDiskType;
	}

	const VirtualDiskType: VirtualDiskTypeConstructor;

	interface VirtualDiskVFlashCacheConfigInfoCacheConsistencyType extends VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType
	{
		name: any;

	}

	interface VirtualDiskVFlashCacheConfigInfoCacheConsistencyTypeConstructor {
		new(value?:any): VirtualDiskVFlashCacheConfigInfoCacheConsistencyType;
		readonly prototype: VirtualDiskVFlashCacheConfigInfoCacheConsistencyType;
	}

	const VirtualDiskVFlashCacheConfigInfoCacheConsistencyType: VirtualDiskVFlashCacheConfigInfoCacheConsistencyTypeConstructor;

	interface VirtualDiskVFlashCacheConfigInfoCacheMode extends VcVirtualDiskVFlashCacheConfigInfoCacheMode
	{
		name: any;

	}

	interface VirtualDiskVFlashCacheConfigInfoCacheModeConstructor {
		new(value?:any): VirtualDiskVFlashCacheConfigInfoCacheMode;
		readonly prototype: VirtualDiskVFlashCacheConfigInfoCacheMode;
	}

	const VirtualDiskVFlashCacheConfigInfoCacheMode: VirtualDiskVFlashCacheConfigInfoCacheModeConstructor;

	interface VirtualEthernetCardLegacyNetworkDeviceName extends VcVirtualEthernetCardLegacyNetworkDeviceName
	{
		name: any;

	}

	interface VirtualEthernetCardLegacyNetworkDeviceNameConstructor {
		new(value?:any): VirtualEthernetCardLegacyNetworkDeviceName;
		readonly prototype: VirtualEthernetCardLegacyNetworkDeviceName;
	}

	const VirtualEthernetCardLegacyNetworkDeviceName: VirtualEthernetCardLegacyNetworkDeviceNameConstructor;

	interface VirtualEthernetCardMacType extends VcVirtualEthernetCardMacType
	{
		name: any;

	}

	interface VirtualEthernetCardMacTypeConstructor {
		new(value?:any): VirtualEthernetCardMacType;
		readonly prototype: VirtualEthernetCardMacType;
	}

	const VirtualEthernetCardMacType: VirtualEthernetCardMacTypeConstructor;

	interface VirtualizationManager extends VcVirtualizationManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VirtualizationManagerConstructor {
		new(value?:any): VirtualizationManager;
		readonly prototype: VirtualizationManager;
	}

	const VirtualizationManager: VirtualizationManagerConstructor;

	interface VirtualMachine extends VcVirtualMachine
	{
		alarmActionsEnabled: any;
		annotation: any;
		biosId: any;
		committedStorage: any;
		configStatus: any;
		connectionState: any;
		cpu: any;
		displayName: any;
		guestHeartbeatStatus: any;
		guestMemoryUsage: any;
		guestOS: any;
		hostMemoryUsage: any;
		hostName: any;
		id: any;
		instanceId: any;
		ipAddress: any;
		isTemplate: any;
		mem: any;
		memory: any;
		memoryOverhead: any;
		name: any;
		overallCpuUsage: any;
		overallStatus: any;
		productFullVersion: any;
		productName: any;
		productVendor: any;
		sdkId: any;
		state: any;
		totalStorage: any;
		type: any;
		unsharedStorage: any;
		vimId: any;
		vimType: any;
		vmToolsStatus: any;
		vmToolsVersionStatus: any;
		vmVersion: any;

		snapshot(): VirtualMachineSnapshot;
	}

	interface VirtualMachineConstructor {
		new(value?:any): VirtualMachine;
		readonly prototype: VirtualMachine;
	}

	const VirtualMachine: VirtualMachineConstructor;

	interface VirtualMachineAppHeartbeatStatusType extends VcVirtualMachineAppHeartbeatStatusType
	{
		name: any;

	}

	interface VirtualMachineAppHeartbeatStatusTypeConstructor {
		new(value?:any): VirtualMachineAppHeartbeatStatusType;
		readonly prototype: VirtualMachineAppHeartbeatStatusType;
	}

	const VirtualMachineAppHeartbeatStatusType: VirtualMachineAppHeartbeatStatusTypeConstructor;

	interface VirtualMachineBackupAgent extends VcVirtualMachineBackupAgent
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VirtualMachineBackupAgentConstructor {
		new(value?:any): VirtualMachineBackupAgent;
		readonly prototype: VirtualMachineBackupAgent;
	}

	const VirtualMachineBackupAgent: VirtualMachineBackupAgentConstructor;

	interface VirtualMachineBackupEventInfoBackupEventType extends VcVirtualMachineBackupEventInfoBackupEventType
	{
		name: any;

	}

	interface VirtualMachineBackupEventInfoBackupEventTypeConstructor {
		new(value?:any): VirtualMachineBackupEventInfoBackupEventType;
		readonly prototype: VirtualMachineBackupEventInfoBackupEventType;
	}

	const VirtualMachineBackupEventInfoBackupEventType: VirtualMachineBackupEventInfoBackupEventTypeConstructor;

	interface VirtualMachineBootOptionsNetworkBootProtocolType extends VcVirtualMachineBootOptionsNetworkBootProtocolType
	{
		name: any;

	}

	interface VirtualMachineBootOptionsNetworkBootProtocolTypeConstructor {
		new(value?:any): VirtualMachineBootOptionsNetworkBootProtocolType;
		readonly prototype: VirtualMachineBootOptionsNetworkBootProtocolType;
	}

	const VirtualMachineBootOptionsNetworkBootProtocolType: VirtualMachineBootOptionsNetworkBootProtocolTypeConstructor;

	interface VirtualMachineCompatibilityChecker extends VcVirtualMachineCompatibilityChecker
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VirtualMachineCompatibilityCheckerConstructor {
		new(value?:any): VirtualMachineCompatibilityChecker;
		readonly prototype: VirtualMachineCompatibilityChecker;
	}

	const VirtualMachineCompatibilityChecker: VirtualMachineCompatibilityCheckerConstructor;

	interface VirtualMachineConfigInfoNpivWwnType extends VcVirtualMachineConfigInfoNpivWwnType
	{
		name: any;

	}

	interface VirtualMachineConfigInfoNpivWwnTypeConstructor {
		new(value?:any): VirtualMachineConfigInfoNpivWwnType;
		readonly prototype: VirtualMachineConfigInfoNpivWwnType;
	}

	const VirtualMachineConfigInfoNpivWwnType: VirtualMachineConfigInfoNpivWwnTypeConstructor;

	interface VirtualMachineConfigInfoSwapPlacementType extends VcVirtualMachineConfigInfoSwapPlacementType
	{
		name: any;

	}

	interface VirtualMachineConfigInfoSwapPlacementTypeConstructor {
		new(value?:any): VirtualMachineConfigInfoSwapPlacementType;
		readonly prototype: VirtualMachineConfigInfoSwapPlacementType;
	}

	const VirtualMachineConfigInfoSwapPlacementType: VirtualMachineConfigInfoSwapPlacementTypeConstructor;

	interface VirtualMachineConfigSpecEncryptedVMotionModes extends VcVirtualMachineConfigSpecEncryptedVMotionModes
	{
		name: any;

	}

	interface VirtualMachineConfigSpecEncryptedVMotionModesConstructor {
		new(value?:any): VirtualMachineConfigSpecEncryptedVMotionModes;
		readonly prototype: VirtualMachineConfigSpecEncryptedVMotionModes;
	}

	const VirtualMachineConfigSpecEncryptedVMotionModes: VirtualMachineConfigSpecEncryptedVMotionModesConstructor;

	interface VirtualMachineConfigSpecNpivWwnOp extends VcVirtualMachineConfigSpecNpivWwnOp
	{
		name: any;

	}

	interface VirtualMachineConfigSpecNpivWwnOpConstructor {
		new(value?:any): VirtualMachineConfigSpecNpivWwnOp;
		readonly prototype: VirtualMachineConfigSpecNpivWwnOp;
	}

	const VirtualMachineConfigSpecNpivWwnOp: VirtualMachineConfigSpecNpivWwnOpConstructor;

	interface VirtualMachineConnectionState extends VcVirtualMachineConnectionState
	{
		name: any;

	}

	interface VirtualMachineConnectionStateConstructor {
		new(value?:any): VirtualMachineConnectionState;
		readonly prototype: VirtualMachineConnectionState;
	}

	const VirtualMachineConnectionState: VirtualMachineConnectionStateConstructor;

	interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther extends VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther
	{
		name: any;

	}

	interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOtherConstructor {
		new(value?:any): VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;
		readonly prototype: VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;
	}

	const VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther: VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOtherConstructor;

	interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm extends VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm
	{
		name: any;

	}

	interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVmConstructor {
		new(value?:any): VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly prototype: VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
	}

	const VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm: VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVmConstructor;

	interface VirtualMachineFaultToleranceState extends VcVirtualMachineFaultToleranceState
	{
		name: any;

	}

	interface VirtualMachineFaultToleranceStateConstructor {
		new(value?:any): VirtualMachineFaultToleranceState;
		readonly prototype: VirtualMachineFaultToleranceState;
	}

	const VirtualMachineFaultToleranceState: VirtualMachineFaultToleranceStateConstructor;

	interface VirtualMachineFaultToleranceType extends VcVirtualMachineFaultToleranceType
	{
		name: any;

	}

	interface VirtualMachineFaultToleranceTypeConstructor {
		new(value?:any): VirtualMachineFaultToleranceType;
		readonly prototype: VirtualMachineFaultToleranceType;
	}

	const VirtualMachineFaultToleranceType: VirtualMachineFaultToleranceTypeConstructor;

	interface VirtualMachineFileLayoutExFileType extends VcVirtualMachineFileLayoutExFileType
	{
		name: any;

	}

	interface VirtualMachineFileLayoutExFileTypeConstructor {
		new(value?:any): VirtualMachineFileLayoutExFileType;
		readonly prototype: VirtualMachineFileLayoutExFileType;
	}

	const VirtualMachineFileLayoutExFileType: VirtualMachineFileLayoutExFileTypeConstructor;

	interface VirtualMachineFlagInfoMonitorType extends VcVirtualMachineFlagInfoMonitorType
	{
		name: any;

	}

	interface VirtualMachineFlagInfoMonitorTypeConstructor {
		new(value?:any): VirtualMachineFlagInfoMonitorType;
		readonly prototype: VirtualMachineFlagInfoMonitorType;
	}

	const VirtualMachineFlagInfoMonitorType: VirtualMachineFlagInfoMonitorTypeConstructor;

	interface VirtualMachineFlagInfoVirtualExecUsage extends VcVirtualMachineFlagInfoVirtualExecUsage
	{
		name: any;

	}

	interface VirtualMachineFlagInfoVirtualExecUsageConstructor {
		new(value?:any): VirtualMachineFlagInfoVirtualExecUsage;
		readonly prototype: VirtualMachineFlagInfoVirtualExecUsage;
	}

	const VirtualMachineFlagInfoVirtualExecUsage: VirtualMachineFlagInfoVirtualExecUsageConstructor;

	interface VirtualMachineFlagInfoVirtualMmuUsage extends VcVirtualMachineFlagInfoVirtualMmuUsage
	{
		name: any;

	}

	interface VirtualMachineFlagInfoVirtualMmuUsageConstructor {
		new(value?:any): VirtualMachineFlagInfoVirtualMmuUsage;
		readonly prototype: VirtualMachineFlagInfoVirtualMmuUsage;
	}

	const VirtualMachineFlagInfoVirtualMmuUsage: VirtualMachineFlagInfoVirtualMmuUsageConstructor;

	interface VirtualMachineForkConfigInfoChildType extends VcVirtualMachineForkConfigInfoChildType
	{
		name: any;

	}

	interface VirtualMachineForkConfigInfoChildTypeConstructor {
		new(value?:any): VirtualMachineForkConfigInfoChildType;
		readonly prototype: VirtualMachineForkConfigInfoChildType;
	}

	const VirtualMachineForkConfigInfoChildType: VirtualMachineForkConfigInfoChildTypeConstructor;

	interface VirtualMachineGuestOsFamily extends VcVirtualMachineGuestOsFamily
	{
		name: any;

	}

	interface VirtualMachineGuestOsFamilyConstructor {
		new(value?:any): VirtualMachineGuestOsFamily;
		readonly prototype: VirtualMachineGuestOsFamily;
	}

	const VirtualMachineGuestOsFamily: VirtualMachineGuestOsFamilyConstructor;

	interface VirtualMachineGuestOsIdentifier extends VcVirtualMachineGuestOsIdentifier
	{
		name: any;

	}

	interface VirtualMachineGuestOsIdentifierConstructor {
		new(value?:any): VirtualMachineGuestOsIdentifier;
		readonly prototype: VirtualMachineGuestOsIdentifier;
	}

	const VirtualMachineGuestOsIdentifier: VirtualMachineGuestOsIdentifierConstructor;

	interface VirtualMachineGuestState extends VcVirtualMachineGuestState
	{
		name: any;

	}

	interface VirtualMachineGuestStateConstructor {
		new(value?:any): VirtualMachineGuestState;
		readonly prototype: VirtualMachineGuestState;
	}

	const VirtualMachineGuestState: VirtualMachineGuestStateConstructor;

	interface VirtualMachineHtSharing extends VcVirtualMachineHtSharing
	{
		name: any;

	}

	interface VirtualMachineHtSharingConstructor {
		new(value?:any): VirtualMachineHtSharing;
		readonly prototype: VirtualMachineHtSharing;
	}

	const VirtualMachineHtSharing: VirtualMachineHtSharingConstructor;

	interface VirtualMachineMemoryAllocationPolicy extends VcVirtualMachineMemoryAllocationPolicy
	{
		name: any;

	}

	interface VirtualMachineMemoryAllocationPolicyConstructor {
		new(value?:any): VirtualMachineMemoryAllocationPolicy;
		readonly prototype: VirtualMachineMemoryAllocationPolicy;
	}

	const VirtualMachineMemoryAllocationPolicy: VirtualMachineMemoryAllocationPolicyConstructor;

	interface VirtualMachineMetadataManager extends VcVirtualMachineMetadataManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VirtualMachineMetadataManagerConstructor {
		new(value?:any): VirtualMachineMetadataManager;
		readonly prototype: VirtualMachineMetadataManager;
	}

	const VirtualMachineMetadataManager: VirtualMachineMetadataManagerConstructor;

	interface VirtualMachineMetadataManagerVmMetadataOp extends VcVirtualMachineMetadataManagerVmMetadataOp
	{
		name: any;

	}

	interface VirtualMachineMetadataManagerVmMetadataOpConstructor {
		new(value?:any): VirtualMachineMetadataManagerVmMetadataOp;
		readonly prototype: VirtualMachineMetadataManagerVmMetadataOp;
	}

	const VirtualMachineMetadataManagerVmMetadataOp: VirtualMachineMetadataManagerVmMetadataOpConstructor;

	interface VirtualMachineMetadataManagerVmMetadataOwnerOwner extends VcVirtualMachineMetadataManagerVmMetadataOwnerOwner
	{
		name: any;

	}

	interface VirtualMachineMetadataManagerVmMetadataOwnerOwnerConstructor {
		new(value?:any): VirtualMachineMetadataManagerVmMetadataOwnerOwner;
		readonly prototype: VirtualMachineMetadataManagerVmMetadataOwnerOwner;
	}

	const VirtualMachineMetadataManagerVmMetadataOwnerOwner: VirtualMachineMetadataManagerVmMetadataOwnerOwnerConstructor;

	interface VirtualMachineMovePriority extends VcVirtualMachineMovePriority
	{
		name: any;

	}

	interface VirtualMachineMovePriorityConstructor {
		new(value?:any): VirtualMachineMovePriority;
		readonly prototype: VirtualMachineMovePriority;
	}

	const VirtualMachineMovePriority: VirtualMachineMovePriorityConstructor;

	interface VirtualMachineNamespaceManager extends VcVirtualMachineNamespaceManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VirtualMachineNamespaceManagerConstructor {
		new(value?:any): VirtualMachineNamespaceManager;
		readonly prototype: VirtualMachineNamespaceManager;
	}

	const VirtualMachineNamespaceManager: VirtualMachineNamespaceManagerConstructor;

	interface VirtualMachineNamespaceManagerDataSpecOpCode extends VcVirtualMachineNamespaceManagerDataSpecOpCode
	{
		name: any;

	}

	interface VirtualMachineNamespaceManagerDataSpecOpCodeConstructor {
		new(value?:any): VirtualMachineNamespaceManagerDataSpecOpCode;
		readonly prototype: VirtualMachineNamespaceManagerDataSpecOpCode;
	}

	const VirtualMachineNamespaceManagerDataSpecOpCode: VirtualMachineNamespaceManagerDataSpecOpCodeConstructor;

	interface VirtualMachineNeedSecondaryReason extends VcVirtualMachineNeedSecondaryReason
	{
		name: any;

	}

	interface VirtualMachineNeedSecondaryReasonConstructor {
		new(value?:any): VirtualMachineNeedSecondaryReason;
		readonly prototype: VirtualMachineNeedSecondaryReason;
	}

	const VirtualMachineNeedSecondaryReason: VirtualMachineNeedSecondaryReasonConstructor;

	interface VirtualMachinePauseManager extends VcVirtualMachinePauseManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VirtualMachinePauseManagerConstructor {
		new(value?:any): VirtualMachinePauseManager;
		readonly prototype: VirtualMachinePauseManager;
	}

	const VirtualMachinePauseManager: VirtualMachinePauseManagerConstructor;

	interface VirtualMachinePowerOffBehavior extends VcVirtualMachinePowerOffBehavior
	{
		name: any;

	}

	interface VirtualMachinePowerOffBehaviorConstructor {
		new(value?:any): VirtualMachinePowerOffBehavior;
		readonly prototype: VirtualMachinePowerOffBehavior;
	}

	const VirtualMachinePowerOffBehavior: VirtualMachinePowerOffBehaviorConstructor;

	interface VirtualMachinePowerOpType extends VcVirtualMachinePowerOpType
	{
		name: any;

	}

	interface VirtualMachinePowerOpTypeConstructor {
		new(value?:any): VirtualMachinePowerOpType;
		readonly prototype: VirtualMachinePowerOpType;
	}

	const VirtualMachinePowerOpType: VirtualMachinePowerOpTypeConstructor;

	interface VirtualMachinePowerPolicyCpuMode extends VcVirtualMachinePowerPolicyCpuMode
	{
		name: any;

	}

	interface VirtualMachinePowerPolicyCpuModeConstructor {
		new(value?:any): VirtualMachinePowerPolicyCpuMode;
		readonly prototype: VirtualMachinePowerPolicyCpuMode;
	}

	const VirtualMachinePowerPolicyCpuMode: VirtualMachinePowerPolicyCpuModeConstructor;

	interface VirtualMachinePowerPolicyPowerMode extends VcVirtualMachinePowerPolicyPowerMode
	{
		name: any;

	}

	interface VirtualMachinePowerPolicyPowerModeConstructor {
		new(value?:any): VirtualMachinePowerPolicyPowerMode;
		readonly prototype: VirtualMachinePowerPolicyPowerMode;
	}

	const VirtualMachinePowerPolicyPowerMode: VirtualMachinePowerPolicyPowerModeConstructor;

	interface VirtualMachinePowerState extends VcVirtualMachinePowerState
	{
		name: any;

	}

	interface VirtualMachinePowerStateConstructor {
		new(value?:any): VirtualMachinePowerState;
		readonly prototype: VirtualMachinePowerState;
	}

	const VirtualMachinePowerState: VirtualMachinePowerStateConstructor;

	interface VirtualMachineProvisioningChecker extends VcVirtualMachineProvisioningChecker
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VirtualMachineProvisioningCheckerConstructor {
		new(value?:any): VirtualMachineProvisioningChecker;
		readonly prototype: VirtualMachineProvisioningChecker;
	}

	const VirtualMachineProvisioningChecker: VirtualMachineProvisioningCheckerConstructor;

	interface VirtualMachineProvisioningPolicyAction extends VcVirtualMachineProvisioningPolicyAction
	{
		name: any;

	}

	interface VirtualMachineProvisioningPolicyActionConstructor {
		new(value?:any): VirtualMachineProvisioningPolicyAction;
		readonly prototype: VirtualMachineProvisioningPolicyAction;
	}

	const VirtualMachineProvisioningPolicyAction: VirtualMachineProvisioningPolicyActionConstructor;

	interface VirtualMachineProvisioningPolicyOpType extends VcVirtualMachineProvisioningPolicyOpType
	{
		name: any;

	}

	interface VirtualMachineProvisioningPolicyOpTypeConstructor {
		new(value?:any): VirtualMachineProvisioningPolicyOpType;
		readonly prototype: VirtualMachineProvisioningPolicyOpType;
	}

	const VirtualMachineProvisioningPolicyOpType: VirtualMachineProvisioningPolicyOpTypeConstructor;

	interface VirtualMachineRecordReplayState extends VcVirtualMachineRecordReplayState
	{
		name: any;

	}

	interface VirtualMachineRecordReplayStateConstructor {
		new(value?:any): VirtualMachineRecordReplayState;
		readonly prototype: VirtualMachineRecordReplayState;
	}

	const VirtualMachineRecordReplayState: VirtualMachineRecordReplayStateConstructor;

	interface VirtualMachineRelocateDiskMoveOptions extends VcVirtualMachineRelocateDiskMoveOptions
	{
		name: any;

	}

	interface VirtualMachineRelocateDiskMoveOptionsConstructor {
		new(value?:any): VirtualMachineRelocateDiskMoveOptions;
		readonly prototype: VirtualMachineRelocateDiskMoveOptions;
	}

	const VirtualMachineRelocateDiskMoveOptions: VirtualMachineRelocateDiskMoveOptionsConstructor;

	interface VirtualMachineRelocateTransformation extends VcVirtualMachineRelocateTransformation
	{
		name: any;

	}

	interface VirtualMachineRelocateTransformationConstructor {
		new(value?:any): VirtualMachineRelocateTransformation;
		readonly prototype: VirtualMachineRelocateTransformation;
	}

	const VirtualMachineRelocateTransformation: VirtualMachineRelocateTransformationConstructor;

	interface VirtualMachineScsiPassthroughType extends VcVirtualMachineScsiPassthroughType
	{
		name: any;

	}

	interface VirtualMachineScsiPassthroughTypeConstructor {
		new(value?:any): VirtualMachineScsiPassthroughType;
		readonly prototype: VirtualMachineScsiPassthroughType;
	}

	const VirtualMachineScsiPassthroughType: VirtualMachineScsiPassthroughTypeConstructor;

	interface VirtualMachineSnapshot extends VcVirtualMachineSnapshot
	{
		description: any;
		id: any;
		name: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;
		virtualMachineName: any;

		snapshot(): VirtualMachineSnapshot;
	}

	interface VirtualMachineSnapshotConstructor {
		new(value?:any): VirtualMachineSnapshot;
		readonly prototype: VirtualMachineSnapshot;
	}

	const VirtualMachineSnapshot: VirtualMachineSnapshotConstructor;

	interface VirtualMachineStandbyActionType extends VcVirtualMachineStandbyActionType
	{
		name: any;

	}

	interface VirtualMachineStandbyActionTypeConstructor {
		new(value?:any): VirtualMachineStandbyActionType;
		readonly prototype: VirtualMachineStandbyActionType;
	}

	const VirtualMachineStandbyActionType: VirtualMachineStandbyActionTypeConstructor;

	interface VirtualMachineTargetInfoConfigurationTag extends VcVirtualMachineTargetInfoConfigurationTag
	{
		name: any;

	}

	interface VirtualMachineTargetInfoConfigurationTagConstructor {
		new(value?:any): VirtualMachineTargetInfoConfigurationTag;
		readonly prototype: VirtualMachineTargetInfoConfigurationTag;
	}

	const VirtualMachineTargetInfoConfigurationTag: VirtualMachineTargetInfoConfigurationTagConstructor;

	interface VirtualMachineTicketType extends VcVirtualMachineTicketType
	{
		name: any;

	}

	interface VirtualMachineTicketTypeConstructor {
		new(value?:any): VirtualMachineTicketType;
		readonly prototype: VirtualMachineTicketType;
	}

	const VirtualMachineTicketType: VirtualMachineTicketTypeConstructor;

	interface VirtualMachineToolsInstallType extends VcVirtualMachineToolsInstallType
	{
		name: any;

	}

	interface VirtualMachineToolsInstallTypeConstructor {
		new(value?:any): VirtualMachineToolsInstallType;
		readonly prototype: VirtualMachineToolsInstallType;
	}

	const VirtualMachineToolsInstallType: VirtualMachineToolsInstallTypeConstructor;

	interface VirtualMachineToolsRunningStatus extends VcVirtualMachineToolsRunningStatus
	{
		name: any;

	}

	interface VirtualMachineToolsRunningStatusConstructor {
		new(value?:any): VirtualMachineToolsRunningStatus;
		readonly prototype: VirtualMachineToolsRunningStatus;
	}

	const VirtualMachineToolsRunningStatus: VirtualMachineToolsRunningStatusConstructor;

	interface VirtualMachineToolsStatus extends VcVirtualMachineToolsStatus
	{
		name: any;

	}

	interface VirtualMachineToolsStatusConstructor {
		new(value?:any): VirtualMachineToolsStatus;
		readonly prototype: VirtualMachineToolsStatus;
	}

	const VirtualMachineToolsStatus: VirtualMachineToolsStatusConstructor;

	interface VirtualMachineToolsVersionStatus extends VcVirtualMachineToolsVersionStatus
	{
		name: any;

	}

	interface VirtualMachineToolsVersionStatusConstructor {
		new(value?:any): VirtualMachineToolsVersionStatus;
		readonly prototype: VirtualMachineToolsVersionStatus;
	}

	const VirtualMachineToolsVersionStatus: VirtualMachineToolsVersionStatusConstructor;

	interface VirtualMachineUsbInfoFamily extends VcVirtualMachineUsbInfoFamily
	{
		name: any;

	}

	interface VirtualMachineUsbInfoFamilyConstructor {
		new(value?:any): VirtualMachineUsbInfoFamily;
		readonly prototype: VirtualMachineUsbInfoFamily;
	}

	const VirtualMachineUsbInfoFamily: VirtualMachineUsbInfoFamilyConstructor;

	interface VirtualMachineUsbInfoSpeed extends VcVirtualMachineUsbInfoSpeed
	{
		name: any;

	}

	interface VirtualMachineUsbInfoSpeedConstructor {
		new(value?:any): VirtualMachineUsbInfoSpeed;
		readonly prototype: VirtualMachineUsbInfoSpeed;
	}

	const VirtualMachineUsbInfoSpeed: VirtualMachineUsbInfoSpeedConstructor;

	interface VirtualMachineVideoCardUse3dRenderer extends VcVirtualMachineVideoCardUse3dRenderer
	{
		name: any;

	}

	interface VirtualMachineVideoCardUse3dRendererConstructor {
		new(value?:any): VirtualMachineVideoCardUse3dRenderer;
		readonly prototype: VirtualMachineVideoCardUse3dRenderer;
	}

	const VirtualMachineVideoCardUse3dRenderer: VirtualMachineVideoCardUse3dRendererConstructor;

	interface VirtualMachineVMCIDeviceAction extends VcVirtualMachineVMCIDeviceAction
	{
		name: any;

	}

	interface VirtualMachineVMCIDeviceActionConstructor {
		new(value?:any): VirtualMachineVMCIDeviceAction;
		readonly prototype: VirtualMachineVMCIDeviceAction;
	}

	const VirtualMachineVMCIDeviceAction: VirtualMachineVMCIDeviceActionConstructor;

	interface VirtualMachineVMCIDeviceDirection extends VcVirtualMachineVMCIDeviceDirection
	{
		name: any;

	}

	interface VirtualMachineVMCIDeviceDirectionConstructor {
		new(value?:any): VirtualMachineVMCIDeviceDirection;
		readonly prototype: VirtualMachineVMCIDeviceDirection;
	}

	const VirtualMachineVMCIDeviceDirection: VirtualMachineVMCIDeviceDirectionConstructor;

	interface VirtualMachineVMCIDeviceProtocol extends VcVirtualMachineVMCIDeviceProtocol
	{
		name: any;

	}

	interface VirtualMachineVMCIDeviceProtocolConstructor {
		new(value?:any): VirtualMachineVMCIDeviceProtocol;
		readonly prototype: VirtualMachineVMCIDeviceProtocol;
	}

	const VirtualMachineVMCIDeviceProtocol: VirtualMachineVMCIDeviceProtocolConstructor;

	interface VirtualMachineWindowsQuiesceSpecVssBackupContext extends VcVirtualMachineWindowsQuiesceSpecVssBackupContext
	{
		name: any;

	}

	interface VirtualMachineWindowsQuiesceSpecVssBackupContextConstructor {
		new(value?:any): VirtualMachineWindowsQuiesceSpecVssBackupContext;
		readonly prototype: VirtualMachineWindowsQuiesceSpecVssBackupContext;
	}

	const VirtualMachineWindowsQuiesceSpecVssBackupContext: VirtualMachineWindowsQuiesceSpecVssBackupContextConstructor;

	interface VirtualPointingDeviceHostChoice extends VcVirtualPointingDeviceHostChoice
	{
		name: any;

	}

	interface VirtualPointingDeviceHostChoiceConstructor {
		new(value?:any): VirtualPointingDeviceHostChoice;
		readonly prototype: VirtualPointingDeviceHostChoice;
	}

	const VirtualPointingDeviceHostChoice: VirtualPointingDeviceHostChoiceConstructor;

	interface VirtualSCSISharing extends VcVirtualSCSISharing
	{
		name: any;

	}

	interface VirtualSCSISharingConstructor {
		new(value?:any): VirtualSCSISharing;
		readonly prototype: VirtualSCSISharing;
	}

	const VirtualSCSISharing: VirtualSCSISharingConstructor;

	interface VirtualSerialPortEndPoint extends VcVirtualSerialPortEndPoint
	{
		name: any;

	}

	interface VirtualSerialPortEndPointConstructor {
		new(value?:any): VirtualSerialPortEndPoint;
		readonly prototype: VirtualSerialPortEndPoint;
	}

	const VirtualSerialPortEndPoint: VirtualSerialPortEndPointConstructor;

	interface VmDasBeingResetEventReasonCode extends VcVmDasBeingResetEventReasonCode
	{
		name: any;

	}

	interface VmDasBeingResetEventReasonCodeConstructor {
		new(value?:any): VmDasBeingResetEventReasonCode;
		readonly prototype: VmDasBeingResetEventReasonCode;
	}

	const VmDasBeingResetEventReasonCode: VmDasBeingResetEventReasonCodeConstructor;

	interface VmFailedStartingSecondaryEventFailureReason extends VcVmFailedStartingSecondaryEventFailureReason
	{
		name: any;

	}

	interface VmFailedStartingSecondaryEventFailureReasonConstructor {
		new(value?:any): VmFailedStartingSecondaryEventFailureReason;
		readonly prototype: VmFailedStartingSecondaryEventFailureReason;
	}

	const VmFailedStartingSecondaryEventFailureReason: VmFailedStartingSecondaryEventFailureReasonConstructor;

	interface VmFaultToleranceConfigIssueReasonForIssue extends VcVmFaultToleranceConfigIssueReasonForIssue
	{
		name: any;

	}

	interface VmFaultToleranceConfigIssueReasonForIssueConstructor {
		new(value?:any): VmFaultToleranceConfigIssueReasonForIssue;
		readonly prototype: VmFaultToleranceConfigIssueReasonForIssue;
	}

	const VmFaultToleranceConfigIssueReasonForIssue: VmFaultToleranceConfigIssueReasonForIssueConstructor;

	interface VmFaultToleranceInvalidFileBackingDeviceType extends VcVmFaultToleranceInvalidFileBackingDeviceType
	{
		name: any;

	}

	interface VmFaultToleranceInvalidFileBackingDeviceTypeConstructor {
		new(value?:any): VmFaultToleranceInvalidFileBackingDeviceType;
		readonly prototype: VmFaultToleranceInvalidFileBackingDeviceType;
	}

	const VmFaultToleranceInvalidFileBackingDeviceType: VmFaultToleranceInvalidFileBackingDeviceTypeConstructor;

	interface VmFolder extends VcVmFolder
	{
		alarmActionsEnabled: any;
		configStatus: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;

		vapps(): VirtualApp;
		vm(): VmFolder;
		vms(): VirtualMachine;
	}

	interface VmFolderConstructor {
		new(value?:any): VmFolder;
		readonly prototype: VmFolder;
	}

	const VmFolder: VmFolderConstructor;

	interface VMotionCompatibilityType extends VcVMotionCompatibilityType
	{
		name: any;

	}

	interface VMotionCompatibilityTypeConstructor {
		new(value?:any): VMotionCompatibilityType;
		readonly prototype: VMotionCompatibilityType;
	}

	const VMotionCompatibilityType: VMotionCompatibilityTypeConstructor;

	interface VmShutdownOnIsolationEventOperation extends VcVmShutdownOnIsolationEventOperation
	{
		name: any;

	}

	interface VmShutdownOnIsolationEventOperationConstructor {
		new(value?:any): VmShutdownOnIsolationEventOperation;
		readonly prototype: VmShutdownOnIsolationEventOperation;
	}

	const VmShutdownOnIsolationEventOperation: VmShutdownOnIsolationEventOperationConstructor;

	interface VmwareDistributedVirtualSwitch extends VcVmwareDistributedVirtualSwitch
	{
		alarmActionsEnabled: any;
		configStatus: any;
		description: any;
		id: any;
		name: any;
		overallStatus: any;
		sdkId: any;
		type: any;
		uuid: any;
		vimId: any;
		vimType: any;

	}

	interface VmwareDistributedVirtualSwitchConstructor {
		new(value?:any): VmwareDistributedVirtualSwitch;
		readonly prototype: VmwareDistributedVirtualSwitch;
	}

	const VmwareDistributedVirtualSwitch: VmwareDistributedVirtualSwitchConstructor;

	interface VmwareDistributedVirtualSwitchPvlanPortType extends VcVmwareDistributedVirtualSwitchPvlanPortType
	{
		name: any;

	}

	interface VmwareDistributedVirtualSwitchPvlanPortTypeConstructor {
		new(value?:any): VmwareDistributedVirtualSwitchPvlanPortType;
		readonly prototype: VmwareDistributedVirtualSwitchPvlanPortType;
	}

	const VmwareDistributedVirtualSwitchPvlanPortType: VmwareDistributedVirtualSwitchPvlanPortTypeConstructor;

	interface VMwareDvsLacpApiVersion extends VcVMwareDvsLacpApiVersion
	{
		name: any;

	}

	interface VMwareDvsLacpApiVersionConstructor {
		new(value?:any): VMwareDvsLacpApiVersion;
		readonly prototype: VMwareDvsLacpApiVersion;
	}

	const VMwareDvsLacpApiVersion: VMwareDvsLacpApiVersionConstructor;

	interface VMwareDvsLacpLoadBalanceAlgorithm extends VcVMwareDvsLacpLoadBalanceAlgorithm
	{
		name: any;

	}

	interface VMwareDvsLacpLoadBalanceAlgorithmConstructor {
		new(value?:any): VMwareDvsLacpLoadBalanceAlgorithm;
		readonly prototype: VMwareDvsLacpLoadBalanceAlgorithm;
	}

	const VMwareDvsLacpLoadBalanceAlgorithm: VMwareDvsLacpLoadBalanceAlgorithmConstructor;

	interface VMwareDvsMulticastFilteringMode extends VcVMwareDvsMulticastFilteringMode
	{
		name: any;

	}

	interface VMwareDvsMulticastFilteringModeConstructor {
		new(value?:any): VMwareDvsMulticastFilteringMode;
		readonly prototype: VMwareDvsMulticastFilteringMode;
	}

	const VMwareDvsMulticastFilteringMode: VMwareDvsMulticastFilteringModeConstructor;

	interface VMwareDVSTeamingMatchStatus extends VcVMwareDVSTeamingMatchStatus
	{
		name: any;

	}

	interface VMwareDVSTeamingMatchStatusConstructor {
		new(value?:any): VMwareDVSTeamingMatchStatus;
		readonly prototype: VMwareDVSTeamingMatchStatus;
	}

	const VMwareDVSTeamingMatchStatus: VMwareDVSTeamingMatchStatusConstructor;

	interface VMwareDVSVspanSessionEncapType extends VcVMwareDVSVspanSessionEncapType
	{
		name: any;

	}

	interface VMwareDVSVspanSessionEncapTypeConstructor {
		new(value?:any): VMwareDVSVspanSessionEncapType;
		readonly prototype: VMwareDVSVspanSessionEncapType;
	}

	const VMwareDVSVspanSessionEncapType: VMwareDVSVspanSessionEncapTypeConstructor;

	interface VMwareDVSVspanSessionType extends VcVMwareDVSVspanSessionType
	{
		name: any;

	}

	interface VMwareDVSVspanSessionTypeConstructor {
		new(value?:any): VMwareDVSVspanSessionType;
		readonly prototype: VMwareDVSVspanSessionType;
	}

	const VMwareDVSVspanSessionType: VMwareDVSVspanSessionTypeConstructor;

	interface VMwareUplinkLacpMode extends VcVMwareUplinkLacpMode
	{
		name: any;

	}

	interface VMwareUplinkLacpModeConstructor {
		new(value?:any): VMwareUplinkLacpMode;
		readonly prototype: VMwareUplinkLacpMode;
	}

	const VMwareUplinkLacpMode: VMwareUplinkLacpModeConstructor;

	interface VRPResourceManager extends VcVRPResourceManager
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VRPResourceManagerConstructor {
		new(value?:any): VRPResourceManager;
		readonly prototype: VRPResourceManager;
	}

	const VRPResourceManager: VRPResourceManagerConstructor;

	interface VsanDiskIssueType extends VcVsanDiskIssueType
	{
		name: any;

	}

	interface VsanDiskIssueTypeConstructor {
		new(value?:any): VsanDiskIssueType;
		readonly prototype: VsanDiskIssueType;
	}

	const VsanDiskIssueType: VsanDiskIssueTypeConstructor;

	interface VsanHostDecommissionModeObjectAction extends VcVsanHostDecommissionModeObjectAction
	{
		name: any;

	}

	interface VsanHostDecommissionModeObjectActionConstructor {
		new(value?:any): VsanHostDecommissionModeObjectAction;
		readonly prototype: VsanHostDecommissionModeObjectAction;
	}

	const VsanHostDecommissionModeObjectAction: VsanHostDecommissionModeObjectActionConstructor;

	interface VsanHostDiskResultState extends VcVsanHostDiskResultState
	{
		name: any;

	}

	interface VsanHostDiskResultStateConstructor {
		new(value?:any): VsanHostDiskResultState;
		readonly prototype: VsanHostDiskResultState;
	}

	const VsanHostDiskResultState: VsanHostDiskResultStateConstructor;

	interface VsanHostHealthState extends VcVsanHostHealthState
	{
		name: any;

	}

	interface VsanHostHealthStateConstructor {
		new(value?:any): VsanHostHealthState;
		readonly prototype: VsanHostHealthState;
	}

	const VsanHostHealthState: VsanHostHealthStateConstructor;

	interface VsanHostNodeState extends VcVsanHostNodeState
	{
		name: any;

	}

	interface VsanHostNodeStateConstructor {
		new(value?:any): VsanHostNodeState;
		readonly prototype: VsanHostNodeState;
	}

	const VsanHostNodeState: VsanHostNodeStateConstructor;

	interface VsanUpgradeSystem extends VcVsanUpgradeSystem
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VsanUpgradeSystemConstructor {
		new(value?:any): VsanUpgradeSystem;
		readonly prototype: VsanUpgradeSystem;
	}

	const VsanUpgradeSystem: VsanUpgradeSystemConstructor;

	interface VsanUpgradeSystemUpgradeHistoryDiskGroupOpType extends VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType
	{
		name: any;

	}

	interface VsanUpgradeSystemUpgradeHistoryDiskGroupOpTypeConstructor {
		new(value?:any): VsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
		readonly prototype: VsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
	}

	const VsanUpgradeSystemUpgradeHistoryDiskGroupOpType: VsanUpgradeSystemUpgradeHistoryDiskGroupOpTypeConstructor;

	interface VStorageObjectConsumptionType extends VcVStorageObjectConsumptionType
	{
		name: any;

	}

	interface VStorageObjectConsumptionTypeConstructor {
		new(value?:any): VStorageObjectConsumptionType;
		readonly prototype: VStorageObjectConsumptionType;
	}

	const VStorageObjectConsumptionType: VStorageObjectConsumptionTypeConstructor;

	interface VStorageObjectManagerBase extends VcVStorageObjectManagerBase
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface VStorageObjectManagerBaseConstructor {
		new(value?:any): VStorageObjectManagerBase;
		readonly prototype: VStorageObjectManagerBase;
	}

	const VStorageObjectManagerBase: VStorageObjectManagerBaseConstructor;

	interface WeekOfMonth extends VcWeekOfMonth
	{
		name: any;

	}

	interface WeekOfMonthConstructor {
		new(value?:any): WeekOfMonth;
		readonly prototype: WeekOfMonth;
	}

	const WeekOfMonth: WeekOfMonthConstructor;

	interface WillLoseHAProtectionResolution extends VcWillLoseHAProtectionResolution
	{
		name: any;

	}

	interface WillLoseHAProtectionResolutionConstructor {
		new(value?:any): WillLoseHAProtectionResolution;
		readonly prototype: WillLoseHAProtectionResolution;
	}

	const WillLoseHAProtectionResolution: WillLoseHAProtectionResolutionConstructor;

	interface WorkflowStepHandler extends VcWorkflowStepHandler
	{
		id: any;
		sdkId: any;
		type: any;
		vimId: any;
		vimType: any;

	}

	interface WorkflowStepHandlerConstructor {
		new(value?:any): WorkflowStepHandler;
		readonly prototype: WorkflowStepHandler;
	}

	const WorkflowStepHandler: WorkflowStepHandlerConstructor;

    }    
